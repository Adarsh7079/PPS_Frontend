import { _PdfStream } from './../../base-stream';
import { _PdfDictionary, _PdfName } from './../../pdf-primitives';
import { _ImageFormat } from './../../enumerator';
var _ImageDecoder = /** @class */ (function () {
    /**
     * Initializes a new instance of the `_ImageDecoder` class.
     *
     * @private
     * @param {Uint8Array} stream byte array.
     */
    function _ImageDecoder(stream) {
        this._format = _ImageFormat.unknown;
        this._height = 0;
        this._width = 0;
        this._bitsPerComponent = 8;
        this._position = 0;
        this._noOfComponents = -1;
        this._stream = stream;
        this._initialize();
    }
    Object.defineProperty(_ImageDecoder.prototype, "_imageDataAsNumberArray", {
        get: function () {
            return this._imageData;
        },
        enumerable: true,
        configurable: true
    });
    _ImageDecoder.prototype._initialize = function () {
        if (this._format === _ImageFormat.unknown && this._checkIfJpeg()) {
            this._format = _ImageFormat.jpeg;
            this._parseJpegImage();
        }
        else {
            throw new TypeError('Only the JPEG format is supported');
        }
        this._reset();
        this._imageData = new Uint8Array(this._stream.byteLength);
        this._read(this._imageData, 0, this._imageData.byteLength);
    };
    _ImageDecoder.prototype._reset = function () {
        this._position = 0;
    };
    _ImageDecoder.prototype._parseJpegImage = function () {
        this._reset();
        var imgData = new Uint8Array(this._stream.byteLength);
        this._read(imgData, 0, imgData.byteLength);
        var i = 4;
        var length = this._getBuffer(i) * 256 + this._getBuffer(i + 1);
        var isLengthExceed = false;
        while (i < imgData.byteLength) {
            i += length;
            if (i < imgData.byteLength) {
                if (this._getBuffer(i + 1) === 192) {
                    this._height = this._getBuffer(i + 5) * 256 + this._getBuffer(i + 6);
                    this._width = this._getBuffer(i + 7) * 256 + this._getBuffer(i + 8);
                    this._noOfComponents = this._getBuffer(i + 9);
                    if (this._width !== 0 && this._height !== 0) {
                        return;
                    }
                }
                else {
                    i += 2;
                    length = this._getBuffer(i) * 256 + this._getBuffer(i + 1);
                }
            }
            else {
                isLengthExceed = true;
                break;
            }
        }
        if (isLengthExceed) {
            this._reset();
            this._seek(2);
            this._readExceededJpegImage();
        }
    };
    _ImageDecoder.prototype._checkIfJpeg = function () {
        this._reset();
        for (var i = 0; i < _ImageDecoder._jpegHeader.length; i++) {
            if (_ImageDecoder._jpegHeader[Number.parseInt(i.toString(), 10)] !== this._getBuffer(i)) {
                return false;
            }
            this._position++;
        }
        return true;
    };
    _ImageDecoder.prototype._read = function (buffer, offset, count) {
        for (var index = offset; index < count; index++) {
            var position = this._position;
            buffer[Number.parseInt(index.toString(), 10)] = this._getBuffer(position);
            this._position++;
        }
    };
    _ImageDecoder.prototype._getBuffer = function (index) {
        return this._stream[Number.parseInt(index.toString(), 10)];
    };
    _ImageDecoder.prototype._getImageDictionary = function () {
        var data = []; // eslint-disable-line
        this._imageStream = new _PdfStream(data, new _PdfDictionary());
        this._imageStream.isImageStream = true;
        var tempString = '';
        var decodedString = '';
        for (var i = 0; i < this._imageDataAsNumberArray.byteLength; i++) {
            tempString += ' ' + String.fromCharCode(this._getBuffer(i));
        }
        for (var i = 0; i < tempString.length; i++) {
            if (i % 2 !== 0) {
                decodedString += tempString[Number.parseInt(i.toString(), 10)];
            }
        }
        this._imageStream.data = [decodedString];
        this._imageStream._isCompress = false;
        var dictionary = new _PdfDictionary();
        dictionary.set('Type', new _PdfName('XObject'));
        dictionary.set('Subtype', new _PdfName('Image'));
        dictionary.set('Width', this._width);
        dictionary.set('Height', this._height);
        dictionary.set('BitsPerComponent', this._bitsPerComponent);
        dictionary.set('Filter', new _PdfName('DCTDecode'));
        dictionary.set('ColorSpace', new _PdfName(this._getColorSpace()));
        dictionary.set('DecodeParms', this._getDecodeParams());
        this._imageStream.dictionary = dictionary;
        this._imageStream.bytes = new Uint8Array(this._imageStream.data[0].length);
        for (var i = 0; i < this._imageStream.data[0].length; i++) {
            this._imageStream.bytes[Number.parseInt(i.toString(), 10)] = this._imageStream.data[0].charCodeAt(i);
        }
        this._imageStream.end = this._imageStream.bytes.length;
        this._imageStream.dictionary._updated = true;
        return this._imageStream;
    };
    _ImageDecoder.prototype._getColorSpace = function () {
        if (this._noOfComponents === 1) {
            return 'DeviceGray';
        }
        else if (this._noOfComponents === 4) {
            return 'DeviceCMYK';
        }
        return 'DeviceRGB';
    };
    _ImageDecoder.prototype._getDecodeParams = function () {
        var decodeParams = new _PdfDictionary();
        decodeParams.set('Columns', this._width);
        decodeParams.set('BlackIs1', true);
        decodeParams.set('K', -1);
        decodeParams.set('Predictor', 15);
        decodeParams.set('BitsPerComponent', this._bitsPerComponent);
        return decodeParams;
    };
    _ImageDecoder.prototype._seek = function (length) {
        this._position += length;
    };
    _ImageDecoder.prototype._readByte = function () {
        if (this._position < this._stream.byteLength) {
            var value = this._getBuffer(this._position);
            this._position += 1;
            return value;
        }
        else {
            throw new Error('Error decoding JPEG image. Invalid offset.');
        }
    };
    _ImageDecoder.prototype._skipStream = function () {
        var length = this._getBuffer(this._position) << 8 | this._getBuffer(this._position + 1);
        this._seek(2);
        if (length < 2) {
            throw new Error('Error decoding JPEG image');
        }
        else if (length > 0) {
            this._seek(length - 2);
        }
    };
    _ImageDecoder.prototype._readExceededJpegImage = function () {
        var isContinueReading = true;
        while (isContinueReading) {
            var marker = this._getMarker();
            switch (marker) {
                case 0x00C0:
                case 0x00C1:
                case 0x00C2:
                case 0x00C3:
                case 0x00C5:
                case 0x00C6:
                case 0x00C7:
                case 0x00C9:
                case 0x00CA:
                case 0x00CB:
                case 0x00CD:
                case 0x00CE:
                case 0x00CF:
                    this._seek(3);
                    this._height = this._getBuffer(this._position) << 8 | this._getBuffer(this._position + 1);
                    this._seek(2);
                    this._width = this._getBuffer(this._position) << 8 | this._getBuffer(this._position + 1);
                    this._seek(2);
                    this._noOfComponents = this._getBuffer(this._position);
                    this._seek(1);
                    isContinueReading = false;
                    break;
                default:
                    this._skipStream();
                    break;
            }
        }
    };
    _ImageDecoder.prototype._toUnsigned16 = function (value) {
        value = value & 0xFFFF;
        return value < 0 ? (value + 0x10000) : value;
    };
    _ImageDecoder.prototype._getMarker = function () {
        var skippedByte = 0;
        var marker = this._readByte();
        while (marker !== 255) {
            skippedByte++;
            marker = this._readByte();
        }
        do {
            marker = this._readByte();
        } while (marker === 255);
        if (skippedByte !== 0) {
            throw new Error('Error decoding JPEG image');
        }
        return this._toUnsigned16(marker);
    };
    _ImageDecoder._jpegHeader = [255, 216];
    return _ImageDecoder;
}());
export { _ImageDecoder };
