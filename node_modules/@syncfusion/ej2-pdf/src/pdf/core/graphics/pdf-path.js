import { _getBezierArc } from './../utils';
import { PdfFillMode } from './../enumerator';
var _PdfPath = /** @class */ (function () {
    function _PdfPath() {
        this._isRoundedRectangle = false;
        this._fillMode = PdfFillMode.winding;
        this._points = [];
        this._pathTypes = [];
        this._isStart = true;
    }
    Object.defineProperty(_PdfPath.prototype, "_lastPoint", {
        get: function () {
            var value = [0, 0];
            var count = this._points.length;
            if (this._points.length > 0) {
                value[0] = this._points[(count - 1)][0];
                value[1] = this._points[(count - 1)][0];
            }
            return value;
        },
        enumerable: true,
        configurable: true
    });
    _PdfPath.prototype._addLine = function (x1, y1, x2, y2) {
        this._addPoints([x1, y1, x2, y2], _PathPointType.line);
    };
    _PdfPath.prototype._addLines = function (linePoints) {
        var start = linePoints[0];
        if (linePoints.length === 1) {
            this._addPoint(linePoints[0], _PathPointType.line);
        }
        else {
            for (var i = 1; i < linePoints.length; i++) {
                var last = linePoints[Number.parseInt(i.toString(), 10)];
                this._addLine(start[0], start[1], last[0], last[1]);
                start = last;
            }
        }
    };
    _PdfPath.prototype._addPoints = function (points, type, start, end) {
        var startIndex = (typeof start !== 'undefined') ? start : 0;
        var endIndex = (typeof end !== 'undefined') ? end : points.length;
        for (var i = startIndex; i < endIndex; i++) {
            var point = [points[Number.parseInt(i.toString(), 10)], points[i + 1]];
            if (i === startIndex) {
                if (this._points.length === 0 || this._isStart) {
                    this._addPoint(point, _PathPointType.start);
                    this._isStart = false;
                }
                else if (this._isRoundedRectangle && (point[0] !== this._lastPoint[0] || point[1] !== this._lastPoint[1])) {
                    this._addPoint(point, _PathPointType.line);
                }
                else if (point[0] !== this._lastPoint[0] && point[1] !== this._lastPoint[1]) {
                    this._addPoint(point, _PathPointType.line);
                }
            }
            else {
                this._addPoint(point, type);
            }
            i++;
        }
    };
    _PdfPath.prototype._addPoint = function (points, type) {
        this._points.push(points);
        this._pathTypes.push(type);
    };
    _PdfPath.prototype._addArc = function (x, y, width, height, startAngle, sweepAngle) {
        var points = _getBezierArc(x, y, x + width, y + height, startAngle, sweepAngle);
        for (var i = 0; i < points.length; ++i) {
            var list = [points[Number.parseInt(i.toString(), 10)],
                points[++i],
                points[++i],
                points[++i],
                points[++i],
                points[++i],
                points[++i],
                points[++i]];
            this._addPoints(list, _PathPointType.bezier);
        }
    };
    _PdfPath.prototype._addRectangle = function (x, y, width, height) {
        this._startFigure();
        this._addPoints([x, y, x + width, y, x + width, y + height, x, y + height], _PathPointType.line);
        this._closeFigure();
    };
    _PdfPath.prototype._addPolygon = function (points) {
        var newPoints = [];
        points.forEach(function (element) {
            newPoints.push(element[0], element[1]);
        });
        this._startFigure();
        this._addPoints(newPoints, _PathPointType.line);
        this._closeFigure();
    };
    _PdfPath.prototype._addEllipse = function (x, y, width, height) {
        this._startFigure();
        this._addArc(x, y, width, height, 0, 360);
        this._closeFigure();
    };
    _PdfPath.prototype._addBezierPoints = function (pointsCollection) {
        if (pointsCollection.length < 4) {
            throw Error('Incorrect size of array points');
        }
        var bound = 3;
        var index = 0;
        var start = pointsCollection[Number.parseInt(index.toString(), 10)];
        index++;
        while ((index + bound) <= pointsCollection.length) {
            var inner1 = pointsCollection[Number.parseInt(index.toString(), 10)];
            index++;
            var inner2 = pointsCollection[Number.parseInt(index.toString(), 10)];
            index++;
            var end = pointsCollection[Number.parseInt(index.toString(), 10)];
            index++;
            this._addBezier(start[0], start[1], inner1[0], inner1[1], inner2[0], inner2[1], end[0], end[1]);
            start = end;
        }
    };
    _PdfPath.prototype._addBezier = function (x, y, firstX, firstY, secondX, secondY, endX, endY) {
        var points = [];
        points.push(x);
        points.push(y);
        points.push(firstX);
        points.push(firstY);
        points.push(secondX);
        points.push(secondY);
        points.push(endX);
        points.push(endY);
        this._addPoints(points, _PathPointType.bezier);
    };
    _PdfPath.prototype._closeFigure = function (index) {
        if (typeof index !== 'undefined') {
            var type = this._pathTypes[Number.parseInt(index.toString(), 10)];
            type |= _PathPointType.closePath;
            this._pathTypes[Number.parseInt(index.toString(), 10)] = type;
        }
        else {
            if (this._points.length > 0) {
                this._closeFigure(this._points.length - 1);
            }
            this._startFigure();
        }
    };
    _PdfPath.prototype._startFigure = function () {
        this._isStart = true;
    };
    _PdfPath.prototype._getBounds = function () {
        var bounds = [0, 0, 0, 0];
        if (this._points.length > 0) {
            var xmin = this._points[0][0];
            var xmax = this._points[0][0];
            var ymin = this._points[0][1];
            var ymax = this._points[0][1];
            for (var i = 1; i < this._points.length; ++i) {
                var point = this._points[Number.parseInt(i.toString(), 10)];
                xmin = Math.min(point[0], xmin);
                xmax = Math.max(point[0], xmax);
                ymin = Math.min(point[1], ymin);
                ymax = Math.max(point[1], ymax);
            }
            bounds = [xmin, ymin, xmax - xmin, ymax - ymin];
        }
        return bounds;
    };
    return _PdfPath;
}());
export { _PdfPath };
export var _PathPointType;
(function (_PathPointType) {
    _PathPointType[_PathPointType["start"] = 0] = "start";
    _PathPointType[_PathPointType["line"] = 1] = "line";
    _PathPointType[_PathPointType["bezier"] = 3] = "bezier";
    _PathPointType[_PathPointType["pathTypeMask"] = 7] = "pathTypeMask";
    _PathPointType[_PathPointType["dashMode"] = 16] = "dashMode";
    _PathPointType[_PathPointType["pathMarker"] = 32] = "pathMarker";
    _PathPointType[_PathPointType["closePath"] = 128] = "closePath";
})(_PathPointType || (_PathPointType = {}));
