var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
import { PdfDestinationMode, PdfRotationAngle, PdfTextStyle } from './enumerator';
import { PdfDestination } from './pdf-page';
import { _PdfDictionary, _PdfName, _PdfReference } from './pdf-primitives';
import { _checkRotation, _getPageIndex, _parseColor } from './utils';
/**
 * Represents a base class for all bookmark objects.
 * ```typescript
 * // Load an existing PDF document
 * let document: PdfDocument = new PdfDocument(data, password);
 * // Get bookmarks
 * let bookmarks: PdfBookmarkBase = document.bookmarks;
 * // Destroy the document
 * document.destroy();
 * ```
 */
var PdfBookmarkBase = /** @class */ (function () {
    /**
     * Initializes a new instance of the `PdfBookmarkBase` class.
     *
     * @private
     * @param {_PdfDictionary} dictionary Outline dictionary.
     * @param {_PdfCrossReference} crossReference Cross reference.
     *
     */
    function PdfBookmarkBase(dictionary, crossReference) {
        this._bookMarkList = [];
        this._isExpanded = false;
        this._isLoadedBookmark = false;
        this._dictionary = dictionary;
        this._crossReference = crossReference;
    }
    Object.defineProperty(PdfBookmarkBase.prototype, "count", {
        /**
         * Gets the bookmark count (Read only).
         *
         * @returns {number} Number of bookmarks.
         *
         * ```typescript
         * // Load an existing PDF document
         * let document: PdfDocument = new PdfDocument(data, password);
         * // Get bookmarks
         * let bookmarks: PdfBookmarkBase = document.bookmarks;
         * // Get bookmark count
         * let bookmarkCount: number = bookmarks.count;
         * // Destroy the document
         * document.destroy();
         * ```
         */
        get: function () {
            if (this._isLoadedBookmark && this._bookMarkList.length === 0) {
                this._reproduceTree();
            }
            return this._bookMarkList.length;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Gets the `PdfBookmark` at the specified index.
     *
     * @param {number} index Bookmark index.
     * @returns {PdfBookmark} Bookmark at the specified index.
     *
     * ```typescript
     * // Load an existing PDF document
     * let document: PdfDocument = new PdfDocument(data, password);
     * // Get bookmarks
     * let bookmarks: PdfBookmarkBase = document.bookmarks;
     * // Get bookmark at the specified index
     * let bookmark: PdfBookmark = bookmarks.at(0) as PdfBookmark;
     * // Destroy the document
     * document.destroy();
     * ```
     */
    PdfBookmarkBase.prototype.at = function (index) {
        var bookmark;
        if (index < 0 || index >= this.count) {
            throw Error('Index out of range.');
        }
        if (this._bookMarkList.length > 0 && index < this._bookMarkList.length) {
            bookmark = this._bookMarkList[Number.parseInt(index.toString(), 10)];
        }
        return bookmark;
    };
    /**
     * Gets the boolean flag indicating whether `PdfBookmark` is present or not.
     *
     * @param {PdfBookmark} outline Bookmark.
     * @returns {boolean} whether the bookmark is present or not.
     *
     * ```typescript
     * // Load an existing PDF document
     * let document: PdfDocument = new PdfDocument(data, password);
     * // Get the bookmarks
     * let bookmarks: PdfBookmarkBase = document.bookmarks;
     * // Get the bookmark at the specified index
     * let bookmark: PdfBookmark = bookmarks.at(0) as PdfBookmark;
     * // Gets the boolean flag indicating whether `PdfBookmark` is present or not.
     * let isPresent: boolean = bookmarks.contains(bookmark);
     * // Destroy the document
     * document.destroy();
     * ```
     */
    PdfBookmarkBase.prototype.contains = function (outline) {
        return this._bookMarkList.indexOf(outline) !== -1;
    };
    PdfBookmarkBase.prototype._reproduceTree = function () {
        var bookmark = this._getFirstBookmark(this);
        var isBookmark = (bookmark) ? true : false;
        while (isBookmark && bookmark._dictionary) {
            this._bookMarkList.push(bookmark);
            bookmark = bookmark._next;
            isBookmark = (bookmark) ? true : false;
        }
    };
    PdfBookmarkBase.prototype._getFirstBookmark = function (bookmarkBase) {
        var bookmarkBaseDictionary = bookmarkBase._dictionary;
        var bookMark;
        if (bookmarkBaseDictionary && bookmarkBaseDictionary.has('First')) {
            var bookMarkDictionary = bookmarkBaseDictionary.get('First');
            if (bookMarkDictionary) {
                bookMark = new PdfBookmark(bookMarkDictionary, this._crossReference);
            }
        }
        return bookMark;
    };
    return PdfBookmarkBase;
}());
export { PdfBookmarkBase };
/**
 * Represents a bookmark in a PDF document
 *
 * ```typescript
 * // Load an existing PDF document
 * let document: PdfDocument = new PdfDocument(data, password);
 * // Get the bookmarks
 * let bookmarks: PdfBookmarkBase = document.bookmarks;
 * // Gets the bookmark at the specified index
 * let bookmark: PdfBookmark = bookmarks.at(0) as PdfBookmark;
 * // Destroy the document
 * document.destroy();
 * ```
 */
var PdfBookmark = /** @class */ (function (_super) {
    __extends(PdfBookmark, _super);
    /**
     * Initializes a new instance of the `PdfBookmark` class.
     *
     * @private
     * @param {_PdfDictionary} dictionary Bookmark dictionary.
     * @param {_PdfCrossReference} crossReference Cross reference.
     *
     */
    function PdfBookmark(dictionary, crossReference) {
        var _this = _super.call(this, dictionary, crossReference) || this;
        if (!_this._dictionary.has('Dest') && _this._dictionary.has('A')) {
            var actionDictionary = _this._dictionary.get('A');
            if (actionDictionary && actionDictionary.has('D')) {
                var destinationArray = actionDictionary.getRaw('D'); // eslint-disable-line
                _this._dictionary.update('Dest', destinationArray);
            }
        }
        _this._isLoadedBookmark = true;
        return _this;
    }
    Object.defineProperty(PdfBookmark.prototype, "destination", {
        /**
         * Gets the destination (Read only).
         *
         * @returns {PdfDestination} Page destination.
         *
         * ```typescript
         * // Load an existing PDF document
         * let document: PdfDocument = new PdfDocument(data, password);
         * // Get the bookmarks
         * let bookmarks: PdfBookmarkBase = document.bookmarks;
         * // Gets the bookmark at the specified index
         * let bookmark: PdfBookmark = bookmarks.at(0) as PdfBookmark;
         * // Gets the destination
         * let destination: PdfDestination = bookmark.destination;
         * // Destroy the document
         * document.destroy();
         * ```
         */
        get: function () {
            var value;
            var namedDestination = this._obtainNamedDestination();
            if (namedDestination === null || typeof namedDestination === 'undefined') {
                value = this._obtainDestination();
            }
            return value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(PdfBookmark.prototype, "namedDestination", {
        /**
         * Gets the named destination (Read only).
         *
         * @returns {PdfNamedDestination} Named destination.
         *
         * ```typescript
         * // Load an existing PDF document
         * let document: PdfDocument = new PdfDocument(data, password);
         * // Get the bookmarks
         * let bookmarks: PdfBookmarkBase = document.bookmarks;
         * // Gets bookmark at the specified index
         * let bookmark: PdfBookmark = bookmarks.at(0) as PdfBookmark;
         * // Gets the named destination
         * let namedDestination: PdfNamedDestination = bookmark.namedDestination;
         * // Destroy the document
         * document.destroy();
         * ```
         */
        get: function () {
            if (this._namedDestination === null || typeof this._namedDestination === 'undefined') {
                this._namedDestination = this._obtainNamedDestination();
            }
            return this._namedDestination;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(PdfBookmark.prototype, "title", {
        /**
         * Gets the bookmark title (Read only).
         *
         * @returns {string} Bookmark title.
         *
         * ```typescript
         * // Load an existing PDF document
         * let document: PdfDocument = new PdfDocument(data, password);
         * // Get the bookmarks
         * let bookmarks: PdfBookmarkBase = document.bookmarks;
         * // Gets bookmark at the specified index
         * let bookmark: PdfBookmark = bookmarks.at(0) as PdfBookmark;
         * // Gets the bookmark title
         * let bookmarkTitle: string = bookmark.title;
         * // Destroy the document
         * document.destroy();
         * ```
         */
        get: function () {
            if (this._title === null || typeof this._title === 'undefined') {
                this._title = this._obtainTitle();
            }
            return this._title;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(PdfBookmark.prototype, "color", {
        /**
         * Gets the bookmark color (Read only).
         *
         * @returns {number[]} Bookmark color.
         *
         * ```typescript
         * // Load an existing PDF document
         * let document: PdfDocument = new PdfDocument(data, password);
         * // Get the bookmarks
         * let bookmarks: PdfBookmarkBase = document.bookmarks;
         * // Gets bookmark at the specified index
         * let bookmark: PdfBookmark = bookmarks.at(0) as PdfBookmark;
         * // Gets the bookmark color
         * let color: number[] = bookmark.color;
         * // Destroy the document
         * document.destroy();
         * ```
         */
        get: function () {
            if (this._color === null || typeof this._color === 'undefined') {
                if (this._dictionary.has('C')) {
                    this._color = _parseColor(this._dictionary.getArray('C'));
                }
            }
            return (this._color) ? this._color : [0, 0, 0];
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(PdfBookmark.prototype, "textStyle", {
        /**
         * Gets the textStyle (Read only).
         *
         * @returns {PdfTextStyle} Text style.
         *
         * ```typescript
         * // Load an existing PDF document
         * let document: PdfDocument = new PdfDocument(data, password);
         * // Get the bookmarks
         * let bookmarks: PdfBookmarkBase = document.bookmarks;
         * // Gets bookmark at the specified index
         * let bookmark: PdfBookmark = bookmarks.at(0) as PdfBookmark;
         * // Gets the textStyle
         * let textStyle: PdfTextStyle = bookmark.textStyle;
         * // Destroy the document
         * document.destroy();
         * ```
         */
        get: function () {
            if (this._textStyle === null || typeof this._textStyle === 'undefined') {
                this._textStyle = this._obtainTextStyle();
            }
            return this._textStyle;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(PdfBookmark.prototype, "isExpanded", {
        /**
         * Gets the boolean flag indicating whether the bookmark is expanded or not (Read only).
         *
         * @returns {boolean} whether the bookmark is expanded or not.
         *
         * ```typescript
         * // Load an existing PDF document
         * let document: PdfDocument = new PdfDocument(data, password);
         * // Get the bookmarks
         * let bookmarks: PdfBookmarkBase = document.bookmarks;
         * // Gets bookmark at the specified index
         * let bookmark: PdfBookmark = bookmarks.at(0) as PdfBookmark;
         * // Gets the boolean flag indicating whether the bookmark is expanded or not
         * let isExpanded: boolean = bookmark.isExpanded;
         * // Destroy the document
         * document.destroy();
         * ```
         */
        get: function () {
            if (this._dictionary.has('Count')) {
                var value = this._dictionary.get('Count');
                if (value >= 0) {
                    return true;
                }
            }
            return this._isExpanded;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(PdfBookmark.prototype, "_next", {
        get: function () {
            var nextBookmark;
            if (this._dictionary.has('Next')) {
                var dictionary = this._dictionary.get('Next');
                if (dictionary) {
                    nextBookmark = new PdfBookmark(dictionary, this._crossReference);
                }
            }
            return nextBookmark;
        },
        enumerable: true,
        configurable: true
    });
    PdfBookmark.prototype._obtainTextStyle = function () {
        var style = PdfTextStyle.regular;
        if (this._dictionary.has('F')) {
            var flag = this._dictionary.get('F');
            var flagValue = 0;
            if (typeof flag !== 'undefined' && flag !== null) {
                flagValue = flag;
            }
            style |= flagValue;
        }
        return style;
    };
    PdfBookmark.prototype._obtainTitle = function () {
        var value = '';
        if (this._dictionary.has('Title')) {
            value = this._dictionary.get('Title');
        }
        return value;
    };
    PdfBookmark.prototype._obtainNamedDestination = function () {
        var document = this._crossReference._document;
        var destinationCollection;
        if (document) {
            destinationCollection = document._destinationCollection;
        }
        var destination; // eslint-disable-line
        var namedDestination;
        if (destinationCollection) {
            var dictionary = this._dictionary;
            if (dictionary.has('A')) {
                var action = dictionary.get('A');
                if (action.has('D')) {
                    destination = action.get('D');
                }
            }
            else if (dictionary.has('Dest')) {
                destination = dictionary.get('Dest');
            }
            if (destination) {
                var value = void 0;
                if (destination instanceof _PdfName) {
                    value = destination.name;
                }
                else if (typeof destination === 'string') {
                    value = destination;
                }
                if (value) {
                    var namedDestinations = destinationCollection._namedDestinations;
                    for (var i = 0; i < namedDestinations.length; i++) {
                        namedDestination = namedDestinations[Number.parseInt(i.toString(), 10)];
                        if (namedDestination._title === value) {
                            destination = namedDestination;
                            break;
                        }
                    }
                }
            }
        }
        return namedDestination;
    };
    PdfBookmark.prototype._obtainDestination = function () {
        var bookMarkDictionary = this._dictionary;
        var page;
        if (bookMarkDictionary && bookMarkDictionary.has('Dest')) {
            var destinationArray = bookMarkDictionary.getArray('Dest'); // eslint-disable-line
            var loadedDocument = this._crossReference._document;
            var mode = void 0;
            if (destinationArray && Array.isArray(destinationArray) && destinationArray.length > 0) {
                var value = destinationArray[0]; // eslint-disable-line
                var left = void 0;
                var height = void 0;
                var bottom = void 0;
                var right = void 0;
                var zoom = void 0;
                if (typeof value === 'number') {
                    var pageNumber = destinationArray[0];
                    if (pageNumber >= 0) {
                        var document_1 = this._crossReference._document;
                        if (document_1 && document_1.pageCount > pageNumber) {
                            page = document_1.getPage(pageNumber);
                        }
                        if (destinationArray.length > 1) {
                            mode = destinationArray[1];
                        }
                        if (mode && mode.name === 'XYZ') {
                            if (destinationArray.length > 2) {
                                left = destinationArray[2];
                            }
                            if (destinationArray.length > 3) {
                                height = destinationArray[3];
                            }
                            if (destinationArray.length > 4) {
                                zoom = destinationArray[4];
                            }
                            if (page) {
                                var topValue = (height === null || typeof height === 'undefined') ? 0 : page.size[1] - height;
                                var leftValue = (left === null || typeof left === 'undefined') ? 0 : left;
                                if (page.rotation !== PdfRotationAngle.angle0) {
                                    _checkRotation(page, height, left);
                                }
                                this._destination = new PdfDestination(page, [leftValue, topValue]);
                                this._destination._index = pageNumber;
                                this._destination.zoom = (typeof zoom !== 'undefined' && zoom !== null) ? zoom : 0;
                                if (left === null || height === null || zoom === null || typeof left === 'undefined'
                                    || typeof height === 'undefined' || typeof zoom === 'undefined') {
                                    this._destination._setValidation(false);
                                }
                            }
                        }
                    }
                }
                if (value instanceof _PdfDictionary) {
                    var pageDictionary = value;
                    var index = void 0;
                    if (loadedDocument && pageDictionary) {
                        index = _getPageIndex(loadedDocument, pageDictionary);
                    }
                    if (typeof index !== 'undefined' && index !== null && index >= 0) {
                        page = loadedDocument.getPage(index);
                    }
                    if (destinationArray.length > 1) {
                        mode = destinationArray[1];
                    }
                    if (mode) {
                        if (mode.name === 'XYZ') {
                            if (destinationArray.length > 2) {
                                left = destinationArray[2];
                            }
                            if (destinationArray.length > 3) {
                                height = destinationArray[3];
                            }
                            if (destinationArray.length > 4) {
                                zoom = destinationArray[4];
                            }
                            if (page) {
                                var topValue = (height === null || typeof height === 'undefined') ? 0 : page.size[1] - height;
                                var leftValue = (left === null || typeof left === 'undefined') ? 0 : left;
                                if (page.rotation !== PdfRotationAngle.angle0) {
                                    topValue = _checkRotation(page, height, left);
                                }
                                this._destination = new PdfDestination(page, [leftValue, topValue]);
                                this._destination._index = index;
                                this._destination.zoom = (typeof zoom !== 'undefined' && zoom !== null) ? zoom : 0;
                                if (left === null || height === null || zoom === null || typeof left === 'undefined' ||
                                    typeof height === 'undefined' || typeof zoom === 'undefined') {
                                    this._destination._setValidation(false);
                                }
                            }
                        }
                        else {
                            if (mode.name === 'FitR') {
                                if (destinationArray.length > 2) {
                                    left = destinationArray[2];
                                }
                                if (destinationArray.length > 3) {
                                    bottom = destinationArray[3];
                                }
                                if (destinationArray.length > 4) {
                                    right = destinationArray[4];
                                }
                                if (destinationArray.length > 5) {
                                    height = destinationArray[5];
                                }
                                if (page) {
                                    left = (left === null || typeof left === 'undefined') ? 0 : left;
                                    bottom = (bottom === null || typeof bottom === 'undefined') ? 0 : bottom;
                                    height = (height === null || typeof height === 'undefined') ? 0 : height;
                                    right = (right === null || typeof right === 'undefined') ? 0 : right;
                                    this._destination = new PdfDestination(page, [left, bottom, right, height]);
                                    this._destination._index = index;
                                    this._destination.mode = PdfDestinationMode.fitR;
                                }
                            }
                            else if (mode.name === 'FitBH' || mode.name === 'FitH') {
                                if (destinationArray.length >= 3) {
                                    height = destinationArray[2];
                                }
                                if (typeof index !== 'undefined' && index !== null && index >= 0) {
                                    page = loadedDocument.getPage(index);
                                }
                                if (page && page.size) {
                                    var topValue = (height === null || typeof height === 'undefined') ? 0 : page.size[1] - height;
                                    this._destination = new PdfDestination(page, [0, topValue]);
                                    this._destination._index = index;
                                    this._destination.mode = PdfDestinationMode.fitH;
                                    if (height === null || typeof height === 'undefined') {
                                        this._destination._setValidation(false);
                                    }
                                }
                            }
                            else {
                                if (page && mode.name === 'Fit') {
                                    this._destination = new PdfDestination(page);
                                    this._destination._index = index;
                                    this._destination.mode = PdfDestinationMode.fitToPage;
                                }
                            }
                        }
                    }
                }
            }
        }
        return this._destination;
    };
    return PdfBookmark;
}(PdfBookmarkBase));
export { PdfBookmark };
/**
 * Represents a named destination in a PDF document.
 * ```typescript
 * // Load an existing PDF document
 * let document: PdfDocument = new PdfDocument(data, password);
 * // Get the bookmarks
 * let bookmarks: PdfBookmarkBase = document.bookmarks;
 * // Gets the bookmark at the specified index
 * let bookmark: PdfBookmark = bookmarks.at(0) as PdfBookmark;
 * // Gets the named destination
 * let namedDestination: PdfNamedDestination = bookmark.namedDestination;
 * // Destroy the document
 * document.destroy();
 * ```
 */
var PdfNamedDestination = /** @class */ (function () {
    /**
     * Initializes a new instance of the `PdfNamedDestination` class.
     *
     * @private
     * @param {_PdfDictionary} dictionary Destination dictionary.
     * @param {_PdfCrossReference} crossReference Cross reference.
     *
     */
    function PdfNamedDestination(dictionary, crossReference) {
        this._dictionary = dictionary;
        this._crossReference = crossReference;
    }
    Object.defineProperty(PdfNamedDestination.prototype, "destination", {
        /**
         * Gets the destination.
         *
         * @returns {PdfDestination} Page destination.
         *
         * ```typescript
         * // Load an existing PDF document
         * let document: PdfDocument = new PdfDocument(data, password);
         * // Get the bookmarks
         * let bookmarks: PdfBookmarkBase = document.bookmarks;
         * // Gets the bookmark at the specified index
         * let bookmark: PdfBookmark = bookmarks.at(0) as PdfBookmark;
         * // Gets the named destination
         * let namedDestination: PdfNamedDestination = bookmark.namedDestination;
         * // Gets the destination
         * let destination: PdfDestination = namedDestination.destination;
         * // Destroy the document
         * document.destroy();
         * ```
         */
        get: function () {
            return this._destination;
        },
        /**
         * Sets the destination.
         *
         * @param {PdfDestination} value destination.
         *
         * ```typescript
         * // Load an existing PDF document
         * let document: PdfDocument = new PdfDocument(data, password);
         * // Get the bookmarks
         * let bookmarks: PdfBookmarkBase = document.bookmarks;
         * // Gets the bookmark at the specified index
         * let bookmark: PdfBookmark = bookmarks.at(0) as PdfBookmark;
         * // Gets the named destination
         * let namedDestination: PdfNamedDestination = bookmark.namedDestination;
         * // Set the destination
         * namedDestination.destination = new PdfDestination(page, [100, 200]);
         * // Save the document
         * document.save('output.pdf');
         * // Destroy the document
         * document.destroy();
         * ```
         */
        set: function (value) {
            if (value) {
                value._parent = this;
                this._destination = value;
                this._destination._initializePrimitive();
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(PdfNamedDestination.prototype, "title", {
        /**
         * Gets the title.
         *
         * @returns {string} title.
         *
         * ```typescript
         * // Load an existing PDF document
         * let document: PdfDocument = new PdfDocument(data, password);
         * // Get the bookmarks
         * let bookmarks: PdfBookmarkBase = document.bookmarks;
         * // Gets the bookmark at the specified index
         * let bookmark: PdfBookmark = bookmarks.at(0) as PdfBookmark;
         * // Gets the named destination
         * let namedDestination: PdfNamedDestination = bookmark.namedDestination;
         * // Gets the title
         * let title: string = namedDestination.title;
         * // Destroy the document
         * document.destroy();
         * ```
         */
        get: function () {
            return this._title;
        },
        /**
         * Sets the title.
         *
         * @param {string} value title.
         *
         * ```typescript
         * // Load an existing PDF document
         * let document: PdfDocument = new PdfDocument(data, password);
         * // Get the bookmarks
         * let bookmarks: PdfBookmarkBase = document.bookmarks;
         * // Gets the bookmark at the specified index
         * let bookmark: PdfBookmark = bookmarks.at(0) as PdfBookmark;
         * // Gets the named destination
         * let namedDestination: PdfNamedDestination = bookmark.namedDestination;
         * // Set the title
         * namedDestination.title = 'Syncfusion';
         * // Save the document
         * document.save('output.pdf');
         * // Destroy the document
         * document.destroy();
         * ```
         */
        set: function (value) {
            if (value !== this._title) {
                this._title = value;
                this._dictionary.update('Title', value);
                this._dictionary._updated = true;
            }
        },
        enumerable: true,
        configurable: true
    });
    return PdfNamedDestination;
}());
export { PdfNamedDestination };
var _PdfNamedDestinationCollection = /** @class */ (function () {
    function _PdfNamedDestinationCollection(dictionary, crossReference) {
        this._namedDestinations = [];
        if (dictionary) {
            this._dictionary = dictionary;
        }
        if (crossReference) {
            this._crossReference = crossReference;
        }
        if (dictionary && dictionary.has('Dests')) {
            var destination = dictionary.get('Dests');
            if (destination) {
                if (destination.has('Names')) {
                    this._addCollection(destination);
                }
                else if (destination.has('Kids')) {
                    var destinationArray = destination.getArray('Kids'); // eslint-disable-line
                    for (var i = 0; i < destinationArray.length; i++) {
                        var destinationElement = destinationArray[Number.parseInt(i.toString(), 10)];
                        this._addCollection(destinationElement);
                    }
                }
            }
        }
    }
    _PdfNamedDestinationCollection.prototype._addCollection = function (destination) {
        var elements = destination.getRaw('Names'); // eslint-disable-line
        var ref; // eslint-disable-line
        var dictionary;
        if (elements instanceof _PdfReference) {
            ref = this._crossReference._fetch(elements);
        }
        if (ref && Array.isArray(ref) && ref.length > 0) {
            elements = ref;
        }
        if (elements && Array.isArray(elements) && elements.length > 0) {
            for (var i = 1; i < elements.length; i = i + 2) {
                var reference = elements[i]; // eslint-disable-line
                if (reference instanceof _PdfReference) {
                    var destinationArray = this._crossReference._fetch(reference); // eslint-disable-line
                    if (destinationArray && Array.isArray(destinationArray) && destinationArray.length > 0) {
                        dictionary = new _PdfDictionary();
                        dictionary.update('D', destinationArray);
                    }
                    else {
                        dictionary = this._crossReference._fetch(reference);
                    }
                }
                else if ((dictionary === null || typeof dictionary === 'undefined') && Array.isArray(reference)) {
                    dictionary = new _PdfDictionary();
                    dictionary.update('D', reference);
                }
                if (dictionary) {
                    var namedDestination = new PdfNamedDestination(dictionary, this._crossReference);
                    var value = elements[i - 1];
                    var destinationObject = void 0;
                    var destinationArray = void 0; // eslint-disable-line
                    if (value) {
                        namedDestination._title = value;
                        if (dictionary.has('D')) {
                            destinationArray = dictionary.get('D');
                            destinationObject = new PdfDestination();
                            var reference_1 = destinationArray[0];
                            if (destinationArray && destinationArray[0] instanceof _PdfReference) {
                                var pageDictionary = this._crossReference._fetch(reference_1);
                                var loadedDocument = this._crossReference._document;
                                var index = void 0;
                                if (loadedDocument && pageDictionary) {
                                    index = _getPageIndex(loadedDocument, pageDictionary);
                                    if (typeof index !== 'undefined' && index !== null && index >= 0) {
                                        destinationObject._index = index;
                                        destinationObject.page = loadedDocument.getPage(index);
                                    }
                                }
                            }
                        }
                    }
                    if (destinationArray[1] instanceof _PdfName) {
                        var left = void 0;
                        var height = void 0;
                        var zoom = void 0;
                        var mode = destinationArray[1].name;
                        var page = destinationObject.page;
                        switch (mode) {
                            case 'Fit':
                                destinationObject._destinationMode = PdfDestinationMode.fitToPage;
                                break;
                            case 'XYZ':
                                destinationObject._destinationMode = PdfDestinationMode.location;
                                if (destinationArray.length > 2) {
                                    left = destinationArray[2];
                                }
                                if (destinationArray.length > 3) {
                                    height = destinationArray[3];
                                }
                                if (destinationArray.length > 4) {
                                    zoom = destinationArray[4];
                                }
                                if (page) {
                                    var size = page.size;
                                    var topValue = (height === null || typeof height === 'undefined') ? 0 : size[1] - height;
                                    var leftValue = (left === null || typeof left === 'undefined') ? 0 : left;
                                    destinationObject._location = [leftValue, topValue];
                                    if (page.rotation !== PdfRotationAngle.angle0) {
                                        topValue = _checkRotation(page, height, left);
                                    }
                                    destinationObject._zoom = (typeof zoom !== 'undefined' && zoom !== null) ? zoom : 0;
                                    if (left === null || height === null || zoom === null || typeof left === 'undefined'
                                        || typeof height === 'undefined' || typeof zoom === 'undefined') {
                                        destinationObject._isValid = false;
                                    }
                                }
                                break;
                            case 'FitH':
                            case 'FitBH':
                                destinationObject._destinationMode = PdfDestinationMode.fitH;
                                if (destinationArray.length >= 3) {
                                    height = destinationArray[2];
                                }
                                if (page) {
                                    var size = page.size;
                                    var topValue = (height === null || typeof height === 'undefined') ? 0 : size[1] - height;
                                    destinationObject._location = [0, topValue];
                                }
                                if (height === null || typeof height === 'undefined') {
                                    destinationObject._isValid = false;
                                }
                                break;
                            case 'FitR':
                                destinationObject._destinationMode = PdfDestinationMode.fitR;
                                break;
                        }
                    }
                    destinationObject._parent = namedDestination;
                    namedDestination._destination = destinationObject;
                    this._namedDestinations.push(namedDestination);
                }
            }
        }
    };
    return _PdfNamedDestinationCollection;
}());
export { _PdfNamedDestinationCollection };
