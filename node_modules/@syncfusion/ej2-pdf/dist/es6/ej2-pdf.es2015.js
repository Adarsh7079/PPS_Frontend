import { CompressedStreamWriter } from '@syncfusion/ej2-compression';
import { Save } from '@syncfusion/ej2-file-utils';

/**
 * Public Enum to define annotation flag types.
 * ```typescript
 * // Load an existing PDF document
 * let document: PdfDocument = new PdfDocument(data, password);
 * // Access first page
 * let page: PdfPage = document.getPage(0);
 * // Access the annotation at index 0
 * let annotation: PdfAnnotation = page.annotations.at(0);
 * // Sets the annotation flag to enable print
 * annotation.flags = PdfAnnotationFlag.print;
 * // Save the document
 * document.save('output.pdf');
 * // Destroy the document
 * document.destroy();
 * ```
 */
var PdfAnnotationFlag;
(function (PdfAnnotationFlag) {
    /**
     * Specifies the type of `default`.
     */
    PdfAnnotationFlag[PdfAnnotationFlag["default"] = 0] = "default";
    /**
     * Specifies the type of `invisible`.
     */
    PdfAnnotationFlag[PdfAnnotationFlag["invisible"] = 1] = "invisible";
    /**
     * Specifies the type of `hidden`.
     */
    PdfAnnotationFlag[PdfAnnotationFlag["hidden"] = 2] = "hidden";
    /**
     * Specifies the type of `print`.
     */
    PdfAnnotationFlag[PdfAnnotationFlag["print"] = 4] = "print";
    /**
     * Specifies the type of `noZoom`.
     */
    PdfAnnotationFlag[PdfAnnotationFlag["noZoom"] = 8] = "noZoom";
    /**
     * Specifies the type of `noRotate`.
     */
    PdfAnnotationFlag[PdfAnnotationFlag["noRotate"] = 16] = "noRotate";
    /**
     * Specifies the type of `noView`.
     */
    PdfAnnotationFlag[PdfAnnotationFlag["noView"] = 32] = "noView";
    /**
     * Specifies the type of `readOnly`.
     */
    PdfAnnotationFlag[PdfAnnotationFlag["readOnly"] = 64] = "readOnly";
    /**
     * Specifies the type of `locked`.
     */
    PdfAnnotationFlag[PdfAnnotationFlag["locked"] = 128] = "locked";
    /**
     * Specifies the type of `toggleNoView`.
     */
    PdfAnnotationFlag[PdfAnnotationFlag["toggleNoView"] = 256] = "toggleNoView";
})(PdfAnnotationFlag || (PdfAnnotationFlag = {}));
/**
 * Public Enum to define line ending style.
 * ```typescript
 * // Load an existing PDF document
 * let document: PdfDocument = new PdfDocument(data, password);
 * // Access first page
 * let page: PdfPage = document.getPage(0);
 * // Access the annotation at index 0
 * let annotation: PdfPolyLineAnnotation = page.annotations.at(0) as PdfPolyLineAnnotation;
 * // Sets the begin line end style as openArrow
 * annotation.beginLineStyle = PdfLineEndingStyle.openArrow;
 * // Save the document
 * document.save('output.pdf');
 * // Destroy the document
 * document.destroy();
 * ```
 */
var PdfLineEndingStyle;
(function (PdfLineEndingStyle) {
    /**
     * Specifies the type of `none`.
     */
    PdfLineEndingStyle[PdfLineEndingStyle["none"] = 0] = "none";
    /**
     * Specifies the type of `openArrow`.
     */
    PdfLineEndingStyle[PdfLineEndingStyle["openArrow"] = 1] = "openArrow";
    /**
     * Specifies the type of `closedArrow`.
     */
    PdfLineEndingStyle[PdfLineEndingStyle["closedArrow"] = 2] = "closedArrow";
    /**
     * Specifies the type of `rOpenArrow`.
     */
    PdfLineEndingStyle[PdfLineEndingStyle["rOpenArrow"] = 3] = "rOpenArrow";
    /**
     * Specifies the type of `rClosedArrow`.
     */
    PdfLineEndingStyle[PdfLineEndingStyle["rClosedArrow"] = 4] = "rClosedArrow";
    /**
     * Specifies the type of `butt`.
     */
    PdfLineEndingStyle[PdfLineEndingStyle["butt"] = 5] = "butt";
    /**
     * Specifies the type of `diamond`.
     */
    PdfLineEndingStyle[PdfLineEndingStyle["diamond"] = 6] = "diamond";
    /**
     * Specifies the type of `circle`.
     */
    PdfLineEndingStyle[PdfLineEndingStyle["circle"] = 7] = "circle";
    /**
     * Specifies the type of `square`.
     */
    PdfLineEndingStyle[PdfLineEndingStyle["square"] = 8] = "square";
    /**
     * Specifies the type of `slash`.
     */
    PdfLineEndingStyle[PdfLineEndingStyle["slash"] = 9] = "slash";
})(PdfLineEndingStyle || (PdfLineEndingStyle = {}));
/**
 * Public Enum to define line indent.
 * ```typescript
 * // Load an existing PDF document
 * let document: PdfDocument = new PdfDocument(data, password);
 * // Access first page
 * let page: PdfPage = document.getPage(0);
 * // Access the annotation at index 0
 * let annotation: PdfLineAnnotation = page.annotations.at(0) as PdfLineAnnotation;
 * // Sets the line intent as lineArrow
 * annotation.lineIntent = PdfLineIntent.lineArrow;
 * // Save the document
 * document.save('output.pdf');
 * // Destroy the document
 * document.destroy();
 * ```
 */
var PdfLineIntent;
(function (PdfLineIntent) {
    /**
     * Specifies the type of `lineArrow`.
     */
    PdfLineIntent[PdfLineIntent["lineArrow"] = 0] = "lineArrow";
    /**
     * Specifies the type of `lineDimension`.
     */
    PdfLineIntent[PdfLineIntent["lineDimension"] = 1] = "lineDimension";
})(PdfLineIntent || (PdfLineIntent = {}));
/**
 * Public Enum to define line caption type.
 * ```typescript
 * // Load an existing PDF document
 * let document: PdfDocument = new PdfDocument(data, password);
 * // Access first page
 * let page: PdfPage = document.getPage(0);
 * // Access the annotation at index 0
 * let annotation: PdfAnnotation = page.annotations.at(0);
 * // Sets the line caption type as inline
 * annotation.caption.type = PdfLineCaptionType.inline;
 * // Save the document
 * document.save('output.pdf');
 * // Destroy the document
 * document.destroy();
 * ```
 */
var PdfLineCaptionType;
(function (PdfLineCaptionType) {
    /**
     * Specifies the type of `inline`.
     */
    PdfLineCaptionType[PdfLineCaptionType["inline"] = 0] = "inline";
    /**
     * Specifies the type of `top`.
     */
    PdfLineCaptionType[PdfLineCaptionType["top"] = 1] = "top";
})(PdfLineCaptionType || (PdfLineCaptionType = {}));
/**
 * Public Enum to define border style.
 * ```typescript
 * // Load an existing PDF document
 * let document: PdfDocument = new PdfDocument(data, password);
 * // Access first page
 * let page: PdfPage = document.getPage(0);
 * // Access the annotation at index 0
 * let annotation: PdfAnnotation = page.annotations.at(0);
 * // Sets the border style as underline
 * annotation.border.style = PdfBorderStyle.underline;
 * // Save the document
 * document.save('output.pdf');
 * // Destroy the document
 * document.destroy();
 * ```
 */
var PdfBorderStyle;
(function (PdfBorderStyle) {
    /**
     * Specifies the type of `solid`.
     */
    PdfBorderStyle[PdfBorderStyle["solid"] = 0] = "solid";
    /**
     * Specifies the type of `dashed`.
     */
    PdfBorderStyle[PdfBorderStyle["dashed"] = 1] = "dashed";
    /**
     * Specifies the type of `beveled`.
     */
    PdfBorderStyle[PdfBorderStyle["beveled"] = 2] = "beveled";
    /**
     * Specifies the type of `inset`.
     */
    PdfBorderStyle[PdfBorderStyle["inset"] = 3] = "inset";
    /**
     * Specifies the type of `underline`.
     */
    PdfBorderStyle[PdfBorderStyle["underline"] = 4] = "underline";
    /**
     * Specifies the type of `dot`.
     */
    PdfBorderStyle[PdfBorderStyle["dot"] = 5] = "dot";
})(PdfBorderStyle || (PdfBorderStyle = {}));
/**
 * Public Enum to define border effect style.
 * ```typescript
 * // Load an existing PDF document
 * let document: PdfDocument = new PdfDocument(data, password);
 * // Access first page
 * let page: PdfPage = document.getPage(0);
 * // Access the annotation at index 0
 * let annotation: PdfAnnotation = page.annotations.at(0);
 * // Sets the border effect as underline
 * annotation.borderEffect.style = PdfBorderEffectStyle.cloudy;
 * // Save the document
 * document.save('output.pdf');
 * // Destroy the document
 * document.destroy();
 * ```
 */
var PdfBorderEffectStyle;
(function (PdfBorderEffectStyle) {
    /**
     * Specifies the type of `solid`.
     */
    PdfBorderEffectStyle[PdfBorderEffectStyle["solid"] = 0] = "solid";
    /**
     * Specifies the type of `cloudy`.
     */
    PdfBorderEffectStyle[PdfBorderEffectStyle["cloudy"] = 1] = "cloudy";
})(PdfBorderEffectStyle || (PdfBorderEffectStyle = {}));
/**
 * Public Enum to define rotation of the interactive elements.
 * ```typescript
 * // Load an existing PDF document
 * let document: PdfDocument = new PdfDocument(data, password);
 * // Access text box field
 * let field: PdfTextBoxField = document.form.fieldAt(0) as PdfTextBoxField;
 * // Gets the rotation of the field
 * let rotation: PdfRotationAngle = field.rotationAngle;
 * // Save the document
 * document.save('output.pdf');
 * // Destroy the document
 * document.destroy();
 * ```
 */
var PdfRotationAngle;
(function (PdfRotationAngle) {
    /**
     * Specifies the type of `angle0`.
     */
    PdfRotationAngle[PdfRotationAngle["angle0"] = 0] = "angle0";
    /**
     * Specifies the type of `angle90`.
     */
    PdfRotationAngle[PdfRotationAngle["angle90"] = 1] = "angle90";
    /**
     * Specifies the type of `angle180`.
     */
    PdfRotationAngle[PdfRotationAngle["angle180"] = 2] = "angle180";
    /**
     * Specifies the type of `angle270`.
     */
    PdfRotationAngle[PdfRotationAngle["angle270"] = 3] = "angle270";
})(PdfRotationAngle || (PdfRotationAngle = {}));
/**
 * Public Enum to define cross reference type.
 * ```typescript
 * // Load an existing PDF document
 * let document: PdfDocument = new PdfDocument(data, password);
 * // Save the document with cross reference type as stream
 * document.save('output.pdf', PdfCrossReferenceType.stream);
 * // Destroy the document
 * document.destroy();
 * ```
 */
var PdfCrossReferenceType;
(function (PdfCrossReferenceType) {
    /**
     * Specifies the type of `table`.
     */
    PdfCrossReferenceType[PdfCrossReferenceType["table"] = 0] = "table";
    /**
     * Specifies the type of `stream`.
     */
    PdfCrossReferenceType[PdfCrossReferenceType["stream"] = 1] = "stream";
})(PdfCrossReferenceType || (PdfCrossReferenceType = {}));
/**
 * Public Enum to define highlight mode of text box field.
 * ```typescript
 * // Load an existing PDF document
 * let document: PdfDocument = new PdfDocument(data, password);
 * // Access text box field
 * let field: PdfTextBoxField = document.form.fieldAt(0) as PdfTextBoxField;
 * // Sets the highlight mode of text box field as outline
 * field.highlightMode = PdfHighlightMode.outline;
 * // Save the document
 * document.save('output.pdf');
 * // Destroy the document
 * document.destroy();
 * ```
 */
var PdfHighlightMode;
(function (PdfHighlightMode) {
    /**
     * Specifies the type of `noHighlighting`.
     */
    PdfHighlightMode[PdfHighlightMode["noHighlighting"] = 0] = "noHighlighting";
    /**
     * Specifies the type of `invert`.
     */
    PdfHighlightMode[PdfHighlightMode["invert"] = 1] = "invert";
    /**
     * Specifies the type of `outline`.
     */
    PdfHighlightMode[PdfHighlightMode["outline"] = 2] = "outline";
    /**
     * Specifies the type of `push`.
     */
    PdfHighlightMode[PdfHighlightMode["push"] = 3] = "push";
})(PdfHighlightMode || (PdfHighlightMode = {}));
/**
 * Public Enum to define text alignment of text box field.
 * ```typescript
 * // Load an existing PDF document
 * let document: PdfDocument = new PdfDocument(data, password);
 * // Access text box field
 * let field: PdfTextBoxField = document.form.fieldAt(0) as PdfTextBoxField;
 * // Sets the text alignment of form field as center
 * field.textAlignment = PdfTextAlignment.center;
 * // Save the document
 * document.save('output.pdf');
 * // Destroy the document
 * document.destroy();
 * ```
 */
var PdfTextAlignment;
(function (PdfTextAlignment) {
    /**
     * Specifies the type of `left`.
     */
    PdfTextAlignment[PdfTextAlignment["left"] = 0] = "left";
    /**
     * Specifies the type of `center`.
     */
    PdfTextAlignment[PdfTextAlignment["center"] = 1] = "center";
    /**
     * Specifies the type of `right`.
     */
    PdfTextAlignment[PdfTextAlignment["right"] = 2] = "right";
    /**
     * Specifies the type of `justify`.
     */
    PdfTextAlignment[PdfTextAlignment["justify"] = 3] = "justify";
})(PdfTextAlignment || (PdfTextAlignment = {}));
/**
 * Public Enum to define visibility of form field.
 * ```typescript
 * // Load an existing PDF document
 * let document: PdfDocument = new PdfDocument(data, password);
 * // Access PDF form field
 * let field: PdfField = document.form.fieldAt(0);
 * // Sets the visibility of form field as hidden
 * field.visibility = PdfFormFieldVisibility.hidden;
 * // Save the document
 * document.save('output.pdf');
 * // Destroy the document
 * document.destroy();
 * ```
 */
var PdfFormFieldVisibility;
(function (PdfFormFieldVisibility) {
    /**
     * Specifies the type of `visible`.
     */
    PdfFormFieldVisibility[PdfFormFieldVisibility["visible"] = 0] = "visible";
    /**
     * Specifies the type of `hidden`.
     */
    PdfFormFieldVisibility[PdfFormFieldVisibility["hidden"] = 1] = "hidden";
    /**
     * Specifies the type of `visibleNotPrintable`.
     */
    PdfFormFieldVisibility[PdfFormFieldVisibility["visibleNotPrintable"] = 2] = "visibleNotPrintable";
    /**
     * Specifies the type of `hiddenPrintable`.
     */
    PdfFormFieldVisibility[PdfFormFieldVisibility["hiddenPrintable"] = 3] = "hiddenPrintable";
})(PdfFormFieldVisibility || (PdfFormFieldVisibility = {}));
/**
 * Public Enum to define measurement unit of line measurement annotation.
 * ```typescript
 * // Load an existing PDF document
 * let document: PdfDocument = new PdfDocument(data, password);
 * // Access first page
 * let page: PdfPage = document.getPage(0);
 * // Access the annotation at index 0
 * let annotation: PdfLineAnnotation = page.annotations.at(0) PdfLineAnnotation;
 * // Sets the measurement unit of line measurement annoation as centimeter
 * annotation.unit = PdfMeasurementUnit.centimeter;
 * // Save the document
 * document.save('output.pdf');
 * // Destroy the document
 * document.destroy();
 * ```
 */
var PdfMeasurementUnit;
(function (PdfMeasurementUnit) {
    /**
     * Specifies the type of `inch`.
     */
    PdfMeasurementUnit[PdfMeasurementUnit["inch"] = 0] = "inch";
    /**
     * Specifies the type of `pica`.
     */
    PdfMeasurementUnit[PdfMeasurementUnit["pica"] = 1] = "pica";
    /**
     * Specifies the type of `point`.
     */
    PdfMeasurementUnit[PdfMeasurementUnit["point"] = 3] = "point";
    /**
     * Specifies the type of `centimeter`.
     */
    PdfMeasurementUnit[PdfMeasurementUnit["centimeter"] = 4] = "centimeter";
    /**
     * Specifies the type of `millimeter`.
     */
    PdfMeasurementUnit[PdfMeasurementUnit["millimeter"] = 6] = "millimeter";
})(PdfMeasurementUnit || (PdfMeasurementUnit = {}));
/**
 * Public Enum to define measurement type of circle annotation.
 * ```typescript
 * // Load an existing PDF document
 * let document: PdfDocument = new PdfDocument(data, password);
 * // Access first page
 * let page: PdfPage = document.getPage(0);
 * // Access the annotation at index 0
 * let annotation: PdfCircleAnnotation = page.annotations.at(0) PdfCircleAnnotation;
 * // Sets the measurement type of circle annotation as diameter
 * annotation.measureType = PdfCircleMeasurementType.diameter;
 * // Save the document
 * document.save('output.pdf');
 * // Destroy the document
 * document.destroy();
 * ```
 */
var PdfCircleMeasurementType;
(function (PdfCircleMeasurementType) {
    /**
     * Specifies the type of `diameter`.
     */
    PdfCircleMeasurementType[PdfCircleMeasurementType["diameter"] = 0] = "diameter";
    /**
     * Specifies the type of `radius`.
     */
    PdfCircleMeasurementType[PdfCircleMeasurementType["radius"] = 1] = "radius";
})(PdfCircleMeasurementType || (PdfCircleMeasurementType = {}));
/**
 * Public Enum to define icon type of rubber stamp annotation.
 * ```typescript
 * // Load an existing PDF document
 * let document: PdfDocument = new PdfDocument(data, password);
 * // Access first page
 * let page: PdfPage = document.getPage(0);
 * // Access the annotation at index 0
 * let annotation: PdfRubberStampAnnotation = page.annotations.at(0) PdfRubberStampAnnotation;
 * // Sets the rubber stamp annotation icon type as confidential
 * annotation.icon = PdfRubberStampAnnotationIcon.confidential;
 * // Save the document
 * document.save('output.pdf');
 * // Destroy the document
 * document.destroy();
 * ```
 */
var PdfRubberStampAnnotationIcon;
(function (PdfRubberStampAnnotationIcon) {
    /**
     * Specifies the type of `approved`.
     */
    PdfRubberStampAnnotationIcon[PdfRubberStampAnnotationIcon["approved"] = 0] = "approved";
    /**
     * Specifies the type of `asIs`.
     */
    PdfRubberStampAnnotationIcon[PdfRubberStampAnnotationIcon["asIs"] = 1] = "asIs";
    /**
     * Specifies the type of `confidential`.
     */
    PdfRubberStampAnnotationIcon[PdfRubberStampAnnotationIcon["confidential"] = 2] = "confidential";
    /**
     * Specifies the type of `departmental`.
     */
    PdfRubberStampAnnotationIcon[PdfRubberStampAnnotationIcon["departmental"] = 3] = "departmental";
    /**
     * Specifies the type of `draft`.
     */
    PdfRubberStampAnnotationIcon[PdfRubberStampAnnotationIcon["draft"] = 4] = "draft";
    /**
     * Specifies the type of `experimental`.
     */
    PdfRubberStampAnnotationIcon[PdfRubberStampAnnotationIcon["experimental"] = 5] = "experimental";
    /**
     * Specifies the type of `expired`.
     */
    PdfRubberStampAnnotationIcon[PdfRubberStampAnnotationIcon["expired"] = 6] = "expired";
    /**
     * Specifies the type of `final`.
     */
    PdfRubberStampAnnotationIcon[PdfRubberStampAnnotationIcon["final"] = 7] = "final";
    /**
     * Specifies the type of `forComment`.
     */
    PdfRubberStampAnnotationIcon[PdfRubberStampAnnotationIcon["forComment"] = 8] = "forComment";
    /**
     * Specifies the type of `forPublicRelease`.
     */
    PdfRubberStampAnnotationIcon[PdfRubberStampAnnotationIcon["forPublicRelease"] = 9] = "forPublicRelease";
    /**
     * Specifies the type of `notApproved`.
     */
    PdfRubberStampAnnotationIcon[PdfRubberStampAnnotationIcon["notApproved"] = 10] = "notApproved";
    /**
     * Specifies the type of `notForPublicRelease`.
     */
    PdfRubberStampAnnotationIcon[PdfRubberStampAnnotationIcon["notForPublicRelease"] = 11] = "notForPublicRelease";
    /**
     * Specifies the type of `sold`.
     */
    PdfRubberStampAnnotationIcon[PdfRubberStampAnnotationIcon["sold"] = 12] = "sold";
    /**
     * Specifies the type of `topSecret`.
     */
    PdfRubberStampAnnotationIcon[PdfRubberStampAnnotationIcon["topSecret"] = 13] = "topSecret";
    /**
     * Specifies the type of `completed`.
     */
    PdfRubberStampAnnotationIcon[PdfRubberStampAnnotationIcon["completed"] = 14] = "completed";
    /**
     * Specifies the type of `void`.
     */
    PdfRubberStampAnnotationIcon[PdfRubberStampAnnotationIcon["void"] = 15] = "void";
    /**
     * Specifies the type of `informationOnly`.
     */
    PdfRubberStampAnnotationIcon[PdfRubberStampAnnotationIcon["informationOnly"] = 16] = "informationOnly";
    /**
     * Specifies the type of `preliminaryResults`.
     */
    PdfRubberStampAnnotationIcon[PdfRubberStampAnnotationIcon["preliminaryResults"] = 17] = "preliminaryResults";
})(PdfRubberStampAnnotationIcon || (PdfRubberStampAnnotationIcon = {}));
/**
 * Public Enum to define check box style.
 * ```typescript
 * // Load an existing PDF document
 * let document: PdfDocument = new PdfDocument(data, password);
 * // Access check box field
 * let field: PdfCheckBoxField = document.form.fieldAt(0) as PdfCheckBoxField;
 * // Access first item of check box field
 * let item: PdfStateItem = field.itemAt(0) as PdfStateItem;
 * // Sets the check box style as check
 * item.style = PdfCheckBoxStyle.check;
 * // Save the document
 * document.save('output.pdf');
 * // Destroy the document
 * document.destroy();
 * ```
 */
var PdfCheckBoxStyle;
(function (PdfCheckBoxStyle) {
    /**
     * Specifies the type of `check`.
     */
    PdfCheckBoxStyle[PdfCheckBoxStyle["check"] = 0] = "check";
    /**
     * Specifies the type of `circle`.
     */
    PdfCheckBoxStyle[PdfCheckBoxStyle["circle"] = 1] = "circle";
    /**
     * Specifies the type of `cross`.
     */
    PdfCheckBoxStyle[PdfCheckBoxStyle["cross"] = 2] = "cross";
    /**
     * Specifies the type of `diamond`.
     */
    PdfCheckBoxStyle[PdfCheckBoxStyle["diamond"] = 3] = "diamond";
    /**
     * Specifies the type of `square`.
     */
    PdfCheckBoxStyle[PdfCheckBoxStyle["square"] = 4] = "square";
    /**
     * Specifies the type of `star`.
     */
    PdfCheckBoxStyle[PdfCheckBoxStyle["star"] = 5] = "star";
})(PdfCheckBoxStyle || (PdfCheckBoxStyle = {}));
/**
 * Public Enum to define type of text markup annotation.
 * ```typescript
 * // Load an existing PDF document
 * let document: PdfDocument = new PdfDocument(data, password);
 * // Access first page
 * let page: PdfPage = document.getPage(0);
 * // Access the annotation at index 0
 * let annotation: PdfTextMarkupAnnotation = page.annotations.at(0) PdfTextMarkupAnnotation;
 * // Sets the type of the text markup annotation as underline
 * annotation.textMarkupType = PdfTextMarkupAnnotationType.underline;
 * // Save the document
 * document.save('output.pdf');
 * // Destroy the document
 * document.destroy();
 * ```
 */
var PdfTextMarkupAnnotationType;
(function (PdfTextMarkupAnnotationType) {
    /**
     * Specifies the type of `highlight`.
     */
    PdfTextMarkupAnnotationType[PdfTextMarkupAnnotationType["highlight"] = 0] = "highlight";
    /**
     * Specifies the type of `underline`.
     */
    PdfTextMarkupAnnotationType[PdfTextMarkupAnnotationType["underline"] = 1] = "underline";
    /**
     * Specifies the type of `squiggly`.
     */
    PdfTextMarkupAnnotationType[PdfTextMarkupAnnotationType["squiggly"] = 2] = "squiggly";
    /**
     * Specifies the type of `strikeOut`.
     */
    PdfTextMarkupAnnotationType[PdfTextMarkupAnnotationType["strikeOut"] = 3] = "strikeOut";
})(PdfTextMarkupAnnotationType || (PdfTextMarkupAnnotationType = {}));
/**
 * Public Enum to define icon type of popup annotation.
 * ```typescript
 * // Load an existing PDF document
 * let document: PdfDocument = new PdfDocument(data, password);
 * // Access first page
 * let page: PdfPage = document.getPage(0);
 * // Access the annotation at index 0
 * let annotation: PdfPopupAnnotation = page.annotations.at(0) PdfPopupAnnotation;
 * // Sets the icon type of the popup annotation as comment
 * annotation.icon = PdfPopupIcon.comment;
 * // Save the document
 * document.save('output.pdf');
 * // Destroy the document
 * document.destroy();
 * ```
 */
var PdfPopupIcon;
(function (PdfPopupIcon) {
    /**
     * Specifies the type of `note`.
     */
    PdfPopupIcon[PdfPopupIcon["note"] = 0] = "note";
    /**
     * Specifies the type of `comment`.
     */
    PdfPopupIcon[PdfPopupIcon["comment"] = 1] = "comment";
    /**
     * Specifies the type of `help`.
     */
    PdfPopupIcon[PdfPopupIcon["help"] = 2] = "help";
    /**
     * Specifies the type of `insert`.
     */
    PdfPopupIcon[PdfPopupIcon["insert"] = 3] = "insert";
    /**
     * Specifies the type of `key`.
     */
    PdfPopupIcon[PdfPopupIcon["key"] = 4] = "key";
    /**
     * Specifies the type of `new paragraph`.
     */
    PdfPopupIcon[PdfPopupIcon["newParagraph"] = 5] = "newParagraph";
    /**
     * Specifies the type of `paragraph`.
     */
    PdfPopupIcon[PdfPopupIcon["paragraph"] = 6] = "paragraph";
})(PdfPopupIcon || (PdfPopupIcon = {}));
/**
 * Public Enum to define annotation state.
 * ```typescript
 * // Load an existing PDF document
 * let document: PdfDocument = new PdfDocument(data, password);
 * // Access first page
 * let page: PdfPage = document.getPage(0);
 * // Access the annotation at index 0
 * let annotation: PdfPopupAnnotation = page.annotations.at(0) PdfPopupAnnotation;
 * // Sets the state of the popup annotation as accepted
 * annotation.state = PdfAnnotationState.accepted;
 * // Save the document
 * document.save('output.pdf');
 * // Destroy the document
 * document.destroy();
 * ```
 */
var PdfAnnotationState;
(function (PdfAnnotationState) {
    /**
     * Specifies the default state of `none`.
     */
    PdfAnnotationState[PdfAnnotationState["none"] = 0] = "none";
    /**
     * Specifies the state of `accepted`.
     */
    PdfAnnotationState[PdfAnnotationState["accepted"] = 1] = "accepted";
    /**
     * Specifies the state of `rejected`.
     */
    PdfAnnotationState[PdfAnnotationState["rejected"] = 2] = "rejected";
    /**
     * Specifies the state of `cancel`.
     */
    PdfAnnotationState[PdfAnnotationState["cancel"] = 3] = "cancel";
    /**
     * Specifies the state of `completed`.
     */
    PdfAnnotationState[PdfAnnotationState["completed"] = 4] = "completed";
    /**
     * Specifies the state of `marked`.
     */
    PdfAnnotationState[PdfAnnotationState["marked"] = 5] = "marked";
    /**
     * Specifies the state of `unmarked`.
     */
    PdfAnnotationState[PdfAnnotationState["unmarked"] = 6] = "unmarked";
    /**
     * Specifies the state of `unknown`.
     */
    PdfAnnotationState[PdfAnnotationState["unknown"] = 7] = "unknown";
})(PdfAnnotationState || (PdfAnnotationState = {}));
/**
 * Public Enum to define annotation state model.
 * ```typescript
 * // Load an existing PDF document
 * let document: PdfDocument = new PdfDocument(data, password);
 * // Access first page
 * let page: PdfPage = document.getPage(0);
 * // Access the annotation at index 0
 * let annotation: PdfPopupAnnotation = page.annotations.at(0) PdfPopupAnnotation;
 * // Sets the state model of the popup annotation as marked
 * annotation.stateModel = PdfAnnotationStateModel.marked;
 * // Save the document
 * document.save('output.pdf');
 * // Destroy the document
 * document.destroy();
 * ```
 */
var PdfAnnotationStateModel;
(function (PdfAnnotationStateModel) {
    /**
     * Specifies the default model of `none`.
     */
    PdfAnnotationStateModel[PdfAnnotationStateModel["none"] = 0] = "none";
    /**
     * Specifies the model of `marked`.
     */
    PdfAnnotationStateModel[PdfAnnotationStateModel["marked"] = 1] = "marked";
    /**
     * Specifies the model of `review`.
     */
    PdfAnnotationStateModel[PdfAnnotationStateModel["review"] = 2] = "review";
})(PdfAnnotationStateModel || (PdfAnnotationStateModel = {}));
/**
 * Public Enum to define icon type of attachment annotation.
 * ```typescript
 * // Load an existing PDF document
 * let document: PdfDocument = new PdfDocument(data, password);
 * // Access first page
 * let page: PdfPage = document.getPage(0);
 * // Access the annotation at index 0
 * let annotation: PdfAttachmentAnnotation = page.annotations.at(0) PdfAttachmentAnnotation;
 * // Sets the icon type of attachment annotation to pushPin
 * annotation.icon = PdfAttachmentIcon.pushPin;
 * // Save the document
 * document.save('output.pdf');
 * // Destroy the document
 * document.destroy();
 * ```
 */
var PdfAttachmentIcon;
(function (PdfAttachmentIcon) {
    /**
     * Specifies the default icon of `pushPin`.
     */
    PdfAttachmentIcon[PdfAttachmentIcon["pushPin"] = 0] = "pushPin";
    /**
     * Specifies the icon of `tag`.
     */
    PdfAttachmentIcon[PdfAttachmentIcon["tag"] = 1] = "tag";
    /**
     * Specifies the icon of `graph`.
     */
    PdfAttachmentIcon[PdfAttachmentIcon["graph"] = 2] = "graph";
    /**
     * Specifies the icon of `paperClip`.
     */
    PdfAttachmentIcon[PdfAttachmentIcon["paperClip"] = 3] = "paperClip";
})(PdfAttachmentIcon || (PdfAttachmentIcon = {}));
/**
 * Public Enum to define annotation intent of free text annotation.
 * ```typescript
 * // Load an existing PDF document
 * let document: PdfDocument = new PdfDocument(data, password);
 * // Access first page
 * let page: PdfPage = document.getPage(0);
 * // Access the annotation at index 0
 * let annotation: PdfFreeTextAnnotation = page.annotations.at(0) PdfFreeTextAnnotation;
 * // Sets the free text annotation intent to freeTextCallout
 * annotation.annotationIntent = PdfAnnotationIntent.freeTextCallout;
 * // Save the document
 * document.save('output.pdf');
 * // Destroy the document
 * document.destroy();
 * ```
 */
var PdfAnnotationIntent;
(function (PdfAnnotationIntent) {
    /**
     * Specifies the default intent of `none`.
     */
    PdfAnnotationIntent[PdfAnnotationIntent["none"] = 0] = "none";
    /**
     * Specifies the intent of `freeTextCallout`.
     */
    PdfAnnotationIntent[PdfAnnotationIntent["freeTextCallout"] = 1] = "freeTextCallout";
    /**
     * Specifies the intent of `freeTextTypeWriter`.
     */
    PdfAnnotationIntent[PdfAnnotationIntent["freeTextTypeWriter"] = 2] = "freeTextTypeWriter";
})(PdfAnnotationIntent || (PdfAnnotationIntent = {}));
/**
 * Public Enum to define destination mode of document link annotation.
 * ```typescript
 * // Load an existing PDF document
 * let document: PdfDocument = new PdfDocument(data, password);
 * // Access first page
 * let page: PdfPage = document.getPage(0);
 * // Access the annotation at index 0
 * let annotation: PdfDocumentLinkAnnotation = page.annotations.at(0) PdfDocumentLinkAnnotation;
 * // Sets the destination mode as fitToPage
 * annotation.destination.mode = PdfDestinationMode.fitToPage;
 * // Save the document
 * document.save('output.pdf');
 * // Destroy the document
 * document.destroy();
 * ```
 */
var PdfDestinationMode;
(function (PdfDestinationMode) {
    /**
     * Specifies the default intent of `location`.
     */
    PdfDestinationMode[PdfDestinationMode["location"] = 0] = "location";
    /**
     * Specifies the intent of `FitToPage`.
     */
    PdfDestinationMode[PdfDestinationMode["fitToPage"] = 1] = "fitToPage";
    /**
     * Specifies the intent of `fitR`.
     */
    PdfDestinationMode[PdfDestinationMode["fitR"] = 2] = "fitR";
    /**
     * Specifies the intent of `fitH`.
     */
    PdfDestinationMode[PdfDestinationMode["fitH"] = 3] = "fitH";
})(PdfDestinationMode || (PdfDestinationMode = {}));
/**
 * Public Enum to define export or import data format.
 * ```typescript
 * // Load an existing PDF document
 * let document: PdfDocument = new PdfDocument(data, password);
 * // Sets export data format as JSON type to annotation export settings
 * let settings: PdfAnnotationExportSettings = new PdfAnnotationExportSettings();
 * settings.dataFormat = DataFormat.json;
 * // Export annotations to JSON format
 * let json: Uint8Array = document.exportAnnotations(settings);
 * // Save the document
 * document.save('output.pdf');
 * // Destroy the document
 * document.destroy();
 * ```
 */
var DataFormat;
(function (DataFormat) {
    /**
     * Specifies the intent of `FDF`.
     */
    DataFormat[DataFormat["fdf"] = 0] = "fdf";
    /**
     * Specifies the intent of `XFDF`.
     */
    DataFormat[DataFormat["xfdf"] = 1] = "xfdf";
    /**
     * Specifies the intent of `JSON`.
     */
    DataFormat[DataFormat["json"] = 2] = "json";
    /**
     * Specifies the intent of `XML`.
     */
    DataFormat[DataFormat["xml"] = 3] = "xml";
})(DataFormat || (DataFormat = {}));
/**
 * Public enum to define form fields tab order.
 * ```typescript
 * // Load an existing PDF document
 * let document: PdfDocument = new PdfDocument(data, password);
 * // Set a PDF form's tab order.
 * document.form.orderFormFields(PdfFormFieldsTabOrder.row);
 * // Save the document
 * document.save('output.pdf');
 * // Destroy the document
 * document.destroy();
 * ```
 */
var PdfFormFieldsTabOrder;
(function (PdfFormFieldsTabOrder) {
    /**
     * Specifies that no tab order is defined.
     */
    PdfFormFieldsTabOrder[PdfFormFieldsTabOrder["none"] = 0] = "none";
    /**
     * Specifies the tab order is defined by the document's rows.
     */
    PdfFormFieldsTabOrder[PdfFormFieldsTabOrder["row"] = 1] = "row";
    /**
     * Specifies the tab order is defined by the document's columns.
     */
    PdfFormFieldsTabOrder[PdfFormFieldsTabOrder["column"] = 2] = "column";
    /**
     * Specifies the tab order is defined by the document's structure tree.
     */
    PdfFormFieldsTabOrder[PdfFormFieldsTabOrder["structure"] = 3] = "structure";
    /**
     * Specifies the tab order is defined manually.
     */
    PdfFormFieldsTabOrder[PdfFormFieldsTabOrder["manual"] = 4] = "manual";
    /**
     * Specifies the tab order is defined by the widget annotations in the document.
     */
    PdfFormFieldsTabOrder[PdfFormFieldsTabOrder["widget"] = 5] = "widget";
})(PdfFormFieldsTabOrder || (PdfFormFieldsTabOrder = {}));
/**
 * Enum for PDF loaded annotation type.
 */
var _PdfAnnotationType;
(function (_PdfAnnotationType) {
    /**
     * Specifies the intent of `highlight`.
     */
    _PdfAnnotationType[_PdfAnnotationType["highlight"] = 0] = "highlight";
    /**
     * Specifies the intent of `underline`.
     */
    _PdfAnnotationType[_PdfAnnotationType["underline"] = 1] = "underline";
    /**
     * Specifies the intent of `strikeOut`.
     */
    _PdfAnnotationType[_PdfAnnotationType["strikeOut"] = 2] = "strikeOut";
    /**
     * Specifies the intent of `squiggly`.
     */
    _PdfAnnotationType[_PdfAnnotationType["squiggly"] = 3] = "squiggly";
    /**
     * Specifies the intent of `redactionAnnotation`.
     */
    _PdfAnnotationType[_PdfAnnotationType["redactionAnnotation"] = 4] = "redactionAnnotation";
    /**
     * Specifies the intent of `textAnnotation`.
     */
    _PdfAnnotationType[_PdfAnnotationType["textAnnotation"] = 5] = "textAnnotation";
    /**
     * Specifies the intent of `linkAnnotation`.
     */
    _PdfAnnotationType[_PdfAnnotationType["linkAnnotation"] = 6] = "linkAnnotation";
    /**
     * Specifies the intent of `documentLinkAnnotation`.
     */
    _PdfAnnotationType[_PdfAnnotationType["documentLinkAnnotation"] = 7] = "documentLinkAnnotation";
    /**
     * Specifies the intent of `uriAnnotation`.
     */
    _PdfAnnotationType[_PdfAnnotationType["uriAnnotation"] = 8] = "uriAnnotation";
    /**
     * Specifies the intent of `fileLinkAnnotation`.
     */
    _PdfAnnotationType[_PdfAnnotationType["fileLinkAnnotation"] = 9] = "fileLinkAnnotation";
    /**
     * Specifies the intent of `freeTextAnnotation`.
     */
    _PdfAnnotationType[_PdfAnnotationType["freeTextAnnotation"] = 10] = "freeTextAnnotation";
    /**
     * Specifies the intent of `lineAnnotation`.
     */
    _PdfAnnotationType[_PdfAnnotationType["lineAnnotation"] = 11] = "lineAnnotation";
    /**
     * Specifies the intent of `circleAnnotation`.
     */
    _PdfAnnotationType[_PdfAnnotationType["circleAnnotation"] = 12] = "circleAnnotation";
    /**
     * Specifies the intent of `ellipseAnnotation`.
     */
    _PdfAnnotationType[_PdfAnnotationType["ellipseAnnotation"] = 13] = "ellipseAnnotation";
    /**
     * Specifies the intent of `squareAnnotation`.
     */
    _PdfAnnotationType[_PdfAnnotationType["squareAnnotation"] = 14] = "squareAnnotation";
    /**
     * Specifies the intent of `rectangleAnnotation`.
     */
    _PdfAnnotationType[_PdfAnnotationType["rectangleAnnotation"] = 15] = "rectangleAnnotation";
    /**
     * Specifies the intent of `polygonAnnotation`.
     */
    _PdfAnnotationType[_PdfAnnotationType["polygonAnnotation"] = 16] = "polygonAnnotation";
    /**
     * Specifies the intent of `polyLineAnnotation`.
     */
    _PdfAnnotationType[_PdfAnnotationType["polyLineAnnotation"] = 17] = "polyLineAnnotation";
    /**
     * Specifies the intent of `textMarkupAnnotation`.
     */
    _PdfAnnotationType[_PdfAnnotationType["textMarkupAnnotation"] = 18] = "textMarkupAnnotation";
    /**
     * Specifies the intent of `caretAnnotation`.
     */
    _PdfAnnotationType[_PdfAnnotationType["caretAnnotation"] = 19] = "caretAnnotation";
    /**
     * Specifies the intent of `rubberStampAnnotation`.
     */
    _PdfAnnotationType[_PdfAnnotationType["rubberStampAnnotation"] = 20] = "rubberStampAnnotation";
    /**
     * Specifies the intent of `popupAnnotation`.
     */
    _PdfAnnotationType[_PdfAnnotationType["popupAnnotation"] = 21] = "popupAnnotation";
    /**
     * Specifies the intent of `fileAttachmentAnnotation`.
     */
    _PdfAnnotationType[_PdfAnnotationType["fileAttachmentAnnotation"] = 22] = "fileAttachmentAnnotation";
    /**
     * Specifies the intent of `soundAnnotation`.
     */
    _PdfAnnotationType[_PdfAnnotationType["soundAnnotation"] = 23] = "soundAnnotation";
    /**
     * Specifies the intent of `movieAnnotation`.
     */
    _PdfAnnotationType[_PdfAnnotationType["movieAnnotation"] = 24] = "movieAnnotation";
    /**
     * Specifies the intent of `screenAnnotation`.
     */
    _PdfAnnotationType[_PdfAnnotationType["screenAnnotation"] = 25] = "screenAnnotation";
    /**
     * Specifies the intent of `widgetAnnotation`.
     */
    _PdfAnnotationType[_PdfAnnotationType["widgetAnnotation"] = 26] = "widgetAnnotation";
    /**
     * Specifies the intent of `printerMarkAnnotation`.
     */
    _PdfAnnotationType[_PdfAnnotationType["printerMarkAnnotation"] = 27] = "printerMarkAnnotation";
    /**
     * Specifies the intent of `trapNetworkAnnotation`.
     */
    _PdfAnnotationType[_PdfAnnotationType["trapNetworkAnnotation"] = 28] = "trapNetworkAnnotation";
    /**
     * Specifies the intent of `watermarkAnnotation`.
     */
    _PdfAnnotationType[_PdfAnnotationType["watermarkAnnotation"] = 29] = "watermarkAnnotation";
    /**
     * Specifies the intent of `textWebLinkAnnotation`.
     */
    _PdfAnnotationType[_PdfAnnotationType["textWebLinkAnnotation"] = 30] = "textWebLinkAnnotation";
    /**
     * Specifies the intent of `inkAnnotation`.
     */
    _PdfAnnotationType[_PdfAnnotationType["inkAnnotation"] = 31] = "inkAnnotation";
    /**
     * Specifies the intent of `richMediaAnnotation`.
     */
    _PdfAnnotationType[_PdfAnnotationType["richMediaAnnotation"] = 32] = "richMediaAnnotation";
    /**
     * Specifies the intent of `angleMeasurementAnnotation`.
     */
    _PdfAnnotationType[_PdfAnnotationType["angleMeasurementAnnotation"] = 33] = "angleMeasurementAnnotation";
    /**
     * Specifies the intent of `null`.
     */
    _PdfAnnotationType[_PdfAnnotationType["null"] = 34] = "null";
})(_PdfAnnotationType || (_PdfAnnotationType = {}));
/**
 * Enum for PDF graphics unit.
 */
var _PdfGraphicsUnit;
(function (_PdfGraphicsUnit) {
    /**
     * Specifies the type of `centimeter`.
     */
    _PdfGraphicsUnit[_PdfGraphicsUnit["centimeter"] = 0] = "centimeter";
    /**
     * Specifies the type of `pica`.
     */
    _PdfGraphicsUnit[_PdfGraphicsUnit["pica"] = 1] = "pica";
    /**
     * Specifies the type of `pixel`.
     */
    _PdfGraphicsUnit[_PdfGraphicsUnit["pixel"] = 2] = "pixel";
    /**
     * Specifies the type of `point`.
     */
    _PdfGraphicsUnit[_PdfGraphicsUnit["point"] = 3] = "point";
    /**
     * Specifies the type of `inch`.
     */
    _PdfGraphicsUnit[_PdfGraphicsUnit["inch"] = 4] = "inch";
    /**
     * Specifies the type of `document`.
     */
    _PdfGraphicsUnit[_PdfGraphicsUnit["document"] = 5] = "document";
    /**
     * Specifies the type of `millimeter`.
     */
    _PdfGraphicsUnit[_PdfGraphicsUnit["millimeter"] = 6] = "millimeter";
})(_PdfGraphicsUnit || (_PdfGraphicsUnit = {}));
var _FieldFlag;
(function (_FieldFlag) {
    _FieldFlag[_FieldFlag["default"] = 0] = "default";
    _FieldFlag[_FieldFlag["readOnly"] = 1] = "readOnly";
    _FieldFlag[_FieldFlag["required"] = 2] = "required";
    _FieldFlag[_FieldFlag["noExport"] = 4] = "noExport";
    _FieldFlag[_FieldFlag["multiLine"] = 4096] = "multiLine";
    _FieldFlag[_FieldFlag["password"] = 8192] = "password";
    _FieldFlag[_FieldFlag["fileSelect"] = 1048576] = "fileSelect";
    _FieldFlag[_FieldFlag["doNotSpellCheck"] = 4194304] = "doNotSpellCheck";
    _FieldFlag[_FieldFlag["doNotScroll"] = 8388608] = "doNotScroll";
    _FieldFlag[_FieldFlag["comb"] = 16777216] = "comb";
    _FieldFlag[_FieldFlag["richText"] = 33554432] = "richText";
    _FieldFlag[_FieldFlag["noToggleToOff"] = 16384] = "noToggleToOff";
    _FieldFlag[_FieldFlag["radio"] = 32768] = "radio";
    _FieldFlag[_FieldFlag["pushButton"] = 65536] = "pushButton";
    _FieldFlag[_FieldFlag["radiosInUnison"] = 33554432] = "radiosInUnison";
    _FieldFlag[_FieldFlag["combo"] = 131072] = "combo";
    _FieldFlag[_FieldFlag["edit"] = 262144] = "edit";
    _FieldFlag[_FieldFlag["sort"] = 524288] = "sort";
    _FieldFlag[_FieldFlag["multiSelect"] = 2097152] = "multiSelect";
    _FieldFlag[_FieldFlag["commitOnSelectChange"] = 67108864] = "commitOnSelectChange";
})(_FieldFlag || (_FieldFlag = {}));
var _SignatureFlag;
(function (_SignatureFlag) {
    _SignatureFlag[_SignatureFlag["none"] = 0] = "none";
    _SignatureFlag[_SignatureFlag["signatureExists"] = 1] = "signatureExists";
    _SignatureFlag[_SignatureFlag["appendOnly"] = 2] = "appendOnly";
})(_SignatureFlag || (_SignatureFlag = {}));
var _PdfCheckFieldState;
(function (_PdfCheckFieldState) {
    _PdfCheckFieldState[_PdfCheckFieldState["unchecked"] = 0] = "unchecked";
    _PdfCheckFieldState[_PdfCheckFieldState["checked"] = 1] = "checked";
    _PdfCheckFieldState[_PdfCheckFieldState["pressedUnchecked"] = 2] = "pressedUnchecked";
    _PdfCheckFieldState[_PdfCheckFieldState["pressedChecked"] = 3] = "pressedChecked";
})(_PdfCheckFieldState || (_PdfCheckFieldState = {}));
/**
 * Public enum to define the PDF document permission flags.
 * ```typescript
 * // Load an existing PDF document
 * let document: PdfDocument = new PdfDocument(data, password);
 * // Get the permission flag
 * let permission: PdfPermissionFlag = document.permissions;
 * // Destroy the document
 * document.destroy();
 * ```
 */
var PdfPermissionFlag;
(function (PdfPermissionFlag) {
    /**
     * Specifies the default permission flag.
     */
    PdfPermissionFlag[PdfPermissionFlag["default"] = 0] = "default";
    /**
     * Specifies the print permission flag.
     */
    PdfPermissionFlag[PdfPermissionFlag["print"] = 4] = "print";
    /**
     * Specifies the edit content permission flag.
     */
    PdfPermissionFlag[PdfPermissionFlag["editContent"] = 8] = "editContent";
    /**
     * Specifies the copy content permission flag.
     */
    PdfPermissionFlag[PdfPermissionFlag["copyContent"] = 16] = "copyContent";
    /**
     * Specifies the edit annotations permission flag.
     */
    PdfPermissionFlag[PdfPermissionFlag["editAnnotations"] = 32] = "editAnnotations";
    /**
     * Specifies the fill fields permission flag.
     */
    PdfPermissionFlag[PdfPermissionFlag["fillFields"] = 256] = "fillFields";
    /**
     * Specifies the accessibility copy content permission flag.
     */
    PdfPermissionFlag[PdfPermissionFlag["accessibilityCopyContent"] = 512] = "accessibilityCopyContent";
    /**
     * Specifies the assemble document permission flag.
     */
    PdfPermissionFlag[PdfPermissionFlag["assembleDocument"] = 1024] = "assembleDocument";
    /**
     * Specifies the full quality print permission flag.
     */
    PdfPermissionFlag[PdfPermissionFlag["fullQualityPrint"] = 2048] = "fullQualityPrint";
})(PdfPermissionFlag || (PdfPermissionFlag = {}));
/**
 * Public enum to define the PDF page orientation.
 * ```typescript
 * // Load an existing PDF document
 * let document: PdfDocument = new PdfDocument(data, password);
 * // Access first page
 * let page: PdfPage = document.getPage(0);
 * // Get the page orientation
 * let orientation: PdfPageOrientation = page.orientation;
 * // Destroy the document
 * document.destroy();
 * ```
 */
var PdfPageOrientation;
(function (PdfPageOrientation) {
    /**
     * Specifies the type of `portrait`.
     */
    PdfPageOrientation[PdfPageOrientation["portrait"] = 0] = "portrait";
    /**
     * Specifies the type of `landscape`.
     */
    PdfPageOrientation[PdfPageOrientation["landscape"] = 1] = "landscape";
})(PdfPageOrientation || (PdfPageOrientation = {}));
/**
 * Public enum to define the text direction.
 * ```typescript
 * // Load an existing PDF document
 * let document: PdfDocument = new PdfDocument(data, password);
 * // Load the font file
 * let font: PdfTrueTypeFont = new PdfTrueTypeFont(read('./resources/Fonts/', 'Arial.ttf'), 10);
 * // Add a string format
 * let format: PdfStringFormat = new PdfStringFormat();
 * format.alignment = PdfTextAlignment.right;
 * format.textDirection = PdfTextDirection.rightToLeft;
 * // Draw a text with right to left direction
 * page.graphics.drawString('Hello World مرحبا بالعالم', font, [10, 20, 300, 200], undefined, new PdfBrush([0, 0, 255]), format);
 * // Save the document
 * document.save('output.pdf');
 * // Destroy the document
 * document.destroy();
 * ```
 */
var PdfTextDirection;
(function (PdfTextDirection) {
    /**
     * Specifies the type of `none`.
     */
    PdfTextDirection[PdfTextDirection["none"] = 0] = "none";
    /**
     * Specifies the type of `leftToRight`.
     */
    PdfTextDirection[PdfTextDirection["leftToRight"] = 1] = "leftToRight";
    /**
     * Specifies the type of `rightToLeft`.
     */
    PdfTextDirection[PdfTextDirection["rightToLeft"] = 2] = "rightToLeft";
})(PdfTextDirection || (PdfTextDirection = {}));
/**
 * Public enum to define the subscript or superscript mode.
 * ```typescript
 * // Load an existing PDF document
 * let document: PdfDocument = new PdfDocument(data, password);
 * // Gets the first page
 * let page: PdfPage = document.getPage(0) as PdfPage;
 * // Create a new PDF standard font
 * let font: PdfStandardFont = new PdfStandardFont(PdfFontFamily.Helvetica, 10);
 * // Create a new PDF string format
 * let format: PdfStringFormat = new PdfStringFormat(PdfTextAlignment.right);
 * // Set a new paragraph indent
 * format.paragraphIndent = 20;
 * // Set the subscript or superscript mode
 * format.subSuperScript = PdfSubSuperScript.subScript;
 * // Draw the text
 * page.graphics.drawString('Helvetica', font, [0, 180, page.size[0], 40], undefined, new PdfBrush([0, 0, 255]), format);
 * // Save the document
 * document.save('output.pdf');
 * // Destroy the document
 * document.destroy();
 * ```
 */
var PdfSubSuperScript;
(function (PdfSubSuperScript) {
    /**
     * Specifies the type of `none`.
     */
    PdfSubSuperScript[PdfSubSuperScript["none"] = 0] = "none";
    /**
     * Specifies the type of `superScript`.
     */
    PdfSubSuperScript[PdfSubSuperScript["superScript"] = 1] = "superScript";
    /**
     * Specifies the type of `subScript`.
     */
    PdfSubSuperScript[PdfSubSuperScript["subScript"] = 2] = "subScript";
})(PdfSubSuperScript || (PdfSubSuperScript = {}));
/**
 * Public enum to define blend mode of the PDF page.
 * ```typescript
 * // Load an existing PDF document
 * let document: PdfDocument = new PdfDocument(data, password);
 * // Access first page
 * let page: PdfPage = document.getPage(0);
 * // Gets the graphics of the PDF page
 * let graphics: PdfGraphics = page.graphics;
 * // Create a new font
 * let font: PdfStandardFont = new PdfStandardFont(PdfFontFamily.symbol, 10);
 * // Set the blend mode
 * graphics.setTransparency(0.5, 0.5, PdfBlendMode.hardLight);
 * // Draw the text
 * graphics.drawString('Hello World', font, null, new PointF(10, 10));
 * // Save the document
 * document.save('output.pdf');
 * // Destroy the document
 * document.destroy();
 * ```
 */
var PdfBlendMode;
(function (PdfBlendMode) {
    /**
     * Specifies the type of `normal`.
     */
    PdfBlendMode[PdfBlendMode["normal"] = 0] = "normal";
    /**
     * Specifies the type of `multiply`.
     */
    PdfBlendMode[PdfBlendMode["multiply"] = 1] = "multiply";
    /**
     * Specifies the type of `screen`.
     */
    PdfBlendMode[PdfBlendMode["screen"] = 2] = "screen";
    /**
     * Specifies the type of `overlay`.
     */
    PdfBlendMode[PdfBlendMode["overlay"] = 3] = "overlay";
    /**
     * Specifies the type of `darken`.
     */
    PdfBlendMode[PdfBlendMode["darken"] = 4] = "darken";
    /**
     * Specifies the type of `lighten`.
     */
    PdfBlendMode[PdfBlendMode["lighten"] = 5] = "lighten";
    /**
     * Specifies the type of `colorDodge`.
     */
    PdfBlendMode[PdfBlendMode["colorDodge"] = 6] = "colorDodge";
    /**
     * Specifies the type of `colorBurn`.
     */
    PdfBlendMode[PdfBlendMode["colorBurn"] = 7] = "colorBurn";
    /**
     * Specifies the type of `hardLight`.
     */
    PdfBlendMode[PdfBlendMode["hardLight"] = 8] = "hardLight";
    /**
     * Specifies the type of `softLight`.
     */
    PdfBlendMode[PdfBlendMode["softLight"] = 9] = "softLight";
    /**
     * Specifies the type of `difference`.
     */
    PdfBlendMode[PdfBlendMode["difference"] = 10] = "difference";
    /**
     * Specifies the type of `exclusion`.
     */
    PdfBlendMode[PdfBlendMode["exclusion"] = 11] = "exclusion";
    /**
     * Specifies the type of `hue`.
     */
    PdfBlendMode[PdfBlendMode["hue"] = 12] = "hue";
    /**
     * Specifies the type of `saturation`.
     */
    PdfBlendMode[PdfBlendMode["saturation"] = 13] = "saturation";
    /**
     * Specifies the type of `color`.
     */
    PdfBlendMode[PdfBlendMode["color"] = 14] = "color";
    /**
     * Specifies the type of `luminosity`.
     */
    PdfBlendMode[PdfBlendMode["luminosity"] = 15] = "luminosity";
})(PdfBlendMode || (PdfBlendMode = {}));
/**
 * Public enum to define fill mode of the PDF page.
 * ```typescript
 * // Load an existing PDF document
 * let document: PdfDocument = new PdfDocument(data, password);
 * // Access first page
 * let page: PdfPage = document.getPage(0);
 * // Gets the graphics of the PDF page
 * let graphics: PdfGraphics = page.graphics;
 * // Create a new font
 * let font: PdfStandardFont = new PdfStandardFont(PdfFontFamily.symbol, 10);
 * // Set the fill mode
 * graphics.setClip([0, 0, 100, 100], PdfFillMode.winding);
 * // Draw the text
 * graphics.drawString('Hello World', font, null, new PointF(10, 10));
 * // Save the document
 * document.save('output.pdf');
 * // Destroy the document
 * document.destroy();
 * ```
 */
var PdfFillMode;
(function (PdfFillMode) {
    /**
     * Specifies the type of `winding`.
     */
    PdfFillMode[PdfFillMode["winding"] = 0] = "winding";
    /**
     * Specifies the type of `alternate`.
     */
    PdfFillMode[PdfFillMode["alternate"] = 1] = "alternate";
})(PdfFillMode || (PdfFillMode = {}));
/**
 * Public enum to define the dash style.
 * ```typescript
 * // Load an existing PDF document
 * let document: PdfDocument = new PdfDocument(data, password);
 * // Access first page
 * let page: PdfPage = document.getPage(0);
 * // Gets the graphics of the PDF page
 * let graphics: PdfGraphics = page.graphics;
 * // Create a new pen
 * let pen: PdfPen = new PdfPen([0, 0, 0], 1);
 * // Set the dash style
 * pen._dashStyle = PdfDashStyle.dashDot;
 * // Draw a rectangle using pen
 * graphics.drawRectangle(150, 50, 50, 50, pen);
 * // Save the document
 * document.save('output.pdf');
 * // Destroy the document
 * document.destroy();
 * ```
 */
var PdfDashStyle;
(function (PdfDashStyle) {
    /**
     * Specifies the type of `solid`.
     */
    PdfDashStyle[PdfDashStyle["solid"] = 0] = "solid";
    /**
     * Specifies the type of `dash`.
     */
    PdfDashStyle[PdfDashStyle["dash"] = 1] = "dash";
    /**
     * Specifies the type of `dot`.
     */
    PdfDashStyle[PdfDashStyle["dot"] = 2] = "dot";
    /**
     * Specifies the type of `dashDot`.
     */
    PdfDashStyle[PdfDashStyle["dashDot"] = 3] = "dashDot";
    /**
     * Specifies the type of `dashDotDot`.
     */
    PdfDashStyle[PdfDashStyle["dashDotDot"] = 4] = "dashDotDot";
    /**
     * Specifies the type of `custom`.
     */
    PdfDashStyle[PdfDashStyle["custom"] = 5] = "custom";
})(PdfDashStyle || (PdfDashStyle = {}));
/**
 * Public enum to define the line cap.
 * ```typescript
 * // Load an existing PDF document
 * let document: PdfDocument = new PdfDocument(data, password);
 * // Access first page
 * let page: PdfPage = document.getPage(0);
 * // Gets the graphics of the PDF page
 * let graphics: PdfGraphics = page.graphics;
 * // Create a new pen
 * let pen: PdfPen = new PdfPen([0, 0, 0], 1);
 * // Set the dash style
 * pen._dashStyle = PdfDashStyle.dashDot;
 * // Set the line cap
 * pen._lineCap = PdfLineCap.round;
 * // Draw a rectangle using pen
 * graphics.drawRectangle(150, 50, 50, 50, pen);
 * // Save the document
 * document.save('output.pdf');
 * // Destroy the document
 * document.destroy();
 * ```
 */
var PdfLineCap;
(function (PdfLineCap) {
    /**
     * Specifies the type of `flat`.
     */
    PdfLineCap[PdfLineCap["flat"] = 0] = "flat";
    /**
     * Specifies the type of `round`.
     */
    PdfLineCap[PdfLineCap["round"] = 1] = "round";
    /**
     * Specifies the type of `square`.
     */
    PdfLineCap[PdfLineCap["square"] = 2] = "square";
})(PdfLineCap || (PdfLineCap = {}));
/**
 * Public enum to define the line join.
 * ```typescript
 * // Load an existing PDF document
 * let document: PdfDocument = new PdfDocument(data, password);
 * // Access first page
 * let page: PdfPage = document.getPage(0);
 * // Gets the graphics of the PDF page
 * let graphics: PdfGraphics = page.graphics;
 * // Create a new pen
 * let pen: PdfPen = new PdfPen([0, 0, 0], 1);
 * // Set the dash style
 * pen._dashStyle = PdfDashStyle.dashDot;
 * // Set the line join
 * pen._lineJoin = PdfLineJoin.bevel;
 * // Draw a rectangle using pen
 * graphics.drawRectangle(150, 50, 50, 50, pen);
 * // Save the document
 * document.save('output.pdf');
 * // Destroy the document
 * document.destroy();
 * ```
 */
var PdfLineJoin;
(function (PdfLineJoin) {
    /**
     * Specifies the type of `miter`.
     */
    PdfLineJoin[PdfLineJoin["miter"] = 0] = "miter";
    /**
     * Specifies the type of `round`.
     */
    PdfLineJoin[PdfLineJoin["round"] = 1] = "round";
    /**
     * Specifies the type of `bevel`.
     */
    PdfLineJoin[PdfLineJoin["bevel"] = 2] = "bevel";
})(PdfLineJoin || (PdfLineJoin = {}));
var _PdfWordWrapType;
(function (_PdfWordWrapType) {
    /**
     * Specifies the type of `none`.
     */
    _PdfWordWrapType[_PdfWordWrapType["none"] = 0] = "none";
    /**
     * Specifies the type of `word`.
     */
    _PdfWordWrapType[_PdfWordWrapType["word"] = 1] = "word";
    /**
     * Specifies the type of `wordOnly`.
     */
    _PdfWordWrapType[_PdfWordWrapType["wordOnly"] = 2] = "wordOnly";
    /**
     * Specifies the type of `character`.
     */
    _PdfWordWrapType[_PdfWordWrapType["character"] = 3] = "character";
})(_PdfWordWrapType || (_PdfWordWrapType = {}));
var _FontDescriptorFlag;
(function (_FontDescriptorFlag) {
    _FontDescriptorFlag[_FontDescriptorFlag["fixedPitch"] = 1] = "fixedPitch";
    _FontDescriptorFlag[_FontDescriptorFlag["serif"] = 2] = "serif";
    _FontDescriptorFlag[_FontDescriptorFlag["symbolic"] = 4] = "symbolic";
    _FontDescriptorFlag[_FontDescriptorFlag["script"] = 8] = "script";
    _FontDescriptorFlag[_FontDescriptorFlag["nonSymbolic"] = 32] = "nonSymbolic";
    _FontDescriptorFlag[_FontDescriptorFlag["italic"] = 64] = "italic";
    _FontDescriptorFlag[_FontDescriptorFlag["forceBold"] = 262144] = "forceBold";
})(_FontDescriptorFlag || (_FontDescriptorFlag = {}));
var _TrueTypeCmapFormat;
(function (_TrueTypeCmapFormat) {
    _TrueTypeCmapFormat[_TrueTypeCmapFormat["apple"] = 0] = "apple";
    _TrueTypeCmapFormat[_TrueTypeCmapFormat["microsoft"] = 4] = "microsoft";
    _TrueTypeCmapFormat[_TrueTypeCmapFormat["trimmed"] = 6] = "trimmed";
})(_TrueTypeCmapFormat || (_TrueTypeCmapFormat = {}));
var _TrueTypeCmapEncoding;
(function (_TrueTypeCmapEncoding) {
    _TrueTypeCmapEncoding[_TrueTypeCmapEncoding["unknown"] = 0] = "unknown";
    _TrueTypeCmapEncoding[_TrueTypeCmapEncoding["symbol"] = 1] = "symbol";
    _TrueTypeCmapEncoding[_TrueTypeCmapEncoding["unicode"] = 2] = "unicode";
    _TrueTypeCmapEncoding[_TrueTypeCmapEncoding["macintosh"] = 3] = "macintosh";
})(_TrueTypeCmapEncoding || (_TrueTypeCmapEncoding = {}));
var _TrueTypePlatformID;
(function (_TrueTypePlatformID) {
    _TrueTypePlatformID[_TrueTypePlatformID["appleUnicode"] = 0] = "appleUnicode";
    _TrueTypePlatformID[_TrueTypePlatformID["macintosh"] = 1] = "macintosh";
    _TrueTypePlatformID[_TrueTypePlatformID["iSO"] = 2] = "iSO";
    _TrueTypePlatformID[_TrueTypePlatformID["microsoft"] = 3] = "microsoft";
})(_TrueTypePlatformID || (_TrueTypePlatformID = {}));
var _TrueTypeMicrosoftEncodingID;
(function (_TrueTypeMicrosoftEncodingID) {
    _TrueTypeMicrosoftEncodingID[_TrueTypeMicrosoftEncodingID["undefined"] = 0] = "undefined";
    _TrueTypeMicrosoftEncodingID[_TrueTypeMicrosoftEncodingID["unicode"] = 1] = "unicode";
})(_TrueTypeMicrosoftEncodingID || (_TrueTypeMicrosoftEncodingID = {}));
var _TrueTypeMacintoshEncodingID;
(function (_TrueTypeMacintoshEncodingID) {
    _TrueTypeMacintoshEncodingID[_TrueTypeMacintoshEncodingID["roman"] = 0] = "roman";
    _TrueTypeMacintoshEncodingID[_TrueTypeMacintoshEncodingID["japanese"] = 1] = "japanese";
    _TrueTypeMacintoshEncodingID[_TrueTypeMacintoshEncodingID["chinese"] = 2] = "chinese";
})(_TrueTypeMacintoshEncodingID || (_TrueTypeMacintoshEncodingID = {}));
var _TrueTypeCompositeGlyphFlag;
(function (_TrueTypeCompositeGlyphFlag) {
    _TrueTypeCompositeGlyphFlag[_TrueTypeCompositeGlyphFlag["Arg1And2AreWords"] = 1] = "Arg1And2AreWords";
    _TrueTypeCompositeGlyphFlag[_TrueTypeCompositeGlyphFlag["ArgsAreXyValues"] = 2] = "ArgsAreXyValues";
    _TrueTypeCompositeGlyphFlag[_TrueTypeCompositeGlyphFlag["RoundXyToGrid"] = 4] = "RoundXyToGrid";
    _TrueTypeCompositeGlyphFlag[_TrueTypeCompositeGlyphFlag["WeHaveScale"] = 8] = "WeHaveScale";
    _TrueTypeCompositeGlyphFlag[_TrueTypeCompositeGlyphFlag["Reserved"] = 16] = "Reserved";
    _TrueTypeCompositeGlyphFlag[_TrueTypeCompositeGlyphFlag["MoreComponents"] = 32] = "MoreComponents";
    _TrueTypeCompositeGlyphFlag[_TrueTypeCompositeGlyphFlag["WeHaveAnXyScale"] = 64] = "WeHaveAnXyScale";
    _TrueTypeCompositeGlyphFlag[_TrueTypeCompositeGlyphFlag["WeHaveTwoByTwo"] = 128] = "WeHaveTwoByTwo";
    _TrueTypeCompositeGlyphFlag[_TrueTypeCompositeGlyphFlag["WeHaveInstructions"] = 256] = "WeHaveInstructions";
    _TrueTypeCompositeGlyphFlag[_TrueTypeCompositeGlyphFlag["UseMyMetrics"] = 512] = "UseMyMetrics";
})(_TrueTypeCompositeGlyphFlag || (_TrueTypeCompositeGlyphFlag = {}));
var _ImageFormat;
(function (_ImageFormat) {
    /**
     * Specifies the type of `unknown`.
     */
    _ImageFormat[_ImageFormat["unknown"] = 0] = "unknown";
    /**
     * Specifies the type of `bmp`.
     */
    _ImageFormat[_ImageFormat["bmp"] = 1] = "bmp";
    /**
     * Specifies the type of `emf`.
     */
    _ImageFormat[_ImageFormat["emf"] = 2] = "emf";
    /**
     * Specifies the type of `gif`.
     */
    _ImageFormat[_ImageFormat["gif"] = 3] = "gif";
    /**
     * Specifies the type of `jpeg`.
     */
    _ImageFormat[_ImageFormat["jpeg"] = 4] = "jpeg";
    /**
     * Specifies the type of `png`.
     */
    _ImageFormat[_ImageFormat["png"] = 5] = "png";
    /**
     * Specifies the type of `wmf`.
     */
    _ImageFormat[_ImageFormat["wmf"] = 6] = "wmf";
    /**
     * Specifies the type of `icon`.
     */
    _ImageFormat[_ImageFormat["icon"] = 7] = "icon";
})(_ImageFormat || (_ImageFormat = {}));
var _TokenType;
(function (_TokenType) {
    _TokenType[_TokenType["none"] = 0] = "none";
    _TokenType[_TokenType["comment"] = 1] = "comment";
    _TokenType[_TokenType["number"] = 2] = "number";
    _TokenType[_TokenType["real"] = 3] = "real";
    _TokenType[_TokenType["string"] = 4] = "string";
    _TokenType[_TokenType["hexString"] = 5] = "hexString";
    _TokenType[_TokenType["unicodeString"] = 6] = "unicodeString";
    _TokenType[_TokenType["unicodeHexString"] = 7] = "unicodeHexString";
    _TokenType[_TokenType["name"] = 8] = "name";
    _TokenType[_TokenType["operator"] = 9] = "operator";
    _TokenType[_TokenType["beginArray"] = 10] = "beginArray";
    _TokenType[_TokenType["endArray"] = 11] = "endArray";
    _TokenType[_TokenType["eof"] = 12] = "eof";
})(_TokenType || (_TokenType = {}));
/**
 * Public enum to define text style.
 * ```typescript
 * // Load an existing PDF document
 * let document: PdfDocument = new PdfDocument(data);
 * // Get the bookmarks
 * let bookmarks: PdfBookmarkBase = document.bookmarks;
 * // Gets bookmark at the specified index
 * let bookmark : PdfBookMark = bookmarks.at(0) as PdfBookMark;
 * // Gets the textStyle
 * let textStyle: PdfTextStyle = bookmark.textStyle;
 * // Destroy the document
 * document.destroy();
 * ```
 */
var PdfTextStyle;
(function (PdfTextStyle) {
    /**
     * Specifies the `regular` text style.
     */
    PdfTextStyle[PdfTextStyle["regular"] = 0] = "regular";
    /**
     * Specifies the `italic` text style.
     */
    PdfTextStyle[PdfTextStyle["italic"] = 1] = "italic";
    /**
     * Specifies the `bold` text style.
     */
    PdfTextStyle[PdfTextStyle["bold"] = 2] = "bold";
})(PdfTextStyle || (PdfTextStyle = {}));

/**
 * `PdfTemplate` class represents the template of the PDF.
 * ```typescript
 * // Load an existing PDF document
 * let document: PdfDocument = new PdfDocument(data, password);
 * // Get the first page
 * let page: PdfPage = document.getPage(0) as PdfPage;
 * // Create a new rubber stamp annotation
 * const annotation: PdfRubberStampAnnotation = new PdfRubberStampAnnotation(50, 100, 100, 50);
 * // Get the normal appearance of the annotation
 * let normalAppearance: PdfTemplate = annotation.appearance.normal;
 * // Create new image object by using JPEG image data as Base64 string format
 * let image: PdfImage = new PdfBitmap('/9j/4AAQSkZJRgABAQEAkACQAAD/4....QB//Z');
 * // Draw the image as the custom appearance for the annotation
 * normalAppearance.graphics.drawImage(image, 0, 0, 100, 50);
 * // Add annotation to the page
 * page.annotations.add(annotation);
 * // Save the document
 * document.save('output.pdf');
 * // Destroy the document
 * document.destroy();
 * ```
 */
class PdfTemplate {
    constructor(value, crossReference) {
        this._crossReference = crossReference;
        if (value instanceof _PdfBaseStream) {
            this._content = value;
            if (!this._content.dictionary.has('Type') || !this._content.dictionary.has('Subtype')) {
                this._initialize();
            }
            const bounds = this._content.dictionary.getArray('BBox');
            if (bounds && bounds.length > 3) {
                const rect = _toRectangle(bounds);
                this._size = [rect.width, rect.height];
            }
            this._isReadOnly = true;
        }
        else {
            this._size = [value[2], value[3]];
            this._content = new _PdfContentStream([]);
            this._content.dictionary._crossReference = this._crossReference;
            this._initialize();
            this._content.dictionary.set('BBox', [value[0], value[1], value[0] + value[2], value[1] + value[3]]);
        }
        this._writeTransformation = true;
    }
    /**
     * Get the graphics of the PDF template.
     *
     * @returns {PdfGraphics} The graphics object of the PDF template.
     * ```typescript
     * // Load an existing PDF document
     * let document: PdfDocument = new PdfDocument(data, password);
     * // Get the first page
     * let page: PdfPage = document.getPage(0) as PdfPage;
     * // Create a new rubber stamp annotation
     * const annotation: PdfRubberStampAnnotation = new PdfRubberStampAnnotation(50, 100, 100, 50);
     * // Access the graphics of the normal appearance
     * let graphics: PdfGraphics = annotation.appearance.normal.graphics;
     * // Create new image object by using JPEG image data as Base64 string format
     * let image: PdfImage = new PdfBitmap('/9j/4AAQSkZJRgABAQEAkACQAAD/4....QB//Z');
     * // Draw the image as the custom appearance for the annotation
     * graphics.drawImage(image, 0, 0, 100, 50);
     * // Add annotation to the page
     * page.annotations.add(annotation);
     * // Save the document
     * document.save('output.pdf');
     * // Destroy the document
     * document.destroy();
     * ```
     */
    get graphics() {
        if (this._isReadOnly) {
            return null;
        }
        if (typeof this._g === 'undefined') {
            this._g = new PdfGraphics(this._size, this._content, this._crossReference, this);
            if (this._writeTransformation) {
                this._g._initializeCoordinates();
            }
            this._g._isTemplateGraphics = true;
        }
        return this._g;
    }
    _initialize() {
        this._content.dictionary.set('Type', _PdfName.get('XObject'));
        this._content.dictionary.set('Subtype', _PdfName.get('Form'));
    }
}

/**
 * Represents the text layout information.
 * ```typescript
 * // Load an existing PDF document
 * let document: PdfDocument = new PdfDocument(data, password);
 * // Gets the first page
 * let page: PdfPage = document.getPage(0) as PdfPage;
 * // Create a new PDF standard font
 * let font: PdfStandardFont = new PdfStandardFont(PdfFontFamily.Helvetica, 10);
 * // Create a new PDF string format
 * let format: PdfStringFormat = new PdfStringFormat(PdfTextAlignment.right, PdfVerticalAlignment.bottom);
 * // Draw the text
 * page.graphics.drawString('Helvetica', font, [0, 180, page.size[0], 40], undefined, new PdfBrush([0, 0, 255]), format);
 * // Save the document
 * document.save('output.pdf');
 * // Destroy the document
 * document.destroy();
 * ```
 */
class PdfStringFormat {
    constructor(arg1, arg2) {
        this.horizontalScalingFactor = 100.0;
        this.rightToLeft = false;
        this._wordWrapType = _PdfWordWrapType.word;
        this.lineLimit = true;
        if (typeof arg1 !== 'undefined') {
            this.alignment = arg1;
        }
        if (typeof arg2 !== 'undefined') {
            this.lineAlignment = arg2;
        }
        else {
            this.lineAlignment = PdfVerticalAlignment.top;
        }
        this.characterSpacing = 0;
        this.wordSpacing = 0;
        this.lineSpacing = 0;
        this.clipPath = false;
        this.firstLineIndent = 0;
        this._internalParagraphIndent = 0;
        this.measureTrailingSpaces = false;
        this.noClip = false;
    }
    /**
     * Gets the paragraph indent from string format.
     *
     * @returns {number} Returns the paragraph indent.
     * ```typescript
     * // Load an existing PDF document
     * let document: PdfDocument = new PdfDocument(data, password);
     * // Gets the first page
     * let page: PdfPage = document.getPage(0) as PdfPage;
     * // Create a new PDF standard font
     * let font: PdfStandardFont = new PdfStandardFont(PdfFontFamily.Helvetica, 10);
     * // Create a new PDF string format
     * let format: PdfStringFormat = new PdfStringFormat(PdfTextAlignment.right);
     * // Get the default paragraph indent
     * let paragraph: number = format.paragraphIndent;
     * // Draw the text
     * page.graphics.drawString('Helvetica', font, [0, 180, page.size[0], 40], undefined, new PdfBrush([0, 0, 255]), format);
     * // Save the document
     * document.save('output.pdf');
     * // Destroy the document
     * document.destroy();
     * ```
     */
    get paragraphIndent() {
        return this._internalParagraphIndent;
    }
    /**
     * Sets the paragraph indent to string format.
     *
     * @param {number} value paragraph indent.
     * ```typescript
     * // Load an existing PDF document
     * let document: PdfDocument = new PdfDocument(data, password);
     * // Gets the first page
     * let page: PdfPage = document.getPage(0) as PdfPage;
     * // Create a new PDF standard font
     * let font: PdfStandardFont = new PdfStandardFont(PdfFontFamily.Helvetica, 10);
     * // Create a new PDF string format
     * let format: PdfStringFormat = new PdfStringFormat(PdfTextAlignment.right);
     * // Set a new paragraph indent
     * format.paragraphIndent = 20;
     * // Draw the text
     * page.graphics.drawString('Helvetica', font, [0, 180, page.size[0], 40], undefined, new PdfBrush([0, 0, 255]), format);
     * // Save the document
     * document.save('output.pdf');
     * // Destroy the document
     * document.destroy();
     * ```
     */
    set paragraphIndent(value) {
        this._internalParagraphIndent = value;
        this.firstLineIndent = value;
    }
    /**
     * Gets the subscript or superscript mode from string format.
     *
     * @returns {PdfSubSuperScript} Returns the subscript or superscript mode.
     * ```typescript
     * // Load an existing PDF document
     * let document: PdfDocument = new PdfDocument(data, password);
     * // Gets the first page
     * let page: PdfPage = document.getPage(0) as PdfPage;
     * // Create a new PDF standard font
     * let font: PdfStandardFont = new PdfStandardFont(PdfFontFamily.Helvetica, 10);
     * // Create a new PDF string format
     * let format: PdfStringFormat = new PdfStringFormat(PdfTextAlignment.right);
     * // Set a new paragraph indent
     * format.paragraphIndent = 20;
     * // Get the subscript or superscript mode
     * let script: PdfSubSuperScript = format.subSuperScript;
     * // Draw the text
     * page.graphics.drawString('Helvetica', font, [0, 180, page.size[0], 40], undefined, new PdfBrush([0, 0, 255]), format);
     * // Save the document
     * document.save('output.pdf');
     * // Destroy the document
     * document.destroy();
     * ```
     */
    get subSuperScript() {
        if (typeof this._pdfSubSuperScript === 'undefined' || this._pdfSubSuperScript === null) {
            return PdfSubSuperScript.none;
        }
        else {
            return this._pdfSubSuperScript;
        }
    }
    /**
     * Sets the subscript or superscript mode to string format.
     *
     * @param {PdfSubSuperScript} value subscript or superscript mode.
     * ```typescript
     * // Load an existing PDF document
     * let document: PdfDocument = new PdfDocument(data, password);
     * // Gets the first page
     * let page: PdfPage = document.getPage(0) as PdfPage;
     * // Create a new PDF standard font
     * let font: PdfStandardFont = new PdfStandardFont(PdfFontFamily.Helvetica, 10);
     * // Create a new PDF string format
     * let format: PdfStringFormat = new PdfStringFormat(PdfTextAlignment.right);
     * // Set a new paragraph indent
     * format.paragraphIndent = 20;
     * // Set the subscript or superscript mode
     * format.subSuperScript = PdfSubSuperScript.subScript;
     * // Draw the text
     * page.graphics.drawString('Helvetica', font, [0, 180, page.size[0], 40], undefined, new PdfBrush([0, 0, 255]), format);
     * // Save the document
     * document.save('output.pdf');
     * // Destroy the document
     * document.destroy();
     * ```
     */
    set subSuperScript(value) {
        this._pdfSubSuperScript = value;
    }
    get _wordWrap() {
        return this._wordWrapType;
    }
    set _wordWrap(value) {
        this._wordWrapType = value;
    }
}
/**
 * Public enum to define vertical alignment.
 * ```typescript
 * // Load an existing PDF document
 * let document: PdfDocument = new PdfDocument(data, password);
 * // Gets the first page
 * let page: PdfPage = document.getPage(0) as PdfPage;
 * // Create a new PDF standard font
 * let font: PdfStandardFont = new PdfStandardFont(PdfFontFamily.Helvetica, 10, PdfFontStyle.regular);
 * // Create a new PDF string format
 * let format: PdfStringFormat = new PdfStringFormat(PdfTextAlignment.right, PdfVerticalAlignment.top);
 * // Draw the text
 * page.graphics.drawString('Helvetica', font, [0, 180, page.size[0], 40], undefined, new PdfBrush([0, 0, 255]), format);
 * // Save the document
 * document.save('output.pdf');
 * // Destroy the document
 * document.destroy();
 * ```
 */
var PdfVerticalAlignment;
(function (PdfVerticalAlignment) {
    /**
     * Specifies the type of `top`.
     */
    PdfVerticalAlignment[PdfVerticalAlignment["top"] = 0] = "top";
    /**
     * Specifies the type of `middle`.
     */
    PdfVerticalAlignment[PdfVerticalAlignment["middle"] = 1] = "middle";
    /**
     * Specifies the type of `bottom`.
     */
    PdfVerticalAlignment[PdfVerticalAlignment["bottom"] = 2] = "bottom";
})(PdfVerticalAlignment || (PdfVerticalAlignment = {}));

class _PdfFontMetrics {
    constructor() {
        this._lineGap = 0;
    }
    _getAscent(format) {
        return this._ascent * 0.001 * this._getSize(format);
    }
    _getDescent(format) {
        return this._descent * 0.001 * this._getSize(format);
    }
    _getLineGap(format) {
        return this._lineGap * 0.001 * this._getSize(format);
    }
    _getHeight(format) {
        let height;
        const clearTypeFonts = ['cambria', 'candara', 'constantia', 'corbel', 'cariadings'];
        const clearTypeFontCollection = [];
        for (let index = 0; index < clearTypeFonts.length; index++) {
            clearTypeFontCollection.push(clearTypeFonts[Number.parseInt(index.toString(), 10)]);
        }
        if (this._getDescent(format) < 0) {
            height = (this._getAscent(format) - this._getDescent(format) + this._getLineGap(format));
        }
        else {
            height = (this._getAscent(format) + this._getDescent(format) + this._getLineGap(format));
        }
        return height;
    }
    _getSize(format) {
        let size = this._size;
        if (format !== null && typeof format !== 'undefined') {
            switch (format.subSuperScript) {
                case PdfSubSuperScript.subScript:
                    size /= this._subScriptSizeFactor;
                    break;
                case PdfSubSuperScript.superScript:
                    size /= this._superscriptSizeFactor;
                    break;
            }
        }
        return size;
    }
}
class _WidthTable {
}
class _StandardWidthTable extends _WidthTable {
    constructor(widths) {
        super();
        this.widths = widths;
    }
    _itemAt(index) {
        if (index < 0 || index >= this.widths.length) {
            throw new Error('The character is not supported by the font.');
        }
        return this.widths[Number.parseInt(index.toString(), 10)];
    }
    _toArray() {
        return this.widths;
    }
}
class _CjkWidthTable extends _WidthTable {
    constructor(defaultWidth) {
        super();
        this._defaultWidth = defaultWidth;
        this.widths = [];
    }
    _itemAt(index) {
        let width = this._defaultWidth;
        this.widths.forEach((entry) => {
            if (index >= entry._from && index <= entry._to) {
                width = entry._itemAt(index);
            }
        });
        return width;
    }
    _toArray() {
        const array = [];
        this.widths.forEach((width) => {
            width._appendToArray(array);
        });
        return array;
    }
    _add(width) {
        this.widths.push(width);
    }
}
class _CjkWidth {
}
class _CjkSameWidth extends _CjkWidth {
    constructor(from, to, width) {
        super();
        this._widthFrom = from;
        this._widthTo = to;
        this._width = width;
    }
    get _from() {
        return this._widthFrom;
    }
    get _to() {
        return this._widthTo;
    }
    _itemAt(index) {
        if (index < this._from || index > this._to) {
            throw new Error('Index is out of range.');
        }
        return this._width;
    }
    _appendToArray(array) {
        array.push(this._from, this._to, this._width);
    }
}
class _CjkDifferentWidth extends _CjkWidth {
    constructor(from, widths) {
        super();
        this._widthFrom = from;
        this._widths = widths;
    }
    get _from() {
        return this._widthFrom;
    }
    get _to() {
        return this._widthFrom + this._widths.length - 1;
    }
    _itemAt(index) {
        if (index < this._widthFrom || index > this._to) {
            throw new Error('Index is out of range.');
        }
        return this._widths[Number.parseInt(index.toString(), 10)];
    }
    _appendToArray(array) {
        array.push(this._from);
        array.forEach((entry) => {
            array.push(entry);
        });
    }
}

class _PdfStringLayouter {
    _layout(text, font, format, size) {
        this._initialize(text, font, format, size);
        const result = this._doLayout();
        this._clear();
        return result;
    }
    _initialize(text, font, format, size) {
        this._font = font;
        this._format = format;
        this._size = size;
        this._rectangle = [0, 0, size[0], size[1]];
        this._reader = new _StringTokenizer(text);
        this._pageHeight = 0;
    }
    _clear() {
        this._font = null;
        this._format = null;
        this._reader._close();
        this._reader = null;
    }
    _doLayout() {
        const result = new _PdfStringLayoutResult();
        let lineResult = new _PdfStringLayoutResult();
        const lines = [];
        let line = this._reader._peekLine();
        let lineIndent = this._getLineIndent(true);
        while (line !== null) {
            lineResult = this._layoutLine(line, lineIndent);
            if (typeof lineResult !== 'undefined' && lineResult !== null) {
                let numSymbolsInserted = 0;
                const returnedValue = this._copyToResult(result, lineResult, lines, numSymbolsInserted);
                const success = returnedValue.success;
                numSymbolsInserted = returnedValue.flag;
                if (!success) {
                    this._reader._read(numSymbolsInserted);
                    break;
                }
            }
            this._reader._readLine();
            line = this._reader._peekLine();
            lineIndent = this._getLineIndent(false);
        }
        this._finalizeResult(result, lines);
        return result;
    }
    _getLineIndent(firstLine) {
        let lineIndent = 0;
        if (this._format) {
            lineIndent = (firstLine) ? this._format.firstLineIndent : this._format.paragraphIndent;
            lineIndent = (this._size[0] > 0) ? Math.min(this._size[0], lineIndent) : lineIndent;
        }
        return lineIndent;
    }
    _getLineHeight() {
        let height = this._font._metrics._getHeight();
        if (this._format && this._format.lineSpacing !== 0) {
            height = this._format.lineSpacing + this._font._metrics._getHeight();
        }
        return height;
    }
    _getLineWidth(line) {
        return this._font.getLineWidth(line, this._format);
    }
    _layoutLine(line, lineIndent) {
        const lineResult = new _PdfStringLayoutResult();
        lineResult._lineHeight = this._getLineHeight();
        let lines = [];
        const maxWidth = this._size[0];
        let lineWidth = this._getLineWidth(line) + lineIndent;
        let lineType = _LineType.firstParagraphLine;
        let readWord = true;
        if (maxWidth <= 0 || Math.round(lineWidth) <= Math.round(maxWidth)) {
            this._addToLineResult(lineResult, lines, line, lineWidth, _LineType.newLineBreak | lineType);
        }
        else {
            let builder = '';
            let curLine = '';
            lineWidth = lineIndent;
            let curIndent = lineIndent;
            const reader = new _StringTokenizer(line);
            let word = reader._peekWord();
            if (word.length !== reader._length) {
                if (word === ' ') {
                    curLine = curLine + word;
                    builder = builder + word;
                    reader._position += 1;
                    word = reader._peekWord();
                }
            }
            while (word !== null) {
                curLine = curLine + word;
                let curLineWidth = this._getLineWidth(curLine.toString()) + curIndent;
                if (curLine.toString() === ' ') {
                    curLine = '';
                    curLineWidth = 0;
                }
                if (curLineWidth > maxWidth) {
                    if (this._getWrapType() === _PdfWordWrapType.none) {
                        break;
                    }
                    if (curLine.length === word.length) {
                        if (this._getWrapType() === _PdfWordWrapType.wordOnly) {
                            lineResult._remainder = line.substring(reader._position);
                            break;
                        }
                        else if (curLine.length === 1) {
                            builder = builder + word;
                            break;
                        }
                        else {
                            readWord = false;
                            curLine = '';
                            word = reader._peek().toString();
                            continue;
                        }
                    }
                    else {
                        if (this._getLineWidth(word.toString()) > maxWidth) {
                            if (typeof this._format !== 'undefined' && this._format !== null) {
                                this._format._wordWrap = _PdfWordWrapType.character;
                            }
                        }
                        else {
                            if (typeof this._format !== 'undefined' && this._format !== null) {
                                this._format._wordWrap = _PdfWordWrapType.word;
                            }
                        }
                        if (this._getWrapType() !== _PdfWordWrapType.character || !readWord) {
                            const stringValue = builder.toString();
                            if (stringValue !== ' ') {
                                this._addToLineResult(lineResult, lines, stringValue, lineWidth, _LineType.layoutBreak | lineType);
                            }
                            curLine = '';
                            builder = '';
                            lineWidth = 0;
                            curIndent = 0;
                            curLineWidth = 0;
                            lineType = _LineType.none;
                            word = (readWord) ? word : reader._peekWord();
                            readWord = true;
                        }
                        else {
                            readWord = false;
                            curLine = '';
                            curLine = curLine + builder.toString();
                            word = reader._peek().toString();
                        }
                        continue;
                    }
                }
                builder = builder + word;
                lineWidth = curLineWidth;
                if (readWord) {
                    reader._readWord();
                    word = reader._peekWord();
                }
                else {
                    reader._read();
                    word = reader._peek().toString();
                }
            }
            if (builder.length > 0) {
                this._addToLineResult(lineResult, lines, builder.toString(), lineWidth, _LineType.newLineBreak | _LineType.lastParagraphLine);
            }
            reader._close();
        }
        lineResult._layoutLines = [];
        for (let index = 0; index < lines.length; index++) {
            lineResult._layoutLines.push(lines[index]); // eslint-disable-line
        }
        lines = [];
        return lineResult;
    }
    _addToLineResult(lineResult, lines, line, lineWidth, breakType) {
        const info = new _LineInfo();
        info._text = line;
        info._width = lineWidth;
        info._lineType = breakType;
        lines.push(info);
        const size = lineResult._actualSize;
        size[1] = size[1] + this._getLineHeight();
        size[0] = Math.max(size[0], lineWidth);
        lineResult._size = size;
    }
    _copyToResult(result, lineResult, lines, flag) {
        let success = true;
        const allowPartialLines = (this._format && !this._format.lineLimit);
        let height = result._actualSize[1];
        let maxHeight = this._size[1];
        if ((this._pageHeight > 0) && (maxHeight + this._rectangle[1] > this._pageHeight)) {
            maxHeight = this._rectangle[1] - this._pageHeight;
            maxHeight = Math.max(maxHeight, -maxHeight);
        }
        flag = 0;
        if (lineResult._lines !== null) {
            for (let i = 0, len = lineResult._lines.length; i < len; i++) {
                const expHeight = height + lineResult._lineHeight;
                if (expHeight <= maxHeight || maxHeight <= 0 || allowPartialLines) {
                    let info = lineResult._lines[i]; // eslint-disable-line
                    flag += info._text.length;
                    info = this._trimLine(info, (lines.length === 0));
                    lines.push(info);
                    const size = result._actualSize;
                    size[0] = Math.max(size[0], info._width);
                    result._size = size;
                    height = expHeight;
                }
                else {
                    success = false;
                    break;
                }
            }
        }
        if (height !== result._size[1]) {
            result._size = [result._actualSize[0], height];
        }
        return { success: success, flag: flag };
    }
    _finalizeResult(result, lines) {
        result._layoutLines = [];
        for (let index = 0; index < lines.length; index++) {
            result._layoutLines.push(lines[index]); // eslint-disable-line
        }
        result._lineHeight = this._getLineHeight();
        if (!this._reader._end) {
            result._remainder = this._reader._readToEnd();
        }
        lines = [];
    }
    _trimLine(info, firstLine) {
        const line = info._text.trim();
        let lineWidth = info._width;
        if (line.length !== info._text.length) {
            lineWidth = this._getLineWidth(line);
            if ((info._lineType & _LineType.firstParagraphLine) > 0) {
                lineWidth += this._getLineIndent(firstLine);
            }
        }
        info._text = line;
        info._width = lineWidth;
        return info;
    }
    _getWrapType() {
        const wrapType = (this._format !== null && typeof this._format !== 'undefined') ?
            this._format._wordWrap : _PdfWordWrapType.word;
        return wrapType;
    }
}
class _PdfStringLayoutResult {
    get _actualSize() {
        if (typeof this._size === 'undefined') {
            this._size = [0, 0];
        }
        return this._size;
    }
    get _lines() {
        return this._layoutLines;
    }
    get _empty() {
        return (this._layoutLines == null || this._layoutLines.length === 0);
    }
    get _lineCount() {
        return (!this._empty) ? this._layoutLines.length : 0;
    }
}
class _LineInfo {
}
var _LineType;
(function (_LineType) {
    _LineType[_LineType["none"] = 0] = "none";
    _LineType[_LineType["newLineBreak"] = 1] = "newLineBreak";
    _LineType[_LineType["layoutBreak"] = 2] = "layoutBreak";
    _LineType[_LineType["firstParagraphLine"] = 4] = "firstParagraphLine";
    _LineType[_LineType["lastParagraphLine"] = 8] = "lastParagraphLine";
})(_LineType || (_LineType = {}));
class _StringTokenizer {
    constructor(textValue) {
        this._position = 0;
        if (typeof textValue === 'undefined' || textValue === null) {
            throw new Error('ArgumentNullException:text');
        }
        this._text = textValue;
    }
    get _length() {
        return this._text.length;
    }
    get _end() {
        return (this._position === this._text.length);
    }
    _readLine() {
        let position = this._position;
        while (position < this._length) {
            const ch = this._text[position]; // eslint-disable-line
            let text;
            switch (ch) {
                case '\r':
                case '\n':
                    text = this._text.substring(this._position, position);
                    this._position = position + 1;
                    if (((ch === '\r') && (this._position < this._length)) && (this._text[this._position] === '\n')) {
                        this._position++;
                    }
                    return text;
            }
            position++;
        }
        if (position > this._position) {
            const text2 = this._text.substring(this._position, position);
            this._position = position;
            return text2;
        }
        return null;
    }
    _peekLine() {
        const position = this._position;
        const line = this._readLine();
        this._position = position;
        return line;
    }
    _readWord() {
        let position = this._position;
        while (position < this._length) {
            const ch = this._text[position]; // eslint-disable-line
            let text;
            switch (ch) {
                case '\r':
                case '\n':
                    text = this._text.substring(this._position, position - this._position);
                    this._position = position + 1;
                    if (((ch === '\r') && (this._position < this._length)) && (this._text[this._position] === '\n')) {
                        this._position++;
                    }
                    return text;
                case ' ':
                case '\t':
                    if (position === this._position) {
                        position++;
                    }
                    text = this._text.substring(this._position, position);
                    this._position = position;
                    return text;
            }
            position++;
        }
        if (position > this._position) {
            const text2 = this._text.substring(this._position, position);
            this._position = position;
            return text2;
        }
        return null;
    }
    _peekWord() {
        const position = this._position;
        const word = this._readWord();
        this._position = position;
        return word;
    }
    _read(count) {
        if (typeof count === 'undefined') {
            let character = '0';
            if (!this._end) {
                character = this._text[this._position];
                this._position++;
            }
            return character;
        }
        else {
            let value = 0;
            let builder = '';
            while (!this._end && value < count) {
                builder += this._read();
                value++;
            }
            return builder;
        }
    }
    _peek() {
        return this._end ? '0' : this._text[this._position];
    }
    _close() {
        this._text = null;
    }
    _readToEnd() {
        let text;
        if (this._position === 0) {
            text = this._text;
        }
        else {
            text = this._text.substring(this._position);
        }
        this._position = this._length;
        return text;
    }
}
_StringTokenizer._whiteSpace = ' ';
_StringTokenizer._tab = '\t';
_StringTokenizer._spaces = [_StringTokenizer._whiteSpace, _StringTokenizer._tab];

class _TrueTypeTableInfo {
    get _empty() {
        const empty = (this._offset === this._length && this._length === this._checksum && this._checksum === 0);
        return empty;
    }
}
class _TrueTypeOS2Table {
}
class _TrueTypePostTable {
}
class _TrueTypeNameTable {
}
class _TrueTypeMicrosoftCmapSubTable {
}
class _TrueTypeHorizontalHeaderTable {
}
class _TrueTypeHeadTable {
}
class _TrueTypeCmapTable {
}
class _TrueTypeCmapSubTable {
}
class _TrueTypeAppleCmapSubTable {
}
class _TrueTypeTrimmedCmapSubTable {
}

class _TrueTypeReader {
    constructor(fontData) {
        this._int32Size = 4;
        this._isFont = false;
        this._isMacTtf = false;
        this._isMacFont = false;
        this._missedGlyphs = 0;
        this._tableNames = ['cvt ', 'fpgm', 'glyf', 'head', 'hhea', 'hmtx', 'loca', 'maxp', 'prep'];
        this._entrySelectors = [0, 0, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 3, 3, 3, 3, 4, 4, 4, 4, 4];
        this._fontData = fontData;
        this._initialize();
    }
    get macintosh() {
        if (this._macintoshDictionary === null || typeof this._macintoshDictionary === 'undefined') {
            this._macintoshDictionary = new Dictionary();
        }
        return this._macintoshDictionary;
    }
    get _microsoft() {
        if (this._microsoftDictionary === null || typeof this._microsoftDictionary === 'undefined') {
            this._microsoftDictionary = new Dictionary();
        }
        return this._microsoftDictionary;
    }
    get _macintoshGlyphs() {
        if (this._internalMacintoshGlyphs === null || typeof this._internalMacintoshGlyphs === 'undefined') {
            this._internalMacintoshGlyphs = new Dictionary();
        }
        return this._internalMacintoshGlyphs;
    }
    get _microsoftGlyphs() {
        if (this._internalMicrosoftGlyphs === null || typeof this._internalMicrosoftGlyphs === 'undefined') {
            this._internalMicrosoftGlyphs = new Dictionary();
        }
        return this._internalMicrosoftGlyphs;
    }
    _initialize() {
        if (typeof this._metrics === 'undefined' || this._metrics === null) {
            this._metrics = new _TrueTypeMetrics();
        }
        this._readFontDictionary();
        const nameTable = this._readNameTable();
        const headTable = this._readHeadTable();
        this._initializeFontName(nameTable);
        this._metrics._macStyle = headTable._macStyle;
    }
    _readFontDictionary() {
        this._offset = 0;
        this._check();
        const table = this._readInt16(this._offset);
        this._readInt16(this._offset);
        this._readInt16(this._offset);
        this._readInt16(this._offset);
        if (typeof this._tableDirectory === 'undefined' || this._tableDirectory === null) {
            this._tableDirectory = new Dictionary();
        }
        for (let i = 0; i < table; ++i) {
            const table = new _TrueTypeTableInfo();
            const tableKey = this._readString(this._int32Size);
            table._checksum = this._readInt32(this._offset);
            table._offset = this._readInt32(this._offset);
            table._length = this._readInt32(this._offset);
            this._tableDirectory.setValue(tableKey, table);
        }
        this._lowestPosition = this._offset;
        if (!this._isFont) {
            this._fixOffsets();
        }
    }
    _fixOffsets() {
        let minOffset = Number.MAX_VALUE;
        const tableKeys = this._tableDirectory.keys();
        for (let i = 0; i < tableKeys.length; i++) {
            const value = this._tableDirectory.getValue(tableKeys[Number.parseInt(i.toString(), 10)]);
            const offset = value._offset;
            if (minOffset > offset) {
                minOffset = offset;
                if (minOffset <= this._lowestPosition) {
                    break;
                }
            }
        }
        const shift = minOffset - this._lowestPosition;
        if (shift !== 0) {
            const table = new Dictionary();
            for (let i = 0; i < tableKeys.length; i++) {
                const value = this._tableDirectory.getValue(tableKeys[Number.parseInt(i.toString(), 10)]);
                value._offset -= shift;
                table.setValue(tableKeys[Number.parseInt(i.toString(), 10)], value);
            }
            this._tableDirectory = table;
        }
    }
    _check() {
        let version = this._readInt32(this._offset);
        this._isMacTtf = (version === 0x74727565) ? true : false;
        if (version !== 0x10000 && version !== 0x74727565 && version !== 0x4f54544f) {
            this._isFont = true;
            this._offset = 0;
            const fontTag = this._readString(4);
            if (fontTag !== 'ttcf') {
                throw new Error('Can not read TTF font data');
            }
            this._offset += 4;
            const ttcIdentificationNumber = this._readInt32(this._offset);
            if (ttcIdentificationNumber < 0) {
                throw new Error('Can not read TTF font data');
            }
            this._offset = this._readInt32(this._offset);
            version = this._readInt32(this._offset);
        }
        return version;
    }
    _readNameTable() {
        const tableInfo = this._getTable('name');
        if (typeof tableInfo._offset !== 'undefined' && tableInfo._offset !== null) {
            this._offset = tableInfo._offset;
        }
        const table = new _TrueTypeNameTable();
        table._formatSelector = this._readUInt16(this._offset);
        table._recordsCount = this._readUInt16(this._offset);
        table._offset = this._readUInt16(this._offset);
        table._nameRecords = [];
        const recordSize = 12;
        let position = this._offset;
        for (let i = 0; i < table._recordsCount; i++) {
            this._offset = position;
            const record = new _TrueTypeNameRecord();
            record._platformID = this._readUInt16(this._offset);
            record._encodingID = this._readUInt16(this._offset);
            record._languageID = this._readUInt16(this._offset);
            record._nameID = this._readUInt16(this._offset);
            record._length = this._readUInt16(this._offset);
            record._offset = this._readUInt16(this._offset);
            this._offset = tableInfo._offset + table._offset + record._offset;
            const unicode = (record._platformID === 0 || record._platformID === 3);
            record._name = this._readString(record._length, unicode);
            table._nameRecords[Number.parseInt(i.toString(), 10)] = record;
            position += recordSize;
        }
        return table;
    }
    _readHeadTable() {
        const tableInfo = this._getTable('head');
        if (typeof tableInfo._offset !== 'undefined' && tableInfo._offset !== null) {
            this._offset = tableInfo._offset;
        }
        const table = new _TrueTypeHeadTable();
        table._version = this._readFixed(this._offset);
        table._fontRevision = this._readFixed(this._offset);
        table._checkSumAdjustment = this._readUInt32(this._offset);
        table._magicNumber = this._readUInt32(this._offset);
        table._flags = this._readUInt16(this._offset);
        table._unitsPerEm = this._readUInt16(this._offset);
        table._created = this._readInt64(this._offset);
        table._modified = this._readInt64(this._offset);
        table._xMin = this._readInt16(this._offset);
        table._yMin = this._readInt16(this._offset);
        table._xMax = this._readInt16(this._offset);
        table._yMax = this._readInt16(this._offset);
        table._macStyle = this._readUInt16(this._offset);
        table._lowestReadableSize = this._readUInt16(this._offset);
        table._fontDirectionHint = this._readInt16(this._offset);
        table._indexToLocalFormat = this._readInt16(this._offset);
        table._glyphDataFormat = this._readInt16(this._offset);
        return table;
    }
    _readHorizontalHeaderTable() {
        const tableInfo = this._getTable('hhea');
        if (typeof tableInfo._offset !== 'undefined' && tableInfo._offset !== null) {
            this._offset = tableInfo._offset;
        }
        const table = new _TrueTypeHorizontalHeaderTable();
        table._version = this._readFixed(this._offset);
        table._ascender = this._readInt16(this._offset);
        table._descender = this._readInt16(this._offset);
        table._lineGap = this._readInt16(this._offset);
        table._advanceWidthMax = this._readUInt16(this._offset);
        table._minLeftSideBearing = this._readInt16(this._offset);
        table._minRightSideBearing = this._readInt16(this._offset);
        table._xMaxExtent = this._readInt16(this._offset);
        table._caretSlopeRise = this._readInt16(this._offset);
        table._caretSlopeRun = this._readInt16(this._offset);
        this._offset += 10;
        table._metricDataFormat = this._readInt16(this._offset);
        table._numberOfHMetrics = this._readUInt16(this._offset);
        return table;
    }
    _readOS2Table() {
        const tableInfo = this._getTable('OS/2');
        if (typeof tableInfo._offset !== 'undefined' && tableInfo._offset !== null) {
            this._offset = tableInfo._offset;
        }
        const table = new _TrueTypeOS2Table();
        table._version = this._readUInt16(this._offset);
        table._xAvgCharWidth = this._readInt16(this._offset);
        table._usWeightClass = this._readUInt16(this._offset);
        table._usWidthClass = this._readUInt16(this._offset);
        table._fsType = this._readInt16(this._offset);
        table._ySubscriptXSize = this._readInt16(this._offset);
        table._ySubscriptYSize = this._readInt16(this._offset);
        table._ySubscriptXOffset = this._readInt16(this._offset);
        table._ySubscriptYOffset = this._readInt16(this._offset);
        table._ySuperscriptXSize = this._readInt16(this._offset);
        table._ySuperscriptYSize = this._readInt16(this._offset);
        table._ySuperscriptXOffset = this._readInt16(this._offset);
        table._ySuperscriptYOffset = this._readInt16(this._offset);
        table._yStrikeoutSize = this._readInt16(this._offset);
        table._yStrikeoutPosition = this._readInt16(this._offset);
        table._sFamilyClass = this._readInt16(this._offset);
        table._panose = this._readBytes(10);
        table._ulUnicodeRange1 = this._readUInt32(this._offset);
        table._ulUnicodeRange2 = this._readUInt32(this._offset);
        table._ulUnicodeRange3 = this._readUInt32(this._offset);
        table._ulUnicodeRange4 = this._readUInt32(this._offset);
        table._vendorIdentifier = this._readBytes(4);
        table._fsSelection = this._readUInt16(this._offset);
        table._usFirstCharIndex = this._readUInt16(this._offset);
        table._usLastCharIndex = this._readUInt16(this._offset);
        table._sTypoAscender = this._readInt16(this._offset);
        table._sTypoDescender = this._readInt16(this._offset);
        table._sTypoLineGap = this._readInt16(this._offset);
        table._usWinAscent = this._readUInt16(this._offset);
        table._usWinDescent = this._readUInt16(this._offset);
        table._ulCodePageRange1 = this._readUInt32(this._offset);
        table._ulCodePageRange2 = this._readUInt32(this._offset);
        if (table._version > 1) {
            table._sxHeight = this._readInt16(this._offset);
            table._sCapHeight = this._readInt16(this._offset);
            table._usDefaultChar = this._readUInt16(this._offset);
            table._usBreakChar = this._readUInt16(this._offset);
            table._usMaxContext = this._readUInt16(this._offset);
        }
        else {
            table._sxHeight = 0;
            table._sCapHeight = 0;
            table._usDefaultChar = 0;
            table._usBreakChar = 0;
            table._usMaxContext = 0;
        }
        return table;
    }
    _readPostTable() {
        const tableInfo = this._getTable('post');
        if (typeof tableInfo._offset !== 'undefined' && tableInfo._offset !== null) {
            this._offset = tableInfo._offset;
        }
        const table = new _TrueTypePostTable();
        table._formatType = this._readFixed(this._offset);
        table._italicAngle = this._readFixed(this._offset);
        table._underlinePosition = this._readInt16(this._offset);
        table._underlineThickness = this._readInt16(this._offset);
        table._isFixedPitch = this._readUInt32(this._offset);
        table._minType42 = this._readUInt32(this._offset);
        table._maxType42 = this._readUInt32(this._offset);
        table._minType1 = this._readUInt32(this._offset);
        table._maxType1 = this._readUInt32(this._offset);
        return table;
    }
    _readWidthTable(glyphCount, unitsPerEm) {
        const tableInfo = this._getTable('hmtx');
        if (typeof tableInfo._offset !== 'undefined' && tableInfo._offset !== null) {
            this._offset = tableInfo._offset;
        }
        const width = [];
        for (let i = 0; i < glyphCount; i++) {
            const glyph = new _TrueTypeLongHorMetric();
            glyph._advanceWidth = this._readUInt16(this._offset);
            glyph._lsb = this._readInt16(this._offset);
            const glyphWidth = glyph._advanceWidth * 1000 / unitsPerEm;
            width.push(Math.floor(glyphWidth));
        }
        return width;
    }
    _readCmapTable() {
        const tableInfo = this._getTable('cmap');
        if (typeof tableInfo._offset !== 'undefined' && tableInfo._offset !== null) {
            this._offset = tableInfo._offset;
        }
        const table = new _TrueTypeCmapTable();
        table._version = this._readUInt16(this._offset);
        table._tablesCount = this._readUInt16(this._offset);
        let position = this._offset;
        const subTables = [];
        for (let i = 0; i < table._tablesCount; i++) {
            this._offset = position;
            const subTable = new _TrueTypeCmapSubTable();
            subTable._platformID = this._readUInt16(this._offset);
            subTable._encodingID = this._readUInt16(this._offset);
            subTable._offset = this._readUInt32(this._offset);
            position = this._offset;
            this._readCmapSubTable(subTable);
            subTables[Number.parseInt(i.toString(), 10)] = subTable;
        }
        return subTables;
    }
    _readCmapSubTable(subTable) {
        const tableInfo = this._getTable('cmap');
        this._offset = tableInfo._offset + subTable._offset;
        const format = this._readUInt16(this._offset);
        const encoding = this._getCmapEncoding(subTable._platformID, subTable._encodingID);
        if (encoding !== _TrueTypeCmapEncoding.unknown) {
            switch (format) {
                case _TrueTypeCmapFormat.apple:
                    this._readAppleCmapTable(subTable, encoding);
                    break;
                case _TrueTypeCmapFormat.microsoft:
                    this._readMicrosoftCmapTable(subTable, encoding);
                    break;
                case _TrueTypeCmapFormat.trimmed:
                    this._readTrimmedCmapTable(subTable, encoding);
                    break;
            }
        }
    }
    _readAppleCmapTable(subTable, encoding) {
        const tableInfo = this._getTable('cmap');
        this._offset = tableInfo._offset + subTable._offset;
        const table = new _TrueTypeAppleCmapSubTable();
        table._format = this._readUInt16(this._offset);
        table._length = this._readUInt16(this._offset);
        table._version = this._readUInt16(this._offset);
        if (this._maxMacIndex === null || typeof this._maxMacIndex === 'undefined') {
            this._maxMacIndex = 0;
        }
        for (let i = 0; i < 256; ++i) {
            const glyphInfo = new _TrueTypeGlyph();
            glyphInfo._index = this._readByte(this._offset);
            glyphInfo._width = this._getWidth(glyphInfo._index);
            glyphInfo._charCode = i;
            this.macintosh.setValue(i, glyphInfo);
            this._addGlyph(glyphInfo, encoding);
            this._maxMacIndex = Math.max(i, this._maxMacIndex);
        }
    }
    _readMicrosoftCmapTable(subTable, encoding) {
        const tableInfo = this._getTable('cmap');
        this._offset = tableInfo._offset + subTable._offset;
        const collection = (encoding === _TrueTypeCmapEncoding.unicode) ? this._microsoft
            : this.macintosh;
        const table = new _TrueTypeMicrosoftCmapSubTable();
        table._format = this._readUInt16(this._offset);
        table._length = this._readUInt16(this._offset);
        table._version = this._readUInt16(this._offset);
        table._segCountX2 = this._readUInt16(this._offset);
        table._searchRange = this._readUInt16(this._offset);
        table._entrySelector = this._readUInt16(this._offset);
        table._rangeShift = this._readUInt16(this._offset);
        const segCount = table._segCountX2 / 2;
        table._endCount = this._readUShortArray(segCount);
        table._reservedPad = this._readUInt16(this._offset);
        table._startCount = this._readUShortArray(segCount);
        table._idDelta = this._readUShortArray(segCount);
        table._idRangeOffset = this._readUShortArray(segCount);
        const length = (table._length / 2 - 8) - (segCount * 4);
        table._glyphID = this._readUShortArray(length);
        let codeOffset = 0;
        let index = 0;
        for (let j = 0; j < segCount; j++) {
            for (let k = table._startCount[Number.parseInt(j.toString(), 10)]; k <=
                table._endCount[Number.parseInt(j.toString(), 10)] && k !== 65535; k++) {
                if (table._idRangeOffset[Number.parseInt(j.toString(), 10)] === 0) {
                    codeOffset = (k + table._idDelta[Number.parseInt(j.toString(), 10)]) & 65535;
                }
                else {
                    index = j + table._idRangeOffset[Number.parseInt(j.toString(), 10)] / 2 - segCount +
                        k - table._startCount[Number.parseInt(j.toString(), 10)];
                    if (index >= table._glyphID.length) {
                        continue;
                    }
                    codeOffset = (table._glyphID[Number.parseInt(index.toString(), 10)] +
                        table._idDelta[Number.parseInt(j.toString(), 10)]) & 65535;
                }
                const glyph = new _TrueTypeGlyph();
                glyph._index = codeOffset;
                glyph._width = this._getWidth(glyph._index);
                const id = (encoding === _TrueTypeCmapEncoding.symbol) ? ((k & 0xff00) === 0xf000 ? k & 0xff : k) : k;
                glyph._charCode = id;
                collection.setValue(id, glyph);
                this._addGlyph(glyph, encoding);
            }
        }
    }
    _readTrimmedCmapTable(subTable, encoding) {
        const tableInfo = this._getTable('cmap');
        this._offset = tableInfo._offset + subTable._offset;
        const table = new _TrueTypeTrimmedCmapSubTable();
        table._format = this._readUInt16(this._offset);
        table._length = this._readUInt16(this._offset);
        table._version = this._readUInt16(this._offset);
        table._firstCode = this._readUInt16(this._offset);
        table._entryCount = this._readUInt16(this._offset);
        for (let i = 0; i < table._entryCount; ++i) {
            const glyphInfo = new _TrueTypeGlyph();
            glyphInfo._index = this._readUInt16(this._offset);
            glyphInfo._width = this._getWidth(glyphInfo._index);
            glyphInfo._charCode = i + table._firstCode;
            this.macintosh.setValue(i, glyphInfo);
            this._addGlyph(glyphInfo, encoding);
            this._maxMacIndex = Math.max(i, this._maxMacIndex);
        }
    }
    _initializeFontName(nameTable) {
        for (let i = 0; i < nameTable._recordsCount; i++) {
            const record = nameTable._nameRecords[Number.parseInt(i.toString(), 10)];
            if (record._nameID === 1) {
                this._metrics._fontFamily = record._name;
            }
            else if (record._nameID === 6) {
                this._metrics._postScriptName = record._name;
            }
            if (this._metrics._fontFamily !== null && this._metrics._fontFamily !== 'undefined' &&
                this._metrics._postScriptName !== null && this._metrics._postScriptName !== 'undefined') {
                break;
            }
        }
    }
    _getTable(name) {
        let table = new _TrueTypeTableInfo();
        let obj;
        if (this._tableDirectory.containsKey(name)) {
            obj = this._tableDirectory.getValue(name);
        }
        if (obj !== null && typeof obj !== 'undefined') {
            table = obj;
        }
        return table;
    }
    _getWidth(glyphCode) {
        glyphCode = (glyphCode < this._width.length) ? glyphCode : this._width.length - 1;
        return this._width[Number.parseInt(glyphCode.toString(), 10)];
    }
    _getCmapEncoding(platformID, encodingID) {
        let format = _TrueTypeCmapEncoding.unknown;
        if (platformID === _TrueTypePlatformID.microsoft &&
            encodingID === _TrueTypeMicrosoftEncodingID.undefined) {
            format = _TrueTypeCmapEncoding.symbol;
        }
        else if (platformID === _TrueTypePlatformID.microsoft
            && encodingID === _TrueTypeMicrosoftEncodingID.unicode) {
            format = _TrueTypeCmapEncoding.unicode;
        }
        else if (platformID === _TrueTypePlatformID.macintosh
            && encodingID === _TrueTypeMacintoshEncodingID.roman) {
            format = _TrueTypeCmapEncoding.macintosh;
        }
        return format;
    }
    _addGlyph(glyph, encoding) {
        let collection = null;
        switch (encoding) {
            case _TrueTypeCmapEncoding.unicode:
                collection = this._microsoftGlyphs;
                break;
            case _TrueTypeCmapEncoding.macintosh:
            case _TrueTypeCmapEncoding.symbol:
                collection = this._macintoshGlyphs;
                break;
        }
        collection.setValue(glyph._index, glyph);
    }
    _initializeMetrics(nameTable, headTable, horizontalHeadTable, os2Table, postTable, cmapTables) {
        this._initializeFontName(nameTable);
        let bSymbol = false;
        for (let i = 0; i < cmapTables.length; i++) {
            const subTable = cmapTables[Number.parseInt(i.toString(), 10)];
            const encoding = this._getCmapEncoding(subTable._platformID, subTable._encodingID);
            if (encoding === _TrueTypeCmapEncoding.symbol) {
                bSymbol = true;
                break;
            }
        }
        this._metrics._isSymbol = bSymbol;
        this._metrics._macStyle = headTable._macStyle;
        this._metrics._isFixedPitch = (postTable._isFixedPitch !== 0);
        this._metrics._italicAngle = postTable._italicAngle;
        const factor = 1000 / headTable._unitsPerEm;
        this._metrics._winAscent = os2Table._sTypoAscender * factor;
        this._metrics._macAscent = horizontalHeadTable._ascender * factor;
        this._metrics._capHeight = (os2Table._sCapHeight !== 0) ? os2Table._sCapHeight : 0.7 * headTable._unitsPerEm * factor;
        this._metrics._winDescent = os2Table._sTypoDescender * factor;
        this._metrics._macDescent = horizontalHeadTable._descender * factor;
        this._metrics._leading = (os2Table._sTypoAscender - os2Table._sTypoDescender + os2Table._sTypoLineGap) * factor;
        this._metrics._lineGap = Math.ceil(horizontalHeadTable._lineGap * factor);
        const left = headTable._xMin * factor;
        const top = Math.ceil(this._metrics._macAscent + this._metrics._lineGap);
        const right = headTable._xMax * factor;
        const bottom = this._metrics._macDescent;
        this._metrics._fontBox = [left, top, right, bottom];
        this._metrics._stemV = 80;
        this._metrics._widthTable = this._updateWidth();
        this._metrics._contains = this._tableDirectory.containsKey('CFF');
        this._metrics._subScriptSizeFactor = headTable._unitsPerEm / os2Table._ySubscriptYSize;
        this._metrics._superscriptSizeFactor = headTable._unitsPerEm / os2Table._ySuperscriptYSize;
    }
    _updateWidth() {
        const count = 256;
        const bytes = [];
        if (this._metrics._isSymbol) {
            for (let i = 0; i < count; i++) {
                const glyphInfo = this._getGlyph(String.fromCharCode(Number.parseInt(i.toString(), 10)));
                bytes[Number.parseInt(i.toString(), 10)] = (glyphInfo._empty) ? 0 : glyphInfo._width;
            }
        }
        else {
            const byteToProcess = [];
            const unknown = '?';
            const space = String.fromCharCode(32);
            for (let i = 0; i < count; i++) {
                byteToProcess[0] = Number.parseInt(i.toString(), 10);
                const text = this._getString(byteToProcess, 0, byteToProcess.length);
                const ch = (text.length > 0) ? text[0] : unknown;
                let glyphInfo = this._getGlyph(ch);
                if (!glyphInfo._empty) {
                    bytes[Number.parseInt(i.toString(), 10)] = glyphInfo._width;
                }
                else {
                    glyphInfo = this._getGlyph(space);
                    bytes[Number.parseInt(i.toString(), 10)] = (glyphInfo._empty) ? 0 : glyphInfo._width;
                }
            }
        }
        return bytes;
    }
    _getDefaultGlyph() {
        const glyph = this._getGlyph(_StringTokenizer._whiteSpace);
        return glyph;
    }
    _getString(byteToProcess, start, length) {
        let result = '';
        for (let index = 0; index < length; index++) {
            result += String.fromCharCode(byteToProcess[index + start]);
        }
        return result;
    }
    _setOffset(offset) {
        this._offset = offset;
    }
    _readFontProgram(chars) {
        const glyphChars = this._getGlyphChars(chars);
        const locaTable = this._readLocaTable(this._bIsLocaShort);
        if (glyphChars && glyphChars._size() < chars._size()) {
            this._missedGlyphs = chars._size() - glyphChars._size();
        }
        this._updateGlyphChars(glyphChars, locaTable);
        const result1 = this._generateGlyphTable(glyphChars, locaTable, null, null);
        const glyphTableSize = result1.glyphTableSize;
        const newLocaTable = result1.newLocaTable;
        const newGlyphTable = result1.newGlyphTable;
        const result2 = this._updateLocaTable(newLocaTable, this._bIsLocaShort);
        const newLocaSize = result2.newLocaSize;
        const newLocaUpdated = result2.newLocaUpdated;
        const fontProgram = this._getFontProgram(newLocaUpdated, newGlyphTable, glyphTableSize, newLocaSize);
        return fontProgram;
    }
    _generateGlyphTable(glyphChars, locaTable, newLocaTable, newGlyphTable) {
        newLocaTable = [];
        const activeGlyphs = glyphChars.keys();
        activeGlyphs.sort((a, b) => a - b);
        let glyphSize = 0;
        for (let i = 0; i < activeGlyphs.length; i++) {
            const glyphIndex = activeGlyphs[Number.parseInt(i.toString(), 10)];
            if (locaTable._offsets.length > 0) {
                glyphSize += locaTable._offsets[glyphIndex + 1] - locaTable._offsets[Number.parseInt(glyphIndex.toString(), 10)];
            }
        }
        const glyphSizeAligned = this._align(glyphSize);
        newGlyphTable = [];
        for (let i = 0; i < glyphSizeAligned; i++) {
            newGlyphTable.push(0);
        }
        let nextGlyphOffset = 0;
        let nextGlyphIndex = 0;
        const table = this._getTable('glyf');
        for (let i = 0; i < locaTable._offsets.length; i++) {
            newLocaTable.push(nextGlyphOffset);
            if (nextGlyphIndex < activeGlyphs.length && activeGlyphs[Number.parseInt(nextGlyphIndex.toString(), 10)] === i) {
                ++nextGlyphIndex;
                newLocaTable[Number.parseInt(i.toString(), 10)] = nextGlyphOffset;
                const oldGlyphOffset = locaTable._offsets[Number.parseInt(i.toString(), 10)];
                const oldNextGlyphOffset = locaTable._offsets[i + 1] - oldGlyphOffset;
                if (oldNextGlyphOffset > 0) {
                    this._offset = table._offset + oldGlyphOffset;
                    const result = this._read(newGlyphTable, nextGlyphOffset, oldNextGlyphOffset);
                    newGlyphTable = result.buffer;
                    nextGlyphOffset += oldNextGlyphOffset;
                }
            }
        }
        return { glyphTableSize: glyphSize, newLocaTable: newLocaTable, newGlyphTable: newGlyphTable };
    }
    _readLocaTable(bShort) {
        const tableInfo = this._getTable('loca');
        this._offset = tableInfo._offset;
        const table = new _TrueTypeLocaTable();
        let buffer = [];
        if (bShort) {
            const len = tableInfo._length / 2;
            buffer = [];
            for (let i = 0; i < len; i++) {
                buffer[Number.parseInt(i.toString(), 10)] = this._readUInt16(this._offset) * 2;
            }
        }
        else {
            const len = tableInfo._length / 4;
            buffer = [];
            for (let i = 0; i < len; i++) {
                buffer[Number.parseInt(i.toString(), 10)] = this._readUInt32(this._offset);
            }
        }
        table._offsets = buffer;
        return table;
    }
    _updateGlyphChars(glyphChars, locaTable) {
        if (!glyphChars.containsKey(0)) {
            glyphChars.setValue(0, 0);
        }
        const clone = new Dictionary();
        const glyphCharKeys = glyphChars.keys();
        for (let i = 0; i < glyphCharKeys.length; i++) {
            clone.setValue(glyphCharKeys[Number.parseInt(i.toString(), 10)], glyphChars.getValue(glyphCharKeys[Number.parseInt(i.toString(), 10)]));
        }
        for (let i = 0; i < glyphCharKeys.length; i++) {
            const nextKey = glyphCharKeys[Number.parseInt(i.toString(), 10)];
            this._processCompositeGlyph(glyphChars, nextKey, locaTable);
        }
    }
    _processCompositeGlyph(glyphChars, glyph, locaTable) {
        if (glyph < locaTable._offsets.length - 1) {
            const glyphOffset = locaTable._offsets[Number.parseInt(glyph.toString(), 10)];
            if (glyphOffset !== locaTable._offsets[glyph + 1]) {
                const tableInfo = this._getTable('glyf');
                this._offset = tableInfo._offset + glyphOffset;
                const glyphHeader = new _TrueTypeGlyphHeader();
                glyphHeader.numberOfContours = this._readInt16(this._offset);
                glyphHeader.xMin = this._readInt16(this._offset);
                glyphHeader.yMin = this._readInt16(this._offset);
                glyphHeader.xMax = this._readInt16(this._offset);
                glyphHeader.yMax = this._readInt16(this._offset);
                if (glyphHeader.numberOfContours < 0) {
                    let skipBytes = 0;
                    const entry = true;
                    while (entry) {
                        const flags = this._readUInt16(this._offset);
                        const glyphIndex = this._readUInt16(this._offset);
                        if (!glyphChars.containsKey(glyphIndex)) {
                            glyphChars.setValue(glyphIndex, 0);
                        }
                        if ((flags & _TrueTypeCompositeGlyphFlag.MoreComponents) === 0) {
                            break;
                        }
                        skipBytes = ((flags & _TrueTypeCompositeGlyphFlag.Arg1And2AreWords) !== 0) ? 4 : 2;
                        if ((flags & _TrueTypeCompositeGlyphFlag.WeHaveScale) !== 0) {
                            skipBytes += 2;
                        }
                        else if ((flags & _TrueTypeCompositeGlyphFlag.WeHaveAnXyScale) !== 0) {
                            skipBytes += 4;
                        }
                        else if ((flags & _TrueTypeCompositeGlyphFlag.WeHaveTwoByTwo) !== 0) {
                            skipBytes += 2 * 4;
                        }
                        this._offset += skipBytes;
                    }
                }
            }
        }
    }
    _updateLocaTable(newLocaTable, bLocaIsShort) {
        const size = (bLocaIsShort) ? newLocaTable.length * 2 : newLocaTable.length * 4;
        const count = this._align(size);
        const writer = new _BigEndianWriter(count);
        for (let i = 0; i < newLocaTable.length; i++) {
            let value = newLocaTable[Number.parseInt(i.toString(), 10)];
            if (bLocaIsShort) {
                value /= 2;
                writer._writeShort(value);
            }
            else {
                writer._writeInt(value);
            }
        }
        return { newLocaUpdated: writer._data, newLocaSize: size };
    }
    _align(value) {
        return (value + 3) & (~3);
    }
    _getFontProgram(newLocaTableOut, newGlyphTable, glyphTableSize, locaTableSize) {
        const result = this._getFontProgramLength(newLocaTableOut, newGlyphTable, 0);
        const fontProgramLength = result.fontProgramLength;
        const table = result.table;
        const writer = new _BigEndianWriter(fontProgramLength);
        writer._writeInt(0x10000);
        writer._writeShort(table);
        const entrySelector = this._entrySelectors[Number.parseInt(table.toString(), 10)];
        writer._writeShort((1 << (entrySelector & 31)) * 16);
        writer._writeShort(entrySelector);
        writer._writeShort((table - (1 << (entrySelector & 31))) * 16);
        this._writeCheckSums(writer, table, newLocaTableOut, newGlyphTable, glyphTableSize, locaTableSize);
        this._writeGlyphs(writer, newLocaTableOut, newGlyphTable);
        return writer._data;
    }
    _getFontProgramLength(newLocaTableOut, newGlyphTable, table) {
        let fontProgramLength = 0;
        if (newLocaTableOut !== null && typeof newLocaTableOut !== 'undefined' && newLocaTableOut.length > 0 &&
            newGlyphTable !== null && typeof newGlyphTable !== 'undefined' && newGlyphTable.length > 0) {
            table = 2;
            const tableNames = this._tableNames;
            for (let i = 0; i < tableNames.length; i++) {
                const tableName = tableNames[Number.parseInt(i.toString(), 10)];
                if (tableName !== 'glyf' && tableName !== 'loca') {
                    const tableInfo = this._getTable(tableName);
                    if (!tableInfo._empty) {
                        ++table;
                        fontProgramLength += this._align(tableInfo._length);
                    }
                }
            }
            fontProgramLength += newLocaTableOut.length;
            fontProgramLength += newGlyphTable.length;
            const usedTablesSize = table * 16 + (3 * 4);
            fontProgramLength += usedTablesSize;
        }
        return { fontProgramLength: fontProgramLength, table: table };
    }
    _getGlyphChars(chars) {
        const dictionary = new Dictionary();
        if (chars !== null && typeof chars !== 'undefined') {
            const charKeys = chars.keys();
            for (let i = 0; i < charKeys.length; i++) {
                const ch = charKeys[Number.parseInt(i.toString(), 10)];
                const glyph = this._getGlyph(ch);
                if (!glyph._empty) {
                    dictionary.setValue(glyph._index, ch.charCodeAt(0));
                }
            }
        }
        return dictionary;
    }
    _writeCheckSums(writer, table, newLocaTableOut, newGlyphTable, glyphTableSize, locaTableSize) {
        if (writer !== null && typeof writer !== 'undefined' && newLocaTableOut !== null && typeof newLocaTableOut !== 'undefined' &&
            newLocaTableOut.length > 0 && newGlyphTable !== null && typeof newGlyphTable !== 'undefined' && newGlyphTable.length > 0) {
            const tableNames = this._tableNames;
            let usedTablesSize = table * 16 + (3 * 4);
            let nextTableSize = 0;
            for (let i = 0; i < tableNames.length; i++) {
                const tableName = tableNames[Number.parseInt(i.toString(), 10)];
                const tableInfo = this._getTable(tableName);
                if (tableInfo._empty) {
                    continue;
                }
                writer._writeString(tableName);
                if (tableName === 'glyf') {
                    const checksum = this._calculateCheckSum(newGlyphTable);
                    writer._writeInt(checksum);
                    nextTableSize = glyphTableSize;
                }
                else if (tableName === 'loca') {
                    const checksum = this._calculateCheckSum(newLocaTableOut);
                    writer._writeInt(checksum);
                    nextTableSize = locaTableSize;
                }
                else {
                    writer._writeInt(tableInfo._checksum);
                    nextTableSize = tableInfo._length;
                }
                writer._writeUInt(usedTablesSize);
                writer._writeUInt(nextTableSize);
                usedTablesSize += this._align(nextTableSize);
            }
        }
    }
    _calculateCheckSum(bytes) {
        let pos = 0;
        let byte1 = 0;
        let byte2 = 0;
        let byte3 = 0;
        let byte4 = 0;
        let result = 0;
        if (bytes !== null && typeof bytes !== 'undefined' && bytes.length > 0) {
            for (let i = 0; i < (bytes.length + 1) / 4; i++) {
                byte4 += (bytes[pos++] & 255);
                byte3 += (bytes[pos++] & 255);
                byte2 += (bytes[pos++] & 255);
                byte1 += (bytes[pos++] & 255);
            }
            result = byte1;
            result += (byte2 << 8);
            result += (byte3 << 16);
            result += (byte4 << 24);
        }
        return result;
    }
    _writeGlyphs(writer, newLocaTable, newGlyphTable) {
        if (writer !== null && typeof writer !== 'undefined' && newLocaTable !== null && typeof newLocaTable !== 'undefined' &&
            newLocaTable.length > 0 && newGlyphTable !== null && typeof newGlyphTable !== 'undefined' && newGlyphTable.length > 0) {
            const tableNames = this._tableNames;
            for (let i = 0; i < tableNames.length; i++) {
                const tableName = tableNames[Number.parseInt(i.toString(), 10)];
                const tableInfo = this._getTable(tableName);
                if (tableInfo._empty) {
                    continue;
                }
                if (tableName === 'glyf') {
                    writer._writeBytes(newGlyphTable);
                }
                else if (tableName === 'loca') {
                    writer._writeBytes(newLocaTable);
                }
                else {
                    const count = this._align(tableInfo._length);
                    const buff = [];
                    for (let i = 0; i < count; i++) {
                        buff.push(0);
                    }
                    this._offset = tableInfo._offset;
                    const result = this._read(buff, 0, tableInfo._length);
                    writer._writeBytes(result.buffer);
                }
            }
        }
    }
    _read(buffer, index, count) {
        let written = 0;
        if (buffer !== null && typeof buffer !== 'undefined' && buffer.length > 0) {
            let read = 0;
            do {
                for (let i = 0; (i < count - written) && (this._offset + i < this._fontData.length); i++) {
                    buffer[index + i] = this._fontData[this._offset + i];
                }
                read = count - written;
                this._offset += read;
                written += read;
            } while (written < count);
        }
        return { buffer: buffer, written: written };
    }
    _createInternals() {
        this._metrics = new _TrueTypeMetrics();
        const nameTable = this._readNameTable();
        const headTable = this._readHeadTable();
        this._bIsLocaShort = (headTable._indexToLocalFormat === 0);
        const horizontalHeadTable = this._readHorizontalHeaderTable();
        const os2Table = this._readOS2Table();
        const postTable = this._readPostTable();
        this._width = this._readWidthTable(horizontalHeadTable._numberOfHMetrics, headTable._unitsPerEm);
        const subTables = this._readCmapTable();
        this._initializeMetrics(nameTable, headTable, horizontalHeadTable, os2Table, postTable, subTables);
    }
    _getGlyph(charCode) {
        if (typeof charCode === 'number') {
            let obj1 = null;
            if (!this._metrics._isSymbol && this._microsoftGlyphs != null) {
                if (this._microsoftGlyphs.containsKey(charCode)) {
                    obj1 = this._microsoftGlyphs.getValue(charCode);
                }
            }
            else if (this._metrics._isSymbol && this._macintoshGlyphs != null) {
                if (this._macintoshGlyphs.containsKey(charCode)) {
                    obj1 = this._macintoshGlyphs.getValue(charCode);
                }
            }
            const glyph = (obj1 != null) ? obj1 : this._getDefaultGlyph();
            return glyph;
        }
        else {
            let obj = null;
            let code = charCode.charCodeAt(0);
            if (!this._metrics._isSymbol && this._microsoft !== null) {
                if (this._microsoft.containsKey(code)) {
                    obj = this._microsoft.getValue(code);
                    if (code !== _StringTokenizer._whiteSpace.charCodeAt(0)) {
                        this._isFontPresent = true;
                    }
                }
                else if (code !== _StringTokenizer._whiteSpace.charCodeAt(0)) {
                    this._isFontPresent = false;
                }
            }
            else if (this._metrics._isSymbol && this.macintosh !== null || this._isMacFont) {
                if (this._maxMacIndex !== 0) {
                    code %= this._maxMacIndex + 1;
                }
                else {
                    code = ((code & 0xff00) === 0xf000 ? code & 0xff : code);
                }
                if (this.macintosh.containsKey(code)) {
                    obj = this.macintosh.getValue(code);
                    this._isFontPresent = true;
                }
            }
            if (charCode === _StringTokenizer._whiteSpace && obj === null) {
                obj = new _TrueTypeGlyph();
            }
            const glyph = (obj !== null) ? obj : this._getDefaultGlyph();
            return glyph;
        }
    }
    _readString(length, isUnicode) {
        if (typeof isUnicode === 'undefined' || isUnicode === null) {
            return this._readString(length, false);
        }
        else {
            let result = '';
            if (isUnicode) {
                for (let i = 0; i < length; i++) {
                    if (i % 2 !== 0) {
                        result += String.fromCharCode(this._fontData[this._offset]);
                    }
                    this._offset += 1;
                }
            }
            else {
                for (let i = 0; i < length; i++) {
                    result += String.fromCharCode(this._fontData[this._offset]);
                    this._offset += 1;
                }
            }
            return result;
        }
    }
    _readFixed(offset) {
        const integer = this._readInt16(offset);
        const sFraction = this._readInt16(offset + 2);
        const fraction = sFraction / 16384;
        return integer + fraction;
    }
    _readInt32(offset) {
        const i1 = this._fontData[Number.parseInt(offset.toString(), 10) + 3];
        const i2 = this._fontData[Number.parseInt(offset.toString(), 10) + 2];
        const i3 = this._fontData[Number.parseInt(offset.toString(), 10) + 1];
        const i4 = this._fontData[Number.parseInt(offset.toString(), 10)];
        this._offset += 4;
        return i1 + (i2 << 8) + (i3 << 16) + (i4 << 24);
    }
    _readUInt32(offset) {
        const i1 = this._fontData[Number.parseInt(offset.toString(), 10) + 3];
        const i2 = this._fontData[Number.parseInt(offset.toString(), 10) + 2];
        const i3 = this._fontData[Number.parseInt(offset.toString(), 10) + 1];
        const i4 = this._fontData[Number.parseInt(offset.toString(), 10)];
        this._offset += 4;
        return (i1 | i2 << 8 | i3 << 16 | i4 << 24);
    }
    _readInt16(offset) {
        let result = (this._fontData[Number.parseInt(offset.toString(), 10)] << 8) +
            this._fontData[Number.parseInt(offset.toString(), 10) + 1];
        result = result & (1 << 15) ? result - 0x10000 : result;
        this._offset += 2;
        return result;
    }
    _readInt64(offset) {
        const low = this._readInt32(offset + 4);
        let n = this._readInt32(offset) * 4294967296.0 + low;
        if (low < 0) {
            n += 4294967296;
        }
        return n;
    }
    _readUInt16(offset) {
        const result = (this._fontData[Number.parseInt(offset.toString(), 10)] << 8) |
            this._fontData[Number.parseInt(offset.toString(), 10) + 1];
        this._offset += 2;
        return result;
    }
    _readUShortArray(length) {
        const buffer = [];
        for (let i = 0; i < length; i++) {
            buffer[Number.parseInt(i.toString(), 10)] = this._readUInt16(this._offset);
        }
        return buffer;
    }
    _readBytes(length) {
        const result = [];
        for (let i = 0; i < length; i++) {
            result.push(this._fontData[Number.parseInt(this._offset.toString(), 10)]);
            this._offset += 1;
        }
        return result;
    }
    _readByte(offset) {
        const result = this._fontData[Number.parseInt(offset.toString(), 10)];
        this._offset += 1;
        return result;
    }
    _getCharacterWidth(code) {
        let glyphInfo = this._getGlyph(code);
        glyphInfo = (!glyphInfo._empty) ? glyphInfo : this._getDefaultGlyph();
        const codeWidth = (!glyphInfo._empty) ? glyphInfo._width : 0;
        return codeWidth;
    }
    _convertString(text) {
        let glyph = '';
        if (text !== null && text !== undefined && text.length > 0) {
            for (let k = 0; k < text.length; k++) {
                const ch = text[Number.parseInt(k.toString(), 10)];
                const glyphInfo = this._getGlyph(ch);
                if (!glyphInfo._empty) {
                    glyph += String.fromCharCode(glyphInfo._index);
                }
            }
        }
        return glyph;
    }
}
class _TrueTypeNameRecord {
}
class _TrueTypeMetrics {
    get _isItalic() {
        return ((this._macStyle & 2) !== 0);
    }
    get _isBold() {
        return ((this._macStyle & 1) !== 0);
    }
}
class _TrueTypeLongHorMetric {
}
class _TrueTypeGlyph {
    get _empty() {
        return (this._index === this._width && this._width === this._charCode && this._charCode === 0);
    }
}
class _TrueTypeLocaTable {
}
class _TrueTypeGlyphHeader {
}
class _BigEndianWriter {
    constructor(capacity) {
        this.int32Size = 4;
        this.int16Size = 2;
        this.int64Size = 8;
        this._bufferLength = capacity;
        this._buffer = [];
    }
    get _data() {
        if (this._buffer.length < this._bufferLength) {
            const length = this._bufferLength - this._buffer.length;
            for (let i = 0; i < length; i++) {
                this._buffer.push(0);
            }
        }
        return this._buffer;
    }
    get _position() {
        if (typeof this._internalPosition === 'undefined' || this._internalPosition === null) {
            this._internalPosition = 0;
        }
        return this._internalPosition;
    }
    _writeShort(value) {
        const bytes = [((value & 0x0000ff00) >> 8), value & 0x000000ff];
        this._flush(bytes);
    }
    _writeInt(value) {
        const bytes = [(value & 0xff000000) >> 24, (value & 0x00ff0000) >> 16, (value & 0x0000ff00) >> 8, value & 0x000000ff];
        this._flush(bytes);
    }
    _writeUInt(value) {
        const buff = [(value & 0xff000000) >> 24, (value & 0x00ff0000) >> 16, (value & 0x0000ff00) >> 8, value & 0x000000ff];
        this._flush(buff);
    }
    _writeString(value) {
        if (value !== null && typeof value !== 'undefined') {
            const bytes = [];
            for (let i = 0; i < value.length; i++) {
                bytes.push(value.charCodeAt(i));
            }
            this._flush(bytes);
        }
    }
    _writeBytes(value) {
        this._flush(value);
    }
    _flush(buff) {
        if (buff !== null && typeof buff !== 'undefined') {
            let position = this._position;
            for (let i = 0; i < buff.length; i++) {
                this._buffer[Number.parseInt(position.toString(), 10)] = buff[Number.parseInt(i.toString(), 10)];
                position++;
            }
            this._internalPosition += buff.length;
        }
    }
}

class _UnicodeTrueTypeFont {
    constructor(base64String, size) {
        this._nameString = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ';
        this._isEmbedFont = false;
        this._cmapPrefix = '/CIDInit /ProcSet findresource begin\n12 dict begin\nbegincmap' + '\r\n' + '/CIDSystemInfo << /Registry (Adobe)/Ordering (UCS)/Supplement 0>> def\n/CMapName ' + '/Adobe-Identity-UCS def\n/CMapType 2 def\n1 beginCodeSpacerange' + '\r\n';
        this._cmapEndCodeSpaceRange = 'endCodeSpacerange' + '\r\n';
        this._cmapBeginRange = 'beginbfrange' + '\r\n';
        this._cmapEndRange = 'endbfrange' + '\r\n';
        this._cmapSuffix = 'endbfrange\nendcmap\nCMapName currentdict ' + '/CMap defineresource pop\nend end' + '\r\n';
        if (base64String === null || typeof base64String === 'undefined') {
            throw new Error('ArgumentNullException:base64String');
        }
        this._fontSize = size;
        this._fontString = base64String;
        this._Initialize();
    }
    _beginSave() {
        this._descendantFontBeginSave();
        this._cmapBeginSave();
        this._fontDictionaryBeginSave();
        this._fontProgramBeginSave();
        if (this._fontDescriptor) {
            this._fontDescriptor.update('FontFile2', this._fontProgram);
            this._fontDescriptor._updated = true;
            this._fontDescriptor._isFont = true;
        }
    }
    _descendantFontBeginSave() {
        if (this._usedChars !== null && typeof this._usedChars !== 'undefined' && this._usedChars._size() > 0) {
            let width = this._getDescendantWidth(); // eslint-disable-line
            if (width !== null) {
                this._descendantFont.set('W', width);
            }
        }
    }
    _fontDictionaryBeginSave() {
        if (this._usedChars !== null && typeof this._usedChars !== 'undefined' && this._usedChars._size() > 0) {
            this._fontDictionary.update('ToUnicode', this._cmap);
        }
    }
    _Initialize() {
        const byteArray = _decode(this._fontString);
        this._fontData = byteArray;
        this._ttfReader = new _TrueTypeReader(this._fontData);
        this._ttfMetrics = this._ttfReader._metrics;
    }
    _createInternals() {
        this._fontDictionary = new _PdfDictionary();
        this._descendantFont = new _PdfDictionary();
        this._metrics = new _PdfFontMetrics();
        this._ttfReader._createInternals();
        this._usedChars = null;
        const data = []; // eslint-disable-line
        this._fontProgram = new _PdfStream(data, new _PdfDictionary());
        this._cmap = new _PdfStream(data, new _PdfDictionary());
        this._ttfMetrics = this._ttfReader._metrics;
        this._initializeMetrics();
        this._subsetName = this._getFontName();
        this._createDescendantFont();
        this._createFontDictionary();
    }
    _getInternals() {
        return this._fontDictionary;
    }
    _initializeMetrics() {
        const ttfMetrics = this._ttfReader._metrics;
        this._metrics._ascent = ttfMetrics._macAscent;
        this._metrics._descent = ttfMetrics._macDescent;
        this._metrics._height = ttfMetrics._macAscent - ttfMetrics._macDescent + ttfMetrics._lineGap;
        this._metrics._name = ttfMetrics._fontFamily;
        this._metrics._postScriptName = ttfMetrics._postScriptName;
        this._metrics._size = this._fontSize;
        this._metrics._widthTable = new _StandardWidthTable(ttfMetrics._widthTable);
        this._metrics._lineGap = ttfMetrics._lineGap;
        this._metrics._subScriptSizeFactor = ttfMetrics._subScriptSizeFactor;
        this._metrics._superscriptSizeFactor = ttfMetrics._superscriptSizeFactor;
        this._metrics._isBold = ttfMetrics._isBold;
    }
    _getFontName() {
        let builder = '';
        for (let i = 0; i < 6; i++) {
            const index = Math.floor(Math.random() * (25 - 0 + 1)) + 0;
            builder += this._nameString[Number.parseInt(index.toString(), 10)];
        }
        builder += '+';
        builder += this._ttfReader._metrics._postScriptName;
        return builder.toString();
    }
    _createDescendantFont() {
        this._descendantFont = new _PdfDictionary();
        this._descendantFont._updated = true;
        this._descendantFont.set('Type', new _PdfName('Font'));
        this._descendantFont.set('Subtype', new _PdfName('CIDFontType2'));
        this._descendantFont.set('BaseFont', new _PdfName(this._subsetName));
        this._descendantFont.set('CIDToGIDMap', new _PdfName('Identity'));
        this._descendantFont.set('DW', 1000);
        this._fontDescriptor = this._createFontDescriptor();
        this._descendantFont.set('FontDescriptor', this._fontDescriptor);
        const systemInfo = this._createSystemInfo();
        this._descendantFont.set('CIDSystemInfo', systemInfo);
        this._descendantFont._isFont = true;
    }
    _createFontDescriptor() {
        const descriptor = new _PdfDictionary();
        const metrics = this._ttfReader._metrics;
        descriptor.set('Type', new _PdfName('FontDescriptor'));
        descriptor.set('FontName', new _PdfName(this._subsetName));
        descriptor.set('Flags', this._getDescriptorFlags());
        descriptor.set('FontBBox', this._getBoundBox());
        descriptor.set('MissingWidth', metrics._widthTable[32]);
        descriptor.set('StemV', metrics._stemV);
        descriptor.set('ItalicAngle', metrics._italicAngle);
        descriptor.set('CapHeight', metrics._capHeight);
        descriptor.set('Ascent', metrics._winAscent);
        descriptor.set('Descent', metrics._winDescent);
        descriptor.set('Leading', metrics._leading);
        descriptor.set('AvgWidth', metrics._widthTable[32]);
        descriptor.set('MaxWidth', metrics._widthTable[32]);
        descriptor.set('XHeight', 0);
        descriptor.set('StemH', 0);
        descriptor._updated = true;
        return descriptor;
    }
    _generateFontProgram() {
        let fontProgram = [];
        this._usedChars = (this._usedChars === null || typeof this._usedChars === 'undefined') ? new Dictionary()
            : this._usedChars;
        this._ttfReader._setOffset(0);
        fontProgram = this._ttfReader._readFontProgram(this._usedChars);
        this._fontProgram._clearStream();
        this._fontProgram._writeBytes(fontProgram);
    }
    _getBoundBox() {
        const rect = this._ttfReader._metrics._fontBox;
        const width = Math.abs(rect[2] - rect[0]);
        const height = Math.abs(rect[1] - rect[3]);
        const rectangle = [rect[0], rect[3], width, height];
        return rectangle;
    }
    _cmapBeginSave() {
        this._generateCmap();
    }
    _fontProgramBeginSave() {
        this._generateFontProgram();
    }
    _toHexString(n, isCaseChange) {
        let s = n.toString(16);
        if (isCaseChange) {
            s = s.toUpperCase();
        }
        return '<0000'.substring(0, 5 - s.length) + s + '>';
    }
    _generateCmap() {
        if (this._usedChars !== null && typeof this._usedChars !== 'undefined' && this._usedChars._size() > 0) {
            const glyphChars = this._ttfReader._getGlyphChars(this._usedChars);
            if (glyphChars._size() > 0) {
                const keys = glyphChars.keys().sort();
                const first = keys[0];
                const last = keys[keys.length - 1];
                const middlePart = this._toHexString(first, false) + this._toHexString(last, false) + '\r\n';
                let builder = '';
                builder += this._cmapPrefix;
                builder += middlePart;
                builder += this._cmapEndCodeSpaceRange;
                let nextRange = 0;
                for (let i = 0; i < keys.length; i++) {
                    if (nextRange === 0) {
                        if (i !== 0) {
                            builder += this._cmapEndRange;
                        }
                        nextRange = Math.min(100, keys.length - i);
                        builder += nextRange;
                        builder += ' ';
                        builder += this._cmapBeginRange;
                    }
                    nextRange -= 1;
                    const key = keys[Number.parseInt(i.toString(), 10)];
                    builder += this._toHexString(key, true) + this._toHexString(key, true);
                    builder += this._toHexString(glyphChars.getValue(key), true) + '\n';
                }
                builder += this._cmapSuffix;
                this._cmap._clearStream();
                this._cmap._write(builder);
            }
        }
    }
    _createFontDictionary() {
        this._fontDictionary._updated = true;
        this._fontDictionary.set('Type', _PdfName.get('Font'));
        this._fontDictionary.set('Subtype', _PdfName.get('Type0'));
        this._fontDictionary.set('BaseFont', new _PdfName(this._subsetName));
        this._fontDictionary.set('Encoding', _PdfName.get('Identity-H'));
        this._fontDictionary.set('DescendantFonts', this._descendantFont);
        this._fontDictionary._isFont = true;
        this._fontDictionary._currentObj = this;
    }
    _createSystemInfo() {
        const systemInfo = new _PdfDictionary();
        systemInfo._updated = true;
        systemInfo.set('Registry', 'Adobe');
        systemInfo.set('Ordering', 'Identity');
        systemInfo.set('Supplement', 0);
        return systemInfo;
    }
    _getDescriptorFlags() {
        let flags = 0;
        const metrics = this._ttfReader._metrics;
        if (metrics._isFixedPitch) {
            flags |= _FontDescriptorFlag.fixedPitch;
        }
        if (metrics._isSymbol) {
            flags |= _FontDescriptorFlag.symbolic;
        }
        else {
            flags |= _FontDescriptorFlag.nonSymbolic;
        }
        if (metrics._isItalic) {
            flags |= _FontDescriptorFlag.italic;
        }
        if (metrics._isBold) {
            flags |= _FontDescriptorFlag.forceBold;
        }
        return flags;
    }
    _getCharacterWidth(charCode) {
        const codeWidth = this._ttfReader._getCharacterWidth(charCode);
        return codeWidth;
    }
    _setSymbols(text) {
        if (text !== null && typeof text !== 'undefined') {
            if (this._usedChars === null || typeof this._usedChars === 'undefined') {
                this._usedChars = new Dictionary();
            }
            for (let i = 0; i < text.length; i++) {
                const ch = text[Number.parseInt(i.toString(), 10)];
                this._usedChars.setValue(ch, String.fromCharCode(0));
            }
        }
    }
    _getDescendantWidth() {
        let array = new Array(); // eslint-disable-line
        if (this._usedChars !== null && typeof this._usedChars !== 'undefined' && this._usedChars._size() > 0) {
            const glyphInfo = [];
            const keys = this._usedChars.keys();
            for (let i = 0; i < keys.length; i++) {
                const chLen = keys[Number.parseInt(i.toString(), 10)];
                const glyph = this._ttfReader._getGlyph(chLen);
                glyphInfo.push(glyph);
            }
            glyphInfo.sort((a, b) => a._index - b._index);
            let firstGlyphIndex = 0;
            let lastGlyphIndex = 0;
            let firstGlyphIndexWasSet = false;
            let widthDetails = new Array(); // eslint-disable-line
            for (let i = 0; i < glyphInfo.length; i++) {
                const glyph = glyphInfo[Number.parseInt(i.toString(), 10)];
                if (!firstGlyphIndexWasSet) {
                    firstGlyphIndexWasSet = true;
                    firstGlyphIndex = glyph._index;
                    lastGlyphIndex = glyph._index - 1;
                }
                if ((lastGlyphIndex + 1 !== glyph._index || (i + 1 === glyphInfo.length)) && glyphInfo.length > 1) {
                    array.push(Number(firstGlyphIndex));
                    if (i !== 0) {
                        array.push(widthDetails);
                    }
                    firstGlyphIndex = glyph._index;
                    widthDetails = new Array(); // eslint-disable-line
                }
                widthDetails.push(Number(glyph._width));
                if ((i + 1) === glyphInfo.length) {
                    array.push(Number(firstGlyphIndex));
                    array.push(widthDetails);
                }
                lastGlyphIndex = glyph._index;
            }
        }
        return array;
    }
}

class _ArabicShapeRenderer {
    /**
     * Creates an instance of the 'ArabicShapeRenderer' class.
     *
     * @private
     */
    constructor() {
        this._arabicCharTable = [['\u0621', '\uFE80'], ['\u0622', '\uFE81', '\uFE82'], ['\u0623', '\uFE83', '\uFE84'],
            ['\u0624', '\uFE85', '\uFE86'], ['\u0625', '\uFE87', '\uFE88'], ['\u0626', '\uFE89', '\uFE8A', '\uFE8B', '\uFE8C'],
            ['\u0627', '\uFE8D', '\uFE8E'], ['\u0628', '\uFE8F', '\uFE90', '\uFE91', '\uFE92'], ['\u0629', '\uFE93', '\uFE94'],
            ['\u062A', '\uFE95', '\uFE96', '\uFE97', '\uFE98'], ['\u062B', '\uFE99', '\uFE9A', '\uFE9B', '\uFE9C'],
            ['\u062C', '\uFE9D', '\uFE9E', '\uFE9F', '\uFEA0'], ['\u062D', '\uFEA1', '\uFEA2', '\uFEA3', '\uFEA4'],
            ['\u062E', '\uFEA5', '\uFEA6', '\uFEA7', '\uFEA8'], ['\u062F', '\uFEA9', '\uFEAA'], ['\u0630', '\uFEAB', '\uFEAC'],
            ['\u0631', '\uFEAD', '\uFEAE'], ['\u0632', '\uFEAF', '\uFEB0'], ['\u0633', '\uFEB1', '\uFEB2', '\uFEB3', '\uFEB4'],
            ['\u0634', '\uFEB5', '\uFEB6', '\uFEB7', '\uFEB8'], ['\u0635', '\uFEB9', '\uFEBA', '\uFEBB', '\uFEBC'],
            ['\u0636', '\uFEBD', '\uFEBE', '\uFEBF', '\uFEC0'], ['\u0637', '\uFEC1', '\uFEC2', '\uFEC3', '\uFEC4'],
            ['\u0638', '\uFEC5', '\uFEC6', '\uFEC7', '\uFEC8'], ['\u0639', '\uFEC9', '\uFECA', '\uFECB', '\uFECC'],
            ['\u063A', '\uFECD', '\uFECE', '\uFECF', '\uFED0'], ['\u0640', '\u0640', '\u0640', '\u0640', '\u0640'],
            ['\u0641', '\uFED1', '\uFED2', '\uFED3', '\uFED4'], ['\u0642', '\uFED5', '\uFED6', '\uFED7', '\uFED8'],
            ['\u0643', '\uFED9', '\uFEDA', '\uFEDB', '\uFEDC'], ['\u0644', '\uFEDD', '\uFEDE', '\uFEDF', '\uFEE0'],
            ['\u0645', '\uFEE1', '\uFEE2', '\uFEE3', '\uFEE4'], ['\u0646', '\uFEE5', '\uFEE6', '\uFEE7', '\uFEE8'],
            ['\u0647', '\uFEE9', '\uFEEA', '\uFEEB', '\uFEEC'], ['\u0648', '\uFEED', '\uFEEE'],
            ['\u0649', '\uFEEF', '\uFEF0', '\uFBE8', '\uFBE9'], ['\u064A', '\uFEF1', '\uFEF2', '\uFEF3', '\uFEF4'],
            ['\u0671', '\uFB50', '\uFB51'], ['\u0679', '\uFB66', '\uFB67', '\uFB68', '\uFB69'],
            ['\u067A', '\uFB5E', '\uFB5F', '\uFB60', '\uFB61'], ['\u067B', '\uFB52', '\uFB53', '\uFB54', '\uFB55'],
            ['\u067E', '\uFB56', '\uFB57', '\uFB58', '\uFB59'], ['\u067F', '\uFB62', '\uFB63', '\uFB64', '\uFB65'],
            ['\u0680', '\uFB5A', '\uFB5B', '\uFB5C', '\uFB5D'], ['\u0683', '\uFB76', '\uFB77', '\uFB78', '\uFB79'],
            ['\u0684', '\uFB72', '\uFB73', '\uFB74', '\uFB75'], ['\u0686', '\uFB7A', '\uFB7B', '\uFB7C', '\uFB7D'],
            ['\u0687', '\uFB7E', '\uFB7F', '\uFB80', '\uFB81'], ['\u0688', '\uFB88', '\uFB89'], ['\u068C', '\uFB84', '\uFB85'],
            ['\u068D', '\uFB82', '\uFB83'], ['\u068E', '\uFB86', '\uFB87'], ['\u0691', '\uFB8C', '\uFB8D'], ['\u0698', '\uFB8A', '\uFB8B'],
            ['\u06A4', '\uFB6A', '\uFB6B', '\uFB6C', '\uFB6D'], ['\u06A6', '\uFB6E', '\uFB6F', '\uFB70', '\uFB71'],
            ['\u06A9', '\uFB8E', '\uFB8F', '\uFB90', '\uFB91'], ['\u06AD', '\uFBD3', '\uFBD4', '\uFBD5', '\uFBD6'],
            ['\u06AF', '\uFB92', '\uFB93', '\uFB94', '\uFB95'], ['\u06B1', '\uFB9A', '\uFB9B', '\uFB9C', '\uFB9D'],
            ['\u06B3', '\uFB96', '\uFB97', '\uFB98', '\uFB99'], ['\u06BA', '\uFB9E', '\uFB9F'],
            ['\u06BB', '\uFBA0', '\uFBA1', '\uFBA2', '\uFBA3'], ['\u06BE', '\uFBAA', '\uFBAB', '\uFBAC', '\uFBAD'],
            ['\u06C0', '\uFBA4', '\uFBA5'], ['\u06C1', '\uFBA6', '\uFBA7', '\uFBA8', '\uFBA9'], ['\u06C5', '\uFBE0', '\uFBE1'],
            ['\u06C6', '\uFBD9', '\uFBDA'], ['\u06C7', '\uFBD7', '\uFBD8'], ['\u06C8', '\uFBDB', '\uFBDC'], ['\u06C9', '\uFBE2', '\uFBE3'],
            ['\u06CB', '\uFBDE', '\uFBDF'], ['\u06CC', '\uFBFC', '\uFBFD', '\uFBFE', '\uFBFF'],
            ['\u06D0', '\uFBE4', '\uFBE5', '\uFBE6', '\uFBE7'], ['\u06D2', '\uFBAE', '\uFBAF'], ['\u06D3', '\uFBB0', '\uFBB1']
        ];
        this._alef = '\u0627';
        this._alefHamza = '\u0623';
        this._alefHamzaBelow = '\u0625';
        this._alefMadda = '\u0622';
        this._lam = '\u0644';
        this._hamza = '\u0621';
        this._zeroWidthJoiner = '\u200D';
        this._hamzaAbove = '\u0654';
        this._hamzaBelow = '\u0655';
        this._wawHamza = '\u0624';
        this._yehHamza = '\u0626';
        this._waw = '\u0648';
        this._alefsura = '\u0649';
        this._yeh = '\u064A';
        this._farsiYeh = '\u06CC';
        this._shadda = '\u0651';
        this._madda = '\u0653';
        this._lwa = '\uFEFB';
        this._lwawh = '\uFEF7';
        this._lwawhb = '\uFEF9';
        this._lwawm = '\uFEF5';
        this._bwhb = '\u06D3';
        this._fathatan = '\u064B';
        this._superalef = '\u0670';
        this._vowel = 0x1;
        this._arabicMapTable = new Map();
        for (let i = 0; i < this._arabicCharTable.length; i++) {
            this._arabicMapTable.set(this._arabicCharTable[Number.parseInt(i.toString(), 10)][0], this._arabicCharTable[Number.parseInt(i.toString(), 10)]);
        }
    }
    _getCharacterShape(input, index) {
        if ((input >= this._hamza) && (input <= this._bwhb)) {
            let value = [];
            if (this._arabicMapTable.get(input)) {
                value = this._arabicMapTable.get(input);
                return value[index + 1];
            }
        }
        else if (input >= this._lwawm && input <= this._lwa) {
            return (input);
        }
        return input;
    }
    _shape(text) {
        let builder = '';
        let value = '';
        for (let i = 0; i < text.length; i++) {
            const c = text[Number.parseInt(i.toString(), 10)];
            if (c >= '؀' && c <= 'ۿ') {
                value = value + c;
            }
            else {
                if (value.length > 0) {
                    const shapeText = this._doShape(value.toString(), 0);
                    builder = builder + shapeText;
                    value = '';
                }
                builder = builder + c;
            }
        }
        if (value.length > 0) {
            const shapeText = this._doShape(value.toString(), 0);
            builder = builder + shapeText;
        }
        return builder.toString();
    }
    _doShape(input, level) {
        let str = '';
        let ligature = 0;
        let len = 0;
        let i = 0;
        let next = '';
        let previous = new _ArabicShape();
        let present = new _ArabicShape();
        while (i < input.length) {
            next = input[i++];
            ligature = this._ligature(next, present);
            if (ligature === 0) {
                const shapeCount = this._getShapeCount(next);
                len = (shapeCount === 1) ? 0 : 2;
                if (previous._shapes > 2) {
                    len += 1;
                }
                len = len % (present._shapes);
                present._shapeValue = this._getCharacterShape(present._shapeValue, len);
                str = this._append(str, previous, level);
                previous = present;
                present = new _ArabicShape();
                present._shapeValue = next;
                present._shapes = shapeCount;
                present._shapeLigature++;
            }
        }
        len = (previous._shapes > 2) ? 1 : 0;
        len = len % (present._shapes);
        present._shapeValue = this._getCharacterShape(present._shapeValue, len);
        str = this._append(str, previous, level);
        str = this._append(str, present, level);
        return str.toString();
    }
    _append(builder, shape, level) {
        if (shape._shapeValue !== '') {
            builder = builder + shape._shapeValue;
            shape._shapeLigature -= 1;
            if (shape._shapeType !== '') {
                if ((level & this._vowel) === 0) {
                    builder = builder + shape._shapeType;
                    shape._shapeLigature -= 1;
                }
                else {
                    shape._shapeLigature -= 1;
                }
            }
            if (shape._shapeVowel !== '') {
                if ((level & this._vowel) === 0) {
                    builder = builder + shape._shapeVowel;
                    shape._shapeLigature -= 1;
                }
                else {
                    shape._shapeLigature -= 1;
                }
            }
        }
        return builder;
    }
    _ligature(value, shape) {
        if (shape._shapeValue !== '') {
            let result = 0;
            if ((value >= this._fathatan && value <= this._hamzaBelow) || value === this._superalef) {
                result = 1;
                if ((shape._shapeVowel !== '') && (value !== this._shadda)) {
                    result = 2;
                }
                if (value === this._shadda) {
                    if (shape._shapeType === '') {
                        shape._shapeType = this._shadda;
                    }
                    else {
                        return 0;
                    }
                }
                else if (value === this._hamzaBelow) {
                    if (shape._shapeValue === this._alef) {
                        shape._shapeValue = this._alefHamzaBelow;
                        result = 2;
                    }
                    else if (shape._shapeValue === this._lwa) {
                        shape._shapeValue = this._lwawhb;
                        result = 2;
                    }
                    else {
                        shape._shapeType = this._hamzaBelow;
                    }
                }
                else if (value === this._hamzaAbove) {
                    if (shape._shapeValue === this._alef) {
                        shape._shapeValue = this._alefHamza;
                        result = 2;
                    }
                    else if (shape._shapeValue === this._lwa) {
                        shape._shapeValue = this._lwawh;
                        result = 2;
                    }
                    else if (shape._shapeValue === this._waw) {
                        shape._shapeValue = this._wawHamza;
                        result = 2;
                    }
                    else if (shape._shapeValue === this._yeh || shape._shapeValue === this._alefsura ||
                        shape._shapeValue === this._farsiYeh) {
                        shape._shapeValue = this._yehHamza;
                        result = 2;
                    }
                    else {
                        shape._shapeType = this._hamzaAbove;
                    }
                }
                else if (value === this._madda) {
                    if (shape._shapeValue === this._alef) {
                        shape._shapeValue = this._alefMadda;
                        result = 2;
                    }
                }
                else {
                    shape._shapeVowel = value;
                }
                if (result === 1) {
                    shape._shapeLigature++;
                }
                return result;
            }
            if (shape._shapeVowel !== '') {
                return 0;
            }
            if (shape._shapeValue === this._lam) {
                if (value === this._alef) {
                    shape._shapeValue = this._lwa;
                    shape._shapes = 2;
                    result = 3;
                }
                else if (value === this._alefHamza) {
                    shape._shapeValue = this._lwawh;
                    shape._shapes = 2;
                    result = 3;
                }
                else if (value === this._alefHamzaBelow) {
                    shape._shapeValue = this._lwawhb;
                    shape._shapes = 2;
                    result = 3;
                }
                else if (value === this._alefMadda) {
                    shape._shapeValue = this._lwawm;
                    shape._shapes = 2;
                    result = 3;
                }
            }
            return result;
        }
        else {
            return 0;
        }
    }
    _getShapeCount(shape) {
        if ((shape >= this._hamza) && (shape <= this._bwhb) && !((shape >= this._fathatan && shape <= this._hamzaBelow)
            || shape === this._superalef)) {
            let c = [];
            if (this._arabicMapTable.get(shape)) {
                c = this._arabicMapTable.get(shape);
                return c.length - 1;
            }
        }
        else if (shape === this._zeroWidthJoiner) {
            return 4;
        }
        return 1;
    }
}
class _ArabicShape {
    constructor() {
        this._shapeValue = '';
        this._shapeType = '';
        this._shapeVowel = '';
        this._shapeLigature = 0;
        this._shapes = 1;
    }
}

class _Bidirectional {
    /**
     * Creates a new instance of the `_Bidirectional` class.
     *
     * @private
     */
    constructor() {
        this._indexes = [];
        this._indexLevels = [];
        this._mirroringShape = new Dictionary();
        this._update();
    }
    _doMirrorShaping(text) {
        const result = [];
        for (let i = 0; i < text.length; i++) {
            if (((this._indexLevels[Number.parseInt(i.toString(), 10)] & 1) === 1)
                && this._mirroringShape.containsKey(text[Number.parseInt(i.toString(), 10)].charCodeAt(0))) {
                const value = text[Number.parseInt(i.toString(), 10)].charCodeAt(0); // eslint-disable-line
                result[Number.parseInt(i.toString(), 10)] = String.fromCharCode(this._mirroringShape.getValue(value));
            }
            else {
                result[Number.parseInt(i.toString(), 10)] = text[Number.parseInt(i.toString(), 10)].toString();
            }
        }
        let res = '';
        for (let j = 0; j < result.length; j++) {
            res = res + result[Number.parseInt(j.toString(), 10)];
        }
        return res;
    }
    _getLogicalToVisualString(inputText, isRtl) {
        const rtlCharacters = new _RtlCharacters();
        this._indexLevels = rtlCharacters._getVisualOrder(inputText, isRtl);
        this._setDefaultIndexLevel();
        this._doOrder(0, this._indexLevels.length - 1);
        const text = this._doMirrorShaping(inputText);
        let resultBuilder = '';
        for (let i = 0; i < this._indexes.length; i++) {
            const index = this._indexes[Number.parseInt(i.toString(), 10)];
            resultBuilder += text[Number.parseInt(index.toString(), 10)];
        }
        return resultBuilder.toString();
    }
    _setDefaultIndexLevel() {
        for (let i = 0; i < this._indexLevels.length; i++) {
            this._indexes[Number.parseInt(i.toString(), 10)] = i;
        }
    }
    _doOrder(sIndex, eIndex) {
        let max = this._indexLevels[Number.parseInt(sIndex.toString(), 10)];
        let min = max;
        let odd = max;
        let even = max;
        for (let i = sIndex + 1; i <= eIndex; ++i) {
            const data = this._indexLevels[Number.parseInt(i.toString(), 10)];
            if (data > max) {
                max = data;
            }
            else if (data < min) {
                min = data;
            }
            odd &= data;
            even |= data;
        }
        if ((even & 1) === 0) {
            return;
        }
        if ((odd & 1) === 1) {
            this._reArrange(sIndex, eIndex + 1);
            return;
        }
        min |= 1;
        while (max >= min) {
            let pstart = sIndex;
            while (true) { // eslint-disable-line
                while (pstart <= eIndex) {
                    if (this._indexLevels[Number.parseInt(pstart.toString(), 10)] >= max) {
                        break;
                    }
                    pstart += 1;
                }
                if (pstart > eIndex) {
                    break;
                }
                let pend = pstart + 1;
                while (pend <= eIndex) {
                    if (this._indexLevels[Number.parseInt(pend.toString(), 10)] < max) {
                        break;
                    }
                    pend += 1;
                }
                this._reArrange(pstart, pend);
                pstart = pend + 1;
            }
            max -= 1;
        }
    }
    _reArrange(i, j) {
        const length = (i + j) / 2;
        --j;
        for (; i < length; ++i, --j) {
            const temp = this._indexes[Number.parseInt(i.toString(), 10)];
            this._indexes[Number.parseInt(i.toString(), 10)] = this._indexes[Number.parseInt(j.toString(), 10)];
            this._indexes[Number.parseInt(j.toString(), 10)] = temp;
        }
    }
    _update() {
        this._mirroringShape.setValue(40, 41);
        this._mirroringShape.setValue(41, 40);
        this._mirroringShape.setValue(60, 62);
        this._mirroringShape.setValue(62, 60);
        this._mirroringShape.setValue(91, 93);
        this._mirroringShape.setValue(93, 91);
        this._mirroringShape.setValue(123, 125);
        this._mirroringShape.setValue(125, 123);
        this._mirroringShape.setValue(171, 187);
        this._mirroringShape.setValue(187, 171);
        this._mirroringShape.setValue(8249, 8250);
        this._mirroringShape.setValue(8250, 8249);
        this._mirroringShape.setValue(8261, 8262);
        this._mirroringShape.setValue(8262, 8261);
        this._mirroringShape.setValue(8317, 8318);
        this._mirroringShape.setValue(8318, 8317);
        this._mirroringShape.setValue(8333, 8334);
        this._mirroringShape.setValue(8334, 8333);
        this._mirroringShape.setValue(8712, 8715);
        this._mirroringShape.setValue(8713, 8716);
        this._mirroringShape.setValue(8714, 8717);
        this._mirroringShape.setValue(8715, 8712);
        this._mirroringShape.setValue(8716, 8713);
        this._mirroringShape.setValue(8717, 8714);
        this._mirroringShape.setValue(8725, 10741);
        this._mirroringShape.setValue(8764, 8765);
        this._mirroringShape.setValue(8765, 8764);
        this._mirroringShape.setValue(8771, 8909);
        this._mirroringShape.setValue(8786, 8787);
        this._mirroringShape.setValue(8787, 8786);
        this._mirroringShape.setValue(8788, 8789);
        this._mirroringShape.setValue(8789, 8788);
        this._mirroringShape.setValue(8804, 8805);
        this._mirroringShape.setValue(8805, 8804);
        this._mirroringShape.setValue(8806, 8807);
        this._mirroringShape.setValue(8807, 8806);
        this._mirroringShape.setValue(8808, 8809);
        this._mirroringShape.setValue(8809, 8808);
        this._mirroringShape.setValue(8810, 8811);
        this._mirroringShape.setValue(8811, 8810);
        this._mirroringShape.setValue(8814, 8815);
        this._mirroringShape.setValue(8815, 8814);
        this._mirroringShape.setValue(8816, 8817);
        this._mirroringShape.setValue(8817, 8816);
        this._mirroringShape.setValue(8818, 8819);
        this._mirroringShape.setValue(8819, 8818);
        this._mirroringShape.setValue(8820, 8821);
        this._mirroringShape.setValue(8821, 8820);
        this._mirroringShape.setValue(8822, 8823);
        this._mirroringShape.setValue(8823, 8822);
        this._mirroringShape.setValue(8824, 8825);
        this._mirroringShape.setValue(8825, 8824);
        this._mirroringShape.setValue(8826, 8827);
        this._mirroringShape.setValue(8827, 8826);
        this._mirroringShape.setValue(8828, 8829);
        this._mirroringShape.setValue(8829, 8828);
        this._mirroringShape.setValue(8830, 8831);
        this._mirroringShape.setValue(8831, 8830);
        this._mirroringShape.setValue(8832, 8833);
        this._mirroringShape.setValue(8833, 8832);
        this._mirroringShape.setValue(8834, 8835);
        this._mirroringShape.setValue(8835, 8834);
        this._mirroringShape.setValue(8836, 8837);
        this._mirroringShape.setValue(8837, 8836);
        this._mirroringShape.setValue(8838, 8839);
        this._mirroringShape.setValue(8839, 8838);
        this._mirroringShape.setValue(8840, 8841);
        this._mirroringShape.setValue(8841, 8840);
        this._mirroringShape.setValue(8842, 8843);
        this._mirroringShape.setValue(8843, 8842);
        this._mirroringShape.setValue(8847, 8848);
        this._mirroringShape.setValue(8848, 8847);
        this._mirroringShape.setValue(8849, 8850);
        this._mirroringShape.setValue(8850, 8849);
        this._mirroringShape.setValue(8856, 10680);
        this._mirroringShape.setValue(8866, 8867);
        this._mirroringShape.setValue(8867, 8866);
        this._mirroringShape.setValue(8870, 10974);
        this._mirroringShape.setValue(8872, 10980);
        this._mirroringShape.setValue(8873, 10979);
        this._mirroringShape.setValue(8875, 10981);
        this._mirroringShape.setValue(8880, 8881);
        this._mirroringShape.setValue(8881, 8880);
        this._mirroringShape.setValue(8882, 8883);
        this._mirroringShape.setValue(8883, 8882);
        this._mirroringShape.setValue(8884, 8885);
        this._mirroringShape.setValue(8885, 8884);
        this._mirroringShape.setValue(8886, 8887);
        this._mirroringShape.setValue(8887, 8886);
        this._mirroringShape.setValue(8905, 8906);
        this._mirroringShape.setValue(8906, 8905);
        this._mirroringShape.setValue(8907, 8908);
        this._mirroringShape.setValue(8908, 8907);
        this._mirroringShape.setValue(8909, 8771);
        this._mirroringShape.setValue(8912, 8913);
        this._mirroringShape.setValue(8913, 8912);
        this._mirroringShape.setValue(8918, 8919);
        this._mirroringShape.setValue(8919, 8918);
        this._mirroringShape.setValue(8920, 8921);
        this._mirroringShape.setValue(8921, 8920);
        this._mirroringShape.setValue(8922, 8923);
        this._mirroringShape.setValue(8923, 8922);
        this._mirroringShape.setValue(8924, 8925);
        this._mirroringShape.setValue(8925, 8924);
        this._mirroringShape.setValue(8926, 8927);
        this._mirroringShape.setValue(8927, 8926);
        this._mirroringShape.setValue(8928, 8929);
        this._mirroringShape.setValue(8929, 8928);
        this._mirroringShape.setValue(8930, 8931);
        this._mirroringShape.setValue(8931, 8930);
        this._mirroringShape.setValue(8932, 8933);
        this._mirroringShape.setValue(8933, 8932);
        this._mirroringShape.setValue(8934, 8935);
        this._mirroringShape.setValue(8935, 8934);
        this._mirroringShape.setValue(8936, 8937);
        this._mirroringShape.setValue(8937, 8936);
        this._mirroringShape.setValue(8938, 8939);
        this._mirroringShape.setValue(8939, 8938);
        this._mirroringShape.setValue(8940, 8941);
        this._mirroringShape.setValue(8941, 8940);
        this._mirroringShape.setValue(8944, 8945);
        this._mirroringShape.setValue(8945, 8944);
        this._mirroringShape.setValue(8946, 8954);
        this._mirroringShape.setValue(8947, 8955);
        this._mirroringShape.setValue(8948, 8956);
        this._mirroringShape.setValue(8950, 8957);
        this._mirroringShape.setValue(8951, 8958);
        this._mirroringShape.setValue(8954, 8946);
        this._mirroringShape.setValue(8955, 8947);
        this._mirroringShape.setValue(8956, 8948);
        this._mirroringShape.setValue(8957, 8950);
        this._mirroringShape.setValue(8958, 8951);
        this._mirroringShape.setValue(8968, 8969);
        this._mirroringShape.setValue(8969, 8968);
        this._mirroringShape.setValue(8970, 8971);
        this._mirroringShape.setValue(8971, 8970);
        this._mirroringShape.setValue(9001, 9002);
        this._mirroringShape.setValue(9002, 9001);
        this._mirroringShape.setValue(10088, 10089);
        this._mirroringShape.setValue(10089, 10088);
        this._mirroringShape.setValue(10090, 10091);
        this._mirroringShape.setValue(10091, 10090);
        this._mirroringShape.setValue(10092, 10093);
        this._mirroringShape.setValue(10093, 10092);
        this._mirroringShape.setValue(10094, 10095);
        this._mirroringShape.setValue(10095, 10094);
        this._mirroringShape.setValue(10096, 10097);
        this._mirroringShape.setValue(10097, 10096);
        this._mirroringShape.setValue(10098, 10099);
        this._mirroringShape.setValue(10099, 10098);
        this._mirroringShape.setValue(10100, 10101);
        this._mirroringShape.setValue(10101, 10100);
        this._mirroringShape.setValue(10197, 10198);
        this._mirroringShape.setValue(10198, 10197);
        this._mirroringShape.setValue(10205, 10206);
        this._mirroringShape.setValue(10206, 10205);
        this._mirroringShape.setValue(10210, 10211);
        this._mirroringShape.setValue(10211, 10210);
        this._mirroringShape.setValue(10212, 10213);
        this._mirroringShape.setValue(10213, 10212);
        this._mirroringShape.setValue(10214, 10215);
        this._mirroringShape.setValue(10215, 10214);
        this._mirroringShape.setValue(10216, 10217);
        this._mirroringShape.setValue(10217, 10216);
        this._mirroringShape.setValue(10218, 10219);
        this._mirroringShape.setValue(10219, 10218);
        this._mirroringShape.setValue(10627, 10628);
        this._mirroringShape.setValue(10628, 10627);
        this._mirroringShape.setValue(10629, 10630);
        this._mirroringShape.setValue(10630, 10629);
        this._mirroringShape.setValue(10631, 10632);
        this._mirroringShape.setValue(10632, 10631);
        this._mirroringShape.setValue(10633, 10634);
        this._mirroringShape.setValue(10634, 10633);
        this._mirroringShape.setValue(10635, 10636);
        this._mirroringShape.setValue(10636, 10635);
        this._mirroringShape.setValue(10637, 10640);
        this._mirroringShape.setValue(10638, 10639);
        this._mirroringShape.setValue(10639, 10638);
        this._mirroringShape.setValue(10640, 10637);
        this._mirroringShape.setValue(10641, 10642);
        this._mirroringShape.setValue(10642, 10641);
        this._mirroringShape.setValue(10643, 10644);
        this._mirroringShape.setValue(10644, 10643);
        this._mirroringShape.setValue(10645, 10646);
        this._mirroringShape.setValue(10646, 10645);
        this._mirroringShape.setValue(10647, 10648);
        this._mirroringShape.setValue(10648, 10647);
        this._mirroringShape.setValue(10680, 8856);
        this._mirroringShape.setValue(10688, 10689);
        this._mirroringShape.setValue(10689, 10688);
        this._mirroringShape.setValue(10692, 10693);
        this._mirroringShape.setValue(10693, 10692);
        this._mirroringShape.setValue(10703, 10704);
        this._mirroringShape.setValue(10704, 10703);
        this._mirroringShape.setValue(10705, 10706);
        this._mirroringShape.setValue(10706, 10705);
        this._mirroringShape.setValue(10708, 10709);
        this._mirroringShape.setValue(10709, 10708);
        this._mirroringShape.setValue(10712, 10713);
        this._mirroringShape.setValue(10713, 10712);
        this._mirroringShape.setValue(10714, 10715);
        this._mirroringShape.setValue(10715, 10714);
        this._mirroringShape.setValue(10741, 8725);
        this._mirroringShape.setValue(10744, 10745);
        this._mirroringShape.setValue(10745, 10744);
        this._mirroringShape.setValue(10748, 10749);
        this._mirroringShape.setValue(10749, 10748);
        this._mirroringShape.setValue(10795, 10796);
        this._mirroringShape.setValue(10796, 10795);
        this._mirroringShape.setValue(10797, 10796);
        this._mirroringShape.setValue(10798, 10797);
        this._mirroringShape.setValue(10804, 10805);
        this._mirroringShape.setValue(10805, 10804);
        this._mirroringShape.setValue(10812, 10813);
        this._mirroringShape.setValue(10813, 10812);
        this._mirroringShape.setValue(10852, 10853);
        this._mirroringShape.setValue(10853, 10852);
        this._mirroringShape.setValue(10873, 10874);
        this._mirroringShape.setValue(10874, 10873);
        this._mirroringShape.setValue(10877, 10878);
        this._mirroringShape.setValue(10878, 10877);
        this._mirroringShape.setValue(10879, 10880);
        this._mirroringShape.setValue(10880, 10879);
        this._mirroringShape.setValue(10881, 10882);
        this._mirroringShape.setValue(10882, 10881);
        this._mirroringShape.setValue(10883, 10884);
        this._mirroringShape.setValue(10884, 10883);
        this._mirroringShape.setValue(10891, 10892);
        this._mirroringShape.setValue(10892, 10891);
        this._mirroringShape.setValue(10897, 10898);
        this._mirroringShape.setValue(10898, 10897);
        this._mirroringShape.setValue(10899, 10900);
        this._mirroringShape.setValue(10900, 10899);
        this._mirroringShape.setValue(10901, 10902);
        this._mirroringShape.setValue(10902, 10901);
        this._mirroringShape.setValue(10903, 10904);
        this._mirroringShape.setValue(10904, 10903);
        this._mirroringShape.setValue(10905, 10906);
        this._mirroringShape.setValue(10906, 10905);
        this._mirroringShape.setValue(10907, 10908);
        this._mirroringShape.setValue(10908, 10907);
        this._mirroringShape.setValue(10913, 10914);
        this._mirroringShape.setValue(10914, 10913);
        this._mirroringShape.setValue(10918, 10919);
        this._mirroringShape.setValue(10919, 10918);
        this._mirroringShape.setValue(10920, 10921);
        this._mirroringShape.setValue(10921, 10920);
        this._mirroringShape.setValue(10922, 10923);
        this._mirroringShape.setValue(10923, 10922);
        this._mirroringShape.setValue(10924, 10925);
        this._mirroringShape.setValue(10925, 10924);
        this._mirroringShape.setValue(10927, 10928);
        this._mirroringShape.setValue(10928, 10927);
        this._mirroringShape.setValue(10931, 10932);
        this._mirroringShape.setValue(10932, 10931);
        this._mirroringShape.setValue(10939, 10940);
        this._mirroringShape.setValue(10940, 10939);
        this._mirroringShape.setValue(10941, 10942);
        this._mirroringShape.setValue(10942, 10941);
        this._mirroringShape.setValue(10943, 10944);
        this._mirroringShape.setValue(10944, 10943);
        this._mirroringShape.setValue(10945, 10946);
        this._mirroringShape.setValue(10946, 10945);
        this._mirroringShape.setValue(10947, 10948);
        this._mirroringShape.setValue(10948, 10947);
        this._mirroringShape.setValue(10949, 10950);
        this._mirroringShape.setValue(10950, 10949);
        this._mirroringShape.setValue(10957, 10958);
        this._mirroringShape.setValue(10958, 10957);
        this._mirroringShape.setValue(10959, 10960);
        this._mirroringShape.setValue(10960, 10959);
        this._mirroringShape.setValue(10961, 10962);
        this._mirroringShape.setValue(10962, 10961);
        this._mirroringShape.setValue(10963, 10964);
        this._mirroringShape.setValue(10964, 10963);
        this._mirroringShape.setValue(10965, 10966);
        this._mirroringShape.setValue(10966, 10965);
        this._mirroringShape.setValue(10974, 8870);
        this._mirroringShape.setValue(10979, 8873);
        this._mirroringShape.setValue(10980, 8872);
        this._mirroringShape.setValue(10981, 8875);
        this._mirroringShape.setValue(10988, 10989);
        this._mirroringShape.setValue(10989, 10988);
        this._mirroringShape.setValue(10999, 11000);
        this._mirroringShape.setValue(11000, 10999);
        this._mirroringShape.setValue(11001, 11002);
        this._mirroringShape.setValue(11002, 11001);
        this._mirroringShape.setValue(12296, 12297);
        this._mirroringShape.setValue(12297, 12296);
        this._mirroringShape.setValue(12298, 12299);
        this._mirroringShape.setValue(12299, 12298);
        this._mirroringShape.setValue(12300, 12301);
        this._mirroringShape.setValue(12301, 12300);
        this._mirroringShape.setValue(12302, 12303);
        this._mirroringShape.setValue(12303, 12302);
        this._mirroringShape.setValue(12304, 12305);
        this._mirroringShape.setValue(12305, 12304);
        this._mirroringShape.setValue(12308, 12309);
        this._mirroringShape.setValue(12309, 12308);
        this._mirroringShape.setValue(12310, 12311);
        this._mirroringShape.setValue(12311, 12310);
        this._mirroringShape.setValue(12312, 12313);
        this._mirroringShape.setValue(12313, 12312);
        this._mirroringShape.setValue(12314, 12315);
        this._mirroringShape.setValue(12315, 12314);
        this._mirroringShape.setValue(65288, 65289);
        this._mirroringShape.setValue(65289, 65288);
        this._mirroringShape.setValue(65308, 65310);
        this._mirroringShape.setValue(65310, 65308);
        this._mirroringShape.setValue(65339, 65341);
        this._mirroringShape.setValue(65341, 65339);
        this._mirroringShape.setValue(65371, 65373);
        this._mirroringShape.setValue(65373, 65371);
        this._mirroringShape.setValue(65375, 65376);
        this._mirroringShape.setValue(65376, 65375);
        this._mirroringShape.setValue(65378, 65379);
        this._mirroringShape.setValue(65379, 65378);
    }
}
class _RtlCharacters {
    /**
     * Creates an instance of the 'RtlCharacters' class.
     *
     * @private
     */
    constructor() {
        this._type = [];
        this._textOrder = -1;
        this._rtlCharacterTypes = new Array(65536);
        this.L = 0;
        this.lre = 1;
        this.lro = 2;
        this.R = 3;
        this.AL = 4;
        this.rle = 5;
        this.rlo = 6;
        this.pdf = 7;
        this.EN = 8;
        this.ES = 9;
        this.ET = 10;
        this.AN = 11;
        this.CS = 12;
        this.nsm = 13;
        this.BN = 14;
        this.B = 15;
        this.S = 16;
        this.WS = 17;
        this.ON = 18;
        this._charTypes = [
            this.L, this.EN, this.BN, this.ES, this.ES, this.S, this.ET, this.ET, this.B, this.AN, this.AN, this.S, this.CS, this.CS,
            this.WS, this.nsm, this.nsm, this.B, this.BN, 27, this.BN, 28, 30, this.B, 31, 31, this.S, 32, 32, this.WS, 33, 34, this.ON, 35,
            37, this.ET, 38, 42, this.ON, 43, 43, this.ET, 44, 44, this.CS, 45, 45, this.ET, 46, 46, this.CS, 47, 47, this.CS, 48, 57, this.EN,
            58, 58, this.CS, 59, 64, this.ON, 65, 90, this.L, 91, 96, this.ON, 97, 122, this.L, 123, 126, this.ON, 127, 132, this.BN, 133, 133,
            this.B, 134, 159, this.BN, 160, 160, this.CS, 161, 161, this.ON, 162, 165, this.ET, 166, 169, this.ON, 170, 170, this.L, 171, 175,
            this.ON, 176, 177, this.ET, 178, 179, this.EN, 180, 180, this.ON, 181, 181, this.L, 182, 184, this.ON, 185, 185, this.EN, 186, 186,
            this.L, 187, 191, this.ON, 192, 214, this.L, 215, 215, this.ON, 216, 246, this.L, 247, 247, this.ON, 248, 696, this.L, 697, 698,
            this.ON, 699, 705, this.L, 706, 719, this.ON, 720, 721, this.L, 722, 735, this.ON, 736, 740, this.L, 741, 749, this.ON, 750, 750,
            this.L, 751, 767, this.ON, 768, 855, this.nsm, 856, 860, this.L, 861, 879, this.nsm, 880, 883, this.L, 884, 885, this.ON, 886, 893,
            this.L, 894, 894, this.ON, 895, 899, this.L, 900, 901, this.ON, 902, 902, this.L, 903, 903, this.ON, 904, 1013, this.L, 1014, 1014,
            this.ON, 1015, 1154, this.L, 1155, 1158, this.nsm, 1159, 1159, this.L, 1160, 1161, this.nsm, 1162, 1417, this.L, 1418, 1418,
            this.ON, 1419, 1424, this.L, 1425, 1441, this.nsm, 1442, 1442, this.L, 1443, 1465, this.nsm, 1466, 1466, this.L, 1467, 1469,
            this.nsm, 1470, 1470, this.R, 1471, 1471, this.nsm, 1472, 1472, this.R, 1473, 1474, this.nsm, 1475, 1475, this.R, 1476, 1476,
            this.nsm, 1477, 1487, this.L, 1488, 1514, this.R, 1515, 1519, this.L, 1520, 1524, this.R, 1525, 1535, this.L, 1536, 1539, this.AL,
            1540, 1547, this.L, 1548, 1548, this.CS, 1549, 1549, this.AL, 1550, 1551, this.ON, 1552, 1557, this.nsm, 1558, 1562, this.L, 1563,
            1563, this.AL, 1564, 1566, this.L, 1567, 1567, this.AL, 1568, 1568, this.L, 1569, 1594, this.AL, 1595, 1599, this.L, 1600, 1610,
            this.AL, 1611, 1624, this.nsm, 1625, 1631, this.L, 1632, 1641, this.AN, 1642, 1642, this.ET, 1643, 1644, this.AN, 1645, 1647,
            this.AL, 1648, 1648, this.nsm, 1649, 1749, this.AL, 1750, 1756, this.nsm, 1757, 1757, this.AL, 1758, 1764, this.nsm, 1765, 1766,
            this.AL, 1767, 1768, this.nsm, 1769, 1769, this.ON, 1770, 1773, this.nsm, 1774, 1775, this.AL, 1776, 1785, this.EN, 1786, 1805,
            this.AL, 1806, 1806, this.L, 1807, 1807, this.BN, 1808, 1808, this.AL, 1809, 1809, this.nsm, 1810, 1839, this.AL, 1840, 1866,
            this.nsm, 1867, 1868, this.L, 1869, 1871, this.AL, 1872, 1919, this.L, 1920, 1957, this.AL, 1958, 1968, this.nsm, 1969, 1969,
            this.AL, 1970, 2304, this.L, 2305, 2306, this.nsm, 2307, 2363, this.L, 2364, 2364, this.nsm, 2365, 2368, this.L, 2369, 2376,
            this.nsm, 2377, 2380, this.L, 2381, 2381, this.nsm, 2382, 2384, this.L, 2385, 2388, this.nsm, 2389, 2401, this.L, 2402, 2403,
            this.nsm, 2404, 2432, this.L, 2433, 2433, this.nsm, 2434, 2491, this.L, 2492, 2492, this.nsm, 2493, 2496, this.L, 2497, 2500,
            this.nsm, 2501, 2508, this.L, 2509, 2509, this.nsm, 2510, 2529, this.L, 2530, 2531, this.nsm, 2532, 2545, this.L, 2546, 2547,
            this.ET, 2548, 2560, this.L, 2561, 2562, this.nsm, 2563, 2619, this.L, 2620, 2620, this.nsm, 2621, 2624, this.L, 2625, 2626,
            this.nsm, 2627, 2630, this.L, 2631, 2632, this.nsm, 2633, 2634, this.L, 2635, 2637, this.nsm, 2638, 2671, this.L, 2672, 2673,
            this.nsm, 2674, 2688, this.L, 2689, 2690, this.nsm, 2691, 2747, this.L, 2748, 2748, this.nsm, 2749, 2752, this.L, 2753, 2757,
            this.nsm, 2758, 2758, this.L, 2759, 2760, this.nsm, 2761, 2764, this.L, 2765, 2765, this.nsm, 2766, 2785, this.L, 2786, 2787,
            this.nsm, 2788, 2800, this.L, 2801, 2801, this.ET, 2802, 2816, this.L, 2817, 2817, this.nsm, 2818, 2875, this.L, 2876, 2876,
            this.nsm, 2877, 2878, this.L, 2879, 2879, this.nsm, 2880, 2880, this.L, 2881, 2883, this.nsm, 2884, 2892, this.L, 2893, 2893,
            this.nsm, 2894, 2901, this.L, 2902, 2902, this.nsm, 2903, 2945, this.L, 2946, 2946, this.nsm, 2947, 3007, this.L, 3008, 3008,
            this.nsm, 3009, 3020, this.L, 3021, 3021, this.nsm, 3022, 3058, this.L, 3059, 3064, this.ON, 3065, 3065, this.ET, 3066, 3066,
            this.ON, 3067, 3133, this.L, 3134, 3136, this.nsm, 3137, 3141, this.L, 3142, 3144, this.nsm, 3145, 3145, this.L, 3146, 3149,
            this.nsm, 3150, 3156, this.L, 3157, 3158, this.nsm, 3159, 3259, this.L, 3260, 3260, this.nsm, 3261, 3275, this.L, 3276, 3277,
            this.nsm, 3278, 3392, this.L, 3393, 3395, this.nsm, 3396, 3404, this.L, 3405, 3405, this.nsm, 3406, 3529, this.L, 3530, 3530,
            this.nsm, 3531, 3537, this.L, 3538, 3540, this.nsm, 3541, 3541, this.L, 3542, 3542, this.nsm, 3543, 3632, this.L, 3633, 3633,
            this.nsm, 3634, 3635, this.L, 3636, 3642, this.nsm, 3643, 3646, this.L, 3647, 3647, this.ET, 3648, 3654, this.L, 3655, 3662,
            this.nsm, 3663, 3760, this.L, 3761, 3761, this.nsm, 3762, 3763, this.L, 3764, 3769, this.nsm, 3770, 3770, this.L, 3771, 3772,
            this.nsm, 3773, 3783, this.L, 3784, 3789, this.nsm, 3790, 3863, this.L, 3864, 3865, this.nsm, 3866, 3892, this.L, 3893, 3893,
            this.nsm, 3894, 3894, this.L, 3895, 3895, this.nsm, 3896, 3896, this.L, 3897, 3897, this.nsm, 3898, 3901, this.ON, 3902, 3952,
            this.L, 3953, 3966, this.nsm, 3967, 3967, this.L, 3968, 3972, this.nsm, 3973, 3973, this.L, 3974, 3975, this.nsm, 3976, 3983,
            this.L, 3984, 3991, this.nsm, 3992, 3992, this.L, 3993, 4028, this.nsm, 4029, 4037, this.L, 4038, 4038, this.nsm, 4039, 4140,
            this.L, 4141, 4144, this.nsm, 4145, 4145, this.L, 4146, 4146, this.nsm, 4147, 4149, this.L, 4150, 4151, this.nsm, 4152, 4152,
            this.L, 4153, 4153, this.nsm, 4154, 4183, this.L, 4184, 4185, this.nsm, 4186, 5759, this.L, 5760, 5760, this.WS, 5761, 5786,
            this.L, 5787, 5788, this.ON, 5789, 5905, this.L, 5906, 5908, this.nsm, 5909, 5937, this.L, 5938, 5940, this.nsm, 5941, 5969,
            this.L, 5970, 5971, this.nsm, 5972, 6001, this.L, 6002, 6003, this.nsm, 6004, 6070, this.L, 6071, 6077, this.nsm, 6078, 6085,
            this.L, 6086, 6086, this.nsm, 6087, 6088, this.L, 6089, 6099, this.nsm, 6100, 6106, this.L, 6107, 6107, this.ET, 6108, 6108,
            this.L, 6109, 6109, this.nsm, 6110, 6127, this.L, 6128, 6137, this.ON, 6138, 6143, this.L, 6144, 6154, this.ON, 6155, 6157,
            this.nsm, 6158, 6158, this.WS, 6159, 6312, this.L, 6313, 6313, this.nsm, 6314, 6431, this.L, 6432, 6434, this.nsm, 6435, 6438,
            this.L, 6439, 6443, this.nsm, 6444, 6449, this.L, 6450, 6450, this.nsm, 6451, 6456, this.L, 6457, 6459, this.nsm, 6460, 6463,
            this.L, 6464, 6464, this.ON, 6465, 6467, this.L, 6468, 6469, this.ON, 6470, 6623, this.L, 6624, 6655, this.ON, 6656, 8124, this.L,
            8125, 8125, this.ON, 8126, 8126, this.L, 8127, 8129, this.ON, 8130, 8140, this.L, 8141, 8143, this.ON, 8144, 8156, this.L, 8157,
            8159, this.ON, 8160, 8172, this.L, 8173, 8175, this.ON, 8176, 8188, this.L, 8189, 8190, this.ON, 8191, 8191, this.L, 8192, 8202,
            this.WS, 8203, 8205, this.BN, 8206, 8206, this.L, 8207, 8207, this.R, 8208, 8231, this.ON, 8232, 8232, this.WS, 8233, 8233, this.B,
            8234, 8234, this.lre, 8235, 8235, this.rle, 8236, 8236, this.pdf, 8237, 8237, this.lro, 8238, 8238, this.rlo, 8239, 8239, this.WS,
            8240, 8244, this.ET, 8245, 8276, this.ON, 8277, 8278, this.L, 8279, 8279, this.ON, 8280, 8286, this.L, 8287, 8287, this.WS, 8288,
            8291, this.BN, 8292, 8297, this.L, 8298, 8303, this.BN, 8304, 8304, this.EN, 8305, 8307, this.L, 8308, 8313, this.EN, 8314, 8315,
            this.ET, 8316, 8318, this.ON, 8319, 8319, this.L, 8320, 8329, this.EN, 8330, 8331, this.ET, 8332, 8334, this.ON, 8335, 8351,
            this.L, 8352, 8369, this.ET, 8370, 8399, this.L, 8400, 8426, this.nsm, 8427, 8447, this.L, 8448, 8449, this.ON, 8450, 8450, this.L,
            8451, 8454, this.ON, 8455, 8455, this.L, 8456, 8457, this.ON, 8458, 8467, this.L, 8468, 8468, this.ON, 8469, 8469, this.L, 8470,
            8472, this.ON, 8473, 8477, this.L, 8478, 8483, this.ON, 8484, 8484, this.L, 8485, 8485, this.ON, 8486, 8486, this.L, 8487, 8487,
            this.ON, 8488, 8488, this.L, 8489, 8489, this.ON, 8490, 8493, this.L, 8494, 8494, this.ET, 8495, 8497, this.L, 8498, 8498, this.ON,
            8499, 8505, this.L, 8506, 8507, this.ON, 8508, 8511, this.L, 8512, 8516, this.ON, 8517, 8521, this.L, 8522, 8523, this.ON, 8524,
            8530, this.L, 8531, 8543, this.ON, 8544, 8591, this.L, 8592, 8721, this.ON, 8722, 8723, this.ET, 8724, 9013, this.ON, 9014, 9082,
            this.L, 9083, 9108, this.ON, 9109, 9109, this.L, 9110, 9168, this.ON, 9169, 9215, this.L, 9216, 9254, this.ON, 9255, 9279, this.L,
            9280, 9290, this.ON, 9291, 9311, this.L, 9312, 9371, this.EN, 9372, 9449, this.L, 9450, 9450, this.EN, 9451, 9751, this.ON, 9752,
            9752, this.L, 9753, 9853, this.ON, 9854, 9855, this.L, 9856, 9873, this.ON, 9874, 9887, this.L, 9888, 9889, this.ON, 9890, 9984,
            this.L, 9985, 9988, this.ON, 9989, 9989, this.L, 9990, 9993, this.ON, 9994, 9995, this.L, 9996, 10023, this.ON, 10024, 10024,
            this.L, 10025, 10059, this.ON, 10060, 10060, this.L, 10061, 10061, this.ON, 10062, 10062, this.L, 10063, 10066, this.ON, 10067,
            10069, this.L, 10070, 10070, this.ON, 10071, 10071, this.L, 10072, 10078, this.ON, 10079, 10080, this.L, 10081, 10132, this.ON,
            10133, 10135, this.L, 10136, 10159, this.ON, 10160, 10160, this.L, 10161, 10174, this.ON, 10175, 10191, this.L, 10192, 10219,
            this.ON, 10220, 10223, this.L, 10224, 11021, this.ON, 11022, 11903, this.L, 11904, 11929, this.ON, 11930, 11930, this.L, 11931,
            12019, this.ON, 12020, 12031, this.L, 12032, 12245, this.ON, 12246, 12271, this.L, 12272, 12283, this.ON, 12284, 12287, this.L,
            12288, 12288, this.WS, 12289, 12292, this.ON, 12293, 12295, this.L, 12296, 12320, this.ON, 12321, 12329, this.L, 12330, 12335,
            this.nsm, 12336, 12336, this.ON, 12337, 12341, this.L, 12342, 12343, this.ON, 12344, 12348, this.L, 12349, 12351, this.ON, 12352,
            12440, this.L, 12441, 12442, this.nsm, 12443, 12444, this.ON, 12445, 12447, this.L, 12448, 12448, this.ON, 12449, 12538, this.L,
            12539, 12539, this.ON, 12540, 12828, this.L, 12829, 12830, this.ON, 12831, 12879, this.L, 12880, 12895, this.ON, 12896, 12923,
            this.L, 12924, 12925, this.ON, 12926, 12976, this.L, 12977, 12991, this.ON, 12992, 13003, this.L, 13004, 13007, this.ON, 13008,
            13174, this.L, 13175, 13178, this.ON, 13179, 13277, this.L, 13278, 13279, this.ON, 13280, 13310, this.L, 13311, 13311, this.ON,
            13312, 19903, this.L, 19904, 19967, this.ON, 19968, 42127, this.L, 42128, 42182, this.ON, 42183, 64284, this.L, 64285, 64285,
            this.R, 64286, 64286, this.nsm, 64287, 64296, this.R, 64297, 64297, this.ET, 64298, 64310, this.R, 64311, 64311, this.L, 64312,
            64316, this.R, 64317, 64317, this.L, 64318, 64318, this.R, 64319, 64319, this.L, 64320, 64321, this.R, 64322, 64322, this.L, 64323,
            64324, this.R, 64325, 64325, this.L, 64326, 64335, this.R, 64336, 64433, this.AL, 64434, 64466, this.L, 64467, 64829, this.AL,
            64830, 64831, this.ON, 64832, 64847, this.L, 64848, 64911, this.AL, 64912, 64913, this.L, 64914, 64967, this.AL, 64968, 65007,
            this.L, 65008, 65020, this.AL, 65021, 65021, this.ON, 65022, 65023, this.L, 65024, 65039, this.nsm, 65040, 65055, this.L, 65056,
            65059, this.nsm, 65060, 65071, this.L, 65072, 65103, this.ON, 65104, 65104, this.CS, 65105, 65105, this.ON, 65106, 65106, this.CS,
            65107, 65107, this.L, 65108, 65108, this.ON, 65109, 65109, this.CS, 65110, 65118, this.ON, 65119, 65119, this.ET, 65120, 65121,
            this.ON, 65122, 65123, this.ET, 65124, 65126, this.ON, 65127, 65127, this.L, 65128, 65128, this.ON, 65129, 65130, this.ET, 65131,
            65131, this.ON, 65132, 65135, this.L, 65136, 65140, this.AL, 65141, 65141, this.L, 65142, 65276, this.AL, 65277, 65278, this.L,
            65279, 65279, this.BN, 65280, 65280, this.L, 65281, 65282, this.ON, 65283, 65285, this.ET, 65286, 65290, this.ON, 65291, 65291,
            this.ET, 65292, 65292, this.CS, 65293, 65293, this.ET, 65294, 65294, this.CS, 65295, 65295, this.ES, 65296, 65305, this.EN, 65306,
            65306, this.CS, 65307, 65312, this.ON, 65313, 65338, this.L, 65339, 65344, this.ON, 65345, 65370, this.L, 65371, 65381, this.ON,
            65382, 65503, this.L, 65504, 65505, this.ET, 65506, 65508, this.ON, 65509, 65510, this.ET, 65511, 65511, this.L, 65512, 65518,
            this.ON, 65519, 65528, this.L, 65529, 65531, this.BN, 65532, 65533, this.ON, 65534, 65535, this.L
        ];
        for (let i = 0; i < this._charTypes.length; ++i) {
            let start = this._charTypes[Number.parseInt(i.toString(), 10)];
            const end = this._charTypes[++i];
            const b = this._charTypes[++i];
            while (start <= end) {
                this._rtlCharacterTypes[start++] = b;
            }
        }
    }
    _getVisualOrder(inputText, isRtl) {
        this._type = this._getCharacterCode(inputText);
        this._textOrder = isRtl ? this.lre : this.L;
        this._doVisualOrder();
        const result = [];
        for (let i = 0; i < this._levels.length; i++) {
            result[Number.parseInt(i.toString(), 10)] = this._levels[Number.parseInt(i.toString(), 10)];
        }
        return result;
    }
    _getCharacterCode(text) {
        const characterCodes = [];
        for (let i = 0; i < text.length; i++) {
            const value = text[Number.parseInt(i.toString(), 10)].charCodeAt(0); // eslint-disable-line
            characterCodes[Number.parseInt(i.toString(), 10)] = this._rtlCharacterTypes[Number.parseInt(value.toString(), 10)];
        }
        return characterCodes;
    }
    _setDefaultLevels() {
        for (let i = 0; i < this._length; i++) {
            this._levels[Number.parseInt(i.toString(), 10)] = this._textOrder;
        }
    }
    _setLevels() {
        this._setDefaultLevels();
        for (let n = 0; n < this._length; ++n) {
            const level = this._levels[Number.parseInt(n.toString(), 10)];
            this._levels[Number.parseInt(n.toString(), 10)] = level;
        }
    }
    _updateLevels(index, level, length) {
        if ((level & 1) === 0) {
            for (let i = index; i < length; ++i) {
                if (this._result[Number.parseInt(i.toString(), 10)] === this.R) {
                    this._levels[Number.parseInt(i.toString(), 10)] += 1;
                }
                else if (this._result[Number.parseInt(i.toString(), 10)] !== this.L) {
                    this._levels[Number.parseInt(i.toString(), 10)] += 2;
                }
            }
        }
        else {
            for (let i = index; i < length; ++i) {
                if (this._result[Number.parseInt(i.toString(), 10)] !== this.R) {
                    this._levels[Number.parseInt(i.toString(), 10)] += 1;
                }
            }
        }
    }
    _doVisualOrder() {
        this._length = this._type.length;
        this._result = this._type;
        this._levels = [];
        this._setLevels();
        this._length = this._getEmbeddedCharactersLength();
        let preview = this._textOrder;
        let i = 0;
        while (i < this._length) {
            const level = this._levels[Number.parseInt(i.toString(), 10)];
            const preType = ((Math.max(preview, level) & 0x1) === 0) ? this.L : this.R;
            let length = i + 1;
            while (length < this._length && this._levels[Number.parseInt(length.toString(), 10)] === level) {
                ++length;
            }
            const success = length < this._length ? this._levels[Number.parseInt(length.toString(), 10)] : this._textOrder;
            const type = ((Math.max(success, level) & 0x1) === 0) ? this.L : this.R;
            this._check(i, length, level, preType, type);
            this._updateLevels(i, level, length);
            preview = level;
            i = length;
        }
        this._checkEmbeddedCharacters(this._length);
    }
    _getEmbeddedCharactersLength() {
        let index = 0;
        for (let i = 0; i < this._length; ++i) {
            if (!(this._type[Number.parseInt(i.toString(), 10)] === this.lre || this._type[Number.parseInt(i.toString(), 10)] === this.rle
                || this._type[Number.parseInt(i.toString(), 10)] === this.lro ||
                this._type[Number.parseInt(i.toString(), 10)] === this.rlo || this._type[Number.parseInt(i.toString(), 10)] === this.pdf
                || this._type[Number.parseInt(i.toString(), 10)] === this.BN)) {
                this._result[Number.parseInt(index.toString(), 10)] = this._result[Number.parseInt(i.toString(), 10)];
                this._levels[Number.parseInt(index.toString(), 10)] = this._levels[Number.parseInt(i.toString(), 10)];
                index++;
            }
        }
        return index;
    }
    _checkEmbeddedCharacters(length) {
        for (let i = this._type.length - 1; i >= 0; --i) {
            if (this._type[Number.parseInt(i.toString(), 10)] === this.lre || this._type[Number.parseInt(i.toString(), 10)] === this.rle
                || this._type[Number.parseInt(i.toString(), 10)] === this.lro ||
                this._type[Number.parseInt(i.toString(), 10)] === this.rlo || this._type[Number.parseInt(i.toString(), 10)] === this.pdf
                || this._type[Number.parseInt(i.toString(), 10)] === this.BN) {
                this._result[Number.parseInt(i.toString(), 10)] = this._type[Number.parseInt(i.toString(), 10)];
                this._levels[Number.parseInt(i.toString(), 10)] = -1;
            }
            else {
                length -= 1;
                this._result[Number.parseInt(i.toString(), 10)] = this._result[Number.parseInt(length.toString(), 10)];
                this._levels[Number.parseInt(i.toString(), 10)] = this._levels[Number.parseInt(length.toString(), 10)];
            }
        }
        for (let i = 0; i < this._type.length; i++) {
            if (this._levels[Number.parseInt(i.toString(), 10)] === -1) {
                this._levels[Number.parseInt(i.toString(), 10)] = this._levels[i - 1];
            }
        }
    }
    _check(index, length, level, startType, endType) {
        let charType = startType;
        for (let i = index; i < length; ++i) {
            if (this._result[Number.parseInt(i.toString(), 10)] === this.nsm) {
                this._result[Number.parseInt(i.toString(), 10)] = charType;
            }
            else {
                charType = this._result[Number.parseInt(i.toString(), 10)];
            }
        }
        this._checkEuropeanDigits(index, length, level, startType, endType);
    }
    _checkEuropeanDigits(index, length, level, startType, endType) {
        for (let i = index; i < length; ++i) {
            if (this._result[Number.parseInt(i.toString(), 10)] === this.EN) {
                for (let j = i - 1; j >= index; --j) {
                    if (this._result[Number.parseInt(j.toString(), 10)] === this.L ||
                        this._result[Number.parseInt(j.toString(), 10)] === this.R ||
                        this._result[Number.parseInt(j.toString(), 10)] === this.AL) {
                        if (this._result[Number.parseInt(j.toString(), 10)] === this.AL) {
                            this._result[Number.parseInt(i.toString(), 10)] = this.AN;
                        }
                        break;
                    }
                }
            }
        }
        this._checkArabicCharacters(index, length, level, startType, endType);
    }
    _checkArabicCharacters(index, length, level, startType, endType) {
        for (let i = index; i < length; ++i) {
            if (this._result[Number.parseInt(i.toString(), 10)] === this.AL) {
                this._result[Number.parseInt(i.toString(), 10)] = this.R;
            }
        }
        this._checkEuropeanNumberSeparator(index, length, level, startType, endType);
    }
    _checkEuropeanNumberSeparator(index, length, level, startType, endType) {
        for (let i = index + 1; i < length - 1; ++i) {
            if (this._result[Number.parseInt(i.toString(), 10)] === this.ES ||
                this._result[Number.parseInt(i.toString(), 10)] === this.CS) {
                const preview = this._result[i - 1];
                const success = this._result[i + 1];
                if (preview === this.EN && success === this.EN) {
                    this._result[Number.parseInt(i.toString(), 10)] = this.EN;
                }
                else if (this._result[Number.parseInt(i.toString(), 10)] === this.CS && preview === this.AN && success === this.AN) {
                    this._result[Number.parseInt(i.toString(), 10)] = this.AN;
                }
            }
        }
        this._checkEuropeanNumberTerminator(index, length, level, startType, endType);
    }
    _checkEuropeanNumberTerminator(index, length, level, startType, endType) {
        for (let i = index; i < length; ++i) {
            if (this._result[Number.parseInt(i.toString(), 10)] === this.ET) {
                const s = i;
                const b = [];
                b.push(this.ET);
                const l = this._getLength(s, length, b);
                let data = s === index ? startType : this._result[s - 1];
                if (data !== this.EN) {
                    data = (l === length) ? endType : this._result[Number.parseInt(l.toString(), 10)];
                }
                i = l;
            }
        }
        this._checkOtherNeutrals(index, length, level, startType, endType);
    }
    _checkOtherNeutrals(index, length, level, startType, endType) {
        for (let i = index; i < length; ++i) {
            if (this._result[Number.parseInt(i.toString(), 10)] === this.ES || this._result[Number.parseInt(i.toString(), 10)] === this.ET
                || this._result[Number.parseInt(i.toString(), 10)] === this.CS) {
                this._result[Number.parseInt(i.toString(), 10)] = this.ON;
            }
        }
        this._checkOtherCharacters(index, length, level, startType, endType);
    }
    _checkOtherCharacters(index, length, level, startType, endType) {
        for (let i = index; i < length; ++i) {
            if (this._result[Number.parseInt(i.toString(), 10)] === this.EN) {
                let pst = startType;
                for (let j = i - 1; j >= index; --j) {
                    if (this._result[Number.parseInt(j.toString(), 10)] === this.L ||
                        this._result[Number.parseInt(j.toString(), 10)] === this.R) {
                        pst = this._result[Number.parseInt(j.toString(), 10)];
                        break;
                    }
                }
                if (pst === this.L) {
                    this._result[Number.parseInt(i.toString(), 10)] = this.L;
                }
            }
        }
        this._checkCharacters(index, length, level, startType, endType);
    }
    _getLength(index, length, validSet) {
        --index;
        while (++index < length) {
            const t = this._result[Number.parseInt(index.toString(), 10)];
            for (let i = 0; i < validSet.length; ++i) {
                if (t === validSet[Number.parseInt(i.toString(), 10)]) {
                    index = this._getLength(++index, length, validSet);
                }
            }
            return index;
        }
        return length;
    }
    _checkCharacters(index, length, level, startType, endType) {
        for (let i = index; i < length; ++i) {
            if (this._result[Number.parseInt(i.toString(), 10)] === this.WS ||
                this._result[Number.parseInt(i.toString(), 10)] === this.ON ||
                this._result[Number.parseInt(i.toString(), 10)] === this.B ||
                this._result[Number.parseInt(i.toString(), 10)] === this.S) {
                const s = i;
                const byte = [this.B, this.S, this.WS, this.ON];
                const l = this._getLength(s, length, byte);
                let lt = 0;
                let tt = 0;
                let rt = 0;
                if (s === index) {
                    lt = startType;
                }
                else {
                    lt = this._result[s - 1];
                    if (lt === this.AN) {
                        lt = this.R;
                    }
                    else if (lt === this.EN) {
                        lt = this.R;
                    }
                }
                if (l === length) {
                    tt = endType;
                }
                else {
                    tt = this._result[Number.parseInt(l.toString(), 10)];
                    if (tt === this.AN) {
                        tt = this.R;
                    }
                }
                if (lt === tt) {
                    rt = lt;
                }
                else {
                    rt = ((level & 0x1) === 0) ? this.L : this.R;
                }
                for (let j = s; j < l; ++j) {
                    this._result[Number.parseInt(j.toString(), 10)] = rt;
                }
                i = l;
            }
        }
    }
}

class _RtlRenderer {
    constructor() {
        this._openBracket = '(';
        this._closeBracket = ')';
    }
    _layout(line, font, rtl, wordSpace, format) {
        let result = [];
        if (font !== null && typeof font !== 'undefined' && line !== null && typeof line !== 'undefined') {
            if (font._isUnicode) {
                result = this._customLayout(line, rtl, format, font, wordSpace);
            }
            else {
                result = [];
                result[0] = line;
            }
        }
        return result;
    }
    _splitLayout(line, font, rtl, wordSpace, format) {
        let words = [];
        if (font !== null && typeof font !== 'undefined' && line !== null && typeof line !== 'undefined') {
            const system = false;
            if (!system) {
                words = this._customSplitLayout(line, font, rtl, wordSpace, format);
            }
        }
        return words;
    }
    _getGlyphIndex(line, font, glyphs) {
        glyphs = [];
        if (font !== null && typeof font !== 'undefined' && line !== null && typeof line !== 'undefined') {
            if (line.length === 0) {
                return { _result: false, _glyphIndex: glyphs };
            }
            const renderer = new _ArabicShapeRenderer();
            const text = renderer._shape(line);
            const internalFont = font._fontInternal;
            const ttfReader = internalFont._ttfReader;
            glyphs = [text.length];
            let i = 0;
            for (let k = 0, len = text.length; k < len; k++) {
                const ch = text[Number.parseInt(k.toString(), 10)];
                const glyphInfo = ttfReader._getGlyph(ch);
                if (glyphInfo !== null && typeof glyphInfo !== 'undefined') {
                    glyphs[i++] = (glyphInfo)._index;
                }
            }
        }
        const unicodeLine = new _UnicodeLine();
        unicodeLine._result = true;
        unicodeLine._glyphIndex = glyphs;
        return unicodeLine;
    }
    _customLayout(line, rtl, format, font, wordSpace) {
        if (wordSpace === null || typeof wordSpace === 'undefined') {
            let result = null;
            if (line !== null && typeof line !== 'undefined') {
                if (format !== null && typeof format !== 'undefined' && format.textDirection !== PdfTextDirection.none) {
                    const bidi = new _Bidirectional();
                    result = bidi._getLogicalToVisualString(line, rtl);
                }
            }
            return result;
        }
        else {
            let layouted = '';
            let result = [];
            if (line !== null && typeof line !== 'undefined' && font !== null && typeof font !== 'undefined') {
                if (format !== null && typeof format !== 'undefined' && format.textDirection !== PdfTextDirection.none) {
                    const renderer = new _ArabicShapeRenderer();
                    const txt = renderer._shape(line);
                    layouted = this._customLayout(txt, rtl, format);
                }
                if (wordSpace) {
                    const words = layouted.split('');
                    const count = words.length;
                    for (let i = 0; i < count; i++) {
                        words[Number.parseInt(i.toString(), 10)] = this._addCharacter(font, words[Number.parseInt(i.toString(), 10)]);
                    }
                    result = words;
                }
                else {
                    result = [];
                    result[0] = this._addCharacter(font, layouted);
                }
            }
            return result;
        }
    }
    _addCharacter(font, glyphs) {
        if (font !== null && typeof font !== 'undefined' && glyphs !== null && typeof glyphs !== 'undefined') {
            const internalFont = font._fontInternal;
            const ttfReader = internalFont._ttfReader;
            font._setSymbols(glyphs);
            glyphs = ttfReader._convertString(glyphs);
            const bytes = _stringToUnicodeArray(glyphs);
            glyphs = _bytesToString(bytes);
        }
        return glyphs;
    }
    _customSplitLayout(line, font, rtl, wordSpace, format) {
        let words = [];
        if (line !== null && typeof line !== 'undefined') {
            const reversedLine = this._customLayout(line, rtl, format);
            words = reversedLine.split('');
        }
        return words;
    }
}

/**
 * Represents the base class for font objects.`
 * ```typescript
 * // Load an existing PDF document
 * let document: PdfDocument = new PdfDocument(data, password);
 * // Gets the first page
 * let page: PdfPage = document.getPage(0) as PdfPage;
 * // Create a new PDF standard font
 * let font: PdfStandardFont = new PdfStandardFont(PdfFontFamily.Helvetica, 10);
 * // Create a new PDF string format
 * let format: PdfStringFormat = new PdfStringFormat(PdfTextAlignment.right, PdfVerticalAlignment.bottom);
 * // Draw the text
 * page.graphics.drawString('Helvetica', font, [0, 180, page.size[0], 40], undefined, new PdfBrush([0, 0, 255]), format);
 * // Save the document
 * document.save('output.pdf');
 * // Destroy the document
 * document.destroy();
 * ```
 */
class PdfFont {
    /**
     * Gets the size of the PDF font.
     *
     * @returns {number} size.
     *
     * ```typescript
     * // Load an existing PDF document
     * let document: PdfDocument = new PdfDocument(data, password);
     * // Gets the first page
     * let page: PdfPage = document.getPage(0) as PdfPage;
     * // Create a new PDF standard font
     * let font: PdfStandardFont = new PdfStandardFont(PdfFontFamily.Helvetica, 10);
     * // Gets the font size
     * let size: number = font.size;
     * // Destroy the document
     * document.destroy();
     * ```
     */
    get size() {
        return this._size;
    }
    /**
     * Gets the style of the PDF font.
     *
     * @returns {PdfFontStyle} size.
     *
     * ```typescript
     * // Load an existing PDF document
     * let document: PdfDocument = new PdfDocument(data, password);
     * // Gets the first page
     * let page: PdfPage = document.getPage(0) as PdfPage;
     * // Create a new PDF standard font
     * let font: PdfStandardFont = new PdfStandardFont(PdfFontFamily.Helvetica, 10, PdfFontStyle.italic);
     * // Gets the font style
     * let style: PdfFontStyle = font.style;
     * // Destroy the document
     * document.destroy();
     * ```
     */
    get style() {
        return this._style;
    }
    /**
     * Sets the style of the PDF font.
     *
     * @param {PdfFontStyle} value to font style.
     *
     * ```typescript
     * // Load an existing PDF document
     * let document: PdfDocument = new PdfDocument(data, password);
     * // Gets the first page
     * let page: PdfPage = document.getPage(0) as PdfPage;
     * // Create a new PDF standard font
     * let font: PdfStandardFont = new PdfStandardFont(PdfFontFamily.Helvetica, 10);
     * // Sets the font style
     * font.style = PdfFontStyle.italic;
     * // Destroy the document
     * document.destroy();
     * ```
     */
    set style(value) {
        this._style = value;
    }
    /**
     * Gets the boolean flag indicating whether the font has underline style or not.
     *
     * @returns {boolean} isUnderline.
     *
     * ```typescript
     * // Load an existing PDF document
     * let document: PdfDocument = new PdfDocument(data, password);
     * // Gets the first page
     * let page: PdfPage = document.getPage(0) as PdfPage;
     * // Create a new PDF standard font
     * let font: PdfStandardFont = new PdfStandardFont(PdfFontFamily.Helvetica, 10, PdfFontStyle.underline);
     * // Gets the boolean flag indicating whether the font has underline style or not.
     * let underline: boolean = font.isUnderline;
     * // Destroy the document
     * document.destroy();
     * ```
     */
    get isUnderline() {
        return (this.style & PdfFontStyle.underline) > 0;
    }
    /**
     * Gets the boolean flag indicating whether the font has strike out style or not.
     *
     * @returns {boolean} isStrikeout.
     *
     * ```typescript
     * // Load an existing PDF document
     * let document: PdfDocument = new PdfDocument(data, password);
     * // Gets the first page
     * let page: PdfPage = document.getPage(0) as PdfPage;
     * // Create a new PDF standard font
     * let font: PdfStandardFont = new PdfStandardFont(PdfFontFamily.Helvetica, 10, PdfFontStyle.strikeout);
     * // Gets the boolean flag indicating whether the font has strike out style or not.
     * let strikeout: boolean = font.isStrikeout;
     * // Destroy the document
     * document.destroy();
     * ```
     */
    get isStrikeout() {
        return (this.style & PdfFontStyle.strikeout) > 0;
    }
    get _metrics() {
        return this._fontMetrics;
    }
    set _metrics(value) {
        this._fontMetrics = value;
    }
    /**
     * Gets the boolean flag indicating whether the font has bold style or not.
     *
     * @returns {boolean} isBold.
     *
     * ```typescript
     * // Load an existing PDF document
     * let document: PdfDocument = new PdfDocument(data, password);
     * // Gets the first page
     * let page: PdfPage = document.getPage(0) as PdfPage;
     * // Create a new PDF standard font
     * let font: PdfStandardFont = new PdfStandardFont(PdfFontFamily.Helvetica, 10, PdfFontStyle.bold);
     * // Gets the boolean flag indicating whether the font has bold style or not.
     * let bold: boolean = font.isBold;
     * // Destroy the document
     * document.destroy();
     * ```
     */
    get isBold() {
        return ((this.style & PdfFontStyle.bold) > 0);
    }
    /**
     * Gets the boolean flag indicating whether the font has italic style or not.
     *
     * @returns {boolean} isItalic.
     *
     * ```typescript
     * // Load an existing PDF document
     * let document: PdfDocument = new PdfDocument(data, password);
     * // Gets the first page
     * let page: PdfPage = document.getPage(0) as PdfPage;
     * // Create a new PDF standard font
     * let font: PdfStandardFont = new PdfStandardFont(PdfFontFamily.Helvetica, 10, PdfFontStyle.italic);
     * // Gets the boolean flag indicating whether the font has italic style or not.
     * let italic: boolean = font.isItalic;
     * // Destroy the document
     * document.destroy();
     * ```
     */
    get isItalic() {
        return ((this.style & PdfFontStyle.italic) > 0);
    }
    /**
     * Gets the font height.
     *
     * @returns {number} height.
     *
     * ```typescript
     * // Load an existing PDF document
     * let document: PdfDocument = new PdfDocument(data, password);
     * // Gets the first page
     * let page: PdfPage = document.getPage(0) as PdfPage;
     * // Create a new PDF standard font
     * let font: PdfStandardFont = new PdfStandardFont(PdfFontFamily.Helvetica, 10, PdfFontStyle.italic);
     * // Gets the font height
     * let height: number = font.height;
     * // Destroy the document
     * document.destroy();
     * ```
     */
    get height() {
        return this._metrics._getHeight();
    }
    constructor(size, style) {
        if (typeof size === 'number' && typeof style === 'undefined') {
            this._size = size;
        }
        else {
            this._size = size;
            this._style = style;
        }
    }
    _setInternals(internals) {
        if (internals == null) {
            throw new Error('ArgumentNullException:internals');
        }
        this._pdfFontInternals = internals;
    }
    _getCharacterCount(text, symbols) {
        if (typeof symbols === 'string') {
            let numSymbols = 0;
            let curIndex = 0;
            curIndex = text.indexOf(symbols, curIndex);
            while (curIndex !== -1) {
                numSymbols++;
                curIndex++;
                curIndex = text.indexOf(symbols, curIndex);
            }
            return numSymbols;
        }
        else {
            let count = 0;
            for (let i = 0; i < text.length; i++) {
                if (symbols.indexOf(text[Number.parseInt(i.toString(), 10)]) !== -1) {
                    count++;
                }
            }
            return count;
        }
    }
    measureString(text, arg2, arg3, arg4, arg5) {
        if (typeof text === 'string' && typeof arg2 === 'undefined') {
            return this.measureString(text, null);
        }
        else if (typeof text === 'string' && (arg2 instanceof PdfStringFormat || arg2 == null) &&
            typeof arg3 === 'undefined' && typeof arg4 === 'undefined') {
            const temparg2 = arg2;
            const charactersFitted = 0;
            const linesFilled = 0;
            return this.measureString(text, temparg2, charactersFitted, linesFilled);
        }
        else if (typeof text === 'string' && (arg2 instanceof PdfStringFormat || arg2 == null)
            && typeof arg3 === 'number' && typeof arg4 === 'number') {
            const temparg2 = arg2;
            return this.measureString(text, 0, temparg2, arg3, arg4);
        }
        else if (typeof text === 'string' && typeof arg2 === 'number'
            && (arg3 instanceof PdfStringFormat || arg3 == null) && typeof arg4 === 'number' && typeof arg5 === 'number') {
            const layoutArea = [arg2, 0];
            const temparg3 = arg3;
            return this.measureString(text, layoutArea, temparg3, arg4, arg5);
        }
        else {
            const temparg2 = arg2;
            const temparg3 = arg3;
            const layouter = new _PdfStringLayouter();
            const result = layouter._layout(text, this, temparg3, temparg2);
            arg4 = text.length;
            arg5 = (result._empty) ? 0 : result._lines.length;
            return result._actualSize;
        }
    }
    _applyFormatSettings(line, format, width) {
        let realWidth = width;
        if (typeof format !== 'undefined' && format !== null && width > 0) {
            if (format.characterSpacing !== 0) {
                realWidth += (line.length - 1) * format.characterSpacing;
            }
            if (format.wordSpacing !== 0) {
                realWidth += this._getCharacterCount(line, [' ', '\t']) * format.wordSpacing;
            }
        }
        return realWidth;
    }
}
/**
 * Represents one of the 14 standard fonts.
 * ```typescript
 * // Load an existing PDF document
 * let document: PdfDocument = new PdfDocument(data, password);
 * // Gets the first page
 * let page: PdfPage = document.getPage(0) as PdfPage;
 * // Create a new PDF standard font
 * let font: PdfStandardFont = new PdfStandardFont(PdfFontFamily.Helvetica, 10);
 * // Create a new PDF string format
 * let format: PdfStringFormat = new PdfStringFormat(PdfTextAlignment.right, PdfVerticalAlignment.bottom);
 * // Draw the text
 * page.graphics.drawString('Helvetica', font, [0, 180, page.size[0], 40], undefined, new PdfBrush([0, 0, 255]), format);
 * // Save the document
 * document.save('output.pdf');
 * // Destroy the document
 * document.destroy();
 * ```
 */
class PdfStandardFont extends PdfFont {
    /**
     * Gets the font family of the PDF standard font.
     *
     * @returns {PdfFontFamily} fontFamily.
     *
     * ```typescript
     * // Load an existing PDF document
     * let document: PdfDocument = new PdfDocument(data, password);
     * // Gets the first page
     * let page: PdfPage = document.getPage(0) as PdfPage;
     * // Create a new PDF standard font
     * let font: PdfStandardFont = new PdfStandardFont(PdfFontFamily.Helvetica, 10, PdfFontStyle.strikeout);
     * // Gets the font family
     * let fontFamily: PdfFontFamily = font.fontFamily;
     * // Destroy the document
     * document.destroy();
     * ```
     */
    get fontFamily() {
        return this._fontFamily;
    }
    constructor(fontFamily, size, style) {
        super(size, (typeof style === 'undefined') ? PdfFontStyle.regular : style);
        this._fontFamily = fontFamily;
        this._checkStyle();
        this._initializeInternals();
    }
    _checkStyle() {
        if (this._fontFamily === PdfFontFamily.symbol || this._fontFamily === PdfFontFamily.zapfDingbats) {
            this._style &= ~(PdfFontStyle.bold | PdfFontStyle.italic);
        }
    }
    /**
     * Gets the line width.
     *
     * @param {string} line Line.
     * @param {PdfStringFormat} format String format.
     * @returns {number} width.
     *
     * ```typescript
     * // Load an existing PDF document
     * let document: PdfDocument = new PdfDocument(data, password);
     * // Gets the first page
     * let page: PdfPage = document.getPage(0) as PdfPage;
     * // Create a new PDF standard font
     * let font: PdfStandardFont = new PdfStandardFont(PdfFontFamily.Helvetica, 10, PdfFontStyle.regular);
     * // Create a new PDF string format
     * let format: PdfStringFormat = new PdfStringFormat(PdfTextAlignment.right, PdfVerticalAlignment.bottom);
     * // Get the text width
     * let width: number = font.getLineWidth('Syncfusion', format);
     * // Save the document
     * document.save('output.pdf');
     * // Destroy the document
     * document.destroy();
     * ```
     */
    getLineWidth(line, format) {
        let width = 0;
        for (let i = 0, len = line.length; i < len; i++) {
            width += this._getCharacterWidthInternal(line[Number.parseInt(i.toString(), 10)]);
        }
        width *= (0.001 * this._metrics._size);
        width = this._applyFormatSettings(line, format, width);
        return width;
    }
    _initializeInternals() {
        this._metrics = _PdfStandardFontMetricsFactory._getMetrics(this._fontFamily, this._style, this._size);
        this._dictionary = this._createInternals();
    }
    _createInternals() {
        const dictionary = new _PdfDictionary();
        dictionary._updated = true;
        dictionary.set('Type', _PdfName.get('Font'));
        dictionary.set('Subtype', _PdfName.get('Type1'));
        dictionary.set('BaseFont', new _PdfName(this._metrics._postScriptName));
        if (this._fontFamily !== PdfFontFamily.symbol && this._fontFamily !== PdfFontFamily.zapfDingbats) {
            dictionary.set('Encoding', new _PdfName('WinAnsiEncoding'));
        }
        return dictionary;
    }
    _getCharacterWidthInternal(charCode) {
        let width = 0;
        let code = 0;
        code = charCode.charCodeAt(0);
        if (this._metrics._name === '0' ||
            this._metrics._name === '1' ||
            this._metrics._name === '2' ||
            this._metrics._name === '3' ||
            this._metrics._name === '4') {
            code = code - 32;
        }
        code = (code >= 0 && code !== 128) ? code : 0;
        const widthTable = this._metrics._widthTable;
        width = widthTable._itemAt(code);
        return width;
    }
}
/**
 * Represents one of the 7 CJK standard fonts.
 * ```typescript
 * // Load an existing PDF document
 * let document: PdfDocument = new PdfDocument(data, password);
 * // Gets the first page
 * let page: PdfPage = document.getPage(0) as PdfPage;
 * // Create a new PDF CJK standard font
 * let font: PdfCjkStandardFont = new PdfCjkStandardFont(PdfCjkFontFamily.heiseiMinchoW3, 20);
 * // Create a new PDF string format
 * let format: PdfStringFormat = new PdfStringFormat(PdfTextAlignment.right, PdfVerticalAlignment.bottom);
 * // Draw the text
 * page.graphics.drawString('こんにちは世界', font, [0, 180, page.size[0], 40], undefined, new PdfBrush([0, 0, 255]), format);
 * // Save the document
 * document.save('output.pdf');
 * // Destroy the document
 * document.destroy();
 * ```
 */
class PdfCjkStandardFont extends PdfFont {
    /**
     * Gets the font family of the PDF CJK font.
     *
     * @returns {PdfCjkFontFamily} fontFamily.
     *
     * ```typescript
     * // Load an existing PDF document
     * let document: PdfDocument = new PdfDocument(data, password);
     * // Gets the first page
     * let page: PdfPage = document.getPage(0) as PdfPage;
     * // Create a new PDF CJK standard font
     * let font: PdfCjkStandardFont = new PdfCjkStandardFont(PdfCjkFontFamily.heiseiMinchoW3, 20);
     * // Gets the font family
     * let fontFamily: PdfCjkFontFamily = font.fontFamily;
     * // Destroy the document
     * document.destroy();
     * ```
     */
    get fontFamily() {
        return this._fontFamily;
    }
    constructor(fontFamily, size, style) {
        super(size, (typeof style === 'undefined') ? PdfFontStyle.regular : style);
        this._fontFamily = fontFamily;
        this._size = size;
        this._initializeInternals();
    }
    _initializeInternals() {
        this._metrics = _PdfCjkStandardFontMetricsFactory._getMetrics(this._fontFamily, this._style, this._size);
        this._dictionary = this._createInternals();
    }
    _createInternals() {
        const dictionary = new _PdfDictionary();
        dictionary._updated = true;
        dictionary.set('Type', _PdfName.get('Font'));
        dictionary.set('Subtype', _PdfName.get('Type0'));
        dictionary.set('BaseFont', new _PdfName(this._metrics._postScriptName));
        dictionary.set('Encoding', this._getEncoding(this._fontFamily));
        dictionary.set('DescendantFonts', this._getDescendantFont());
        return dictionary;
    }
    _getEncoding(fontFamily) {
        let encoding = 'Unknown';
        switch (fontFamily) {
            case PdfCjkFontFamily.hanyangSystemsGothicMedium:
            case PdfCjkFontFamily.hanyangSystemsShinMyeongJoMedium:
                encoding = 'UniKS-UCS2-H';
                break;
            case PdfCjkFontFamily.heiseiKakuGothicW5:
            case PdfCjkFontFamily.heiseiMinchoW3:
                encoding = 'UniJIS-UCS2-H';
                break;
            case PdfCjkFontFamily.monotypeHeiMedium:
            case PdfCjkFontFamily.monotypeSungLight:
                encoding = 'UniCNS-UCS2-H';
                break;
            case PdfCjkFontFamily.sinoTypeSongLight:
                encoding = 'UniGB-UCS2-H';
                break;
        }
        return new _PdfName(encoding);
    }
    _getDescendantFont() {
        const dictionary = new _PdfDictionary();
        dictionary._updated = true;
        dictionary.set('Type', _PdfName.get('Font'));
        dictionary.set('Subtype', _PdfName.get('CIDFontType2'));
        dictionary.set('BaseFont', new _PdfName(this._metrics._postScriptName));
        dictionary.set('DW', this._metrics._widthTable._defaultWidth);
        dictionary.set('W', this._metrics._widthTable._toArray());
        dictionary.set('FontDescriptor', _PdfCjkFontDescriptorFactory._getFontDescriptor(this._fontFamily, this._style, this._metrics));
        dictionary.set('CIDSystemInfo', this._getSystemInformation());
        return [dictionary];
    }
    _getSystemInformation() {
        const systemInformation = new _PdfDictionary();
        systemInformation._updated = true;
        systemInformation.set('Registry', 'Adobe');
        switch (this._fontFamily) {
            case PdfCjkFontFamily.hanyangSystemsGothicMedium:
            case PdfCjkFontFamily.hanyangSystemsShinMyeongJoMedium:
                systemInformation.set('Ordering', 'Korea1');
                systemInformation.set('Supplement', 1);
                break;
            case PdfCjkFontFamily.heiseiKakuGothicW5:
            case PdfCjkFontFamily.heiseiMinchoW3:
                systemInformation.set('Ordering', 'Japan1');
                systemInformation.set('Supplement', 2);
                break;
            case PdfCjkFontFamily.monotypeHeiMedium:
            case PdfCjkFontFamily.monotypeSungLight:
                systemInformation.set('Ordering', 'CNS1');
                systemInformation.set('Supplement', '0');
                break;
            case PdfCjkFontFamily.sinoTypeSongLight:
                systemInformation.set('Ordering', 'GB1');
                systemInformation.set('Supplement', 2);
                break;
        }
        return systemInformation;
    }
    /**
     * Gets the line width.
     *
     * @param {string} line Line.
     * @param {PdfStringFormat} format String format.
     * @returns {number} width.
     *
     * ```typescript
     * // Load an existing PDF document
     * let document: PdfDocument = new PdfDocument(data, password);
     * // Gets the first page
     * let page: PdfPage = document.getPage(0) as PdfPage;
     * // Create a new PDF CJK standard font
     * let font: PdfCjkStandardFont = new PdfCjkStandardFont(PdfCjkFontFamily.heiseiMinchoW3, 20, PdfFontStyle.bold);
     * // Create a new PDF string format
     * let format: PdfStringFormat = new PdfStringFormat(PdfTextAlignment.right, PdfVerticalAlignment.bottom);
     * // Get the text width
     * let width: number = font.getLineWidth('Syncfusion', format);
     * // Save the document
     * document.save('output.pdf');
     * // Destroy the document
     * document.destroy();
     * ```
     */
    getLineWidth(line, format) {
        let width = 0;
        for (let i = 0; i < line.length; i++) {
            width += this._getCharacterWidthInternal(line.charCodeAt(i));
        }
        width *= (0.001 * this._metrics._size);
        width = this._applyFormatSettings(line, format, width);
        return width;
    }
    _getCharacterWidthInternal(charCode) {
        charCode = (charCode >= 0) ? charCode : 0;
        return this._metrics._widthTable._itemAt(charCode);
    }
}
/**
 * Represents TrueType font.
 * ```typescript
 * // Load an existing PDF document
 * let document: PdfDocument = new PdfDocument(data, password);
 * // Gets the first page
 * let page: PdfPage = document.getPage(0) as PdfPage;
 * // Create a new PDF truetype font
 * let font: PdfTrueTypeFont = new PdfTrueTypeFont(base64String, 10);
 * // Create a new PDF string format
 * let format: PdfStringFormat = new PdfStringFormat(PdfTextAlignment.right, PdfVerticalAlignment.bottom);
 * // Draw the text
 * page.graphics.drawString('Helvetica', font, [0, 180, page.size[0], 40], undefined, new PdfBrush([0, 0, 255]), format);
 * // Save the document
 * document.save('output.pdf');
 * // Destroy the document
 * document.destroy();
 * ```
 */
class PdfTrueTypeFont extends PdfFont {
    constructor(base64String, size, style) {
        super(size, (typeof style === 'undefined') ? PdfFontStyle.regular : style);
        this._isEmbedFont = false;
        this._isUnicode = true;
        if (style !== undefined) {
            this._createFontInternal(base64String, style);
        }
        else {
            this._createFontInternal(base64String, PdfFontStyle.regular);
        }
    }
    /**
     * Gets the boolean flag indicating whether the font has unicode or not.
     *
     * @returns {boolean} unicode.
     *
     * ```typescript
     * // Load an existing PDF document
     * let document: PdfDocument = new PdfDocument(data, password);
     * // Gets the first page
     * let page: PdfPage = document.getPage(0) as PdfPage;
     * // Create a new PDF truetype font
     * let font: PdfTrueTypeFont = new PdfTrueTypeFont(base64String, 10);
     * // Gets the boolean flag indicating whether the font has or not.
     * let isUnicode: boolean = font.isUnicode;
     * // Destroy the document
     * document.destroy();
     * ```
     */
    get isUnicode() {
        return this._isUnicode;
    }
    /**
     * Gets the boolean flag indicating whether the font is embedded or not.
     *
     * @returns {boolean} isEmbed.
     *
     * ```typescript
     * // Load an existing PDF document
     * let document: PdfDocument = new PdfDocument(data, password);
     * // Gets the first page
     * let page: PdfPage = document.getPage(0) as PdfPage;
     * // Create a new PDF truetype font
     * let font: PdfTrueTypeFont = new PdfTrueTypeFont(base64String, 10);
     * // Gets the boolean flag indicating whether the font is embedded or not.
     * let isEmbed: boolean = font.isEmbed;
     * // Destroy the document
     * document.destroy();
     * ```
     */
    get isEmbed() {
        return this._isEmbedFont;
    }
    _createFontInternal(base64String, style) {
        this._fontInternal = new _UnicodeTrueTypeFont(base64String, this._size);
        this._calculateStyle(style);
        this._initializeInternals();
    }
    _calculateStyle(style) {
        let iStyle = this._fontInternal._ttfMetrics._macStyle;
        if ((style & PdfFontStyle.underline) !== 0) {
            iStyle |= PdfFontStyle.underline;
        }
        if ((style & PdfFontStyle.strikeout) !== 0) {
            iStyle |= PdfFontStyle.strikeout;
        }
        this.style = iStyle;
    }
    _initializeInternals() {
        let internals = null;
        if (this._fontInternal instanceof _UnicodeTrueTypeFont) {
            this._fontInternal._isEmbed = this._isEmbedFont;
        }
        this._fontInternal._createInternals();
        internals = this._fontInternal._getInternals();
        this._metrics = this._fontInternal._metrics;
        this._metrics._isUnicodeFont = true;
        this._setInternals(internals);
    }
    /**
     * Gets the line width.
     *
     * @param {string} line Line.
     * @param {PdfStringFormat} format String format.
     * @returns {number} width.
     *
     * ```typescript
     * // Load an existing PDF document
     * let document: PdfDocument = new PdfDocument(data, password);
     * // Gets the first page
     * let page: PdfPage = document.getPage(0) as PdfPage;
     * // Create a new PDF truetype font
     * let font: PdfTrueTypeFont = new PdfTrueTypeFont(base64String, 10, PdfFontStyle.regular);
     * // Create a new PDF string format
     * let format: PdfStringFormat = new PdfStringFormat(PdfTextAlignment.right, PdfVerticalAlignment.bottom);
     * // Get the text width
     * let width: number = font.getLineWidth('Syncfusion', format);
     * // Save the document
     * document.save('output.pdf');
     * // Destroy the document
     * document.destroy();
     * ```
     */
    getLineWidth(line, format) {
        let width = 0;
        if (format !== null && typeof format !== 'undefined' && format.textDirection !== PdfTextDirection.none) {
            width = this._getUnicodeLineWidth(line, width);
        }
        else {
            for (let i = 0, len = line.length; i < len; i++) {
                width += this._getCharacterWidthInternal(line[Number.parseInt(i.toString(), 10)]);
            }
        }
        width *= (0.001 * this._metrics._size);
        width = this._applyFormatSettings(line, format, width);
        return width;
    }
    _getUnicodeLineWidth(line, width) {
        width = 0;
        let glyphIndex = [];
        let result = false;
        const rtlRender = new _RtlRenderer();
        const value = rtlRender._getGlyphIndex(line, this, glyphIndex);
        result = value._result;
        glyphIndex = value._glyphIndex;
        if (result && glyphIndex !== null) {
            const ttfReader = this._fontInternal._ttfReader;
            for (let i = 0, len = glyphIndex.length; i < len; i++) {
                const index = glyphIndex[Number.parseInt(i.toString(), 10)];
                const glyph = ttfReader._getGlyph(index);
                if (glyph !== null && typeof glyph !== 'undefined') {
                    width += glyph._width;
                }
            }
        }
        return width;
    }
    _getCharacterWidth(charCode, format) {
        let codeWidth = this._fontInternal._getCharacterWidth(charCode);
        const size = this._metrics._getSize(format);
        codeWidth *= (0.001 * size);
        return codeWidth;
    }
    _setSymbols(text) {
        const internalFont = this._fontInternal;
        if (internalFont !== null && typeof internalFont !== 'undefined') {
            internalFont._setSymbols(text);
        }
    }
    _getCharacterWidthInternal(charCode) {
        let width = 0;
        let code = 0;
        code = charCode.charCodeAt(0);
        if (this._metrics._name === '0' ||
            this._metrics._name === '1' ||
            this._metrics._name === '2' ||
            this._metrics._name === '3' ||
            this._metrics._name === '4') {
            code = code - 32;
        }
        code = (code >= 0 && code !== 128) ? code : 0;
        const widthTable = this._metrics._widthTable;
        width = widthTable._itemAt(code);
        return width;
    }
}
class _PdfStandardFontMetricsFactory {
    static _getMetrics(fontFamily, fontStyle, size) {
        let metrics = null;
        switch (fontFamily) {
            case PdfFontFamily.helvetica:
                metrics = this._getHelveticaMetrics(fontStyle, size);
                break;
            case PdfFontFamily.courier:
                metrics = this._getCourierMetrics(fontStyle, size);
                break;
            case PdfFontFamily.timesRoman:
                metrics = this._getTimesMetrics(fontStyle, size);
                break;
            case PdfFontFamily.symbol:
                metrics = this._getSymbolMetrics(size);
                break;
            case PdfFontFamily.zapfDingbats:
                metrics = this._getZapfDingbatsMetrics(size);
                break;
            default:
                metrics = this._getHelveticaMetrics(fontStyle, size);
                break;
        }
        metrics._name = fontFamily.toString();
        metrics._subScriptSizeFactor = this._subSuperScriptFactor;
        metrics._superscriptSizeFactor = this._subSuperScriptFactor;
        return metrics;
    }
    static _getHelveticaMetrics(fontStyle, size) {
        const metrics = new _PdfFontMetrics();
        if ((fontStyle & PdfFontStyle.bold) > 0 && (fontStyle & PdfFontStyle.italic) > 0) {
            metrics._ascent = this._helveticaBoldItalicAscent;
            metrics._descent = this._helveticaBoldItalicDescent;
            metrics._postScriptName = this._helveticaBoldItalicName;
            metrics._size = size;
            metrics._widthTable = new _StandardWidthTable(this._arialBoldWidth);
            metrics._height = metrics._ascent - metrics._descent;
        }
        else if ((fontStyle & PdfFontStyle.bold) > 0) {
            metrics._ascent = this._helveticaBoldAscent;
            metrics._descent = this._helveticaBoldDescent;
            metrics._postScriptName = this._helveticaBoldName;
            metrics._size = size;
            metrics._widthTable = new _StandardWidthTable(this._arialBoldWidth);
            metrics._height = metrics._ascent - metrics._descent;
        }
        else if ((fontStyle & PdfFontStyle.italic) > 0) {
            metrics._ascent = this._helveticaItalicAscent;
            metrics._descent = this._helveticaItalicDescent;
            metrics._postScriptName = this._helveticaItalicName;
            metrics._size = size;
            metrics._widthTable = new _StandardWidthTable(this._arialWidth);
            metrics._height = metrics._ascent - metrics._descent;
        }
        else {
            metrics._ascent = this._helveticaAscent;
            metrics._descent = this._helveticaDescent;
            metrics._postScriptName = this._helveticaName;
            metrics._size = size;
            metrics._widthTable = new _StandardWidthTable(this._arialWidth);
            metrics._height = metrics._ascent - metrics._descent;
        }
        return metrics;
    }
    static _getCourierMetrics(fontStyle, size) {
        const metrics = new _PdfFontMetrics();
        if ((fontStyle & PdfFontStyle.bold) > 0 && (fontStyle & PdfFontStyle.italic) > 0) {
            metrics._ascent = this._courierBoldItalicAscent;
            metrics._descent = this._courierBoldItalicDescent;
            metrics._postScriptName = this._courierBoldItalicName;
            metrics._size = size;
            metrics._widthTable = new _StandardWidthTable(this._fixedWidth);
            metrics._height = metrics._ascent - metrics._descent;
        }
        else if ((fontStyle & PdfFontStyle.bold) > 0) {
            metrics._ascent = this._courierBoldAscent;
            metrics._descent = this._courierBoldDescent;
            metrics._postScriptName = this._courierBoldName;
            metrics._size = size;
            metrics._widthTable = new _StandardWidthTable(this._fixedWidth);
            metrics._height = metrics._ascent - metrics._descent;
        }
        else if ((fontStyle & PdfFontStyle.italic) > 0) {
            metrics._ascent = this._courierItalicAscent;
            metrics._descent = this._courierItalicDescent;
            metrics._postScriptName = this._courierItalicName;
            metrics._size = size;
            metrics._widthTable = new _StandardWidthTable(this._fixedWidth);
            metrics._height = metrics._ascent - metrics._descent;
        }
        else {
            metrics._ascent = this._courierAscent;
            metrics._descent = this._courierDescent;
            metrics._postScriptName = this._courierName;
            metrics._size = size;
            metrics._widthTable = new _StandardWidthTable(this._fixedWidth);
            metrics._height = metrics._ascent - metrics._descent;
        }
        return metrics;
    }
    static _getTimesMetrics(fontStyle, size) {
        const metrics = new _PdfFontMetrics();
        if ((fontStyle & PdfFontStyle.bold) > 0 && (fontStyle & PdfFontStyle.italic) > 0) {
            metrics._ascent = this._timesBoldItalicAscent;
            metrics._descent = this._timesBoldItalicDescent;
            metrics._postScriptName = this._timesBoldItalicName;
            metrics._size = size;
            metrics._widthTable = new _StandardWidthTable(this._timesRomanBoldItalicWidths);
            metrics._height = metrics._ascent - metrics._descent;
        }
        else if ((fontStyle & PdfFontStyle.bold) > 0) {
            metrics._ascent = this._timesBoldAscent;
            metrics._descent = this._timesBoldDescent;
            metrics._postScriptName = this._timesBoldName;
            metrics._size = size;
            metrics._widthTable = new _StandardWidthTable(this._timesRomanBoldWidth);
            metrics._height = metrics._ascent - metrics._descent;
        }
        else if ((fontStyle & PdfFontStyle.italic) > 0) {
            metrics._ascent = this._timesItalicAscent;
            metrics._descent = this._timesItalicDescent;
            metrics._postScriptName = this._timesItalicName;
            metrics._size = size;
            metrics._widthTable = new _StandardWidthTable(this._timesRomanItalicWidth);
            metrics._height = metrics._ascent - metrics._descent;
        }
        else {
            metrics._ascent = this._timesAscent;
            metrics._descent = this._timesDescent;
            metrics._postScriptName = this._timesName;
            metrics._size = size;
            metrics._widthTable = new _StandardWidthTable(this._timesRomanWidth);
            metrics._height = metrics._ascent - metrics._descent;
        }
        return metrics;
    }
    static _getSymbolMetrics(size) {
        const metrics = new _PdfFontMetrics();
        metrics._ascent = this._symbolAscent;
        metrics._descent = this._symbolDescent;
        metrics._postScriptName = this._symbolName;
        metrics._size = size;
        metrics._widthTable = new _StandardWidthTable(this._symbolWidth);
        metrics._height = metrics._ascent - metrics._descent;
        return metrics;
    }
    static _getZapfDingbatsMetrics(size) {
        const metrics = new _PdfFontMetrics();
        metrics._ascent = this._zapfDingbatsAscent;
        metrics._descent = this._zapfDingbatsDescent;
        metrics._postScriptName = this._zapfDingbatsName;
        metrics._size = size;
        metrics._widthTable = new _StandardWidthTable(this._zapfDingbatsWidth);
        metrics._height = metrics._ascent - metrics._descent;
        return metrics;
    }
}
_PdfStandardFontMetricsFactory._subSuperScriptFactor = 1.52;
_PdfStandardFontMetricsFactory._helveticaAscent = 931;
_PdfStandardFontMetricsFactory._helveticaDescent = -225;
_PdfStandardFontMetricsFactory._helveticaName = 'Helvetica';
_PdfStandardFontMetricsFactory._helveticaBoldAscent = 962;
_PdfStandardFontMetricsFactory._helveticaBoldDescent = -228;
_PdfStandardFontMetricsFactory._helveticaBoldName = 'Helvetica-Bold';
_PdfStandardFontMetricsFactory._helveticaItalicAscent = 931;
_PdfStandardFontMetricsFactory._helveticaItalicDescent = -225;
_PdfStandardFontMetricsFactory._helveticaItalicName = 'Helvetica-Oblique';
_PdfStandardFontMetricsFactory._helveticaBoldItalicAscent = 962;
_PdfStandardFontMetricsFactory._helveticaBoldItalicDescent = -228;
_PdfStandardFontMetricsFactory._helveticaBoldItalicName = 'Helvetica-BoldOblique';
_PdfStandardFontMetricsFactory._courierAscent = 805;
_PdfStandardFontMetricsFactory._courierDescent = -250;
_PdfStandardFontMetricsFactory._courierName = 'Courier';
_PdfStandardFontMetricsFactory._courierBoldAscent = 801;
_PdfStandardFontMetricsFactory._courierBoldDescent = -250;
_PdfStandardFontMetricsFactory._courierBoldName = 'Courier-Bold';
_PdfStandardFontMetricsFactory._courierItalicAscent = 805;
_PdfStandardFontMetricsFactory._courierItalicDescent = -250;
_PdfStandardFontMetricsFactory._courierItalicName = 'Courier-Oblique';
_PdfStandardFontMetricsFactory._courierBoldItalicAscent = 801;
_PdfStandardFontMetricsFactory._courierBoldItalicDescent = -250;
_PdfStandardFontMetricsFactory._courierBoldItalicName = 'Courier-BoldOblique';
_PdfStandardFontMetricsFactory._timesAscent = 898;
_PdfStandardFontMetricsFactory._timesDescent = -218;
_PdfStandardFontMetricsFactory._timesName = 'Times-Roman';
_PdfStandardFontMetricsFactory._timesBoldAscent = 935;
_PdfStandardFontMetricsFactory._timesBoldDescent = -218;
_PdfStandardFontMetricsFactory._timesBoldName = 'Times-Bold';
_PdfStandardFontMetricsFactory._timesItalicAscent = 883;
_PdfStandardFontMetricsFactory._timesItalicDescent = -217;
_PdfStandardFontMetricsFactory._timesItalicName = 'Times-Italic';
_PdfStandardFontMetricsFactory._timesBoldItalicAscent = 921;
_PdfStandardFontMetricsFactory._timesBoldItalicDescent = -218;
_PdfStandardFontMetricsFactory._timesBoldItalicName = 'Times-BoldItalic';
_PdfStandardFontMetricsFactory._symbolAscent = 1010;
_PdfStandardFontMetricsFactory._symbolDescent = -293;
_PdfStandardFontMetricsFactory._symbolName = 'Symbol';
_PdfStandardFontMetricsFactory._zapfDingbatsAscent = 820;
_PdfStandardFontMetricsFactory._zapfDingbatsDescent = -143;
_PdfStandardFontMetricsFactory._zapfDingbatsName = 'ZapfDingbats';
_PdfStandardFontMetricsFactory._arialWidth = [
    278, 278, 355, 556, 556, 889, 667, 191, 333, 333, 389, 584, 278, 333,
    278, 278, 556, 556, 556, 556, 556, 556, 556, 556, 556, 556, 278, 278, 584, 584,
    584, 556, 1015, 667, 667, 722, 722, 667, 611, 778, 722, 278, 500, 667, 556, 833,
    722, 778, 667, 778, 722, 667, 611, 722, 667, 944, 667, 667, 611, 278, 278, 278,
    469, 556, 333, 556, 556, 500, 556, 556, 278, 556, 556, 222, 222, 500, 222, 833,
    556, 556, 556, 556, 333, 500, 278, 556, 500, 722, 500, 500, 500, 334, 260, 334,
    584, 0, 556, 0, 222, 556, 333, 1000, 556, 556, 333, 1000, 667, 333, 1000, 0,
    611, 0, 0, 222, 222, 333, 333, 350, 556, 1000, 333, 1000, 500, 333, 944, 0,
    500, 667, 0, 333, 556, 556, 556, 556, 260, 556, 333, 737, 370, 556, 584, 0,
    737, 333, 400, 584, 333, 333, 333, 556, 537, 278, 333, 333, 365, 556, 834, 834,
    834, 611, 667, 667, 667, 667, 667, 667, 1000, 722, 667, 667, 667, 667, 278, 278,
    278, 278, 722, 722, 778, 778, 778, 778, 778, 584, 778, 722, 722, 722, 722, 667,
    667, 611, 556, 556, 556, 556, 556, 556, 889, 500, 556, 556, 556, 556, 278, 278,
    278, 278, 556, 556, 556, 556, 556, 556, 556, 584, 611, 556, 556, 556, 556, 500,
    556, 500
];
_PdfStandardFontMetricsFactory._arialBoldWidth = [
    278, 333, 474, 556, 556, 889, 722, 238, 333, 333, 389, 584, 278, 333,
    278, 278, 556, 556, 556, 556, 556, 556, 556, 556, 556, 556, 333, 333, 584, 584,
    584, 611, 975, 722, 722, 722, 722, 667, 611, 778, 722, 278, 556, 722, 611, 833,
    722, 778, 667, 778, 722, 667, 611, 722, 667, 944, 667, 667, 611, 333, 278, 333,
    584, 556, 333, 556, 611, 556, 611, 556, 333, 611, 611, 278, 278, 556, 278, 889,
    611, 611, 611, 611, 389, 556, 333, 611, 556, 778, 556, 556, 500, 389, 280, 389,
    584, 0, 556, 0, 278, 556, 500, 1000, 556, 556, 333, 1000, 667, 333, 1000, 0,
    611, 0, 0, 278, 278, 500, 500, 350, 556, 1000, 333, 1000, 556, 333, 944, 0,
    500, 667, 0, 333, 556, 556, 556, 556, 280, 556, 333, 737, 370, 556, 584, 0,
    737, 333, 400, 584, 333, 333, 333, 611, 556, 278, 333, 333, 365, 556, 834, 834,
    834, 611, 722, 722, 722, 722, 722, 722, 1000, 722, 667, 667, 667, 667, 278, 278,
    278, 278, 722, 722, 778, 778, 778, 778, 778, 584, 778, 722, 722, 722, 722, 667,
    667, 611, 556, 556, 556, 556, 556, 556, 889, 556, 556, 556, 556, 556, 278, 278,
    278, 278, 611, 611, 611, 611, 611, 611, 611, 584, 611, 611, 611, 611, 611, 556,
    611, 556
];
_PdfStandardFontMetricsFactory._fixedWidth = [
    600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600,
    600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600,
    600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600,
    600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600,
    600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600,
    600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600,
    600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600,
    600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600,
    600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600,
    600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600,
    600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600,
    600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600,
    600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600,
    600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600
];
_PdfStandardFontMetricsFactory._timesRomanWidth = [
    250, 333, 408, 500, 500, 833, 778, 180, 333, 333, 500, 564, 250, 333,
    250, 278, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 278, 278, 564, 564,
    564, 444, 921, 722, 667, 667, 722, 611, 556, 722, 722, 333, 389, 722, 611, 889,
    722, 722, 556, 722, 667, 556, 611, 722, 722, 944, 722, 722, 611, 333, 278, 333,
    469, 500, 333, 444, 500, 444, 500, 444, 333, 500, 500, 278, 278, 500, 278, 778,
    500, 500, 500, 500, 333, 389, 278, 500, 500, 722, 500, 500, 444, 480, 200, 480,
    541, 0, 500, 0, 333, 500, 444, 1000, 500, 500, 333, 1000, 556, 333, 889, 0,
    611, 0, 0, 333, 333, 444, 444, 350, 500, 1000, 333, 980, 389, 333, 722, 0,
    444, 722, 0, 333, 500, 500, 500, 500, 200, 500, 333, 760, 276, 500, 564, 0,
    760, 333, 400, 564, 300, 300, 333, 500, 453, 250, 333, 300, 310, 500, 750, 750,
    750, 444, 722, 722, 722, 722, 722, 722, 889, 667, 611, 611, 611, 611, 333, 333,
    333, 333, 722, 722, 722, 722, 722, 722, 722, 564, 722, 722, 722, 722, 722, 722,
    556, 500, 444, 444, 444, 444, 444, 444, 667, 444, 444, 444, 444, 444, 278, 278,
    278, 278, 500, 500, 500, 500, 500, 500, 500, 564, 500, 500, 500, 500, 500, 500,
    500, 500
];
_PdfStandardFontMetricsFactory._timesRomanBoldWidth = [
    250, 333, 555, 500, 500, 1000, 833, 278, 333, 333, 500, 570, 250, 333,
    250, 278, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 333, 333, 570, 570,
    570, 500, 930, 722, 667, 722, 722, 667, 611, 778, 778, 389, 500, 778, 667, 944,
    722, 778, 611, 778, 722, 556, 667, 722, 722, 1000, 722, 722, 667, 333, 278, 333,
    581, 500, 333, 500, 556, 444, 556, 444, 333, 500, 556, 278, 333, 556, 278, 833,
    556, 500, 556, 556, 444, 389, 333, 556, 500, 722, 500, 500, 444, 394, 220, 394,
    520, 0, 500, 0, 333, 500, 500, 1000, 500, 500, 333, 1000, 556, 333, 1000, 0,
    667, 0, 0, 333, 333, 500, 500, 350, 500, 1000, 333, 1000, 389, 333, 722, 0,
    444, 722, 0, 333, 500, 500, 500, 500, 220, 500, 333, 747, 300, 500, 570, 0,
    747, 333, 400, 570, 300, 300, 333, 556, 540, 250, 333, 300, 330, 500, 750, 750,
    750, 500, 722, 722, 722, 722, 722, 722, 1000, 722, 667, 667, 667, 667, 389, 389,
    389, 389, 722, 722, 778, 778, 778, 778, 778, 570, 778, 722, 722, 722, 722, 722,
    611, 556, 500, 500, 500, 500, 500, 500, 722, 444, 444, 444, 444, 444, 278, 278,
    278, 278, 500, 556, 500, 500, 500, 500, 500, 570, 500, 556, 556, 556, 556, 500,
    556, 500
];
_PdfStandardFontMetricsFactory._timesRomanItalicWidth = [
    250, 333, 420, 500, 500, 833, 778, 214, 333, 333, 500, 675, 250, 333,
    250, 278, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 333, 333, 675, 675,
    675, 500, 920, 611, 611, 667, 722, 611, 611, 722, 722, 333, 444, 667, 556, 833,
    667, 722, 611, 722, 611, 500, 556, 722, 611, 833, 611, 556, 556, 389, 278, 389,
    422, 500, 333, 500, 500, 444, 500, 444, 278, 500, 500, 278, 278, 444, 278, 722,
    500, 500, 500, 500, 389, 389, 278, 500, 444, 667, 444, 444, 389, 400, 275, 400,
    541, 0, 500, 0, 333, 500, 556, 889, 500, 500, 333, 1000, 500, 333, 944, 0,
    556, 0, 0, 333, 333, 556, 556, 350, 500, 889, 333, 980, 389, 333, 667, 0,
    389, 556, 0, 389, 500, 500, 500, 500, 275, 500, 333, 760, 276, 500, 675, 0,
    760, 333, 400, 675, 300, 300, 333, 500, 523, 250, 333, 300, 310, 500, 750, 750,
    750, 500, 611, 611, 611, 611, 611, 611, 889, 667, 611, 611, 611, 611, 333, 333,
    333, 333, 722, 667, 722, 722, 722, 722, 722, 675, 722, 722, 722, 722, 722, 556,
    611, 500, 500, 500, 500, 500, 500, 500, 667, 444, 444, 444, 444, 444, 278, 278,
    278, 278, 500, 500, 500, 500, 500, 500, 500, 675, 500, 500, 500, 500, 500, 444,
    500, 444
];
_PdfStandardFontMetricsFactory._timesRomanBoldItalicWidths = [
    250, 389, 555, 500, 500, 833, 778, 278, 333, 333, 500, 570, 250, 333,
    250, 278, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 333, 333, 570, 570,
    570, 500, 832, 667, 667, 667, 722, 667, 667, 722, 778, 389, 500, 667, 611, 889,
    722, 722, 611, 722, 667, 556, 611, 722, 667, 889, 667, 611, 611, 333, 278, 333,
    570, 500, 333, 500, 500, 444, 500, 444, 333, 500, 556, 278, 278, 500, 278, 778,
    556, 500, 500, 500, 389, 389, 278, 556, 444, 667, 500, 444, 389, 348, 220, 348,
    570, 0, 500, 0, 333, 500, 500, 1000, 500, 500, 333, 1000, 556, 333, 944, 0,
    611, 0, 0, 333, 333, 500, 500, 350, 500, 1000, 333, 1000, 389, 333, 722, 0,
    389, 611, 0, 389, 500, 500, 500, 500, 220, 500, 333, 747, 266, 500, 606, 0,
    747, 333, 400, 570, 300, 300, 333, 576, 500, 250, 333, 300, 300, 500, 750, 750,
    750, 500, 667, 667, 667, 667, 667, 667, 944, 667, 667, 667, 667, 667, 389, 389,
    389, 389, 722, 722, 722, 722, 722, 722, 722, 570, 722, 722, 722, 722, 722, 611,
    611, 500, 500, 500, 500, 500, 500, 500, 722, 444, 444, 444, 444, 444, 278, 278,
    278, 278, 500, 556, 500, 500, 500, 500, 500, 570, 500, 556, 556, 556, 556, 444,
    500, 444
];
_PdfStandardFontMetricsFactory._symbolWidth = [
    250, 333, 713, 500, 549, 833, 778, 439, 333, 333, 500, 549, 250, 549,
    250, 278, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 278, 278,
    549, 549, 549, 444, 549, 722, 667, 722, 612, 611, 763, 603, 722, 333,
    631, 722, 686, 889, 722, 722, 768, 741, 556, 592, 611, 690, 439, 768,
    645, 795, 611, 333, 863, 333, 658, 500, 500, 631, 549, 549, 494, 439,
    521, 411, 603, 329, 603, 549, 549, 576, 521, 549, 549, 521, 549, 603,
    439, 576, 713, 686, 493, 686, 494, 480, 200, 480, 549, 750, 620, 247,
    549, 167, 713, 500, 753, 753, 753, 753, 1042, 987, 603, 987, 603, 400,
    549, 411, 549, 549, 713, 494, 460, 549, 549, 549, 549, 1000, 603, 1000,
    658, 823, 686, 795, 987, 768, 768, 823, 768, 768, 713, 713, 713, 713,
    713, 713, 713, 768, 713, 790, 790, 890, 823, 549, 250, 713, 603, 603,
    1042, 987, 603, 987, 603, 494, 329, 790, 790, 786, 713, 384, 384, 384,
    384, 384, 384, 494, 494, 494, 494, 329, 274, 686, 686, 686, 384, 384,
    384, 384, 384, 384, 494, 494, 494, -1
];
_PdfStandardFontMetricsFactory._zapfDingbatsWidth = [
    278, 974, 961, 974, 980, 719, 789, 790, 791, 690, 960, 939, 549, 855,
    911, 933, 911, 945, 974, 755, 846, 762, 761, 571, 677, 763, 760, 759,
    754, 494, 552, 537, 577, 692, 786, 788, 788, 790, 793, 794, 816, 823,
    789, 841, 823, 833, 816, 831, 923, 744, 723, 749, 790, 792, 695, 776,
    768, 792, 759, 707, 708, 682, 701, 826, 815, 789, 789, 707, 687, 696,
    689, 786, 787, 713, 791, 785, 791, 873, 761, 762, 762, 759, 759, 892,
    892, 788, 784, 438, 138, 277, 415, 392, 392, 668, 668, 390, 390, 317,
    317, 276, 276, 509, 509, 410, 410, 234, 234, 334, 334, 732, 544, 544,
    910, 667, 760, 760, 776, 595, 694, 626, 788, 788, 788, 788, 788, 788,
    788, 788, 788, 788, 788, 788, 788, 788, 788, 788, 788, 788, 788, 788,
    788, 788, 788, 788, 788, 788, 788, 788, 788, 788, 788, 788, 788, 788,
    788, 788, 788, 788, 788, 788, 894, 838, 1016, 458, 748, 924, 748, 918,
    927, 928, 928, 834, 873, 828, 924, 924, 917, 930, 931, 463, 883, 836,
    836, 867, 867, 696, 696, 874, 874, 760, 946, 771, 865, 771, 888, 967,
    888, 831, 873, 927, 970, 918
];
class _PdfCjkStandardFontMetricsFactory {
    static _getHanyangSystemsGothicMedium(fontStyle, size) {
        const metrics = new _PdfFontMetrics();
        const widthTable = new _CjkWidthTable(1000);
        widthTable._add(new _CjkSameWidth(1, 127, 500));
        widthTable._add(new _CjkSameWidth(8094, 8190, 500));
        metrics._widthTable = widthTable;
        metrics._ascent = 880;
        metrics._descent = -120;
        metrics._size = size;
        metrics._height = metrics._ascent - metrics._descent;
        if ((fontStyle & PdfFontStyle.bold) !== 0 && (fontStyle & PdfFontStyle.italic) !== 0) {
            metrics._postScriptName = 'HYGoThic-Medium,BoldItalic';
        }
        else if ((fontStyle & PdfFontStyle.bold) !== 0) {
            metrics._postScriptName = 'HYGoThic-Medium,Bold';
        }
        else if ((fontStyle & PdfFontStyle.italic) !== 0) {
            metrics._postScriptName = 'HYGoThic-Medium,Italic';
        }
        else {
            metrics._postScriptName = 'HYGoThic-Medium';
        }
        return metrics;
    }
    static _getHanyangSystemsShinMyeongJoMedium(fontStyle, size) {
        const metrics = new _PdfFontMetrics();
        const widthTable = new _CjkWidthTable(1000);
        widthTable._add(new _CjkSameWidth(1, 95, 500));
        widthTable._add(new _CjkSameWidth(8094, 8190, 500));
        metrics._widthTable = widthTable;
        metrics._ascent = 880;
        metrics._descent = -120;
        metrics._size = size;
        metrics._height = metrics._ascent - metrics._descent;
        if ((fontStyle & PdfFontStyle.bold) !== 0 && (fontStyle & PdfFontStyle.italic) !== 0) {
            metrics._postScriptName = 'HYSMyeongJo-Medium,BoldItalic';
        }
        else if ((fontStyle & PdfFontStyle.bold) !== 0) {
            metrics._postScriptName = 'HYSMyeongJo-Medium,Bold';
        }
        else if ((fontStyle & PdfFontStyle.italic) !== 0) {
            metrics._postScriptName = 'HYSMyeongJo-Medium,Italic';
        }
        else {
            metrics._postScriptName = 'HYSMyeongJo-Medium';
        }
        return metrics;
    }
    static _getHeiseiKakuGothicW5(fontStyle, size) {
        const metrics = new _PdfFontMetrics();
        const widthTable = new _CjkWidthTable(1000);
        widthTable._add(new _CjkSameWidth(1, 95, 500));
        widthTable._add(new _CjkSameWidth(231, 632, 500));
        metrics._widthTable = widthTable;
        metrics._ascent = 857;
        metrics._descent = -125;
        metrics._size = size;
        metrics._height = metrics._ascent - metrics._descent;
        if ((fontStyle & PdfFontStyle.bold) !== 0 && (fontStyle & PdfFontStyle.italic) !== 0) {
            metrics._postScriptName = 'HeiseiKakuGo-W5,BoldItalic';
        }
        else if ((fontStyle & PdfFontStyle.bold) !== 0) {
            metrics._postScriptName = 'HeiseiKakuGo-W5,Bold';
        }
        else if ((fontStyle & PdfFontStyle.italic) !== 0) {
            metrics._postScriptName = 'HeiseiKakuGo-W5,Italic';
        }
        else {
            metrics._postScriptName = 'HeiseiKakuGo-W5';
        }
        return metrics;
    }
    static _getHeiseiMinchoW3(fontStyle, size) {
        const metrics = new _PdfFontMetrics();
        const widthTable = new _CjkWidthTable(1000);
        widthTable._add(new _CjkSameWidth(1, 95, 500));
        widthTable._add(new _CjkSameWidth(231, 632, 500));
        metrics._widthTable = widthTable;
        metrics._ascent = 857;
        metrics._descent = -143;
        metrics._size = size;
        metrics._height = metrics._ascent - metrics._descent;
        if ((fontStyle & PdfFontStyle.bold) !== 0 && (fontStyle & PdfFontStyle.italic) !== 0) {
            metrics._postScriptName = 'HeiseiMin-W3,BoldItalic';
        }
        else if ((fontStyle & PdfFontStyle.bold) !== 0) {
            metrics._postScriptName = 'HeiseiMin-W3,Bold';
        }
        else if ((fontStyle & PdfFontStyle.italic) !== 0) {
            metrics._postScriptName = 'HeiseiMin-W3,Italic';
        }
        else {
            metrics._postScriptName = 'HeiseiMin-W3';
        }
        return metrics;
    }
    static _getMonotypeHeiMedium(fontStyle, size) {
        const metrics = new _PdfFontMetrics();
        const widthTable = new _CjkWidthTable(1000);
        widthTable._add(new _CjkSameWidth(1, 95, 500));
        widthTable._add(new _CjkSameWidth(13648, 13742, 500));
        metrics._widthTable = widthTable;
        metrics._ascent = 880;
        metrics._descent = -120;
        metrics._size = size;
        metrics._height = metrics._ascent - metrics._descent;
        if ((fontStyle & PdfFontStyle.bold) !== 0 && (fontStyle & PdfFontStyle.italic) !== 0) {
            metrics._postScriptName = 'MHei-Medium,BoldItalic';
        }
        else if ((fontStyle & PdfFontStyle.bold) !== 0) {
            metrics._postScriptName = 'MHei-Medium,Bold';
        }
        else if ((fontStyle & PdfFontStyle.italic) !== 0) {
            metrics._postScriptName = 'MHei-Medium,Italic';
        }
        else {
            metrics._postScriptName = 'MHei-Medium';
        }
        return metrics;
    }
    static _getMonotypeSungLight(fontStyle, size) {
        const metrics = new _PdfFontMetrics();
        const widthTable = new _CjkWidthTable(1000);
        widthTable._add(new _CjkSameWidth(1, 95, 500));
        widthTable._add(new _CjkSameWidth(13648, 13742, 500));
        metrics._widthTable = widthTable;
        metrics._ascent = 880;
        metrics._descent = -120;
        metrics._size = size;
        metrics._height = metrics._ascent - metrics._descent;
        if ((fontStyle & PdfFontStyle.bold) !== 0 && (fontStyle & PdfFontStyle.italic) !== 0) {
            metrics._postScriptName = 'MSung-Light,BoldItalic';
        }
        else if ((fontStyle & PdfFontStyle.bold) !== 0) {
            metrics._postScriptName = 'MSung-Light,Bold';
        }
        else if ((fontStyle & PdfFontStyle.italic) !== 0) {
            metrics._postScriptName = 'MSung-Light,Italic';
        }
        else {
            metrics._postScriptName = 'MSung-Light';
        }
        return metrics;
    }
    static _getSinoTypeSongLight(fontStyle, size) {
        const metrics = new _PdfFontMetrics();
        const widthTable = new _CjkWidthTable(1000);
        widthTable._add(new _CjkSameWidth(1, 95, 500));
        widthTable._add(new _CjkSameWidth(814, 939, 500));
        widthTable._add(new _CjkDifferentWidth(7712, [500]));
        widthTable._add(new _CjkDifferentWidth(7716, [500]));
        metrics._ascent = 880;
        metrics._descent = -120;
        metrics._size = size;
        metrics._height = metrics._ascent - metrics._descent;
        if ((fontStyle & PdfFontStyle.bold) !== 0 && (fontStyle & PdfFontStyle.italic) !== 0) {
            metrics._postScriptName = 'STSong-Light,BoldItalic';
        }
        else if ((fontStyle & PdfFontStyle.bold) !== 0) {
            metrics._postScriptName = 'STSong-Light,Bold';
        }
        else if ((fontStyle & PdfFontStyle.italic) !== 0) {
            metrics._postScriptName = 'STSong-Light,Italic';
        }
        else {
            metrics._postScriptName = 'STSong-Light';
        }
        metrics._widthTable = widthTable;
        return metrics;
    }
    static _getMetrics(fontFamily, fontStyle, size) {
        let metrics;
        switch (fontFamily) {
            case PdfCjkFontFamily.hanyangSystemsGothicMedium:
                metrics = this._getHanyangSystemsGothicMedium(fontStyle, size);
                metrics._name = 'HanyangSystemsGothicMedium';
                break;
            case PdfCjkFontFamily.hanyangSystemsShinMyeongJoMedium:
                metrics = this._getHanyangSystemsShinMyeongJoMedium(fontStyle, size);
                metrics._name = 'HanyangSystemsShinMyeongJoMedium';
                break;
            case PdfCjkFontFamily.heiseiKakuGothicW5:
                metrics = this._getHeiseiKakuGothicW5(fontStyle, size);
                metrics._name = 'HeiseiKakuGothicW5';
                break;
            case PdfCjkFontFamily.heiseiMinchoW3:
                metrics = this._getHeiseiMinchoW3(fontStyle, size);
                metrics._name = 'HeiseiMinchoW3';
                break;
            case PdfCjkFontFamily.monotypeHeiMedium:
                metrics = this._getMonotypeHeiMedium(fontStyle, size);
                metrics._name = 'MonotypeHeiMedium';
                break;
            case PdfCjkFontFamily.monotypeSungLight:
                metrics = this._getMonotypeSungLight(fontStyle, size);
                metrics._name = 'MonotypeSungLight';
                break;
            case PdfCjkFontFamily.sinoTypeSongLight:
                metrics = this._getSinoTypeSongLight(fontStyle, size);
                metrics._name = 'SinoTypeSongLight';
                break;
        }
        metrics._subScriptSizeFactor = this._subSuperScriptFactor;
        metrics._superscriptSizeFactor = this._subSuperScriptFactor;
        return metrics;
    }
}
_PdfCjkStandardFontMetricsFactory._subSuperScriptFactor = 1.52;
class _PdfCjkFontDescriptorFactory {
    static _fillMonotypeSungLight(fontDescriptor, fontFamily, fontMetrics) {
        const fontBox = { x: -160, y: -249, width: 1175, height: 1137 };
        this._fillFontBox(fontDescriptor, fontBox);
        this._fillKnownInformation(fontDescriptor, fontFamily, fontMetrics);
        fontDescriptor.set('StemV', 93);
        fontDescriptor.set('StemH', 93);
        fontDescriptor.set('AvgWidth', 1000);
        fontDescriptor.set('MaxWidth', 1000);
        fontDescriptor.set('CapHeight', 880);
        fontDescriptor.set('XHeight', 616);
        fontDescriptor.set('Leading', 250);
    }
    static _fillHeiseiKakuGothicW5(fontDescriptor, fontStyle, fontFamily, fontMetrics) {
        const fontBox = { x: -92, y: -250, width: 1102, height: 1172 };
        const fontBoxItalic = { x: -92, y: -250, width: 1102, height: 1932 };
        if ((fontStyle & (PdfFontStyle.italic | PdfFontStyle.bold)) !== PdfFontStyle.italic) {
            this._fillFontBox(fontDescriptor, fontBox);
        }
        else {
            this._fillFontBox(fontDescriptor, fontBoxItalic);
        }
        this._fillKnownInformation(fontDescriptor, fontFamily, fontMetrics);
        fontDescriptor.set('StemV', 93);
        fontDescriptor.set('StemH', 93);
        fontDescriptor.set('AvgWidth', 689);
        fontDescriptor.set('MaxWidth', 1000);
        fontDescriptor.set('CapHeight', 718);
        fontDescriptor.set('XHeight', 500);
        fontDescriptor.set('Leading', 250);
    }
    static _fillHanyangSystemsShinMyeongJoMedium(fontDescriptor, fontFamily, fontMetrics) {
        const fontBox = { x: 0, y: -148, width: 1001, height: 1028 };
        this._fillFontBox(fontDescriptor, fontBox);
        this._fillKnownInformation(fontDescriptor, fontFamily, fontMetrics);
        fontDescriptor.set('StemV', 93);
        fontDescriptor.set('StemH', 93);
        fontDescriptor.set('AvgWidth', 1000);
        fontDescriptor.set('MaxWidth', 1000);
        fontDescriptor.set('CapHeight', 880);
        fontDescriptor.set('XHeight', 616);
        fontDescriptor.set('Leading', 250);
    }
    static _fillHeiseiMinchoW3(fontDescriptor, fontFamily, fontMetrics) {
        const fontBox = { x: -123, y: -257, width: 1124, height: 1167 };
        this._fillFontBox(fontDescriptor, fontBox);
        this._fillKnownInformation(fontDescriptor, fontFamily, fontMetrics);
        fontDescriptor.set('StemV', 93);
        fontDescriptor.set('StemH', 93);
        fontDescriptor.set('AvgWidth', 702);
        fontDescriptor.set('MaxWidth', 1000);
        fontDescriptor.set('CapHeight', 718);
        fontDescriptor.set('XHeight', 500);
        fontDescriptor.set('Leading', 250);
    }
    static _fillSinoTypeSongLight(fontDescriptor, fontFamily, fontMetrics) {
        const fontBox = { x: -25, y: -254, width: 1025, height: 1134 };
        this._fillFontBox(fontDescriptor, fontBox);
        this._fillKnownInformation(fontDescriptor, fontFamily, fontMetrics);
        fontDescriptor.set('StemV', 93);
        fontDescriptor.set('StemH', 93);
        fontDescriptor.set('AvgWidth', 1000);
        fontDescriptor.set('MaxWidth', 1000);
        fontDescriptor.set('CapHeight', 880);
        fontDescriptor.set('XHeight', 616);
        fontDescriptor.set('Leading', 250);
    }
    static _fillMonotypeHeiMedium(fontDescriptor, fontFamily, fontMetrics) {
        const fontBox = { x: -45, y: -250, width: 1060, height: 1137 };
        this._fillFontBox(fontDescriptor, fontBox);
        this._fillKnownInformation(fontDescriptor, fontFamily, fontMetrics);
        fontDescriptor.set('StemV', 93);
        fontDescriptor.set('StemH', 93);
        fontDescriptor.set('AvgWidth', 1000);
        fontDescriptor.set('MaxWidth', 1000);
        fontDescriptor.set('CapHeight', 880);
        fontDescriptor.set('XHeight', 616);
        fontDescriptor.set('Leading', 250);
    }
    static _fillHanyangSystemsGothicMedium(fontDescriptor, fontFamily, fontMetrics) {
        const fontBox = { x: -6, y: -145, width: 1009, height: 1025 };
        this._fillFontBox(fontDescriptor, fontBox);
        this._fillKnownInformation(fontDescriptor, fontFamily, fontMetrics);
        fontDescriptor.set('Flags', 4);
        fontDescriptor.set('StemV', 93);
        fontDescriptor.set('StemH', 93);
        fontDescriptor.set('AvgWidth', 1000);
        fontDescriptor.set('MaxWidth', 1000);
        fontDescriptor.set('CapHeight', 880);
        fontDescriptor.set('XHeight', 616);
        fontDescriptor.set('Leading', 250);
    }
    static _fillFontBox(fontDescriptor, fontBox) {
        fontDescriptor.set('FontBBox', _fromRectangle(fontBox));
    }
    static _fillKnownInformation(fontDescriptor, fontFamily, fontMetrics) {
        fontDescriptor.set('FontName', _PdfName.get(fontMetrics._postScriptName));
        fontDescriptor.set('Type', _PdfName.get('FontDescriptor'));
        fontDescriptor.set('ItalicAngle', 0);
        fontDescriptor.set('MissingWidth', fontMetrics._widthTable._defaultWidth);
        fontDescriptor.set('Ascent', fontMetrics._ascent);
        fontDescriptor.set('Descent', fontMetrics._descent);
        switch (fontFamily) {
            case PdfCjkFontFamily.monotypeHeiMedium:
            case PdfCjkFontFamily.hanyangSystemsGothicMedium:
            case PdfCjkFontFamily.heiseiKakuGothicW5:
                fontDescriptor.set('Flags', 4);
                break;
            case PdfCjkFontFamily.sinoTypeSongLight:
            case PdfCjkFontFamily.monotypeSungLight:
            case PdfCjkFontFamily.hanyangSystemsShinMyeongJoMedium:
            case PdfCjkFontFamily.heiseiMinchoW3:
                fontDescriptor.set('Flags', 6);
                break;
        }
    }
    static _getFontDescriptor(fontFamily, fontStyle, fontMetrics) {
        const fontDescriptor = new _PdfDictionary();
        fontDescriptor._updated = true;
        switch (fontFamily) {
            case PdfCjkFontFamily.hanyangSystemsGothicMedium:
                this._fillHanyangSystemsGothicMedium(fontDescriptor, fontFamily, fontMetrics);
                break;
            case PdfCjkFontFamily.hanyangSystemsShinMyeongJoMedium:
                this._fillHanyangSystemsShinMyeongJoMedium(fontDescriptor, fontFamily, fontMetrics);
                break;
            case PdfCjkFontFamily.heiseiKakuGothicW5:
                this._fillHeiseiKakuGothicW5(fontDescriptor, fontStyle, fontFamily, fontMetrics);
                break;
            case PdfCjkFontFamily.heiseiMinchoW3:
                this._fillHeiseiMinchoW3(fontDescriptor, fontFamily, fontMetrics);
                break;
            case PdfCjkFontFamily.monotypeHeiMedium:
                this._fillMonotypeHeiMedium(fontDescriptor, fontFamily, fontMetrics);
                break;
            case PdfCjkFontFamily.monotypeSungLight:
                this._fillMonotypeSungLight(fontDescriptor, fontFamily, fontMetrics);
                break;
            case PdfCjkFontFamily.sinoTypeSongLight:
                this._fillSinoTypeSongLight(fontDescriptor, fontFamily, fontMetrics);
                break;
            default:
                break;
        }
        return fontDescriptor;
    }
}
/**
 * Public enum to define font style.
 * ```typescript
 * // Load an existing PDF document
 * let document: PdfDocument = new PdfDocument(data, password);
 * // Gets the first page
 * let page: PdfPage = document.getPage(0) as PdfPage;
 * // Create a new PDF standard font
 * let font: PdfStandardFont = new PdfStandardFont(PdfFontFamily.Helvetica, 10, PdfFontStyle.regular);
 * // Create a new PDF string format
 * let format: PdfStringFormat = new PdfStringFormat(PdfTextAlignment.right, PdfVerticalAlignment.bottom);
 * // Draw the text
 * page.graphics.drawString('Helvetica', font, [0, 180, page.size[0], 40], undefined, new PdfBrush([0, 0, 255]), format);
 * // Save the document
 * document.save('output.pdf');
 * // Destroy the document
 * document.destroy();
 * ```
 */
var PdfFontStyle;
(function (PdfFontStyle) {
    /**
     * Specifies the font style `regular`.
     */
    PdfFontStyle[PdfFontStyle["regular"] = 0] = "regular";
    /**
     * Specifies the font style `bold`.
     */
    PdfFontStyle[PdfFontStyle["bold"] = 1] = "bold";
    /**
     * Specifies the font style `italic`.
     */
    PdfFontStyle[PdfFontStyle["italic"] = 2] = "italic";
    /**
     * Specifies the font style `underline`.
     */
    PdfFontStyle[PdfFontStyle["underline"] = 4] = "underline";
    /**
     * Specifies the font style `strikeout`.
     */
    PdfFontStyle[PdfFontStyle["strikeout"] = 8] = "strikeout";
})(PdfFontStyle || (PdfFontStyle = {}));
/**
 * Public enum to define font family.
 * ```typescript
 * // Load an existing PDF document
 * let document: PdfDocument = new PdfDocument(data, password);
 * // Gets the first page
 * let page: PdfPage = document.getPage(0) as PdfPage;
 * // Create a new PDF standard font
 * let font: PdfStandardFont = new PdfStandardFont(PdfFontFamily.Helvetica, 10, PdfFontStyle.regular);
 * // Create a new PDF string format
 * let format: PdfStringFormat = new PdfStringFormat(PdfTextAlignment.right, PdfVerticalAlignment.bottom);
 * // Draw the text
 * page.graphics.drawString('Helvetica', font, [0, 180, page.size[0], 40], undefined, new PdfBrush([0, 0, 255]), format);
 * // Save the document
 * document.save('output.pdf');
 * // Destroy the document
 * document.destroy();
 * ```
 */
var PdfFontFamily;
(function (PdfFontFamily) {
    /**
     * Specifies the `helvetica` font family.
     */
    PdfFontFamily[PdfFontFamily["helvetica"] = 0] = "helvetica";
    /**
     * Specifies the `courier` font family.
     */
    PdfFontFamily[PdfFontFamily["courier"] = 1] = "courier";
    /**
     * Specifies the `timesRoman` font family.
     */
    PdfFontFamily[PdfFontFamily["timesRoman"] = 2] = "timesRoman";
    /**
     * Specifies the `symbol` font family.
     */
    PdfFontFamily[PdfFontFamily["symbol"] = 3] = "symbol";
    /**
     * Specifies the `zapfDingbats` font family.
     */
    PdfFontFamily[PdfFontFamily["zapfDingbats"] = 4] = "zapfDingbats";
})(PdfFontFamily || (PdfFontFamily = {}));
/**
 * Public enum to define CJK font family.
 * ```typescript
 * // Load an existing PDF document
 * let document: PdfDocument = new PdfDocument(data, password);
 * // Gets the first page
 * let page: PdfPage = document.getPage(0) as PdfPage;
 * // Create a new PDF CJK standard font
 * let font: PdfCjkStandardFont = new PdfCjkStandardFont(PdfCjkFontFamily.heiseiMinchoW3, 20);
 * // Create a new PDF string format
 * let format: PdfStringFormat = new PdfStringFormat(PdfTextAlignment.right, PdfVerticalAlignment.bottom);
 * // Draw the text
 * page.graphics.drawString('こんにちは世界', font, [0, 180, page.size[0], 40], undefined, new PdfBrush([0, 0, 255]), format);
 * // Save the document
 * document.save('output.pdf');
 * // Destroy the document
 * document.destroy();
 * ```
 */
var PdfCjkFontFamily;
(function (PdfCjkFontFamily) {
    /**
     * Specifies the `heiseiKakuGothicW5` CJK font family.
     */
    PdfCjkFontFamily[PdfCjkFontFamily["heiseiKakuGothicW5"] = 0] = "heiseiKakuGothicW5";
    /**
     * Specifies the `heiseiMinchoW3` CJK font family.
     */
    PdfCjkFontFamily[PdfCjkFontFamily["heiseiMinchoW3"] = 1] = "heiseiMinchoW3";
    /**
     * Specifies the `hanyangSystemsGothicMedium` CJK font family.
     */
    PdfCjkFontFamily[PdfCjkFontFamily["hanyangSystemsGothicMedium"] = 2] = "hanyangSystemsGothicMedium";
    /**
     * Specifies the `hanyangSystemsShinMyeongJoMedium` CJK font family.
     */
    PdfCjkFontFamily[PdfCjkFontFamily["hanyangSystemsShinMyeongJoMedium"] = 3] = "hanyangSystemsShinMyeongJoMedium";
    /**
     * Specifies the `monotypeHeiMedium` CJK font family.
     */
    PdfCjkFontFamily[PdfCjkFontFamily["monotypeHeiMedium"] = 4] = "monotypeHeiMedium";
    /**
     * Specifies the `monotypeSungLight` CJK font family.
     */
    PdfCjkFontFamily[PdfCjkFontFamily["monotypeSungLight"] = 5] = "monotypeSungLight";
    /**
     * Specifies the `sinoTypeSongLight` CJK font family.
     */
    PdfCjkFontFamily[PdfCjkFontFamily["sinoTypeSongLight"] = 6] = "sinoTypeSongLight";
})(PdfCjkFontFamily || (PdfCjkFontFamily = {}));
class _UnicodeLine {
    constructor() {
        this._result = false;
        this._glyphIndex = [];
    }
}

class _PdfPath {
    constructor() {
        this._isRoundedRectangle = false;
        this._fillMode = PdfFillMode.winding;
        this._points = [];
        this._pathTypes = [];
        this._isStart = true;
    }
    get _lastPoint() {
        const value = [0, 0];
        const count = this._points.length;
        if (this._points.length > 0) {
            value[0] = this._points[(count - 1)][0];
            value[1] = this._points[(count - 1)][0];
        }
        return value;
    }
    _addLine(x1, y1, x2, y2) {
        this._addPoints([x1, y1, x2, y2], _PathPointType.line);
    }
    _addLines(linePoints) {
        let start = linePoints[0];
        if (linePoints.length === 1) {
            this._addPoint(linePoints[0], _PathPointType.line);
        }
        else {
            for (let i = 1; i < linePoints.length; i++) {
                const last = linePoints[Number.parseInt(i.toString(), 10)];
                this._addLine(start[0], start[1], last[0], last[1]);
                start = last;
            }
        }
    }
    _addPoints(points, type, start, end) {
        const startIndex = (typeof start !== 'undefined') ? start : 0;
        const endIndex = (typeof end !== 'undefined') ? end : points.length;
        for (let i = startIndex; i < endIndex; i++) {
            const point = [points[Number.parseInt(i.toString(), 10)], points[i + 1]];
            if (i === startIndex) {
                if (this._points.length === 0 || this._isStart) {
                    this._addPoint(point, _PathPointType.start);
                    this._isStart = false;
                }
                else if (this._isRoundedRectangle && (point[0] !== this._lastPoint[0] || point[1] !== this._lastPoint[1])) {
                    this._addPoint(point, _PathPointType.line);
                }
                else if (point[0] !== this._lastPoint[0] && point[1] !== this._lastPoint[1]) {
                    this._addPoint(point, _PathPointType.line);
                }
            }
            else {
                this._addPoint(point, type);
            }
            i++;
        }
    }
    _addPoint(points, type) {
        this._points.push(points);
        this._pathTypes.push(type);
    }
    _addArc(x, y, width, height, startAngle, sweepAngle) {
        const points = _getBezierArc(x, y, x + width, y + height, startAngle, sweepAngle);
        for (let i = 0; i < points.length; ++i) {
            const list = [points[Number.parseInt(i.toString(), 10)],
                points[++i],
                points[++i],
                points[++i],
                points[++i],
                points[++i],
                points[++i],
                points[++i]];
            this._addPoints(list, _PathPointType.bezier);
        }
    }
    _addRectangle(x, y, width, height) {
        this._startFigure();
        this._addPoints([x, y, x + width, y, x + width, y + height, x, y + height], _PathPointType.line);
        this._closeFigure();
    }
    _addPolygon(points) {
        const newPoints = [];
        points.forEach((element) => {
            newPoints.push(element[0], element[1]);
        });
        this._startFigure();
        this._addPoints(newPoints, _PathPointType.line);
        this._closeFigure();
    }
    _addEllipse(x, y, width, height) {
        this._startFigure();
        this._addArc(x, y, width, height, 0, 360);
        this._closeFigure();
    }
    _addBezierPoints(pointsCollection) {
        if (pointsCollection.length < 4) {
            throw Error('Incorrect size of array points');
        }
        const bound = 3;
        let index = 0;
        let start = pointsCollection[Number.parseInt(index.toString(), 10)];
        index++;
        while ((index + bound) <= pointsCollection.length) {
            const inner1 = pointsCollection[Number.parseInt(index.toString(), 10)];
            index++;
            const inner2 = pointsCollection[Number.parseInt(index.toString(), 10)];
            index++;
            const end = pointsCollection[Number.parseInt(index.toString(), 10)];
            index++;
            this._addBezier(start[0], start[1], inner1[0], inner1[1], inner2[0], inner2[1], end[0], end[1]);
            start = end;
        }
    }
    _addBezier(x, y, firstX, firstY, secondX, secondY, endX, endY) {
        const points = [];
        points.push(x);
        points.push(y);
        points.push(firstX);
        points.push(firstY);
        points.push(secondX);
        points.push(secondY);
        points.push(endX);
        points.push(endY);
        this._addPoints(points, _PathPointType.bezier);
    }
    _closeFigure(index) {
        if (typeof index !== 'undefined') {
            let type = this._pathTypes[Number.parseInt(index.toString(), 10)];
            type |= _PathPointType.closePath;
            this._pathTypes[Number.parseInt(index.toString(), 10)] = type;
        }
        else {
            if (this._points.length > 0) {
                this._closeFigure(this._points.length - 1);
            }
            this._startFigure();
        }
    }
    _startFigure() {
        this._isStart = true;
    }
    _getBounds() {
        let bounds = [0, 0, 0, 0];
        if (this._points.length > 0) {
            let xmin = this._points[0][0];
            let xmax = this._points[0][0];
            let ymin = this._points[0][1];
            let ymax = this._points[0][1];
            for (let i = 1; i < this._points.length; ++i) {
                const point = this._points[Number.parseInt(i.toString(), 10)];
                xmin = Math.min(point[0], xmin);
                xmax = Math.max(point[0], xmax);
                ymin = Math.min(point[1], ymin);
                ymax = Math.max(point[1], ymax);
            }
            bounds = [xmin, ymin, xmax - xmin, ymax - ymin];
        }
        return bounds;
    }
}
var _PathPointType;
(function (_PathPointType) {
    _PathPointType[_PathPointType["start"] = 0] = "start";
    _PathPointType[_PathPointType["line"] = 1] = "line";
    _PathPointType[_PathPointType["bezier"] = 3] = "bezier";
    _PathPointType[_PathPointType["pathTypeMask"] = 7] = "pathTypeMask";
    _PathPointType[_PathPointType["dashMode"] = 16] = "dashMode";
    _PathPointType[_PathPointType["pathMarker"] = 32] = "pathMarker";
    _PathPointType[_PathPointType["closePath"] = 128] = "closePath";
})(_PathPointType || (_PathPointType = {}));

/**
 * `PdfField` class represents the base class for form field objects.
 * ```typescript
 * // Load an existing PDF document
 * let document: PdfDocument = new PdfDocument(data, password);
 * // Access the form field at index 0
 * let field: PdfField = document.form.fieldAt(0);
 * // Gets the count of the loaded field items
 * let count: number = field.itemsCount;
 * // Save the document
 * document.save('output.pdf');
 * // Destroy the document
 * document.destroy();
 * ```
 */
class PdfField {
    constructor() {
        this._visible = true;
        this._isTransparentBackColor = false;
        this._defaultFont = new PdfStandardFont(PdfFontFamily.helvetica, 8);
        this._appearanceFont = new PdfStandardFont(PdfFontFamily.helvetica, 10, PdfFontStyle.regular);
        this._defaultItemFont = new PdfStandardFont(PdfFontFamily.timesRoman, 12);
        this._flatten = false;
        this._hasData = false;
        this._circleCaptionFont = new PdfStandardFont(PdfFontFamily.helvetica, 8, PdfFontStyle.regular);
    }
    /**
     * Gets the count of the loaded field items (Read only).
     *
     * @returns {number} Items count.
     * ```typescript
     * // Load an existing PDF document
     * let document: PdfDocument = new PdfDocument(data, password);
     * // Access the form field at index 0
     * let field: PdfField = document.form.fieldAt(0);
     * // Gets the count of the loaded field items
     * let count: number = field.itemsCount;
     * // Save the document
     * document.save('output.pdf');
     * // Destroy the document
     * document.destroy();
     * ```
     */
    get itemsCount() {
        return this._kids ? this._kids.length : 0;
    }
    /**
     * Gets the form object of the field (Read only).
     *
     * @returns {PdfForm} Form.
     * ```typescript
     * // Load an existing PDF document
     * let document: PdfDocument = new PdfDocument(data, password);
     * // Access the form field at index 0
     * let field: PdfField = document.form.fieldAt(0);
     * // Gets the form object of the field
     * let form: PdfForm = field.form;
     * // Save the document
     * document.save('output.pdf');
     * // Destroy the document
     * document.destroy();
     * ```
     */
    get form() {
        return this._form;
    }
    /**
     * Gets the name of the field (Read only).
     *
     * @returns {string} Field name.
     * ```typescript
     * // Load an existing PDF document
     * let document: PdfDocument = new PdfDocument(data, password);
     * // Access the form field at index 0
     * let field: PdfField = document.form.fieldAt(0);
     * // Gets the name of the field
     * let name: string = field.name;
     * // Save the document
     * document.save('output.pdf');
     * // Destroy the document
     * document.destroy();
     * ```
     */
    get name() {
        if (typeof this._name === 'undefined') {
            const names = _getInheritableProperty(this._dictionary, 'T', false, false, 'Parent');
            if (names && names.length > 0) {
                if (names.length === 1) {
                    this._name = names[0];
                }
                else {
                    this._name = names.join('.');
                }
            }
        }
        return this._name;
    }
    /**
     * Gets the actual name of the field (Read only).
     *
     * @private
     * @returns {string} Actual name.
     * ```typescript
     * // Load an existing PDF document
     * let document: PdfDocument = new PdfDocument(data, password);
     * // Access the form field at index 0
     * let field: PdfField = document.form.fieldAt(0);
     * // Gets the actual name of the field
     * let name: string = field.actualName;
     * // Save the document
     * document.save('output.pdf');
     * // Destroy the document
     * document.destroy();
     * ```
     */
    get actualName() {
        if (typeof this._actualName === 'undefined' && this._dictionary.has('T')) {
            const name = this._dictionary.get('T');
            if (name && typeof name === 'string') {
                this._actualName = name;
            }
        }
        return this._actualName;
    }
    /**
     * Gets the mapping name to be used when exporting interactive form field data from the document.
     *
     * @returns {string} Mapping name.
     * ```typescript
     * // Load an existing PDF document
     * let document: PdfDocument = new PdfDocument(data, password);
     * // Access the form field at index 0
     * let field: PdfField = document.form.fieldAt(0);
     * // Gets the mapping name of the field
     * let name: string = field.mappingName;
     * // Save the document
     * document.save('output.pdf');
     * // Destroy the document
     * document.destroy();
     * ```
     */
    get mappingName() {
        if (typeof this._mappingName === 'undefined' && this._dictionary.has('TM')) {
            const name = this._dictionary.get('TM');
            if (name && typeof name === 'string') {
                this._mappingName = name;
            }
        }
        return this._mappingName;
    }
    /**
     * Sets the mapping name to be used when exporting interactive form field data from the document.
     *
     * @param {string} value Mapping name.
     * ```typescript
     * // Load an existing PDF document
     * let document: PdfDocument = new PdfDocument(data, password);
     * // Access the form field at index 0
     * let field: PdfField = document.form.fieldAt(0);
     * // Sets the mapping name of the field
     * field.mappingName = ‘Author’;
     * // Save the document
     * document.save('output.pdf');
     * // Destroy the document
     * document.destroy();
     * ```
     */
    set mappingName(value) {
        if (typeof this.mappingName === 'undefined' || this._mappingName !== value) {
            this._mappingName = value;
            this._dictionary.update('TM', value);
        }
    }
    /**
     * Gets the tool tip of the form field.
     *
     * @returns {string} Tooltip.
     * ```typescript
     * // Load an existing PDF document
     * let document: PdfDocument = new PdfDocument(data, password);
     * // Access the form field at index 0
     * let field: PdfField = document.form.fieldAt(0);
     * // Gets the tool tip value of the field
     * let toolTip: string = field.toolTip;
     * // Save the document
     * document.save('output.pdf');
     * // Destroy the document
     * document.destroy();
     * ```
     */
    get toolTip() {
        if (typeof this._alternateName === 'undefined' && this._dictionary.has('TU')) {
            const name = this._dictionary.get('TU');
            if (name && typeof name === 'string') {
                this._alternateName = name;
            }
        }
        return this._alternateName;
    }
    /**
     * Sets the tool tip of the form field.
     *
     * @param {string} value Tooltip.
     * ```typescript
     * // Load an existing PDF document
     * let document: PdfDocument = new PdfDocument(data, password);
     * // Access the form field at index 0
     * let field: PdfField = document.form.fieldAt(0);
     * // Sets the tool tip value of the field
     * field.toolTip = ‘Author of the document’;
     * // Save the document
     * document.save('output.pdf');
     * // Destroy the document
     * document.destroy();
     * ```
     */
    set toolTip(value) {
        if (typeof this.toolTip === 'undefined' || this._alternateName !== value) {
            this._alternateName = value;
            this._dictionary.update('TU', value);
        }
    }
    /**
     * Gets the form field visibility.
     *
     * @returns {PdfFormFieldVisibility} Field visibility option.
     * ```typescript
     * // Load an existing PDF document
     * let document: PdfDocument = new PdfDocument(data, password);
     * // Access the form field at index 0
     * let field: PdfField = document.form.fieldAt(0);
     * // Gets the form field visibility.
     * let visibility: PdfFormFieldVisibility = field.visibility;
     * // Save the document
     * document.save('output.pdf');
     * // Destroy the document
     * document.destroy();
     * ```
     */
    get visibility() {
        let value;
        if (this._isLoaded) {
            value = PdfFormFieldVisibility.visible;
            const widget = this.itemAt(this._defaultIndex);
            let flag = PdfAnnotationFlag.default;
            if (widget && widget._hasFlags) {
                flag = widget.flags;
            }
            else if (this._dictionary.has('F')) {
                flag = this._dictionary.get('F');
            }
            else {
                return PdfFormFieldVisibility.visibleNotPrintable;
            }
            let flagValue = 3;
            if ((flag & PdfAnnotationFlag.hidden) === PdfAnnotationFlag.hidden) {
                flagValue = 0;
            }
            if ((flag & PdfAnnotationFlag.noView) === PdfAnnotationFlag.noView) {
                flagValue = 1;
            }
            if ((flag & PdfAnnotationFlag.print) !== PdfAnnotationFlag.print) {
                flagValue &= 2;
            }
            switch (flagValue) {
                case 0:
                    value = PdfFormFieldVisibility.hidden;
                    break;
                case 1:
                    value = PdfFormFieldVisibility.hiddenPrintable;
                    break;
                case 2:
                    value = PdfFormFieldVisibility.visibleNotPrintable;
                    break;
                case 3:
                    value = PdfFormFieldVisibility.visible;
                    break;
            }
        }
        else {
            if (typeof this._visibility === 'undefined') {
                this._visibility = PdfFormFieldVisibility.visible;
            }
            value = this._visibility;
        }
        return value;
    }
    /**
     * Sets the form field visibility.
     *
     * @param {PdfFormFieldVisibility} value visibility.
     * ```typescript
     * // Load an existing PDF document
     * let document: PdfDocument = new PdfDocument(data, password);
     * // Access the form field at index 0
     * let field: PdfField = document.form.fieldAt(0);
     * // Sets the form field visibility.
     * field.visibility = PdfFormFieldVisibility.visible;
     * // Save the document
     * document.save('output.pdf');
     * // Destroy the document
     * document.destroy();
     * ```
     */
    set visibility(value) {
        const widget = this.itemAt(this._defaultIndex);
        if (this._isLoaded) {
            if (widget && (!widget._hasFlags || this.visibility !== value)) {
                _updateVisibility(widget._dictionary, value);
                this._dictionary._updated = true;
            }
            else if (!this._dictionary.has('F') || this.visibility !== value) {
                _updateVisibility(this._dictionary, value);
                this._dictionary._updated = true;
            }
        }
        else {
            if (this.visibility !== value) {
                this._visibility = value;
                switch (value) {
                    case PdfFormFieldVisibility.hidden:
                        widget.flags = PdfAnnotationFlag.hidden;
                        break;
                    case PdfFormFieldVisibility.hiddenPrintable:
                        widget.flags = (PdfAnnotationFlag.noView | PdfAnnotationFlag.print);
                        break;
                    case PdfFormFieldVisibility.visible:
                        widget.flags = PdfAnnotationFlag.print;
                        break;
                    case PdfFormFieldVisibility.visibleNotPrintable:
                        widget.flags = PdfAnnotationFlag.default;
                        break;
                }
            }
        }
    }
    /**
     * Gets the bounds.
     *
     * @returns {{ x: number, y: number, width: number, height: number }} Bounds.
     * ```typescript
     * // Load an existing PDF document
     * let document: PdfDocument = new PdfDocument(data, password);
     * // Access the form field at index 0
     * let field: PdfField = document.form.fieldAt(0);
     * // Gets the bounds of list box field.
     * let bounds: {x: number, y: number, width: number, height: number} = field.bounds;
     * // Save the document
     * document.save('output.pdf');
     * // Destroy the document
     * document.destroy();
     * ```
     */
    get bounds() {
        let value;
        const widget = this.itemAt(this._defaultIndex);
        if (widget) {
            widget._page = this.page;
        }
        if (widget && widget.bounds) {
            value = widget.bounds;
        }
        else if (this._dictionary.has('Rect')) {
            value = _calculateBounds(this._dictionary, this.page);
        }
        if (typeof value === 'undefined' || value === null) {
            value = { x: 0, y: 0, width: 0, height: 0 };
        }
        return value;
    }
    /**
     * Sets the bounds.
     *
     * @param {{ x: number, y: number, width: number, height: number }} value bounds.
     * ```typescript
     * // Load an existing PDF document
     * let document: PdfDocument = new PdfDocument(data, password);
     * // Access the form field at index 0
     * let field: PdfField = document.form.fieldAt(0);
     * // Sets the bounds.
     * field.bounds = {x: 10, y: 10, width: 100, height: 20};
     * // Save the document
     * document.save('output.pdf');
     * // Destroy the document
     * document.destroy();
     * ```
     */
    set bounds(value) {
        if (value.x === 0 && value.y === 0 && value.width === 0 && value.height === 0) {
            throw new Error('Cannot set empty bounds');
        }
        const widget = this.itemAt(this._defaultIndex);
        if (this._isLoaded) {
            if (typeof widget === 'undefined' || this._dictionary.has('Rect')) {
                this._dictionary.update('Rect', _getUpdatedBounds([value.x, value.y, value.width, value.height], this.page));
            }
            else {
                widget._page = this.page;
                widget.bounds = value;
            }
        }
        else {
            widget._page = this.page;
            widget.bounds = value;
        }
    }
    /**
     * Gets the rotation angle of the field.
     *
     * @returns {number} angle.
     * ```typescript
     * // Load an existing PDF document
     * let document: PdfDocument = new PdfDocument(data, password);
     * // Access the form field at index 0
     * let field: PdfField = document.form.fieldAt(0);
     * // Gets the rotation angle of the form field.
     * let rotate: number = field.rotate;
     * // Save the document
     * document.save('output.pdf');
     * // Destroy the document
     * document.destroy();
     * ```
     */
    get rotate() {
        let widget = this.itemAt(this._defaultIndex);
        let angle;
        if (widget && typeof widget.rotate !== 'undefined') {
            angle = widget.rotate;
        }
        else if (this._dictionary.has('R')) {
            angle = this._dictionary.get('R');
        }
        else {
            for (let i = 0; i < this._kidsCount && typeof angle === 'undefined'; i++) {
                if (i !== this._defaultIndex) {
                    widget = this.itemAt(i);
                    if (widget && typeof widget.rotate !== 'undefined') {
                        angle = widget.rotate;
                    }
                }
            }
        }
        if (typeof angle === 'undefined') {
            angle = 0;
        }
        return angle;
    }
    /**
     * Sets the rotation angle of the field.
     *
     * @param {number} value rotation angle.
     * ```typescript
     * // Load an existing PDF document
     * let document: PdfDocument = new PdfDocument(data, password);
     * // Access the form field at index 0
     * let field: PdfField = document.form.fieldAt(0);
     * // Sets the rotation angle.
     * field.rotate = 90;
     * // Save the document
     * document.save('output.pdf');
     * // Destroy the document
     * document.destroy();
     * ```
     */
    set rotate(value) {
        const widget = this.itemAt(this._defaultIndex);
        if (widget) {
            widget.rotate = value;
        }
        else if (!this._dictionary.has('R') || this._dictionary.get('R') !== value) {
            this._dictionary.update('R', value);
        }
    }
    /**
     * Gets the fore color of the field.
     *
     * @returns {number[]} R, G, B color values in between 0 to 255.
     * ```typescript
     * // Load an existing PDF document
     * let document: PdfDocument = new PdfDocument(data, password);
     * // Access the form field at index 0
     * let field: PdfField = document.form.fieldAt(0);
     * // Gets the fore color of the field.
     * let color: number[] = field.color;
     * // Save the document
     * document.save('output.pdf');
     * // Destroy the document
     * document.destroy();
     * ```
     */
    get color() {
        let value;
        const widget = this.itemAt(this._defaultIndex);
        if (widget && widget.color) {
            value = widget.color;
        }
        else if (this._defaultAppearance) {
            value = this._da.color;
        }
        return value;
    }
    /**
     * Sets the fore color of the field.
     *
     * @param {number[]} value R, G, B color values in between 0 to 255.
     * ```typescript
     * // Load an existing PDF document
     * let document: PdfDocument = new PdfDocument(data, password);
     * // Access the form field at index 0
     * let field: PdfField = document.form.fieldAt(0);
     * // Sets the fore color of the field.
     * field.color = [255, 0, 0];
     * // Save the document
     * document.save('output.pdf');
     * // Destroy the document
     * document.destroy();
     * ```
     */
    set color(value) {
        const widget = this.itemAt(this._defaultIndex);
        if (widget && widget.color) {
            widget.color = value;
        }
        else {
            let isNew = false;
            if (!this._defaultAppearance) {
                this._da = new _PdfDefaultAppearance('');
                isNew = true;
            }
            if (isNew || this._da.color !== value) {
                this._da.color = value;
                this._dictionary.update('DA', this._da.toString());
            }
        }
    }
    /**
     * Gets the background color of the field.
     *
     * @returns {number[]} R, G, B color values in between 0 to 255.
     * ```typescript
     * // Load an existing PDF document
     * let document: PdfDocument = new PdfDocument(data, password);
     * // Access the form field at index 0
     * let field: PdfField = document.form.fieldAt(0);
     * // Gets the background color of the field.
     * let backColor: number[] = field.backColor;
     * // Save the document
     * document.save('output.pdf');
     * // Destroy the document
     * document.destroy();
     * ```
     */
    get backColor() {
        return this._parseBackColor(false);
    }
    /**
     * Sets the background color of the field.
     *
     * @param {number[]} value R, G, B color values in between 0 to 255.
     * ```typescript
     * // Load an existing PDF document
     * let document: PdfDocument = new PdfDocument(data, password);
     * // Access the form field at index 0
     * let field: PdfField = document.form.fieldAt(0);
     * // Sets the background color of the field.
     * field.backColor = [255, 0, 0];
     * // Save the document
     * document.save('output.pdf');
     * // Destroy the document
     * document.destroy();
     * ```
     */
    set backColor(value) {
        this._updateBackColor(value);
    }
    /**
     * Gets the border color of the field.
     *
     * @returns {number[]} R, G, B color values in between 0 to 255.
     * ```typescript
     * // Load an existing PDF document
     * let document: PdfDocument = new PdfDocument(data, password);
     * // Access the form field at index 0
     * let field: PdfField = document.form.fieldAt(0);
     * // Gets the border color of the field.
     * let borderColor: number[] = field.borderColor;
     * // Save the document
     * document.save('output.pdf');
     * // Destroy the document
     * document.destroy();
     * ```
     */
    get borderColor() {
        let value;
        const widget = this.itemAt(this._defaultIndex);
        if (widget && widget.borderColor) {
            value = widget.borderColor;
        }
        else if (this._mkDictionary) {
            const dictionary = this._mkDictionary;
            if (dictionary && dictionary.has('BC')) {
                const colorArray = dictionary.getArray('BC');
                if (colorArray) {
                    value = _parseColor(colorArray);
                }
            }
        }
        if (typeof value === 'undefined' || value === null) {
            value = [0, 0, 0];
        }
        return value;
    }
    /**
     * Sets the border color of the field.
     *
     * @param {number[]} value R, G, B color values in between 0 to 255.
     * ```typescript
     * // Load an existing PDF document
     * let document: PdfDocument = new PdfDocument(data, password);
     * // Access the form field at index 0
     * let field: PdfField = document.form.fieldAt(0);
     * // Sets the border color of the field.
     * field.borderColor = [255, 0, 0];
     * // Save the document
     * document.save('output.pdf');
     * // Destroy the document
     * document.destroy();
     * ```
     */
    set borderColor(value) {
        const widget = this.itemAt(this._defaultIndex);
        if (widget && widget.borderColor !== value) {
            widget.borderColor = value;
        }
        else {
            const mkDict = this._mkDictionary;
            if (typeof mkDict === 'undefined') {
                const dictionary = new _PdfDictionary(this._crossReference);
                dictionary.update('BC', [Number.parseFloat((value[0] / 255).toFixed(3)),
                    Number.parseFloat((value[1] / 255).toFixed(3)),
                    Number.parseFloat((value[2] / 255).toFixed(3))]);
                this._dictionary.update('MK', dictionary);
            }
            else if (!mkDict.has('BC') || _parseColor(mkDict.getArray('BC')) !== value) {
                mkDict.update('BC', [Number.parseFloat((value[0] / 255).toFixed(3)),
                    Number.parseFloat((value[1] / 255).toFixed(3)),
                    Number.parseFloat((value[2] / 255).toFixed(3))]);
                this._dictionary._updated = true;
            }
        }
    }
    /**
     * Gets a value indicating whether read only.
     *
     * @returns {boolean} read only or not.
     * ```typescript
     * // Load an existing PDF document
     * let document: PdfDocument = new PdfDocument(data, password);
     * // Access the form field at index 0
     * let field: PdfField = document.form.fieldAt(0);
     * // Gets a value indicating whether read only.
     * let readOnly: boolean = field.readOnly;
     * // Save the document
     * document.save('output.pdf');
     * // Destroy the document
     * document.destroy();
     * ```
     */
    get readOnly() {
        return (this._fieldFlags & _FieldFlag.readOnly) !== 0;
    }
    /**
     * Sets a value indicating whether read only.
     *
     * @param {boolean} value read only or not.
     * ```typescript
     * // Load an existing PDF document
     * let document: PdfDocument = new PdfDocument(data, password);
     * // Access the form field at index 0
     * let field: PdfField = document.form.fieldAt(0);
     * // Sets a value indicating whether read only.
     * field.readOnly = true;
     * // Save the document
     * document.save('output.pdf');
     * // Destroy the document
     * document.destroy();
     * ```
     */
    set readOnly(value) {
        if (value) {
            this._fieldFlags |= _FieldFlag.readOnly;
        }
        else {
            if (this._fieldFlags === _FieldFlag.readOnly) {
                this._fieldFlags |= _FieldFlag.default;
            }
            this._fieldFlags &= ~_FieldFlag.readOnly;
        }
    }
    /**
     * Gets a value indicating whether the field is required.
     *
     * @returns {boolean} required or not.
     * ```typescript
     * // Load an existing PDF document
     * let document: PdfDocument = new PdfDocument(data, password);
     * // Access the form field at index 0
     * let field: PdfField = document.form.fieldAt(0);
     * // Gets a value indicating whether the field is required.
     * let required: boolean = field.required;
     * // Save the document
     * document.save('output.pdf');
     * // Destroy the document
     * document.destroy();
     * ```
     */
    get required() {
        return (this._fieldFlags & _FieldFlag.required) !== 0;
    }
    /**
     * Sets a value indicating whether the field is required.
     *
     * @param {boolean} value required or not.
     * ```typescript
     * // Load an existing PDF document
     * let document: PdfDocument = new PdfDocument(data, password);
     * // Access the form field at index 0
     * let field: PdfField = document.form.fieldAt(0);
     * // Sets a value indicating whether the field is required.
     * field.required = true;
     * // Save the document
     * document.save('output.pdf');
     * // Destroy the document
     * document.destroy();
     * ```
     */
    set required(value) {
        if (value) {
            this._fieldFlags |= _FieldFlag.required;
        }
        else {
            this._fieldFlags &= ~_FieldFlag.required;
        }
    }
    /**
     * Gets a value indicating the visibility of the field (Read only).
     *
     * @returns {boolean} visible or not.
     * ```typescript
     * // Load an existing PDF document
     * let document: PdfDocument = new PdfDocument(data, password);
     * // Access the form field at index 0
     * let field: PdfField = document.form.fieldAt(0);
     * // Gets a value indicating the visibility of the field.
     * let visible: boolean = field.visible;
     * // Save the document
     * document.save('output.pdf');
     * // Destroy the document
     * document.destroy();
     * ```
     */
    get visible() {
        if (this._isLoaded) {
            const widget = this.itemAt(this._defaultIndex);
            let flag = PdfAnnotationFlag.default;
            if (widget && widget._hasFlags) {
                flag = widget.flags;
            }
            else if (this._dictionary.has('F')) {
                flag = this._dictionary.get('F');
            }
            return flag !== PdfAnnotationFlag.hidden;
        }
        else {
            return this._visible;
        }
    }
    /**
     * Sets a value indicating the visibility of the field.
     * Only applicable for newly created PDF form fields.
     *
     * @param {boolean} value or not.
     * ```typescript
     * // Load an existing PDF document
     * let document: PdfDocument = new PdfDocument(data, password);
     * // Access the form field at index 0
     * let field: PdfField = document.form.fieldAt(0);
     * // Sets a value indicating the visibility of the field
     * field.visible = true;
     * // Save the document
     * document.save('output.pdf');
     * // Destroy the document
     * document.destroy();
     * ```
     */
    set visible(value) {
        if (!this._isLoaded && this._visible !== value && !value) {
            this._visible = value;
            this.itemAt(this._defaultIndex).flags = PdfAnnotationFlag.hidden;
        }
    }
    /**
     * Gets the width, style and dash of the border of the field.
     *
     * @returns {PdfInteractiveBorder} Border properties.
     * ```typescript
     * // Load an existing PDF document
     * let document: PdfDocument = new PdfDocument(data, password);
     * // Access the form field at index 0
     * let field: PdfField = document.form.fieldAt(0);
     * // Gets the width, style and dash of the border of the field.
     * let border: PdfInteractiveBorder = field.border;
     * // Save the document
     * document.save('output.pdf');
     * // Destroy the document
     * document.destroy();
     * ```
     */
    get border() {
        const widget = this.itemAt(this._defaultIndex);
        let value;
        if (widget && widget._dictionary.has('BS')) {
            value = widget.border;
        }
        else {
            value = new PdfInteractiveBorder();
            if (!(this instanceof PdfButtonField)) {
                value._width = 0;
            }
            value._dictionary = this._dictionary;
            if (this._dictionary.has('BS')) {
                const border = this._dictionary.get('BS');
                if (border) {
                    if (border.has('W')) {
                        value._width = border.get('W');
                    }
                    if (border.has('S')) {
                        const borderStyle = border.get('S');
                        if (borderStyle) {
                            switch (borderStyle.name) {
                                case 'D':
                                    value._style = PdfBorderStyle.dashed;
                                    break;
                                case 'B':
                                    value._style = PdfBorderStyle.beveled;
                                    break;
                                case 'I':
                                    value._style = PdfBorderStyle.inset;
                                    break;
                                case 'U':
                                    value._style = PdfBorderStyle.underline;
                                    break;
                                default:
                                    value._style = PdfBorderStyle.solid;
                                    break;
                            }
                        }
                    }
                    if (border.has('D')) {
                        value._dash = border.getArray('D');
                    }
                }
            }
        }
        return value;
    }
    /**
     * Sets the width, style and dash of the border of the field.
     *
     * @param {PdfInteractiveBorder} value Border properties.
     * ```typescript
     * // Load an existing PDF document
     * let document: PdfDocument = new PdfDocument(data, password);
     * // Access the form field at index 0
     * let field: PdfField = document.form.fieldAt(0);
     * // Sets the width, style and dash of the border of the field.
     * field.border = new PdfInteractiveBorder(2, PdfBorderStyle.solid);
     * // Save the document
     * document.save('output.pdf');
     * // Destroy the document
     * document.destroy();
     * ```
     */
    set border(value) {
        const widget = this.itemAt(this._defaultIndex);
        if (widget) {
            this._updateBorder(widget._dictionary, value);
        }
        else {
            this._updateBorder(this._dictionary, value);
        }
    }
    /**
     * Gets the rotation of the field (Read only).
     *
     * @returns {PdfRotationAngle} Rotation angle.
     * ```typescript
     * // Load an existing PDF document
     * let document: PdfDocument = new PdfDocument(data, password);
     * // Access the form field at index 0
     * let field: PdfField = document.form.fieldAt(0);
     * // Gets the rotation of the field.
     * let rotate: PdfRotationAngle = field.rotationAngle;
     * // Save the document
     * document.save('output.pdf');
     * // Destroy the document
     * document.destroy();
     * ```
     */
    get rotationAngle() {
        let value = PdfRotationAngle.angle0;
        const widget = this.itemAt(this._defaultIndex);
        if (widget) {
            value = widget.rotationAngle;
        }
        return value;
    }
    /**
     * Gets a value indicating whether the field is allow to export data or not.
     *
     * @returns {boolean} Allow to export data or not.
     * ```typescript
     * // Load an existing PDF document
     * let document: PdfDocument = new PdfDocument(data, password);
     * // Access the form field at index 0
     * let field: PdfField = document.form.fieldAt(0);
     * // Gets a value indicating whether the field is allow to export data or not.
     * let export: boolean = field.export;
     * // Save the document
     * document.save('output.pdf');
     * // Destroy the document
     * document.destroy();
     * ```
     */
    get export() {
        return !((this._fieldFlags & _FieldFlag.noExport) !== 0);
    }
    /**
     * Sets a value indicating whether the field is allow to export data or not.
     *
     * @param {boolean} value Allow to export data or not.
     * ```typescript
     * // Load an existing PDF document
     * let document: PdfDocument = new PdfDocument(data, password);
     * // Access the form field at index 0
     * let field: PdfField = document.form.fieldAt(0);
     * // Sets a value indicating whether the field is allow to export data or not.
     * field.export = true;
     * // Save the document
     * document.save('output.pdf');
     * // Destroy the document
     * document.destroy();
     * ```
     */
    set export(value) {
        if (value) {
            this._fieldFlags &= ~_FieldFlag.noExport;
        }
        else {
            this._fieldFlags |= _FieldFlag.noExport;
        }
    }
    /**
     * Gets the tab index of annotation in current page.
     *
     * @returns {number} tab index.
     * ```typescript
     * // Load an existing PDF document
     * let document: PdfDocument = new PdfDocument(data, password);
     * // Access the form field at index 0
     * let field: PdfField = document.form.fieldAt(0);
     * // Gets the tab index of annotation in current page.
     * let tabIndex: number = field.tabIndex;
     * // Save the document
     * document.save('output.pdf');
     * // Destroy the document
     * document.destroy();
     * ```
     */
    get tabIndex() {
        let annots;
        if (this.page._pageDictionary.has('Annots')) {
            annots = this.page._pageDictionary.get('Annots');
        }
        if (this._kids && this._kids.length > 0) {
            for (let i = 0; i < this._kids.length; i++) {
                const reference = this._kids[Number.parseInt(i.toString(), 10)];
                if (reference) {
                    if (this.page._pageDictionary.has('Annots')) {
                        if (annots) {
                            const index1 = annots.indexOf(reference);
                            if (index1 !== -1) {
                                return index1;
                            }
                        }
                    }
                }
            }
        }
        else if (this._dictionary.has('Subtype') && this._dictionary.get('Subtype').name === 'Widget') {
            if (this._ref) {
                if (annots) {
                    const index1 = annots.indexOf(this._ref);
                    if (index1 !== -1) {
                        return index1;
                    }
                }
            }
        }
        return -1;
    }
    /**
     * Sets the tab index of a annotation in the current page.
     *
     * @param {number} value index.
     * ```typescript
     * // Load an existing PDF document
     * let document: PdfDocument = new PdfDocument(data, password);
     * // Access the form field at index 0
     * let field: PdfField = document.form.fieldAt(0);
     * // Sets the tab index of annotation in current page.
     * field.tabIndex = 5;
     * // Save the document
     * document.save('output.pdf');
     * // Destroy the document
     * document.destroy();
     * ```
     */
    set tabIndex(value) {
        this._tabIndex = value;
        const page = this.page;
        if (page && (this.form._tabOrder === PdfFormFieldsTabOrder.manual || page.tabOrder === PdfFormFieldsTabOrder.manual)) {
            if (page._pageDictionary.has('Annots')) {
                const annots = page._pageDictionary.get('Annots');
                const annotationCollection = new PdfAnnotationCollection(annots, this._crossReference, page);
                page._annotations = annotationCollection;
                let index = annots.indexOf(this._ref);
                if (index < 0) {
                    index = this._annotationIndex;
                }
                const annotations = page.annotations._reArrange(this._ref, this._tabIndex, index);
                page._pageDictionary.update('Annots', annotations);
                page._pageDictionary._updated = true;
            }
        }
    }
    /**
     * Gets the page object of the form field (Read only).
     *
     * @returns {PdfPage} Page object.
     * ```typescript
     * // Load an existing PDF document
     * let document: PdfDocument = new PdfDocument(data, password);
     * // Access the form field at index 0
     * let field: PdfField = document.form.fieldAt(0);
     * // Gets the page object of the form field.
     * let page: PdfPage = field.page;
     * // Save the document
     * document.save('output.pdf');
     * // Destroy the document
     * document.destroy();
     * ```
     */
    get page() {
        if (!this._page) {
            const widget = this.itemAt(this._defaultIndex);
            const dictionary = (typeof widget !== 'undefined') ? widget._dictionary : this._dictionary;
            let document;
            if (this._crossReference) {
                document = this._crossReference._document;
            }
            let page;
            if (dictionary.has('P')) {
                const ref = dictionary.getRaw('P');
                if (ref && document) {
                    for (let i = 0; i < document.pageCount; i++) {
                        const entry = document.getPage(i);
                        if (entry && entry._ref === ref) {
                            page = entry;
                            break;
                        }
                    }
                }
            }
            if (!page && document) {
                const widgetRef = (typeof widget !== 'undefined') ? widget._ref : this._ref;
                if (!page && widgetRef) {
                    page = _findPage(document, widgetRef);
                }
                if (!page && this._kids && this._kids.length > 0) {
                    for (let i = 0; i < this._kids.length; i++) {
                        page = _findPage(document, this._kids[Number.parseInt(i.toString(), 10)]);
                        if (page) {
                            break;
                        }
                    }
                }
            }
            this._page = page;
        }
        return this._page;
    }
    /**
     * Gets the boolean flag indicating whether the form field have been flattened or not.
     *
     * @returns {boolean} Flatten.
     *
     * ```typescript
     * // Load an existing PDF document
     * let document: PdfDocument = new PdfDocument(data, password);
     * // Get the first field
     * let field: PdfField = document.form.fieldAt(0);
     * // Gets the boolean flag indicating whether the form field have been flattened or not.
     * let flatten: boolean = field.flatten;
     * // Destroy the document
     * document.destroy();
     * ```
     */
    get flatten() {
        return this._flatten;
    }
    /**
     * Sets the boolean flag indicating whether the form field have been flattened or not.
     *
     * @param {boolean} value Flatten.
     *
     * ```typescript
     * // Load an existing PDF document
     * let document: PdfDocument = new PdfDocument(data, password);
     * // Get the first field
     * let field: PdfField = document.form.fieldAt(0);
     * // Sets the boolean flag indicating whether the form field have been flattened or not.
     * field.flatten = true;
     * // Destroy the document
     * document.destroy();
     * ```
     */
    set flatten(value) {
        this._flatten = value;
    }
    get _grayBrush() {
        if (!this._gray) {
            this._gray = new PdfBrush([128, 128, 128]);
        }
        return this._gray;
    }
    get _silverBrush() {
        if (!this._silver) {
            this._silver = new PdfBrush([198, 198, 198]);
        }
        return this._silver;
    }
    get _whiteBrush() {
        if (!this._white) {
            this._white = new PdfBrush([255, 255, 255]);
        }
        return this._white;
    }
    get _blackBrush() {
        if (!this._black) {
            this._black = new PdfBrush([0, 0, 0]);
        }
        return this._black;
    }
    get _kidsCount() {
        return this._kids ? this._kids.length : 0;
    }
    get _hasBackColor() {
        if (this._isLoaded) {
            let mkDictionary = this._mkDictionary;
            if (!mkDictionary) {
                const item = this.itemAt(this._defaultIndex);
                if (item && item._dictionary.has('MK')) {
                    mkDictionary = item._dictionary.get('MK');
                }
            }
            return (mkDictionary && mkDictionary.has('BG'));
        }
        else {
            return !this._isTransparentBackColor;
        }
    }
    _parseBackColor(hasTransparency) {
        let value;
        if ((!hasTransparency) || ((this._isLoaded && this._hasBackColor) || (!this._isLoaded && !this._isTransparentBackColor))) {
            const widget = this.itemAt(this._defaultIndex);
            if (widget && widget.backColor) {
                value = widget.backColor;
            }
            else if (this._mkDictionary) {
                const mkDict = this._mkDictionary;
                if (mkDict && mkDict.has('BG')) {
                    const bgArray = mkDict.getArray('BG');
                    if (bgArray) {
                        value = _parseColor(bgArray);
                    }
                }
            }
            if (typeof value === 'undefined' || value === null) {
                value = [255, 255, 255];
            }
        }
        return value;
    }
    _updateBackColor(value, hasTransparency = false) {
        if (hasTransparency && value.length === 4 && value[3] !== 255) {
            this._isTransparentBackColor = true;
            if (this._dictionary.has('BG')) {
                delete this._dictionary._map.BG;
            }
            const mkDictionary = this._mkDictionary;
            if (mkDictionary && mkDictionary.has('BG')) {
                delete mkDictionary._map.BG;
                this._dictionary._updated = true;
            }
            const item = this.itemAt(this._defaultIndex);
            if (item) {
                item.backColor = value;
            }
        }
        else {
            this._isTransparentBackColor = false;
            const widget = this.itemAt(this._defaultIndex);
            if (widget && widget.backColor !== value) {
                widget.backColor = value;
            }
            else {
                const mkDictionary = this._mkDictionary;
                if (typeof mkDictionary === 'undefined') {
                    const dictionary = new _PdfDictionary(this._crossReference);
                    dictionary.update('BG', [Number.parseFloat((value[0] / 255).toFixed(3)),
                        Number.parseFloat((value[1] / 255).toFixed(3)),
                        Number.parseFloat((value[2] / 255).toFixed(3))]);
                    this._dictionary.update('MK', dictionary);
                }
                else if (!mkDictionary.has('BG') || _parseColor(mkDictionary.getArray('BG')) !== value) {
                    mkDictionary.update('BG', [Number.parseFloat((value[0] / 255).toFixed(3)),
                        Number.parseFloat((value[1] / 255).toFixed(3)),
                        Number.parseFloat((value[2] / 255).toFixed(3))]);
                    this._dictionary._updated = true;
                }
            }
        }
    }
    /**
     * Gets the field item as `PdfWidgetAnnotation` at the specified index.
     *
     * @param {number} index Item index.
     * @returns {PdfWidgetAnnotation} Loaded PDF form field item at the specified index.
     *
     * ```typescript
     * // Load an existing PDF document
     * let document: PdfDocument = new PdfDocument(data, password);
     * // Access the loaded form field
     * let field: PdfField = document.form.fieldAt(0);
     * // Access the count of the field items.
     * let count: number = field.count;
     * // Access the first item
     * let item: PdfWidgetAnnotation = field.itemAt(0);
     * // Save the document
     * document.save('output.pdf');
     * // Destroy the document
     * document.destroy();
     * ```
     */
    itemAt(index) {
        let item;
        if (index >= 0 && index < this._kidsCount) {
            if (this._parsedItems.has(index)) {
                item = this._parsedItems.get(index);
            }
            else {
                let dictionary;
                const reference = this._kids[Number.parseInt(index.toString(), 10)];
                if (reference && reference instanceof _PdfReference) {
                    dictionary = this._crossReference._fetch(reference);
                }
                if (dictionary) {
                    item = PdfWidgetAnnotation._load(dictionary, this._crossReference);
                    item._ref = reference;
                    this._parsedItems.set(index, item);
                }
            }
        }
        return item;
    }
    /**
     * Sets the flag to indicate the new appearance creation.
     *
     * @param {boolean} value Set appearance.
     * @returns {void} Nothing.
     *
     * ```typescript
     * // Load an existing PDF document
     * let document: PdfDocument = new PdfDocument(data, password);
     * // Set boolean flag to create a new appearance stream for form fields.
     * document.form.fieldAt(0).setAppearance(true);
     * // Save the document
     * document.save('output.pdf');
     * // Destroy the document
     * document.destroy();
     * ```
     */
    setAppearance(value) {
        this._setAppearance = value;
    }
    /**
     * Gets the value associated with the specified key.
     *
     * @param {string} name Key.
     * @returns {string} Value associated with the key.
     *
     * ```typescript
     * // Load an existing PDF document
     * let document: PdfDocument = new PdfDocument(data, password);
     * // Gets the value associated with the key 'Author'.
     * let value: string = document.form.fieldAt(0).getValue('Author');
     * // Save the document
     * document.save('output.pdf');
     * // Destroy the document
     * document.destroy();
     * ```
     */
    getValue(name) {
        let value;
        if (this._dictionary.has(name)) {
            const element = this._dictionary.get(name); // eslint-disable-line
            if (element instanceof _PdfName) {
                value = element.name;
            }
            else if (typeof element === 'string') {
                value = element;
            }
            else {
                throw new Error('PdfException: ' + name + ' is not found');
            }
        }
        else {
            throw new Error('PdfException: ' + name + ' is not found');
        }
        return value;
    }
    /**
     * Sets the value associated with the specified key.
     *
     * @param {string} name Key.
     * @param {string} value Value associated with the key..
     * @returns {void} Nothing.
     *
     * ```typescript
     * // Load an existing PDF document
     * let document: PdfDocument = new PdfDocument(data, password);
     * // Access the form field at index 0
     * let field: PdfField = document.form.fieldAt(0);
     * // Set custom value
     * field.setValue('Author', 'John');
     * // Save the document
     * document.save('output.pdf');
     * // Destroy the document
     * document.destroy();
     * ```
     */
    setValue(name, value) {
        if (name && name !== '' && value && value !== '') {
            this._dictionary.update(name, value);
        }
    }
    /**
     * Remove the form field item from the specified index.
     *
     * @param {number} index Item index to remove.
     * @returns {void} Nothing.
     *
     * ```typescript
     * // Load an existing PDF document
     * let document: PdfDocument = new PdfDocument(data, password);
     * // Access the form field at index 0
     * let field: PdfField = document.form.fieldAt(0);
     * // Remove the first item of the form field
     * field.removeItemAt(0);
     * // Save the document
     * document.save('output.pdf');
     * // Destroy the document
     * document.destroy();
     * ```
     */
    removeItemAt(index) {
        if (this._dictionary.has('Kids') && this.itemsCount > 0) {
            const item = this.itemAt(index);
            if (item && item._ref) {
                const page = item._getPage();
                if (page) {
                    page._removeAnnotation(item._ref);
                }
                this._kids.splice(index, 1);
                this._dictionary.set('Kids', this._kids);
                this._dictionary._updated = true;
                this._parsedItems.delete(index);
                if (this._parsedItems.size > 0) {
                    const parsedItems = new Map();
                    this._parsedItems.forEach((value, key) => {
                        if (key > index) {
                            parsedItems.set(key - 1, value);
                        }
                        else {
                            parsedItems.set(key, value);
                        }
                    });
                    this._parsedItems = parsedItems;
                }
            }
        }
    }
    /**
     * Remove the specified form field item.
     *
     * @param {PdfWidgetAnnotation} item Item to remove.
     * @returns {void} Nothing.
     *
     * ```typescript
     * // Load an existing PDF document
     * let document: PdfDocument = new PdfDocument(data, password);
     * // Access the form field at index 0
     * let field: PdfField = document.form.fieldAt(0);
     * // Remove the first item of the form field
     * field.removeItem(field.itemAt(0));
     * // Save the document
     * document.save('output.pdf');
     * // Destroy the document
     * document.destroy();
     * ```
     */
    removeItem(item) {
        if (item && item._ref) {
            const index = this._kids.indexOf(item._ref);
            if (index !== -1) {
                this.removeItemAt(index);
            }
        }
    }
    get _fieldFlags() {
        if (typeof this._flags === 'undefined') {
            this._flags = _getInheritableProperty(this._dictionary, 'Ff', false, true, 'Parent');
            if (typeof this._flags === 'undefined') {
                this._flags = _FieldFlag.default;
            }
        }
        return this._flags;
    }
    set _fieldFlags(value) {
        if (this._fieldFlags !== value) {
            this._flags = value;
            this._dictionary.update('Ff', value);
        }
    }
    get _defaultAppearance() {
        if (typeof this._da === 'undefined') {
            const da = _getInheritableProperty(this._dictionary, 'DA', false, true, 'Parent');
            if (da && da !== '') {
                this._da = new _PdfDefaultAppearance(da);
            }
        }
        return this._da;
    }
    get _mkDictionary() {
        let value;
        if (this._dictionary.has('MK')) {
            value = this._dictionary.get('MK');
        }
        return value;
    }
    _updateBorder(dictionary, value) {
        let bs;
        let isNew = false;
        if (dictionary.has('BS')) {
            bs = dictionary.get('BS');
        }
        else {
            bs = new _PdfDictionary(this._crossReference);
            dictionary.update('BS', bs);
            isNew = true;
        }
        if (typeof value.width !== 'undefined') {
            bs.update('W', value.width);
            dictionary._updated = true;
        }
        else if (isNew) {
            bs.update('W', 0);
        }
        if (typeof value.style !== 'undefined') {
            bs.update('S', _mapBorderStyle(value.style));
            dictionary._updated = true;
        }
        else if (isNew) {
            bs.update('S', _mapBorderStyle(PdfBorderStyle.solid));
        }
        if (typeof value.dash !== 'undefined') {
            bs.update('D', value.dash);
            dictionary._updated = true;
        }
    }
    _checkFieldFlag(dictionary) {
        const flag = dictionary.get('F');
        return (typeof flag !== 'undefined' && flag === 6);
    }
    _initializeFont(font) {
        this._font = font;
        const document = this._crossReference._document;
        let resource;
        if (document) {
            if (document.form._dictionary.has('DR')) {
                resource = document.form._dictionary.get('DR');
            }
            else {
                resource = new _PdfDictionary(this._crossReference);
            }
        }
        let fontDict;
        let isReference = false;
        if (resource.has('Font')) {
            const obj = resource.getRaw('Font'); // eslint-disable-line
            if (obj && obj instanceof _PdfReference) {
                isReference = true;
                fontDict = this._crossReference._fetch(obj);
            }
            else if (obj instanceof _PdfDictionary) {
                fontDict = obj;
            }
        }
        if (!fontDict) {
            fontDict = new _PdfDictionary(this._crossReference);
            resource.update('Font', fontDict);
        }
        const keyName = _PdfName.get(_getNewGuidString());
        const reference = this._crossReference._getNextReference();
        if (font instanceof PdfTrueTypeFont) {
            if (this._font._pdfFontInternals) {
                this._crossReference._cacheMap.set(reference, this._font._pdfFontInternals);
            }
        }
        else if (this._font._dictionary) {
            this._crossReference._cacheMap.set(reference, this._font._dictionary);
        }
        fontDict.update(keyName.name, reference);
        resource._updated = true;
        document.form._dictionary.update('DR', resource);
        document.form._dictionary._updated = true;
        this._fontName = keyName.name;
        const defaultAppearance = new _PdfDefaultAppearance();
        defaultAppearance.fontName = this._fontName;
        defaultAppearance.fontSize = this._font._size;
        defaultAppearance.color = this.color ? this.color : [0, 0, 0];
        if (this._dictionary.has('Kids')) {
            const widgetDictionary = this._dictionary.getArray('Kids');
            for (let i = 0; i < widgetDictionary.length; i++) {
                const dictionary = widgetDictionary[Number.parseInt(i.toString(), 10)];
                dictionary.update('DA', defaultAppearance.toString());
            }
        }
        else if (this._dictionary.has('Subtype') && this._dictionary.get('Subtype').name === 'Widget') {
            this._dictionary.update('DA', defaultAppearance.toString());
        }
        if (isReference) {
            resource._updated = true;
        }
    }
    _drawRectangularControl(g, parameter) {
        g.drawRectangle(parameter.bounds[0], parameter.bounds[1], parameter.bounds[2], parameter.bounds[3], parameter.backBrush);
        this._drawBorder(g, parameter.bounds, parameter.borderPen, parameter.borderStyle, parameter.borderWidth);
        switch (parameter.borderStyle) {
            case PdfBorderStyle.inset:
                this._drawLeftTopShadow(g, parameter.bounds, parameter.borderWidth, this._grayBrush);
                this._drawRightBottomShadow(g, parameter.bounds, parameter.borderWidth, this._silverBrush);
                break;
            case PdfBorderStyle.beveled:
                this._drawLeftTopShadow(g, parameter.bounds, parameter.borderWidth, this._whiteBrush);
                this._drawRightBottomShadow(g, parameter.bounds, parameter.borderWidth, parameter.shadowBrush);
                break;
        }
    }
    _drawBorder(g, bounds, borderPen, style, borderWidth) {
        if (borderPen && borderWidth > 0) {
            if (style === PdfBorderStyle.underline) {
                g.drawLine(borderPen, bounds[0], bounds[0] + bounds[3] - borderWidth / 2, bounds[0] + bounds[2], bounds[1] + bounds[3] - borderWidth / 2);
            }
            else {
                g.drawRectangle(bounds[0] + borderWidth / 2, bounds[1] + borderWidth / 2, bounds[2] - borderWidth, bounds[3] - borderWidth, borderPen);
            }
        }
    }
    _drawLeftTopShadow(g, bounds, width, brush) {
        const path = new _PdfPath();
        const points = [];
        points.push([bounds[0] + width, bounds[1] + width]);
        points.push([bounds[0] + width, (bounds[1] + bounds[3]) - width]);
        points.push([bounds[0] + 2 * width, (bounds[1] + bounds[3]) - 2 * width]);
        points.push([bounds[0] + 2 * width, bounds[1] + 2 * width]);
        points.push([(bounds[0] + bounds[2]) - 2 * width, bounds[1] + 2 * width]);
        points.push([(bounds[0] + bounds[2]) - width, bounds[1] + width]);
        path._addPolygon(points);
        g._drawPath(path, null, brush);
    }
    _drawRightBottomShadow(g, bounds, width, brush) {
        const path = new _PdfPath();
        const points = [];
        points.push([bounds[0] + width, (bounds[1] + bounds[3]) - width]);
        points.push([bounds[0] + 2 * width, (bounds[1] + bounds[3]) - 2 * width]);
        points.push([(bounds[0] + bounds[2]) - 2 * width, (bounds[1] + bounds[3]) - 2 * width]);
        points.push([(bounds[0] + bounds[2]) - 2 * width, bounds[1] + 2 * width]);
        points.push([bounds[0] + bounds[2] - width, bounds[1] + width]);
        points.push([(bounds[0] + bounds[2]) - width, (bounds[1] + bounds[3]) - width]);
        path._addPolygon(points);
        g._drawPath(path, null, brush);
    }
    _drawRadioButton(graphics, parameter, checkSymbol, state) {
        if (checkSymbol === 'l') {
            const bounds = parameter.bounds;
            switch (state) {
                case _PdfCheckFieldState.checked:
                case _PdfCheckFieldState.unchecked:
                    graphics.drawEllipse(bounds[0], bounds[1], bounds[2], bounds[3], parameter.backBrush);
                    break;
                case _PdfCheckFieldState.pressedChecked:
                case _PdfCheckFieldState.pressedUnchecked:
                    if ((parameter.borderStyle === PdfBorderStyle.beveled) || (parameter.borderStyle === PdfBorderStyle.underline)) {
                        graphics.drawEllipse(bounds[0], bounds[1], bounds[2], bounds[3], parameter.backBrush);
                    }
                    else {
                        graphics.drawEllipse(bounds[0], bounds[1], bounds[2], bounds[3], parameter.shadowBrush);
                    }
                    break;
            }
            this._drawRoundBorder(graphics, bounds, parameter.borderPen, parameter.borderWidth);
            this._drawRoundShadow(graphics, parameter, state);
            if (state === _PdfCheckFieldState.checked || state === _PdfCheckFieldState.pressedChecked) {
                const outward = [bounds[0] + parameter.borderWidth / 2,
                    bounds[1] + parameter.borderWidth / 2,
                    bounds[2] - parameter.borderWidth,
                    bounds[3] - parameter.borderWidth];
                graphics.drawEllipse(outward[0] + (outward[2] / 4), outward[1] + (outward[2] / 4), outward[2] - (outward[2] / 2), outward[3] - (outward[2] / 2), parameter.foreBrush);
            }
        }
        else {
            this._drawCheckBox(graphics, parameter, checkSymbol, state);
        }
    }
    _drawRoundBorder(graphics, bounds, borderPen, borderWidth) {
        if (bounds[0] !== 0 || bounds[1] !== 0 || bounds[2] !== 0 || bounds[3] !== 0) {
            graphics.drawEllipse(bounds[0] + borderWidth / 2, bounds[1] + borderWidth / 2, bounds[2] - borderWidth, bounds[3] - borderWidth, borderPen);
        }
    }
    _drawRoundShadow(graphics, parameter, state) {
        const borderWidth = parameter.borderWidth;
        const inflateValue = -1.5 * borderWidth;
        const x = parameter.bounds[0] + inflateValue;
        const y = parameter.bounds[1] + inflateValue;
        const width = parameter.bounds[2] + (2 * inflateValue);
        const height = parameter.bounds[3] + (2 * inflateValue);
        const shadowBrush = parameter.shadowBrush;
        if (shadowBrush) {
            const shadowColor = shadowBrush._color;
            let leftTop;
            let rightBottom;
            switch (parameter.borderStyle) {
                case PdfBorderStyle.beveled:
                    switch (state) {
                        case _PdfCheckFieldState.pressedChecked:
                        case _PdfCheckFieldState.pressedUnchecked:
                            leftTop = new PdfPen(shadowColor, borderWidth);
                            rightBottom = new PdfPen([255, 255, 255], borderWidth);
                            break;
                        case _PdfCheckFieldState.checked:
                        case _PdfCheckFieldState.unchecked:
                            leftTop = new PdfPen([255, 255, 255], borderWidth);
                            rightBottom = new PdfPen(shadowColor, borderWidth);
                            break;
                    }
                    break;
                case PdfBorderStyle.inset:
                    switch (state) {
                        case _PdfCheckFieldState.pressedChecked:
                        case _PdfCheckFieldState.pressedUnchecked:
                            leftTop = new PdfPen([0, 0, 0], borderWidth);
                            rightBottom = new PdfPen([0, 0, 0], borderWidth);
                            break;
                        case _PdfCheckFieldState.checked:
                        case _PdfCheckFieldState.unchecked:
                            leftTop = new PdfPen([128, 128, 128], borderWidth);
                            rightBottom = new PdfPen([192, 192, 192], borderWidth);
                            break;
                    }
                    break;
            }
            if (leftTop && rightBottom) {
                graphics.drawArc(x, y, width, height, 135, 180, leftTop);
                graphics.drawArc(x, y, width, height, -45, 180, rightBottom);
            }
        }
    }
    _drawCheckBox(graphics, parameter, checkSymbol, state, font) {
        switch (state) {
            case _PdfCheckFieldState.unchecked:
            case _PdfCheckFieldState.checked:
                if (parameter.borderPen) {
                    graphics.drawRectangle(parameter.bounds[0], parameter.bounds[1], parameter.bounds[2], parameter.bounds[3], parameter.backBrush);
                }
                break;
            case _PdfCheckFieldState.pressedChecked:
            case _PdfCheckFieldState.pressedUnchecked:
                if ((parameter.borderStyle === PdfBorderStyle.beveled) ||
                    (parameter.borderStyle === PdfBorderStyle.underline)) {
                    if (parameter.borderPen) {
                        graphics.drawRectangle(parameter.bounds[0], parameter.bounds[1], parameter.bounds[2], parameter.bounds[3], parameter.backBrush);
                    }
                }
                else if (parameter.borderPen) {
                    graphics.drawRectangle(parameter.bounds[0], parameter.bounds[1], parameter.bounds[2], parameter.bounds[3], parameter.shadowBrush);
                }
                break;
        }
        let rectangle = parameter.bounds;
        this._drawBorder(graphics, parameter.bounds, parameter.borderPen, parameter.borderStyle, parameter.borderWidth);
        if ((state === _PdfCheckFieldState.pressedChecked) || (state === _PdfCheckFieldState.pressedUnchecked)) {
            switch (parameter.borderStyle) {
                case PdfBorderStyle.inset:
                    this._drawLeftTopShadow(graphics, parameter.bounds, parameter.borderWidth, this._blackBrush);
                    this._drawRightBottomShadow(graphics, parameter.bounds, parameter.borderWidth, this._whiteBrush);
                    break;
                case PdfBorderStyle.beveled:
                    this._drawLeftTopShadow(graphics, parameter.bounds, parameter.borderWidth, parameter.shadowBrush);
                    this._drawRightBottomShadow(graphics, parameter.bounds, parameter.borderWidth, this._whiteBrush);
                    break;
            }
        }
        else {
            switch (parameter.borderStyle) {
                case PdfBorderStyle.inset:
                    this._drawLeftTopShadow(graphics, parameter.bounds, parameter.borderWidth, this._grayBrush);
                    this._drawRightBottomShadow(graphics, parameter.bounds, parameter.borderWidth, this._silverBrush);
                    break;
                case PdfBorderStyle.beveled:
                    this._drawLeftTopShadow(graphics, parameter.bounds, parameter.borderWidth, this._whiteBrush);
                    this._drawRightBottomShadow(graphics, parameter.bounds, parameter.borderWidth, parameter.shadowBrush);
                    break;
            }
        }
        let yOffset = 0;
        let size = 0;
        switch (state) {
            case _PdfCheckFieldState.pressedChecked:
            case _PdfCheckFieldState.checked:
                if (!font) {
                    const extraBorder = parameter.borderStyle === PdfBorderStyle.beveled ||
                        parameter.borderStyle === PdfBorderStyle.inset;
                    let borderWidth = parameter.borderWidth;
                    if (extraBorder) {
                        borderWidth *= 2;
                    }
                    const xPosition = Math.max((extraBorder ? 2 * parameter.borderWidth : parameter.borderWidth), 1);
                    const xOffset = Math.min(borderWidth, xPosition);
                    size = (parameter.bounds[2] > parameter.bounds[3]) ? parameter.bounds[3] : parameter.bounds[2];
                    const fontSize = size - 2 * xOffset;
                    font = new PdfStandardFont(PdfFontFamily.zapfDingbats, fontSize);
                    if (parameter.bounds[2] > parameter.bounds[3]) {
                        yOffset = ((parameter.bounds[3] - font._metrics._getHeight()) / 2);
                    }
                }
                else {
                    font = new PdfStandardFont(PdfFontFamily.zapfDingbats, font._size);
                }
                if (size === 0) {
                    size = parameter.bounds[3];
                }
                if (parameter.pageRotationAngle !== PdfRotationAngle.angle0 || parameter.rotationAngle > 0) {
                    const state = graphics.save();
                    const size = graphics._size;
                    if (parameter.pageRotationAngle !== PdfRotationAngle.angle0) {
                        if (parameter.pageRotationAngle === PdfRotationAngle.angle90) {
                            graphics.translateTransform(size[1], 0);
                            graphics.rotateTransform(90);
                            const y = size[1] - (rectangle[0] + rectangle[2]);
                            const x = rectangle[1];
                            rectangle = [x, y, rectangle[3], rectangle[2]];
                        }
                        else if (parameter.pageRotationAngle === PdfRotationAngle.angle180) {
                            graphics.translateTransform(size[0], size[1]);
                            graphics.rotateTransform(-180);
                            const x = size[0] - (rectangle[0] + rectangle[2]);
                            const y = size[1] - (rectangle[1] + rectangle[3]);
                            rectangle = [x, y, rectangle[2], rectangle[3]];
                        }
                        else if (parameter.pageRotationAngle === PdfRotationAngle.angle270) {
                            graphics.translateTransform(0, size[0]);
                            graphics.rotateTransform(270);
                            const x = size[0] - (rectangle[1] + rectangle[3]);
                            const y = rectangle[0];
                            rectangle = [x, y, rectangle[3], rectangle[2]];
                        }
                    }
                    if (parameter.rotationAngle > 0) {
                        if (parameter.rotationAngle === 90) {
                            if (parameter.pageRotationAngle === PdfRotationAngle.angle90) {
                                graphics.translateTransform(0, size[1]);
                                graphics.rotateTransform(-90);
                                const x = size[1] - (rectangle[1] + rectangle[3]);
                                const y = rectangle[0];
                                rectangle = [x, y, rectangle[3], rectangle[2]];
                            }
                            else {
                                if (rectangle[2] > rectangle[3]) {
                                    graphics.translateTransform(0, size[1]);
                                    graphics.rotateTransform(-90);
                                    rectangle = [parameter.bounds[0], parameter.bounds[1], parameter.bounds[2], parameter.bounds[3]];
                                }
                                else {
                                    const z = rectangle[0];
                                    rectangle[0] = -(rectangle[1] + rectangle[3]);
                                    rectangle[1] = z;
                                    const height = rectangle[3];
                                    rectangle[3] = rectangle[2] > font._metrics._getHeight() ? rectangle[2] : font._metrics._getHeight();
                                    rectangle[2] = height;
                                    graphics.rotateTransform(-90);
                                    rectangle = [rectangle[0], rectangle[1], rectangle[2], rectangle[3]];
                                }
                            }
                        }
                        else if (parameter.rotationAngle === 270) {
                            graphics.translateTransform(size[0], 0);
                            graphics.rotateTransform(-270);
                            const x = rectangle[1];
                            const y = size[0] - (rectangle[0] + rectangle[2]);
                            rectangle = [x, y, rectangle[3], rectangle[2]];
                        }
                        else if (parameter.rotationAngle === 180) {
                            graphics.translateTransform(size[0], size[1]);
                            graphics.rotateTransform(-180);
                            const x = size[0] - (rectangle[0] + rectangle[2]);
                            const y = size[1] - (rectangle[1] + rectangle[3]);
                            rectangle = [x, y, rectangle[2], rectangle[3]];
                        }
                        graphics.drawString(checkSymbol, font, [rectangle[0], rectangle[1] - yOffset, rectangle[2], rectangle[3]], null, parameter.foreBrush, new PdfStringFormat(PdfTextAlignment.center, PdfVerticalAlignment.middle));
                        graphics.restore(state);
                    }
                    else {
                        graphics.drawString(checkSymbol, font, [rectangle[0], rectangle[1] - yOffset, rectangle[2], rectangle[3]], null, parameter.foreBrush, new PdfStringFormat(PdfTextAlignment.center, PdfVerticalAlignment.middle));
                    }
                    break;
                }
        }
    }
    _addToKid(item) {
        if (this._dictionary.has('Kids')) {
            this._kids = this._dictionary.get('Kids');
        }
        else {
            this._kids = [];
            this._dictionary.update('Kids', this._kids);
            this._parsedItems = new Map();
        }
        const currentIndex = this._kidsCount;
        item._index = currentIndex;
        this._kids.push(item._ref);
        this._parsedItems.set(currentIndex, item);
    }
    _drawTemplate(template, page, bounds) {
        if (template && page) {
            const graphics = page.graphics;
            graphics.save();
            if (page.rotation === PdfRotationAngle.angle90) {
                graphics.translateTransform(graphics._size[0], graphics._size[1]);
                graphics.rotateTransform(90);
            }
            else if (page.rotation === PdfRotationAngle.angle180) {
                graphics.translateTransform(graphics._size[0], graphics._size[1]);
                graphics.rotateTransform(-180);
            }
            else if (page.rotation === PdfRotationAngle.angle270) {
                graphics.translateTransform(graphics._size[0], graphics._size[1]);
                graphics.rotateTransform(270);
            }
            graphics._sw._setTextRenderingMode(_TextRenderingMode.fill);
            graphics._drawTemplate(template, bounds);
            graphics.restore();
        }
    }
    _addToOptions(item, field) {
        if (field instanceof PdfListBoxField) {
            field._listValues.push(item._text);
        }
        field._options.push([item._value, item._text]);
        field._dictionary.set('Opt', field._options);
        field._dictionary._updated = true;
        if (!item._isFont && item._pdfFont) {
            this._initializeFont(item._pdfFont);
        }
    }
    _addAppearance(dictionary, template, key) {
        let appearance = new _PdfDictionary();
        if (dictionary.has('AP')) {
            appearance = dictionary.get('AP');
            _removeDuplicateReference(dictionary.get('AP'), this._crossReference, key);
        }
        else {
            appearance = new _PdfDictionary(this._crossReference);
            dictionary.update('AP', appearance);
        }
        const reference = this._crossReference._getNextReference();
        this._crossReference._cacheMap.set(reference, template._content);
        appearance.update(key, reference);
    }
    _rotateTextBox(rect, size, angle) {
        let rectangle = [0, 0, 0, 0];
        if (angle === PdfRotationAngle.angle180) {
            rectangle = [size[0] - (rect[0] + rect[2]), size[1] - (rect[1] + rect[3]), rect[2], rect[3]];
        }
        else if (angle === PdfRotationAngle.angle270) {
            rectangle = [rect[1], size[0] - (rect[0] + rect[2]), rect[3], rect[2]];
        }
        else if (angle === PdfRotationAngle.angle90) {
            rectangle = [size[1] - (rect[1] + rect[3]), rect[0], rect[3], rect[2]];
        }
        return rectangle;
    }
    _checkIndex(value, length) {
        if (value < 0 || (value !== 0 && value >= length)) {
            throw Error('Index out of range.');
        }
    }
    _getAppearanceStateValue() {
        let value;
        if (this._dictionary.has('Kids')) {
            for (let i = 0; i < this._kidsCount; i++) {
                const item = this.itemAt(i);
                if (item && item._dictionary && item._dictionary.has('AS')) {
                    const state = item._dictionary.get('AS');
                    if (state && state.name !== 'Off') {
                        value = state.name;
                        break;
                    }
                }
            }
        }
        else if (this._dictionary.has('AS')) {
            const state = this._dictionary.get('AS');
            if (state && state.name !== 'Off') {
                value = state.name;
            }
        }
        return value;
    }
    _getTextAlignment() {
        if (this._textAlignment === null || typeof this._textAlignment === 'undefined') {
            if (this._isLoaded) {
                const widget = this.itemAt(this._defaultIndex);
                if (widget && widget._dictionary && widget._dictionary.has('Q')) {
                    this._textAlignment = widget._dictionary.get('Q');
                }
                else if (this._dictionary.has('Q')) {
                    this._textAlignment = this._dictionary.get('Q');
                }
                else {
                    this._textAlignment = PdfTextAlignment.left;
                }
            }
            else {
                this._textAlignment = PdfTextAlignment.left;
            }
        }
        return this._textAlignment;
    }
    _setTextAlignment(value) {
        const widget = this.itemAt(this._defaultIndex);
        if (this._isLoaded && !this.readOnly) {
            if (widget && widget._dictionary) {
                widget._dictionary.update('Q', value);
            }
            else {
                this._dictionary.update('Q', value);
            }
        }
        if (!this._isLoaded && this._textAlignment !== value) {
            if (widget && widget._dictionary) {
                widget._dictionary.update('Q', value);
            }
            else if (this._dictionary) {
                this._dictionary.update('Q', value);
            }
        }
        this._textAlignment = value;
        this._stringFormat = new PdfStringFormat(value, PdfVerticalAlignment.middle);
    }
    _parseItems() {
        const collection = [];
        for (let i = 0; i < this.itemsCount; i++) {
            collection.push(this.itemAt(i));
        }
        return collection;
    }
}
/**
 * `PdfTextBoxField` class represents the text box field objects.
 * ```typescript
 * // Load an existing PDF document
 * let document: PdfDocument = new PdfDocument(data);
 * // Access text box field
 * let field: PdfTextBoxField = document.form.fieldAt(0) as PdfTextBoxField;
 * // Save the document
 * document.save('output.pdf');
 * // Destroy the document
 * document.destroy();
 * ```
 */
class PdfTextBoxField extends PdfField {
    constructor(page, name, bounds) {
        super();
        this._autoResizeText = false;
        if (page && name && bounds) {
            this._initialize(page, name, bounds);
        }
    }
    /**
     * Parse an existing text box field.
     *
     * @private
     * @param {PdfForm} form Form object.
     * @param {_PdfDictionary} dictionary Field dictionary.
     * @param {_PdfCrossReference} crossReference Cross reference object.
     * @param {_PdfReference} reference Field reference.
     * @returns {PdfTextBoxField} Text box field.
     */
    static _load(form, dictionary, crossReference, reference) {
        const field = new PdfTextBoxField();
        field._isLoaded = true;
        field._form = form;
        field._dictionary = dictionary;
        field._crossReference = crossReference;
        field._ref = reference;
        if (field._dictionary.has('Kids')) {
            field._kids = field._dictionary.get('Kids');
        }
        field._defaultIndex = 0;
        field._parsedItems = new Map();
        return field;
    }
    /**
     * Gets the value of the text box field.
     *
     * @returns {string} Text.
     * ```typescript
     * // Load an existing PDF document
     * let document: PdfDocument = new PdfDocument(data);
     * // Access text box field
     * let field: PdfTextBoxField = document.form.fieldAt(0) as PdfTextBoxField;
     * // Gets the text value from text box field
     * let text: string = field.text;
     * // Save the document
     * document.save('output.pdf');
     * // Destroy the document
     * document.destroy();
     * ```
     */
    get text() {
        if (typeof this._text === 'undefined') {
            if (this._isLoaded) {
                let text = _getInheritableProperty(this._dictionary, 'V', false, true, 'Parent');
                if (text) {
                    this._text = text;
                }
                else {
                    const widget = this.itemAt(this._defaultIndex);
                    if (widget) {
                        text = widget._dictionary.get('V');
                        if (text) {
                            this._text = text;
                        }
                    }
                }
            }
            else {
                this._text = '';
            }
        }
        return this._text;
    }
    /**
     * Sets the value of the text box field.
     *
     * @param {string} value Text.
     * ```typescript
     * // Load an existing PDF document
     * let document: PdfDocument = new PdfDocument(data);
     * // Access text box field
     * let field: PdfTextBoxField = document.form.fieldAt(0) as PdfTextBoxField;
     * // Sets the text value to text box field
     * field.text = ‘Syncfusion’;
     * // Save the document
     * document.save('output.pdf');
     * // Destroy the document
     * document.destroy();
     * ```
     */
    set text(value) {
        if (this._isLoaded) {
            if (!this.readOnly) {
                if (!(this._dictionary.has('V') && this._dictionary.get('V') === value)) {
                    this._dictionary.update('V', value);
                }
                const widget = this.itemAt(this._defaultIndex);
                if (widget && !(widget._dictionary.has('V') && widget._dictionary.get('V') === value)) {
                    widget._dictionary.update('V', value);
                }
            }
        }
        else if (this._text !== value) {
            this._dictionary.update('V', value);
            this._text = value;
        }
    }
    /**
     * Gets the text alignment in a text box.
     *
     * @returns {PdfTextAlignment} Text alignment.
     * ```typescript
     * // Load an existing PDF document
     * let document: PdfDocument = new PdfDocument(data);
     * // Access text box field
     * let field: PdfTextBoxField = document.form.fieldAt(0) as PdfTextBoxField;
     * // Gets the text alignment from text box field
     * let alignment: PdfTextAlignment = field.textAlignment;
     * // Save the document
     * document.save('output.pdf');
     * // Destroy the document
     * document.destroy();
     * ```
     */
    get textAlignment() {
        return this._getTextAlignment();
    }
    /**
     * Sets the text alignment in a text box.
     *
     * @param {PdfTextAlignment} value Text alignment.
     * ```typescript
     * // Load an existing PDF document
     * let document: PdfDocument = new PdfDocument(data);
     * // Access text box field
     * let field: PdfTextBoxField = document.form.fieldAt(0) as PdfTextBoxField;
     * // Sets the text alignment of form field as center
     * field.textAlignment = PdfTextAlignment.center;
     * // Save the document
     * document.save('output.pdf');
     * // Destroy the document
     * document.destroy();
     * ```
     */
    set textAlignment(value) {
        if (this._textAlignment !== value) {
            this._setTextAlignment(value);
        }
    }
    /**
     * Gets the default value of the field.
     *
     * @returns {string} Default value.
     * ```typescript
     * // Load an existing PDF document
     * let document: PdfDocument = new PdfDocument(data);
     * // Access text box field
     * let field: PdfTextBoxField = document.form.fieldAt(0) as PdfTextBoxField;
     * // Gets the default value from the text box field
     * let value: string = field.defaultValue;
     * // Save the document
     * document.save('output.pdf');
     * // Destroy the document
     * document.destroy();
     * ```
     */
    get defaultValue() {
        if (typeof this._defaultValue === 'undefined') {
            const text = _getInheritableProperty(this._dictionary, 'DV', false, true, 'Parent');
            if (text) {
                this._defaultValue = text;
            }
        }
        return this._defaultValue;
    }
    /**
     * Sets the default value of the field.
     *
     * @param {string} value Default value.
     * ```typescript
     * // Load an existing PDF document
     * let document: PdfDocument = new PdfDocument(data);
     * // Access text box field
     * let field: PdfTextBoxField = document.form.fieldAt(0) as PdfTextBoxField;
     * // Sets the default value of the text box field
     * field.defaultValue = 'Syncfusion';
     * // Save the document
     * document.save('output.pdf');
     * // Destroy the document
     * document.destroy();
     * ```
     */
    set defaultValue(value) {
        if (value !== this.defaultValue) {
            this._dictionary.update('DV', value);
            this._defaultValue = value;
        }
    }
    /**
     * Gets a value indicating whether this `PdfTextBoxField` is multiline.
     *
     * @returns {boolean} multiline.
     * ```typescript
     * // Load an existing PDF document
     * let document: PdfDocument = new PdfDocument(data);
     * // Access text box field
     * let field: PdfTextBoxField = document.form.fieldAt(0) as PdfTextBoxField;
     * // Gets a value indicating whether this `PdfTextBoxField` is multiline.
     * let multiLine: boolean = field.multiLine;
     * // Save the document
     * document.save('output.pdf');
     * // Destroy the document
     * document.destroy();
     * ```
     */
    get multiLine() {
        return (this._fieldFlags & _FieldFlag.multiLine) !== 0;
    }
    /**
     * Sets a value indicating whether this `PdfTextBoxField` is multiline.
     *
     * @param {boolean} value multiLine or not.
     * ```typescript
     * // Load an existing PDF document
     * let document: PdfDocument = new PdfDocument(data);
     * // Access text box field
     * let field: PdfTextBoxField = document.form.fieldAt(0) as PdfTextBoxField;
     * // Sets a value indicating whether this `PdfTextBoxField` is multiline.
     * field.multiLine = false;
     * // Save the document
     * document.save('output.pdf');
     * // Destroy the document
     * document.destroy();
     * ```
     */
    set multiLine(value) {
        if (value) {
            this._fieldFlags |= _FieldFlag.multiLine;
        }
        else {
            this._fieldFlags &= ~_FieldFlag.multiLine;
        }
    }
    /**
     * Gets a value indicating whether this `PdfTextBoxField` is password.
     *
     * @returns {boolean} password.
     * ```typescript
     * // Load an existing PDF document
     * let document: PdfDocument = new PdfDocument(data);
     * // Access text box field
     * let field: PdfTextBoxField = document.form.fieldAt(0) as PdfTextBoxField;
     * // Gets a value indicating whether this `PdfTextBoxField` is password.
     * let password: boolean = field.password;
     * // Save the document
     * document.save('output.pdf');
     * // Destroy the document
     * document.destroy();
     * ```
     */
    get password() {
        return (this._fieldFlags & _FieldFlag.password) !== 0;
    }
    /**
     * Sets a value indicating whether this `PdfTextBoxField` is password.
     *
     * @param {boolean} value password or not.
     * ```typescript
     * // Load an existing PDF document
     * let document: PdfDocument = new PdfDocument(data);
     * // Access text box field
     * let field: PdfTextBoxField = document.form.fieldAt(0) as PdfTextBoxField;
     * // Sets a value indicating whether this `PdfTextBoxField` is password.
     * field.password = false;
     * // Save the document
     * document.save('output.pdf');
     * // Destroy the document
     * document.destroy();
     * ```
     */
    set password(value) {
        if (value) {
            this._fieldFlags |= _FieldFlag.password;
        }
        else {
            this._fieldFlags &= ~_FieldFlag.password;
        }
    }
    /**
     * Gets a value indicating whether this `PdfTextBoxField` is scrollable.
     *
     * @returns {boolean} scrollable.
     * ```typescript
     * // Load an existing PDF document
     * let document: PdfDocument = new PdfDocument(data);
     * // Access text box field
     * let field: PdfTextBoxField = document.form.fieldAt(0) as PdfTextBoxField;
     * // Gets a value indicating whether this `PdfTextBoxField` is scrollable.
     * let scrollable: boolean = field.scrollable;
     * // Save the document
     * document.save('output.pdf');
     * // Destroy the document
     * document.destroy();
     * ```
     */
    get scrollable() {
        return !((this._fieldFlags & _FieldFlag.doNotScroll) !== 0);
    }
    /**
     * Sets a value indicating whether this `PdfTextBoxField` is scrollable.
     *
     * @param {boolean} value scrollable or not.
     * ```typescript
     * // Load an existing PDF document
     * let document: PdfDocument = new PdfDocument(data);
     * // Access text box field
     * let field: PdfTextBoxField = document.form.fieldAt(0) as PdfTextBoxField;
     * // Sets a value indicating whether this `PdfTextBoxField` is scrollable.
     * field.scrollable = false;
     * // Save the document
     * document.save('output.pdf');
     * // Destroy the document
     * document.destroy();
     * ```
     */
    set scrollable(value) {
        if (value) {
            this._fieldFlags &= ~_FieldFlag.doNotScroll;
        }
        else {
            this._fieldFlags |= _FieldFlag.doNotScroll;
        }
    }
    /**
     * Gets a value indicating whether to check spelling.
     *
     * @returns {boolean} spellCheck.
     * ```typescript
     * // Load an existing PDF document
     * let document: PdfDocument = new PdfDocument(data);
     * // Access text box field
     * let field: PdfTextBoxField = document.form.fieldAt(0) as PdfTextBoxField;
     * // Gets a value indicating whether to check spelling
     * let spellCheck: boolean = field.spellCheck;
     * // Save the document
     * document.save('output.pdf');
     * // Destroy the document
     * document.destroy();
     * ```
     */
    get spellCheck() {
        return !((this._fieldFlags & _FieldFlag.doNotSpellCheck) !== 0);
    }
    /**
     * Sets a value indicating whether to check spelling.
     *
     * @param {boolean} value spellCheck or not.
     * ```typescript
     * // Load an existing PDF document
     * let document: PdfDocument = new PdfDocument(data);
     * // Access text box field
     * let field: PdfTextBoxField = document.form.fieldAt(0) as PdfTextBoxField;
     * // Sets a value indicating whether to check spelling
     * field.spellCheck = false;
     * // Save the document
     * document.save('output.pdf');
     * // Destroy the document
     * document.destroy();
     * ```
     */
    set spellCheck(value) {
        if (value) {
            this._fieldFlags &= ~_FieldFlag.doNotSpellCheck;
        }
        else {
            this._fieldFlags |= _FieldFlag.doNotSpellCheck;
        }
    }
    /**
     * Meaningful only if the MaxLength property is set and the Multiline, Password properties are false.
     * If set, the field is automatically divided into as many equally spaced positions, or combs,
     * as the value of MaxLength, and the text is laid out into those combs.
     *
     * @returns {boolean} insertSpaces.
     * ```typescript
     * // Load an existing PDF document
     * let document: PdfDocument = new PdfDocument(data);
     * // Access text box field
     * let field: PdfTextBoxField = document.form.fieldAt(0) as PdfTextBoxField;
     * // Gets a value indicating whether this `PdfTextBoxField` is insertSpaces.
     * let insertSpaces: boolean = field.insertSpaces;
     * // Save the document
     * document.save('output.pdf');
     * // Destroy the document
     * document.destroy();
     * ```
     */
    get insertSpaces() {
        const flags = this._fieldFlags;
        return ((_FieldFlag.comb & flags) !== 0) &&
            ((flags & _FieldFlag.multiLine) === 0) &&
            ((flags & _FieldFlag.password) === 0) &&
            ((flags & _FieldFlag.fileSelect) === 0);
    }
    /**
     * Meaningful only if the MaxLength property is set and the Multiline, Password properties are false.
     * If set, the field is automatically divided into as many equally spaced positions, or combs,
     * as the value of MaxLength, and the text is laid out into those combs.
     *
     * @param {boolean} value insertSpaces.
     * ```typescript
     * // Load an existing PDF document
     * let document: PdfDocument = new PdfDocument(data);
     * // Access text box field
     * let field: PdfTextBoxField = document.form.fieldAt(0) as PdfTextBoxField;
     * // Sets a value indicating whether this `PdfTextBoxField` is insertSpaces.
     * field.insertSpaces = false;
     * // Save the document
     * document.save('output.pdf');
     * // Destroy the document
     * document.destroy();
     * ```
     */
    set insertSpaces(value) {
        if (value) {
            this._fieldFlags |= _FieldFlag.comb;
        }
        else {
            this._fieldFlags &= ~_FieldFlag.comb;
        }
    }
    /**
     * Gets the highlight mode of the field.
     *
     * @returns {PdfHighlightMode} highlight mode.
     * ```typescript
     * // Load an existing PDF document
     * let document: PdfDocument = new PdfDocument(data);
     * // Access text box field
     * let field: PdfTextBoxField = document.form.fieldAt(0) as PdfTextBoxField;
     * // Gets the highlight mode of text box field
     * let mode: PdfHighlightMode = field.highlightMode;
     * // Save the document
     * document.save('output.pdf');
     * // Destroy the document
     * document.destroy();
     * ```
     */
    get highlightMode() {
        const widget = this.itemAt(this._defaultIndex);
        let mode;
        if (widget && typeof widget.highlightMode !== 'undefined') {
            mode = widget.highlightMode;
        }
        else if (this._dictionary.has('H')) {
            const name = this._dictionary.get('H');
            mode = _mapHighlightMode(name.name);
        }
        return (typeof mode !== 'undefined') ? mode : PdfHighlightMode.noHighlighting;
    }
    /**
     * Sets the highlight mode of the field.
     *
     * @param {PdfHighlightMode} value highlight mode.
     * ```typescript
     * // Load an existing PDF document
     * let document: PdfDocument = new PdfDocument(data);
     * // Access text box field
     * let field: PdfTextBoxField = document.form.fieldAt(0) as PdfTextBoxField;
     * // Sets the highlight mode of text box field as outline
     * field.highlightMode = PdfHighlightMode.outline;
     * // Save the document
     * document.save('output.pdf');
     * // Destroy the document
     * document.destroy();
     * ```
     */
    set highlightMode(value) {
        const widget = this.itemAt(this._defaultIndex);
        if (widget && (typeof widget.highlightMode === 'undefined' || widget.highlightMode !== value)) {
            widget.highlightMode = value;
        }
        else if (!this._dictionary.has('H') || _mapHighlightMode(this._dictionary.get('H')) !== value) {
            this._dictionary.update('H', _reverseMapHighlightMode(value));
        }
    }
    /**
     * Gets the maximum length of the field, in characters.
     *
     * @returns {number} maximum length.
     * ```typescript
     * // Load an existing PDF document
     * let document: PdfDocument = new PdfDocument(data);
     * // Access text box field
     * let field: PdfTextBoxField = document.form.fieldAt(0) as PdfTextBoxField;
     * // Gets the maximum length of the field, in characters.
     * let maxLength: number = field.maxLength;
     * // Save the document
     * document.save('output.pdf');
     * // Destroy the document
     * document.destroy();
     * ```
     */
    get maxLength() {
        if (typeof this._maxLength === 'undefined') {
            const length = _getInheritableProperty(this._dictionary, 'MaxLen', false, true, 'Parent');
            this._maxLength = (typeof length !== 'undefined' && Number.isInteger(length)) ? length : 0;
        }
        return this._maxLength;
    }
    /**
     * Sets the maximum length of the field, in characters.
     *
     * @param {number} value maximum length.
     * ```typescript
     * // Load an existing PDF document
     * let document: PdfDocument = new PdfDocument(data);
     * // Access text box field
     * let field: PdfTextBoxField = document.form.fieldAt(0) as PdfTextBoxField;
     * // Sets the maximum length of the field, in characters.
     * field.maxLength = 20;
     * // Save the document
     * document.save('output.pdf');
     * // Destroy the document
     * document.destroy();
     * ```
     */
    set maxLength(value) {
        if (this.maxLength !== value) {
            this._dictionary.update('MaxLen', value);
            this._maxLength = value;
        }
    }
    /**
     * Gets the flag indicating whether the auto resize text enabled or not.
     * Note: Applicable only for newly created PDF fields.
     *
     * @returns {boolean} Enable or disable auto resize text.
     * ```typescript
     * // Load an existing PDF document
     * let document: PdfDocument = new PdfDocument(data);
     * // Access text box field
     * let field: PdfTextBoxField = document.form.fieldAt(0) as PdfTextBoxField;
     * // Gets the flag indicating whether the auto resize text enabled or not.
     * let isAutoResize: boolean = field.isAutoResizeText;
     * // Save the document
     * document.save('output.pdf');
     * // Destroy the document
     * document.destroy();
     * ```
     */
    get isAutoResizeText() {
        return this._autoResizeText;
    }
    /**
     * Sets the flag indicating whether the auto resize text enabled or not.
     * Note: Applicable only for newly created PDF fields.
     *
     * @param {boolean} value Enable or disable auto resize text.
     * ```typescript
     * // Load an existing PDF document
     * let document: PdfDocument = new PdfDocument(data);
     * // Access text box field
     * let field: PdfTextBoxField = document.form.fieldAt(0) as PdfTextBoxField;
     * // Sets the flag indicating whether the auto resize text enabled or not.
     * field.isAutoResizeText = false;
     * // Save the document
     * document.save('output.pdf');
     * // Destroy the document
     * document.destroy();
     * ```
     */
    set isAutoResizeText(value) {
        this._autoResizeText = value;
        const widget = this.itemAt(this._defaultIndex);
        if (widget) {
            widget._isAutoResize = value;
        }
    }
    /**
     * Gets the font of the field.
     *
     * @returns {PdfFont} font.
     *
     * ```typescript
     * // Load an existing PDF document
     * let document: PdfDocument = new PdfDocument(data, password);
     * // Access the form field at index 0
     * let field: PdfTextBoxField = document.form.fieldAt(0) as PdfTextBoxField;
     * // Gets the font of the field.
     * let font: PdfFont = field.font;
     * // Save the document
     * document.save('output.pdf');
     * // Destroy the document
     * document.destroy();
     * ```
     */
    get font() {
        if (this._font) {
            return this._font;
        }
        else {
            const widget = this.itemAt(this._defaultIndex);
            this._font = _obtainFontDetails(this._form, widget, this);
        }
        return this._font;
    }
    /**
     * Sets the font of the field.
     *
     * @param {PdfFont} value font.
     *
     * ```typescript
     * // Load an existing PDF document
     * let document: PdfDocument = new PdfDocument(data, password);
     * // Access the form field at index 0
     * let field: PdfTextBoxField = document.form.fieldAt(0) as PdfTextBoxField;
     * // Sets the font of the field
     * field.font = new PdfStandardFont(PdfFontFamily.helvetica, 12, PdfFontStyle.bold);
     * // Save the document
     * document.save('output.pdf');
     * // Destroy the document
     * document.destroy();
     * ```
     */
    set font(value) {
        if (value && value instanceof PdfFont) {
            this._font = value;
            this._initializeFont(value);
        }
    }
    /**
     * Gets the background color of the field.
     *
     * @returns {number[]} R, G, B color values in between 0 to 255.
     * ```typescript
     * // Load an existing PDF document
     * let document: PdfDocument = new PdfDocument(data, password);
     * // Access the form field at index 0
     * let field: PdfField = document.form.fieldAt(0);
     * // Gets the background color of the field.
     * let backColor: number[] = field.backColor;
     * // Save the document
     * document.save('output.pdf');
     * // Destroy the document
     * document.destroy();
     * ```
     */
    get backColor() {
        return this._parseBackColor(true);
    }
    /**
     * Sets the background color of the field.
     *
     * @param {number[]} value Array with R, G, B, A color values in between 0 to 255. For optional A (0-254), it signifies transparency.
     * ```typescript
     * // Load an existing PDF document
     * let document: PdfDocument = new PdfDocument(data, password);
     * // Access the text box field at index 0
     * let firstName: PdfField = document.form.fieldAt(0);
     * // Sets the background color of the field.
     * firstName.backColor = [255, 0, 0];
     * // Access the text box field at index 1
     * let secondName: PdfField = document.form.fieldAt(1);
     * // Sets the background color of the field to transparent.
     * secondName.backColor = [0, 0, 0, 0];
     * // Save the document
     * document.save('output.pdf');
     * // Destroy the document
     * document.destroy();
     * ```
     */
    set backColor(value) {
        this._updateBackColor(value, true);
    }
    _initialize(page, name, bounds) {
        this._crossReference = page._crossReference;
        this._page = page;
        this._name = name;
        this._text = '';
        this._defaultValue = '';
        this._defaultIndex = 0;
        this._spellCheck = false;
        this._insertSpaces = false;
        this._multiline = false;
        this._password = false;
        this._scrollable = false;
        this._dictionary = new _PdfDictionary(this._crossReference);
        this._ref = this._crossReference._getNextReference();
        this._crossReference._cacheMap.set(this._ref, this._dictionary);
        this._dictionary.objId = this._ref.toString();
        this._dictionary.update('FT', _PdfName.get('Tx'));
        this._dictionary.update('T', name);
        this._fieldFlags |= _FieldFlag.doNotSpellCheck;
        this._initializeFont(this._defaultFont);
        this._createItem(bounds);
    }
    _createItem(bounds) {
        const widget = new PdfWidgetAnnotation();
        widget._create(this._page, bounds, this);
        widget.textAlignment = PdfTextAlignment.left;
        this._stringFormat = new PdfStringFormat(widget.textAlignment, PdfVerticalAlignment.middle);
        widget._dictionary.update('MK', new _PdfDictionary(this._crossReference));
        widget._mkDictionary.update('BC', [0, 0, 0]);
        widget._mkDictionary.update('BG', [1, 1, 1]);
        widget._mkDictionary.update('CA', this.actualName);
        this._addToKid(widget);
    }
    _doPostProcess(isFlatten = false) {
        if (isFlatten || this._setAppearance || this._form._setAppearance) {
            const count = this._kidsCount;
            if (this._isLoaded) {
                if (count > 0) {
                    for (let i = 0; i < count; i++) {
                        const item = this.itemAt(i);
                        if (item) {
                            this._postProcess(isFlatten, item);
                        }
                    }
                }
                else if ((isFlatten || this._form._setAppearance || this._setAppearance) && !this._checkFieldFlag(this._dictionary)) {
                    this._postProcess(isFlatten);
                }
            }
            else if (isFlatten || this._form._setAppearance || this._setAppearance) {
                for (let i = 0; i < count; i++) {
                    const item = this.itemAt(i);
                    if (item && !this._checkFieldFlag(item._dictionary)) {
                        const template = this._createAppearance(isFlatten, item);
                        if (isFlatten) {
                            this._drawTemplate(template, item._page, { x: item.bounds.x, y: item.bounds.y, width: template._size[0], height: template._size[1] });
                        }
                        else {
                            this._addAppearance(item._dictionary, template, 'N');
                        }
                        item._dictionary._updated = !isFlatten;
                    }
                }
            }
            if (isFlatten) {
                this._dictionary._updated = false;
            }
        }
    }
    _postProcess(isFlatten, widget) {
        let template;
        let bounds;
        const source = widget ? widget : this;
        if (this._form._setAppearance || this._setAppearance || (isFlatten && !source._dictionary.has('AP'))) {
            template = this._createAppearance(isFlatten, source);
        }
        else if (source._dictionary.has('AP')) {
            let appearanceStream;
            const dictionary = source._dictionary.get('AP');
            if (dictionary && dictionary.has('N')) {
                appearanceStream = dictionary.get('N');
                const reference = dictionary.getRaw('N');
                if (reference) {
                    appearanceStream.reference = reference;
                }
                if (appearanceStream) {
                    template = new PdfTemplate(appearanceStream, this._crossReference);
                }
            }
        }
        if (template) {
            if (isFlatten) {
                const page = source instanceof PdfWidgetAnnotation ? source._getPage() : source.page;
                if (page) {
                    const graphics = page.graphics;
                    graphics.save();
                    if (page.rotation === PdfRotationAngle.angle90) {
                        graphics.translateTransform(graphics._size[0], graphics._size[1]);
                        graphics.rotateTransform(90);
                    }
                    else if (page.rotation === PdfRotationAngle.angle180) {
                        graphics.translateTransform(graphics._size[0], graphics._size[1]);
                        graphics.rotateTransform(-180);
                    }
                    else if (page.rotation === PdfRotationAngle.angle270) {
                        graphics.translateTransform(graphics._size[0], graphics._size[1]);
                        graphics.rotateTransform(270);
                    }
                    bounds = { x: source.bounds.x, y: source.bounds.y, width: template._size[0], height: template._size[1] };
                    graphics._drawTemplate(template, bounds);
                    graphics.restore();
                }
                source._dictionary._updated = false;
            }
            else {
                this._addAppearance(source._dictionary, template, 'N');
            }
        }
    }
    _createAppearance(isFlatten, widget) {
        const bounds = widget.bounds;
        const template = new PdfTemplate([0, 0, bounds.width, bounds.height], this._crossReference);
        _setMatrix(template, null);
        template._writeTransformation = false;
        const graphics = template.graphics;
        const parameter = new _PaintParameter();
        parameter.bounds = [0, 0, bounds.width, bounds.height];
        const backcolor = widget.backColor;
        if (isFlatten && backcolor) {
            parameter.backBrush = new PdfBrush(backcolor);
        }
        parameter.foreBrush = new PdfBrush(widget.color);
        const border = widget.border;
        parameter.borderPen = new PdfPen(widget.borderColor, border.width);
        parameter.borderStyle = border.style;
        parameter.borderWidth = border.width;
        if (backcolor) {
            const shadowColor = [backcolor[0] - 64, backcolor[1] - 64, backcolor[2] - 64];
            const color = [shadowColor[0] >= 0 ? shadowColor[0] : 0,
                shadowColor[1] >= 0 ? shadowColor[1] : 0,
                shadowColor[2] >= 0 ? shadowColor[2] : 0];
            parameter.shadowBrush = new PdfBrush(color);
        }
        parameter.rotationAngle = widget.rotate;
        parameter.insertSpaces = this.insertSpaces;
        let text = this.text;
        if (text === null || typeof text === 'undefined') {
            text = '';
        }
        if (this.password) {
            let password = '';
            for (let i = 0; i < text.length; i++) {
                password += '*';
            }
            text = password;
        }
        parameter.required = this.required;
        if (!this.required) {
            graphics._sw._beginMarkupSequence('Tx');
            graphics._initializeCoordinates();
        }
        if (typeof this._font === 'undefined' || this._font === null) {
            this._font = this._defaultFont;
        }
        if (typeof this._stringFormat === 'undefined' || this._stringFormat === null) {
            if (typeof this.textAlignment === 'undefined' || this.textAlignment === null) {
                this._stringFormat = new PdfStringFormat(this.textAlignment, PdfVerticalAlignment.middle);
            }
            else {
                this._stringFormat = new PdfStringFormat(PdfTextAlignment.left, PdfVerticalAlignment.middle);
            }
        }
        this._drawTextBox(graphics, parameter, text, this._font, this._stringFormat, this.multiLine, this.scrollable, this.maxLength);
        if (!this.required) {
            graphics._sw._endMarkupSequence();
        }
        return template;
    }
    _drawTextBox(g, parameter, text, font, format, multiline, scroll, maxLength) {
        if (typeof maxLength !== 'undefined') {
            if (parameter.insertSpaces) {
                let width = 0;
                if (typeof maxLength !== 'undefined' && maxLength > 0) {
                    width = parameter.bounds[2] / maxLength;
                    g.drawRectangle(parameter.bounds[0], parameter.bounds[1], parameter.bounds[2], parameter.bounds[3], parameter.borderPen, parameter.backBrush);
                    const current = text;
                    for (let i = 0; i < maxLength; i++) {
                        if (format.alignment === PdfTextAlignment.right) {
                            if (maxLength - current.length <= i) {
                                text = current[i - (maxLength - current.length)];
                            }
                            else {
                                text = '';
                            }
                        }
                        else {
                            if (format.alignment === PdfTextAlignment.center && current.length < maxLength) {
                                const startlocation = maxLength / 2 - (Math.ceil(current.length / 2));
                                if (i >= startlocation && i < startlocation + current.length) {
                                    text = current[i - startlocation];
                                }
                                else {
                                    text = '';
                                }
                            }
                            else {
                                if (current.length > i) {
                                    text = current[Number.parseInt(i.toString(), 10)];
                                }
                                else {
                                    text = '';
                                }
                            }
                        }
                        parameter.bounds[2] = width;
                        format.alignment = PdfTextAlignment.center;
                        this._drawTextBox(g, parameter, text, font, format, multiline, scroll);
                        parameter.bounds[0] = parameter.bounds[0] + width;
                        if (parameter.borderWidth) {
                            g.drawLine(parameter.borderPen, parameter.bounds[0], parameter.bounds[1], parameter.bounds[0], parameter.bounds[1] + parameter.bounds[3]);
                        }
                    }
                }
                else {
                    this._drawTextBox(g, parameter, text, font, format, multiline, scroll);
                }
            }
            else {
                this._drawTextBox(g, parameter, text, font, format, multiline, scroll);
            }
        }
        else {
            if (g._isTemplateGraphics && parameter.required) {
                g.save();
                g._initializeCoordinates();
            }
            if (!parameter.insertSpaces) {
                this._drawRectangularControl(g, parameter);
            }
            if (g._isTemplateGraphics && parameter.required) {
                g.restore();
                g.save();
                g._sw._beginMarkupSequence('Tx');
                g._initializeCoordinates();
            }
            let rectangle = parameter.bounds;
            if (parameter.borderStyle === PdfBorderStyle.beveled || parameter.borderStyle === PdfBorderStyle.inset) {
                rectangle[0] = rectangle[0] + 4 * parameter.borderWidth;
                rectangle[2] = rectangle[2] - 8 * parameter.borderWidth;
            }
            else {
                rectangle[0] = rectangle[0] + 2 * parameter.borderWidth;
                rectangle[2] = rectangle[2] - 4 * parameter.borderWidth;
            }
            if (multiline) {
                const tempheight = (typeof format === 'undefined' || format === null || format.lineSpacing === 0) ?
                    font._metrics._getHeight() :
                    format.lineSpacing;
                const ascent = font._metrics._getAscent(format);
                const shift = tempheight - ascent;
                if (text.indexOf('\n') !== -1) {
                    if (rectangle[0] === 0 && rectangle[1] === 1) {
                        rectangle[1] = -(rectangle[1] - shift);
                    }
                }
                else if (rectangle[0] === 0 && rectangle[1] === 1) {
                    rectangle[1] = -(rectangle[1] - shift);
                }
                if (parameter.isAutoFontSize) {
                    if (parameter.borderWidth !== 0) {
                        rectangle[1] = rectangle[1] + 2.5 * parameter.borderWidth;
                    }
                }
            }
            if ((g._page &&
                typeof g._page.rotation !== 'undefined' &&
                g._page.rotation !== PdfRotationAngle.angle0) ||
                parameter.rotationAngle > 0) {
                const state = g.save();
                if (typeof parameter.pageRotationAngle !== 'undefined' && parameter.pageRotationAngle !== PdfRotationAngle.angle0) {
                    if (parameter.pageRotationAngle === PdfRotationAngle.angle90) {
                        g.translateTransform(g._size[1], 0);
                        g.rotateTransform(90);
                        const y = g._size[1] - (rectangle[0] + rectangle[2]);
                        const x = rectangle[1];
                        rectangle = [x, y, rectangle[3], rectangle[2]];
                    }
                    else if (parameter.pageRotationAngle === PdfRotationAngle.angle180) {
                        g.translateTransform(g._size[0], g._size[1]);
                        g.rotateTransform(-180);
                        const x = g._size[0] - (rectangle[0] + rectangle[2]);
                        const y = g._size[1] - (rectangle[1] + rectangle[3]);
                        rectangle = [x, y, rectangle[2], rectangle[3]];
                    }
                    else if (parameter.pageRotationAngle === PdfRotationAngle.angle270) {
                        g.translateTransform(0, g._size[0]);
                        g.rotateTransform(270);
                        const x = g._size[0] - (rectangle[1] + rectangle[3]);
                        const y = rectangle[0];
                        rectangle = [x, y, rectangle[3], rectangle[2]];
                    }
                }
                if (parameter.rotationAngle) {
                    if (parameter.rotationAngle === 90) {
                        if (parameter.pageRotationAngle === PdfRotationAngle.angle90) {
                            g.translateTransform(0, g._size[1]);
                            g.rotateTransform(-90);
                            const x = g._size[1] - (rectangle[1] + rectangle[3]);
                            const y = rectangle[0];
                            rectangle = [x, y, rectangle[3], rectangle[2]];
                        }
                        else {
                            if (rectangle[2] > rectangle[3]) {
                                g.translateTransform(0, g._size[1]);
                                g.rotateTransform(-90);
                                rectangle = [parameter.bounds[0], parameter.bounds[1], parameter.bounds[2], parameter.bounds[3]];
                            }
                            else {
                                const z = rectangle[0];
                                rectangle[0] = -(rectangle[1] + rectangle[3]);
                                rectangle[1] = z;
                                const height = rectangle[3];
                                rectangle[3] = rectangle[2] > font._metrics._getHeight() ? rectangle[2] : font._metrics._getHeight();
                                rectangle[2] = height;
                                g.rotateTransform(-90);
                            }
                        }
                    }
                    else if (parameter.rotationAngle === 270) {
                        g.translateTransform(g._size[0], 0);
                        g.rotateTransform(-270);
                        const x = rectangle[1];
                        const y = g._size[0] - (rectangle[0] + rectangle[2]);
                        rectangle = [x, y, rectangle[3], rectangle[2]];
                    }
                    else if (parameter.rotationAngle === 180) {
                        g.translateTransform(g._size[0], g._size[1]);
                        g.rotateTransform(-180);
                        const x = g._size[0] - (rectangle[0] + rectangle[2]);
                        const y = g._size[1] - (rectangle[1] + rectangle[3]);
                        rectangle = [x, y, rectangle[2], rectangle[3]];
                    }
                }
                g.drawString(text, font, rectangle, null, parameter.foreBrush, format);
                g.restore(state);
            }
            else {
                g.drawString(text, font, rectangle, null, parameter.foreBrush, format);
            }
            if (g._isTemplateGraphics && parameter.required) {
                g._sw._endMarkupSequence();
                g.restore();
            }
        }
    }
}
/**
 * `PdfButtonField` class represents the button field objects.
 * ```typescript
 * // Load an existing PDF document
 * let document: PdfDocument = new PdfDocument(data);
 * // Gets the first page of the document
 * let page: PdfPage = document.getPage(0);
 * // Access the PDF form
 * let form: PdfForm = document.form;
 * // Create a new button field
 * let field: PdfButtonField = new PdfButtonField(page , 'Button1', {x: 100, y: 40, width: 100, height: 20});
 * // Add the field into PDF form
 * form.add(field);
 * // Save the document
 * document.save('output.pdf');
 * // Destroy the document
 * document.destroy();
 * ```
 */
class PdfButtonField extends PdfField {
    constructor(page, name, bounds) {
        super();
        if (page && name && bounds) {
            this._initialize(page, name, bounds);
        }
    }
    /**
     * Gets value of the text box field.
     *
     * @returns {string} Text.
     * ```typescript
     * // Load an existing PDF document
     * let document: PdfDocument = new PdfDocument(data);
     * // Access text box field
     * let field: PdfButtonField = document.form.fieldAt(0) as PdfButtonField;
     * // Gets the text value from button field
     * let text: string = field.text;
     * // Save the document
     * document.save('output.pdf');
     * // Destroy the document
     * document.destroy();
     * ```
     */
    get text() {
        if (this._isLoaded) {
            if (typeof this._text === 'undefined') {
                const widget = this.itemAt(this._defaultIndex);
                if (widget && widget._mkDictionary && widget._mkDictionary.has('CA')) {
                    this._text = widget._mkDictionary.get('CA');
                }
                else if (this._mkDictionary && this._mkDictionary.has('CA')) {
                    this._text = this._mkDictionary.get('CA');
                }
            }
            if (typeof this._text === 'undefined') {
                const value = _getInheritableProperty(this._dictionary, 'V', false, true, 'Parent');
                if (value) {
                    this._text = value;
                }
            }
        }
        if (typeof this._text === 'undefined') {
            this._text = '';
        }
        return this._text;
    }
    /**
     * Sets value of the text box field.
     *
     * @param {string} value Text.
     * ```typescript
     * // Load an existing PDF document
     * let document: PdfDocument = new PdfDocument(data);
     * // Access button field
     * let field: PdfButtonField = document.form.fieldAt(0) as PdfButtonField;
     * // Sets the text value of form field
     * field.text = ’Click to submit’;
     * // Save the document
     * document.save('output.pdf');
     * // Destroy the document
     * document.destroy();
     * ```
     */
    set text(value) {
        if (this._isLoaded && !this.readOnly) {
            const widget = this.itemAt(this._defaultIndex);
            if (widget && widget._dictionary) {
                this._assignText(widget._dictionary, value);
            }
            else {
                this._assignText(this._dictionary, value);
            }
        }
        if (!this._isLoaded && this._text !== value) {
            const widget = this.itemAt(this._defaultIndex);
            this._assignText(widget._dictionary, value);
            this._text = value;
        }
    }
    /**
     * Gets the text alignment in a button field.
     *
     * @returns {PdfTextAlignment} Text alignment.
     * ```typescript
     * // Load an existing PDF document
     * let document: PdfDocument = new PdfDocument(data);
     * // Access button field
     * let field: PdfButtonField = document.form.fieldAt(0) as PdfButtonField;
     * // Gets the text alignment from button field
     * let alignment: PdfTextAlignment = field.textAlignment;
     * // Save the document
     * document.save('output.pdf');
     * // Destroy the document
     * document.destroy();
     * ```
     */
    get textAlignment() {
        return this._getTextAlignment();
    }
    /**
     * Sets the text alignment in a button field.
     *
     * @param {PdfTextAlignment} value Text alignment.
     * ```typescript
     * // Load an existing PDF document
     * let document: PdfDocument = new PdfDocument(data);
     * // Access button field
     * let field: PdfButtonField = document.form.fieldAt(0) as PdfButtonField;
     * // Sets the text alignment of form field as center
     * field.textAlignment = PdfTextAlignment.center;
     * // Save the document
     * document.save('output.pdf');
     * // Destroy the document
     * document.destroy();
     * ```
     */
    set textAlignment(value) {
        if (this._textAlignment !== value) {
            this._setTextAlignment(value);
        }
    }
    /**
     * Gets the highlight mode of the field.
     *
     * @returns {PdfHighlightMode} highlight mode.
     * ```typescript
     * // Load an existing PDF document
     * let document: PdfDocument = new PdfDocument(data);
     * // Access button field
     * let field: PdfButtonField = document.form.fieldAt(0) as PdfButtonField;
     * // Gets the highlight mode from button field
     * let highlightMode: PdfHighlightMode = field. highlightMode;
     * // Save the document
     * document.save('output.pdf');
     * // Destroy the document
     * document.destroy();
     * ```
     */
    get highlightMode() {
        const widget = this.itemAt(this._defaultIndex);
        let mode;
        if (widget && typeof widget.highlightMode !== 'undefined') {
            mode = widget.highlightMode;
        }
        else if (this._dictionary.has('H')) {
            const highlight = this._dictionary.get('H');
            mode = _mapHighlightMode(highlight.name);
        }
        return (typeof mode !== 'undefined') ? mode : PdfHighlightMode.invert;
    }
    /**
     * Sets the highlight mode of the field.
     *
     * @param {PdfHighlightMode} value highlight mode.
     * ```typescript
     * // Load an existing PDF document
     * let document: PdfDocument = new PdfDocument(data);
     * // Access button field
     * let field: PdfButtonField = document.form.fieldAt(0) as PdfButtonField;
     * // Sets the highlight mode of button field as outline
     * field.highlightMode = PdfHighlightMode.outline;
     * // Save the document
     * document.save('output.pdf');
     * // Destroy the document
     * document.destroy();
     * ```
     */
    set highlightMode(value) {
        const widget = this.itemAt(this._defaultIndex);
        if (widget && (typeof widget.highlightMode === 'undefined' || widget.highlightMode !== value)) {
            widget.highlightMode = value;
        }
        else if (!this._dictionary.has('H') || _mapHighlightMode(this._dictionary.get('H')) !== value) {
            this._dictionary.update('H', _reverseMapHighlightMode(value));
        }
    }
    /**
     * Gets the font of the field.
     *
     * @returns {PdfFont} font.
     *
     * ```typescript
     * // Load an existing PDF document
     * let document: PdfDocument = new PdfDocument(data, password);
     * // Access the form field at index 0
     * let field: PdfButtonField = document.form.fieldAt(0) as PdfButtonField;
     * // Gets the font of the field.
     * let font: PdfFont = field.font;
     * // Save the document
     * document.save('output.pdf');
     * // Destroy the document
     * document.destroy();
     * ```
     */
    get font() {
        if (this._font) {
            return this._font;
        }
        else {
            const widget = this.itemAt(this._defaultIndex);
            this._font = _obtainFontDetails(this._form, widget, this);
        }
        return this._font;
    }
    /**
     * Sets the font of the field.
     *
     * @param {PdfFont} value font.
     *
     * ```typescript
     * // Load an existing PDF document
     * let document: PdfDocument = new PdfDocument(data, password);
     * // Access the form field at index 0
     * let field: PdfButtonField = document.form.fieldAt(0) as PdfButtonField;
     * // Sets the font of the field
     * field.font = new PdfStandardFont(PdfFontFamily.helvetica, 12, PdfFontStyle.bold);
     * // Save the document
     * document.save('output.pdf');
     * // Destroy the document
     * document.destroy();
     * ```
     */
    set font(value) {
        if (value && value instanceof PdfFont) {
            this._font = value;
            this._initializeFont(value);
        }
    }
    /**
     * Gets the background color of the field.
     *
     * @returns {number[]} R, G, B color values in between 0 to 255.
     * ```typescript
     * // Load an existing PDF document
     * let document: PdfDocument = new PdfDocument(data, password);
     * // Access the form field at index 0
     * let field: PdfField = document.form.fieldAt(0);
     * // Gets the background color of the field.
     * let backColor: number[] = field.backColor;
     * // Save the document
     * document.save('output.pdf');
     * // Destroy the document
     * document.destroy();
     * ```
     */
    get backColor() {
        return this._parseBackColor(true);
    }
    /**
     * Sets the background color of the field.
     *
     * @param {number[]} value Array with R, G, B, A color values in between 0 to 255. For optional A (0-254), it signifies transparency.
     * ```typescript
     * // Load an existing PDF document
     * let document: PdfDocument = new PdfDocument(data, password);
     * // Access the button field at index 0
     * let submitButton: PdfField = document.form.fieldAt(0);
     * // Sets the background color of the field.
     * submitButton.backColor = [255, 0, 0];
     * // Access the button field at index 1
     * let cancelButton: PdfField = document.form.fieldAt(1);
     * // Sets the background color of the field to transparent.
     * cancelButton.backColor = [0, 0, 0, 0];
     * // Save the document
     * document.save('output.pdf');
     * // Destroy the document
     * document.destroy();
     * ```
     */
    set backColor(value) {
        this._updateBackColor(value, true);
    }
    _assignText(fieldDictionary, value) {
        let dictionary;
        if (fieldDictionary.has('MK')) {
            dictionary = fieldDictionary.get('MK');
        }
        else {
            dictionary = new _PdfDictionary(this._crossReference);
            fieldDictionary.set('MK', dictionary);
        }
        dictionary.update('CA', value);
        fieldDictionary._updated = true;
    }
    /**
     * Parse an existing button field.
     *
     * @private
     * @param {PdfForm} form Form object.
     * @param {_PdfDictionary} dictionary Field dictionary.
     * @param {_PdfCrossReference} crossReference Cross reference object.
     * @param {_PdfReference} reference Field reference.
     * @returns {PdfButtonField} Button field.
     */
    static _load(form, dictionary, crossReference, reference) {
        const field = new PdfButtonField();
        field._isLoaded = true;
        field._form = form;
        field._dictionary = dictionary;
        field._crossReference = crossReference;
        field._ref = reference;
        if (field._dictionary.has('Kids')) {
            field._kids = field._dictionary.get('Kids');
        }
        field._defaultIndex = 0;
        field._parsedItems = new Map();
        return field;
    }
    _initialize(page, name, bounds) {
        this._crossReference = page._crossReference;
        this._page = page;
        this._name = name;
        this._defaultIndex = 0;
        this._dictionary = new _PdfDictionary(this._crossReference);
        this._ref = this._crossReference._getNextReference();
        this._crossReference._cacheMap.set(this._ref, this._dictionary);
        this._dictionary.objId = this._ref.toString();
        this._dictionary.update('FT', _PdfName.get('Btn'));
        this._dictionary.update('T', name);
        this._fieldFlags |= _FieldFlag.pushButton;
        this._initializeFont(this._defaultFont);
        this._createItem(bounds);
    }
    _createItem(bounds) {
        const widget = new PdfWidgetAnnotation();
        widget._create(this._page, bounds, this);
        widget.textAlignment = PdfTextAlignment.center;
        this._stringFormat = new PdfStringFormat(widget.textAlignment, PdfVerticalAlignment.middle);
        widget._dictionary.update('MK', new _PdfDictionary(this._crossReference));
        widget._mkDictionary.update('BC', [0, 0, 0]);
        widget._mkDictionary.update('BG', [.827451, .827451, .827451]);
        widget._mkDictionary.update('CA', (typeof this._name !== 'undefined' && this._name !== null) ? this._name : this._actualName);
        this._addToKid(widget);
    }
    _doPostProcess(isFlatten = false) {
        if (isFlatten || this._setAppearance || this._form._setAppearance) {
            const count = this._kidsCount;
            if (this._isLoaded) {
                if (count > 0) {
                    for (let i = 0; i < count; i++) {
                        const item = this.itemAt(i);
                        if (item) {
                            this._postProcess(isFlatten, item);
                        }
                    }
                }
                else if ((isFlatten || this._form._setAppearance || this._setAppearance) && !this._checkFieldFlag(this._dictionary)) {
                    this._postProcess(isFlatten);
                }
            }
            else if (isFlatten || this._form._setAppearance || this._setAppearance) {
                for (let i = 0; i < count; i++) {
                    const item = this.itemAt(i);
                    if (item && !this._checkFieldFlag(item._dictionary)) {
                        const template = this._createAppearance(item);
                        if (isFlatten) {
                            this._drawTemplate(template, item._getPage(), { x: item.bounds.x, y: item.bounds.y, width: template._size[0], height: template._size[1] });
                        }
                        else {
                            this._addAppearance(item._dictionary, template, 'N');
                            const pressed = this._createAppearance(item, true);
                            if (pressed) {
                                this._addAppearance(item._dictionary, pressed, 'D');
                            }
                        }
                        item._dictionary._updated = !isFlatten;
                    }
                }
            }
            if (isFlatten) {
                this._dictionary._updated = false;
            }
        }
    }
    _postProcess(isFlatten, widget) {
        let template;
        let bounds;
        const source = widget ? widget : this;
        if (this._form._setAppearance || this._setAppearance || (isFlatten && !source._dictionary.has('AP'))) {
            template = this._createAppearance(source);
        }
        else if (source._dictionary.has('AP')) {
            let appearanceStream;
            const dictionary = source._dictionary.get('AP');
            if (dictionary && dictionary.has('N')) {
                appearanceStream = dictionary.get('N');
                const reference = dictionary.getRaw('N');
                if (reference) {
                    appearanceStream.reference = reference;
                }
                if (appearanceStream) {
                    template = new PdfTemplate(appearanceStream, this._crossReference);
                }
            }
        }
        if (template) {
            if (isFlatten) {
                const page = source instanceof PdfWidgetAnnotation ? source._getPage() : source.page;
                if (page) {
                    const graphics = page.graphics;
                    graphics.save();
                    if (page.rotation === PdfRotationAngle.angle90) {
                        graphics.translateTransform(graphics._size[0], graphics._size[1]);
                        graphics.rotateTransform(90);
                    }
                    else if (page.rotation === PdfRotationAngle.angle180) {
                        graphics.translateTransform(graphics._size[0], graphics._size[1]);
                        graphics.rotateTransform(-180);
                    }
                    else if (page.rotation === PdfRotationAngle.angle270) {
                        graphics.translateTransform(graphics._size[0], graphics._size[1]);
                        graphics.rotateTransform(270);
                    }
                    bounds = { x: source.bounds.x, y: source.bounds.y, width: template._size[0], height: template._size[1] };
                    graphics._drawTemplate(template, bounds);
                    graphics.restore();
                }
                source._dictionary._updated = false;
            }
            else {
                this._addAppearance(source._dictionary, template, 'N');
            }
        }
    }
    _createAppearance(widget, isPressed = false) {
        const bounds = widget.bounds;
        const template = new PdfTemplate([0, 0, bounds.width, bounds.height], this._crossReference);
        const parameter = new _PaintParameter();
        parameter.bounds = [0, 0, bounds.width, bounds.height];
        const backcolor = widget.backColor;
        if (backcolor) {
            parameter.backBrush = new PdfBrush(backcolor);
        }
        parameter.foreBrush = new PdfBrush(widget.color);
        const border = widget.border;
        parameter.borderPen = new PdfPen(widget.borderColor, border.width);
        parameter.borderStyle = border.style;
        parameter.borderWidth = border.width;
        if (backcolor) {
            const shadowColor = [backcolor[0] - 64, backcolor[1] - 64, backcolor[2] - 64];
            const color = [shadowColor[0] >= 0 ? shadowColor[0] : 0,
                shadowColor[1] >= 0 ? shadowColor[1] : 0,
                shadowColor[2] >= 0 ? shadowColor[2] : 0];
            parameter.shadowBrush = new PdfBrush(color);
        }
        parameter.rotationAngle = widget.rotate;
        if (typeof this._font === 'undefined' || this._font === null) {
            this._font = this._defaultFont;
        }
        if (isPressed) {
            this._drawPressedButton(template.graphics, parameter, this.text, this._font, this._stringFormat);
        }
        else {
            this._drawButton(template.graphics, parameter, this.text, this._font, this._stringFormat);
        }
        return template;
    }
    _drawButton(g, parameter, text, font, format) {
        this._drawRectangularControl(g, parameter);
        let rectangle = parameter.bounds;
        if ((g._page &&
            typeof g._page.rotation !== 'undefined' &&
            g._page.rotation !== PdfRotationAngle.angle0) ||
            parameter.rotationAngle > 0) {
            const state = g.save();
            if (typeof parameter.pageRotationAngle !== 'undefined' && parameter.pageRotationAngle !== PdfRotationAngle.angle0) {
                if (parameter.pageRotationAngle === PdfRotationAngle.angle90) {
                    g.translateTransform(g._size[1], 0);
                    g.rotateTransform(90);
                    const y = g._size[1] - (rectangle[0] + rectangle[2]);
                    const x = rectangle[1];
                    rectangle = [x, y, rectangle[3], rectangle[2]];
                }
                else if (parameter.pageRotationAngle === PdfRotationAngle.angle180) {
                    g.translateTransform(g._size[0], g._size[1]);
                    g.rotateTransform(-180);
                    const x = g._size[0] - (rectangle[0] + rectangle[2]);
                    const y = g._size[1] - (rectangle[1] + rectangle[3]);
                    rectangle = [x, y, rectangle[2], rectangle[3]];
                }
                else if (parameter.pageRotationAngle === PdfRotationAngle.angle270) {
                    g.translateTransform(0, g._size[0]);
                    g.rotateTransform(270);
                    const x = g._size[0] - (rectangle[1] + rectangle[3]);
                    const y = rectangle[0];
                    rectangle = [x, y, rectangle[3], rectangle[2]];
                }
            }
            if (parameter.rotationAngle) {
                if (parameter.rotationAngle === 90) {
                    if (parameter.pageRotationAngle === PdfRotationAngle.angle90) {
                        g.translateTransform(0, g._size[1]);
                        g.rotateTransform(-90);
                        const x = g._size[1] - (rectangle[1] + rectangle[3]);
                        const y = rectangle[0];
                        rectangle = [x, y, rectangle[3], rectangle[2]];
                    }
                    else {
                        if (rectangle[2] > rectangle[3]) {
                            g.translateTransform(0, g._size[1]);
                            g.rotateTransform(-90);
                            rectangle = [parameter.bounds[0], parameter.bounds[1], parameter.bounds[2], parameter.bounds[3]];
                        }
                        else {
                            const z = rectangle[0];
                            rectangle[0] = -(rectangle[1] + rectangle[3]);
                            rectangle[1] = z;
                            const height = rectangle[3];
                            rectangle[3] = rectangle[2] > font._metrics._getHeight() ? rectangle[2] : font._metrics._getHeight();
                            rectangle[2] = height;
                            g.rotateTransform(-90);
                        }
                    }
                }
                else if (parameter.rotationAngle === 270) {
                    g.translateTransform(g._size[0], 0);
                    g.rotateTransform(-270);
                    const x = rectangle[1];
                    const y = g._size[0] - (rectangle[0] + rectangle[2]);
                    rectangle = [x, y, rectangle[3], rectangle[2]];
                }
                else if (parameter.rotationAngle === 180) {
                    g.translateTransform(g._size[0], g._size[1]);
                    g.rotateTransform(-180);
                    const x = g._size[0] - (rectangle[0] + rectangle[2]);
                    const y = g._size[1] - (rectangle[1] + rectangle[3]);
                    rectangle = [x, y, rectangle[2], rectangle[3]];
                }
            }
            g.drawString(text, font, rectangle, null, parameter.foreBrush, format);
            g.restore(state);
        }
        else {
            g.drawString(text, font, rectangle, null, parameter.foreBrush, format);
        }
    }
    _drawPressedButton(g, parameter, text, font, format) {
        switch (parameter.borderStyle) {
            case PdfBorderStyle.inset:
                g.drawRectangle(parameter.bounds[0], parameter.bounds[1], parameter.bounds[2], parameter.bounds[3], parameter.shadowBrush);
                break;
            default:
                g.drawRectangle(parameter.bounds[0], parameter.bounds[1], parameter.bounds[2], parameter.bounds[3], parameter.backBrush);
                break;
        }
        this._drawBorder(g, parameter.bounds, parameter.borderPen, parameter.borderStyle, parameter.borderWidth);
        const rectangle = [parameter.borderWidth,
            parameter.borderWidth,
            parameter.bounds[2] - parameter.borderWidth,
            parameter.bounds[3] - parameter.borderWidth];
        g.drawString(text, font, rectangle, null, parameter.foreBrush, format);
        switch (parameter.borderStyle) {
            case PdfBorderStyle.inset:
                this._drawLeftTopShadow(g, parameter.bounds, parameter.borderWidth, this._grayBrush);
                this._drawRightBottomShadow(g, parameter.bounds, parameter.borderWidth, this._silverBrush);
                break;
            case PdfBorderStyle.beveled:
                this._drawLeftTopShadow(g, parameter.bounds, parameter.borderWidth, parameter.shadowBrush);
                this._drawRightBottomShadow(g, parameter.bounds, parameter.borderWidth, this._whiteBrush);
                break;
            default:
                this._drawLeftTopShadow(g, parameter.bounds, parameter.borderWidth, parameter.shadowBrush);
                break;
        }
    }
}
/**
 * `PdfCheckBoxField` class represents the check box field objects.
 * ```typescript
 * // Load an existing PDF document
 * let document: PdfDocument = new PdfDocument(data);
 * // Gets the first page of the document
 * let page: PdfPage = document.getPage(0);
 * // Access the PDF form
 * let form: PdfForm = document.form;
 * // Create a new check box field
 * let field: PdfCheckBoxField = new PdfCheckBoxField('CheckBox1', {x: 100, y: 40, width: 20, height: 20}, page);
 * // Sets the checked flag as true.
 * field.checked = true;
 * // Sets the tool tip value
 * field.toolTip = 'Checked';
 * // Add the field into PDF form
 * form.add(field);
 * // Save the document
 * document.save('output.pdf');
 * // Destroy the document
 * document.destroy();
 * ```
 */
class PdfCheckBoxField extends PdfField {
    constructor(name, bounds, page) {
        super();
        if (page && name && bounds) {
            this._initialize(page, name, bounds);
        }
    }
    /**
     * Parse an existing check box field.
     *
     * @private
     * @param {PdfForm} form Form object.
     * @param {_PdfDictionary} dictionary Field dictionary.
     * @param {_PdfCrossReference} crossReference Cross reference object.
     * @param {_PdfReference} reference Field reference.
     * @returns {PdfCheckBoxField} Check box field.
     */
    static _load(form, dictionary, crossReference, reference) {
        const field = new PdfCheckBoxField();
        field._isLoaded = true;
        field._form = form;
        field._dictionary = dictionary;
        field._crossReference = crossReference;
        field._ref = reference;
        field._defaultIndex = 0;
        field._parsedItems = new Map();
        if (field._dictionary.has('Kids')) {
            field._kids = field._dictionary.get('Kids');
        }
        else {
            const item = PdfStateItem._load(dictionary, crossReference, field);
            item._isLoaded = true;
            item._ref = reference;
            field._parsedItems.set(0, item);
        }
        return field;
    }
    /**
     * Gets the item at the specified index.
     *
     * @param {number} index Index of the field item.
     * @returns {PdfStateItem} Field item at the index.
     * ```typescript
     * // Load an existing PDF document
     * let document: PdfDocument = new PdfDocument(data);
     * // Gets the first page of the document
     * let page: PdfPage = document.getPage(0);
     * // Access the PDF form
     * let form: PdfForm = document.form;
     * // Access the check box field
     * let field: PdfCheckBoxField = form.fieldAt(0) as PdfCheckBoxField;
     * // Gets the first list item.
     * let item: PdfStateItem = field.itemAt(0);
     * // Save the document
     * document.save('output.pdf');
     * // Destroy the document
     * document.destroy();
     * ```
     */
    itemAt(index) {
        if (index < 0 || (index !== 0 && index >= this._kidsCount)) {
            throw Error('Index out of range.');
        }
        let item;
        if (this._parsedItems.has(index)) {
            item = this._parsedItems.get(index);
        }
        else {
            let dictionary;
            if (index >= 0 && this._kids && this._kids.length > 0 && index < this._kids.length) {
                const ref = this._kids[Number.parseInt(index.toString(), 10)];
                if (ref && ref instanceof _PdfReference) {
                    dictionary = this._crossReference._fetch(ref);
                }
                if (dictionary) {
                    item = PdfStateItem._load(dictionary, this._crossReference, this);
                    item._isLoaded = true;
                    item._ref = ref;
                    this._parsedItems.set(index, item);
                }
            }
        }
        return item;
    }
    /**
     * Gets the font of the field.
     *
     * @returns {PdfFont} font.
     *
     * ```typescript
     * // Load an existing PDF document
     * let document: PdfDocument = new PdfDocument(data, password);
     * // Access the form field at index 0
     * let field: PdfCheckBoxField = document.form.fieldAt(0) as PdfCheckBoxField;
     * // Gets the font of the field.
     * let font: PdfFont = field.font;
     * // Save the document
     * document.save('output.pdf');
     * // Destroy the document
     * document.destroy();
     * ```
     */
    get font() {
        if (this._font) {
            return this._font;
        }
        else {
            const widget = this.itemAt(this._defaultIndex);
            this._font = _obtainFontDetails(this._form, widget, this);
        }
        return this._font;
    }
    /**
     * Sets the font of the field.
     *
     * @param {PdfFont} value font.
     *
     * ```typescript
     * // Load an existing PDF document
     * let document: PdfDocument = new PdfDocument(data, password);
     * // Access the form field at index 0
     * let field: PdfCheckBoxField = document.form.fieldAt(0) as PdfCheckBoxField;
     * // Sets the font of the field
     * field.font = new PdfStandardFont(PdfFontFamily.helvetica, 12, PdfFontStyle.bold);
     * // Save the document
     * document.save('output.pdf');
     * // Destroy the document
     * document.destroy();
     * ```
     */
    set font(value) {
        if (value && value instanceof PdfFont) {
            this._font = value;
            this._initializeFont(value);
        }
    }
    /**
     * Gets the flag indicating whether the field is checked or not.
     *
     * @returns {boolean} Checked.
     * ```typescript
     * // Load an existing PDF document
     * let document: PdfDocument = new PdfDocument(data);
     * // Gets the first page of the document
     * let page: PdfPage = document.getPage(0);
     * // Access the PDF form
     * let form: PdfForm = document.form;
     * // Access the check box field
     * let field: PdfCheckBoxField = form.fieldAt(0) as PdfCheckBoxField;
     * // Gets the flag indicating whether the field is checked or not.
     * let checked: Boolean = field.checked;
     * // Save the document
     * document.save('output.pdf');
     * // Destroy the document
     * document.destroy();
     * ```
     */
    get checked() {
        return (this._kidsCount > 0) ? this.itemAt(this._defaultIndex).checked : _checkField(this._dictionary);
    }
    /**
     * Sets the flag indicating whether the field is checked or not.
     *
     * @param {boolean} value Checked.
     * ```typescript
     * // Load an existing PDF document
     * let document: PdfDocument = new PdfDocument(data);
     * // Gets the first page of the document
     * let page: PdfPage = document.getPage(0);
     * // Access the PDF form
     * let form: PdfForm = document.form;
     * // Access the check box field
     * let field: PdfCheckBoxField = form.fieldAt(0) as PdfCheckBoxField;
     * // Sets the flag indicating whether the field is checked or not.
     * field.checked = true;
     * // Save the document
     * document.save('output.pdf');
     * // Destroy the document
     * document.destroy();
     * ```
     */
    set checked(value) {
        if (this.checked !== value) {
            if (this._kidsCount > 0) {
                this.itemAt(this._defaultIndex).checked = value;
            }
            if (value) {
                if (this._isLoaded) {
                    const entry = _getItemValue((this._kidsCount > 0) ?
                        this.itemAt(this._defaultIndex)._dictionary : this._dictionary);
                    this._dictionary.update('V', _PdfName.get(entry));
                    this._dictionary.update('AS', _PdfName.get(entry));
                }
                else {
                    this._dictionary.update('V', _PdfName.get('Yes'));
                    this._dictionary.update('AS', _PdfName.get('Yes'));
                }
            }
            else {
                if (this._dictionary.has('V')) {
                    delete this._dictionary._map.V;
                }
                if (this._dictionary.has('AS')) {
                    delete this._dictionary._map.AS;
                }
            }
            this._dictionary._updated = true;
        }
    }
    /**
     * Gets the text alignment in a check box field.
     *
     * @returns {PdfTextAlignment} Text alignment.
     *
     * ```typescript
     * // Load an existing PDF document
     * let document: PdfDocument = new PdfDocument(data);
     * // Access check box field
     * let field: PdfCheckBoxField = document.form.fieldAt(0) as PdfCheckBoxField;
     * // Gets the text alignment from check box field
     * let alignment: PdfTextAlignment = field.textAlignment;
     * // Save the document
     * document.save('output.pdf');
     * // Destroy the document
     * document.destroy();
     * ```
     */
    get textAlignment() {
        return this._getTextAlignment();
    }
    /**
     * Sets the text alignment in a check box field.
     *
     * @param {PdfTextAlignment} value Text alignment.
     *
     * ```typescript
     * // Load an existing PDF document
     * let document: PdfDocument = new PdfDocument(data);
     * // Access check box field
     * let field: PdfCheckBoxField = document.form.fieldAt(0) as PdfCheckBoxField;
     * // Sets the text alignment of form field as center
     * field.textAlignment = PdfTextAlignment.center;
     * // Save the document
     * document.save('output.pdf');
     * // Destroy the document
     * document.destroy();
     * ```
     */
    set textAlignment(value) {
        if (this._textAlignment !== value) {
            this._setTextAlignment(value);
        }
    }
    /**
     * Gets the background color of the field.
     *
     * @returns {number[]} R, G, B color values in between 0 to 255.
     * ```typescript
     * // Load an existing PDF document
     * let document: PdfDocument = new PdfDocument(data, password);
     * // Access the form field at index 0
     * let field: PdfField = document.form.fieldAt(0);
     * // Gets the background color of the field.
     * let backColor: number[] = field.backColor;
     * // Save the document
     * document.save('output.pdf');
     * // Destroy the document
     * document.destroy();
     * ```
     */
    get backColor() {
        return this._parseBackColor(true);
    }
    /**
     * Sets the background color of the field.
     *
     * @param {number[]} value Array with R, G, B, A color values in between 0 to 255. For optional A (0-254), it signifies transparency.
     * ```typescript
     * // Load an existing PDF document
     * let document: PdfDocument = new PdfDocument(data, password);
     * // Access the check box field at index 0
     * let checkBox1: PdfField = document.form.fieldAt(0);
     * // Sets the background color of the field.
     * checkBox1.backColor = [255, 0, 0];
     * // Access the check box field at index 1
     * let checkBox2: PdfField = document.form.fieldAt(1);
     * // Sets the background color of the field to transparent.
     * checkBox2.backColor = [0, 0, 0, 0];
     * // Save the document
     * document.save('output.pdf');
     * // Destroy the document
     * document.destroy();
     * ```
     */
    set backColor(value) {
        this._updateBackColor(value, true);
    }
    _initialize(page, name, bounds) {
        this._crossReference = page._crossReference;
        this._page = page;
        this._name = name;
        this._defaultIndex = 0;
        this._dictionary = new _PdfDictionary(this._crossReference);
        this._ref = this._crossReference._getNextReference();
        this._crossReference._cacheMap.set(this._ref, this._dictionary);
        this._dictionary.objId = this._ref.toString();
        this._dictionary.update('FT', _PdfName.get('Btn'));
        this._dictionary.update('T', name);
        this._createItem(bounds);
    }
    _createItem(bounds) {
        const widget = new PdfStateItem();
        widget._create(this._page, bounds, this);
        widget.textAlignment = PdfTextAlignment.center;
        this._stringFormat = new PdfStringFormat(widget.textAlignment, PdfVerticalAlignment.middle);
        widget._dictionary.update('MK', new _PdfDictionary(this._crossReference));
        widget._mkDictionary.update('BC', [0, 0, 0]);
        widget._mkDictionary.update('BG', [1, 1, 1]);
        widget.style = PdfCheckBoxStyle.check;
        widget._dictionary.update('DA', '/TiRo 0 Tf 0 0 0 rg');
        this._addToKid(widget);
    }
    _doPostProcess(isFlatten = false) {
        const count = this._kidsCount;
        if (this._isLoaded) {
            if (count > 0) {
                for (let i = 0; i < count; i++) {
                    const item = this.itemAt(i);
                    if (item) {
                        if (!this._checkFieldFlag(item._dictionary)) {
                            if (isFlatten) {
                                let template;
                                const state = item.checked ?
                                    _PdfCheckFieldState.checked :
                                    _PdfCheckFieldState.unchecked;
                                if (this._setAppearance || this._form._setAppearance || !item._dictionary.has('AP')) {
                                    template = this._createAppearance(item, state);
                                }
                                else {
                                    template = _getStateTemplate(state, this);
                                }
                                this._drawTemplate(template, item._getPage(), item.bounds);
                            }
                            else if (this._setAppearance || this._form._setAppearance || !item._isLoaded) {
                                item._postProcess(item.checked ? 'Yes' : 'Off');
                                this._drawAppearance(item);
                            }
                        }
                        item._dictionary._updated = !isFlatten;
                    }
                }
            }
            else {
                const style = this.checked ?
                    _PdfCheckFieldState.checked :
                    _PdfCheckFieldState.unchecked;
                this._drawTemplate(_getStateTemplate(style, this), this.page, this.bounds);
            }
        }
        else {
            for (let i = 0; i < count; i++) {
                const item = this.itemAt(i);
                if (item) {
                    const state = item.checked ? _PdfCheckFieldState.checked : _PdfCheckFieldState.unchecked;
                    item._postProcess(item.checked ? 'Yes' : 'Off');
                    if (isFlatten) {
                        const template = this._createAppearance(item, state);
                        this._drawTemplate(template, item._getPage(), item.bounds);
                    }
                    else {
                        this._drawAppearance(item);
                    }
                    item._dictionary._updated = !isFlatten;
                }
            }
        }
        this._dictionary._updated = !isFlatten;
    }
    _createAppearance(widget, state) {
        const bounds = widget.bounds;
        const parameter = new _PaintParameter();
        parameter.bounds = [0, 0, bounds.width, bounds.height];
        const backcolor = widget.backColor;
        if (backcolor) {
            parameter.backBrush = new PdfBrush(backcolor);
        }
        parameter.foreBrush = new PdfBrush(widget.color);
        const border = widget.border;
        parameter.borderPen = new PdfPen(widget.borderColor, border.width);
        parameter.borderStyle = border.style;
        parameter.borderWidth = border.width;
        if (backcolor) {
            const shadowColor = [backcolor[0] - 64, backcolor[1] - 64, backcolor[2] - 64];
            const color = [shadowColor[0] >= 0 ? shadowColor[0] : 0,
                shadowColor[1] >= 0 ? shadowColor[1] : 0,
                shadowColor[2] >= 0 ? shadowColor[2] : 0];
            parameter.shadowBrush = new PdfBrush(color);
        }
        parameter.rotationAngle = widget.rotate;
        const template = new PdfTemplate(parameter.bounds, this._crossReference);
        const graphics = template.graphics;
        this._drawCheckBox(graphics, parameter, _styleToString(widget._style), state);
        return template;
    }
    _drawAppearance(item) {
        let appearance = new _PdfDictionary();
        if (item._dictionary.has('AP')) {
            appearance = item._dictionary.get('AP');
            if (appearance) {
                if (appearance.has('N')) {
                    _removeReferences(appearance.get('N'), this._crossReference, 'Yes', 'Off');
                }
                if (appearance.has('D')) {
                    _removeReferences(appearance.get('D'), this._crossReference, 'Yes', 'Off');
                }
            }
            _removeDuplicateReference(appearance, this._crossReference, 'N');
            _removeDuplicateReference(appearance, this._crossReference, 'D');
        }
        else {
            const reference = this._crossReference._getNextReference();
            appearance = new _PdfDictionary(this._crossReference);
            this._crossReference._cacheMap.set(reference, appearance);
            item._dictionary.update('AP', reference);
        }
        const normalChecked = this._createAppearance(item, _PdfCheckFieldState.checked);
        const normalCheckedReference = this._crossReference._getNextReference();
        this._crossReference._cacheMap.set(normalCheckedReference, normalChecked._content);
        const normalUnchecked = this._createAppearance(item, _PdfCheckFieldState.unchecked);
        const normalUncheckedReference = this._crossReference._getNextReference();
        this._crossReference._cacheMap.set(normalUncheckedReference, normalUnchecked._content);
        const normalDictionary = new _PdfDictionary(this._crossReference);
        normalDictionary.update('Yes', normalCheckedReference);
        normalDictionary.update('Off', normalUncheckedReference);
        const normalReference = this._crossReference._getNextReference();
        this._crossReference._cacheMap.set(normalReference, normalDictionary);
        appearance.update('N', normalReference);
        const pressChecked = this._createAppearance(item, _PdfCheckFieldState.pressedChecked);
        const pressCheckedReference = this._crossReference._getNextReference();
        this._crossReference._cacheMap.set(pressCheckedReference, pressChecked._content);
        const pressUnchecked = this._createAppearance(item, _PdfCheckFieldState.pressedUnchecked);
        const pressUncheckedReference = this._crossReference._getNextReference();
        this._crossReference._cacheMap.set(pressUncheckedReference, pressUnchecked._content);
        const pressedDictionary = new _PdfDictionary(this._crossReference);
        pressedDictionary.update('Yes', pressCheckedReference);
        pressedDictionary.update('Off', pressUncheckedReference);
        const pressedReference = this._crossReference._getNextReference();
        this._crossReference._cacheMap.set(pressedReference, pressedDictionary);
        appearance.update('D', pressedReference);
        item._dictionary._updated = true;
    }
}
/**
 * `PdfRadioButtonListField` class represents the radio button field objects.
 * ```typescript
 * // Load an existing PDF document
 * let document: PdfDocument = new PdfDocument(data);
 * // Gets the first page of the document
 * let page: PdfPage = document.getPage(0);
 * // Access the PDF form
 * let form: PdfForm = document.form;
 * // Create a new radio button list field
 * let field: PdfRadioButtonListField = new PdfRadioButtonListField(page, 'Age');
 * // Create and add first item
 * let first: PdfRadioButtonListItem = field.add('1-9', {x: 100, y: 140, width: 20, height: 20});
 * // Create and add second item
 * let second: PdfRadioButtonListItem = new PdfRadioButtonListItem('10-49', {x: 100, y: 170, width: 20, height: 20}, page);
 * field.add(second);
 * // Sets selected index of the radio button list field
 * field.selectedIndex = 0;
 * // Add the field into PDF form
 * form.add(field);
 * // Save the document
 * document.save('output.pdf');
 * // Destroy the document
 * document.destroy();
 * ```
 */
class PdfRadioButtonListField extends PdfField {
    constructor(page, name) {
        super();
        this._selectedIndex = -1;
        if (page && name) {
            this._initialize(page, name);
        }
    }
    /**
     * Parse an existing radio button list field.
     *
     * @private
     * @param {PdfForm} form Form object.
     * @param {_PdfDictionary} dictionary Field dictionary.
     * @param {_PdfCrossReference} crossReference Cross reference object.
     * @param {_PdfReference} reference Field reference.
     * @returns {PdfRadioButtonListField} Radio button list field.
     */
    static _load(form, dictionary, crossReference, reference) {
        const field = new PdfRadioButtonListField();
        field._isLoaded = true;
        field._form = form;
        field._dictionary = dictionary;
        field._crossReference = crossReference;
        field._ref = reference;
        if (field._dictionary.has('Kids')) {
            field._kids = field._dictionary.get('Kids');
        }
        field._defaultIndex = 0;
        field._parsedItems = new Map();
        if (field._kidsCount > 0) {
            field._retrieveOptionValue();
        }
        return field;
    }
    /**
     * Gets the flag indicating whether the field is checked or not (Read only).
     *
     * @returns {boolean} Checked.
     * ```typescript
     * // Load an existing PDF document
     * let document: PdfDocument = new PdfDocument(data);
     * // Gets the first page of the document
     * let page: PdfPage = document.getPage(0);
     * // Access the PDF form
     * let form: PdfForm = document.form;
     * // Access the radio button list field
     * let field: PdfRadioButtonListField = form.fieldAt(0) as PdfRadioButtonListField;
     * // Gets the flag indicating whether the field is checked or not.
     * let checked: boolean = field.checked;
     * // Save the document
     * document.save('output.pdf');
     * // Destroy the document
     * document.destroy();
     * ```
     */
    get checked() {
        let check = false;
        if (this._kidsCount > 0) {
            check = this.itemAt(this._defaultIndex).checked;
        }
        return check;
    }
    /**
     * Gets the selected item index.
     *
     * @returns {number} Index.
     * ```typescript
     * // Load an existing PDF document
     * let document: PdfDocument = new PdfDocument(data);
     * // Gets the first page of the document
     * let page: PdfPage = document.getPage(0);
     * // Access the PDF form
     * let form: PdfForm = document.form;
     * // Access the radio button list field
     * let field: PdfRadioButtonListField = form.fieldAt(0) as PdfRadioButtonListField;
     * // Gets the selected index.
     * let index: number = field.selectedIndex;
     * // Save the document
     * document.save('output.pdf');
     * // Destroy the document
     * document.destroy();
     * ```
     */
    get selectedIndex() {
        if (this._isLoaded && this._selectedIndex === -1) {
            this._selectedIndex = this._obtainSelectedIndex();
        }
        return this._selectedIndex;
    }
    /**
     * Sets the selected item index.
     *
     * @param {number} value Selected index.
     * ```typescript
     * // Load an existing PDF document
     * let document: PdfDocument = new PdfDocument(data);
     * // Gets the first page of the document
     * let page: PdfPage = document.getPage(0);
     * // Access the PDF form
     * let form: PdfForm = document.form;
     * // Create a new radio button list field
     * let field: PdfRadioButtonListField = new PdfRadioButtonListField(page, 'Age');
     * // Create and add first item
     * let first: PdfRadioButtonListItem = field.add('1-9', {x: 100, y: 140, width: 20, height: 20});
     * // Create and add second item
     * let second: PdfRadioButtonListItem = new PdfRadioButtonListItem('10-49', {x: 100, y: 170, width: 20, height: 20}, page);
     * field.add(second);
     * // Sets selected index of the radio button list field
     * field.selectedIndex = 0;
     * // Add the field into PDF form
     * form.add(field);
     * // Save the document
     * document.save('output.pdf');
     * // Destroy the document
     * document.destroy();
     * ```
     */
    set selectedIndex(value) {
        if (this.selectedIndex !== value) {
            this._selectedIndex = value;
            for (let i = 0; i < this._kidsCount; i++) {
                const item = this.itemAt(i);
                if (i === value) {
                    item._dictionary.update('AS', _PdfName.get(item.value));
                    const name = _PdfName.get(item.value);
                    this._dictionary.update('V', name);
                    this._dictionary.update('DV', name);
                }
                else {
                    item._dictionary.update('AS', _PdfName.get('Off'));
                }
            }
        }
    }
    /**
     * Gets the item at the specified index.
     *
     * @param {number} index Index of the field item.
     * @returns {PdfRadioButtonListItem} Field item at the index.
     * ```typescript
     * // Load an existing PDF document
     * let document: PdfDocument = new PdfDocument(data);
     * // Gets the first page of the document
     * let page: PdfPage = document.getPage(0);
     * // Access the PDF form
     * let form: PdfForm = document.form;
     * // Access the radio button list field
     * let field: PdfRadioButtonListField = form.fieldAt(0) as PdfRadioButtonListField;
     * // Gets the first list item.
     * let item: PdfRadioButtonListField = field.itemAt(0);
     * // Save the document
     * document.save('output.pdf');
     * // Destroy the document
     * document.destroy();
     * ```
     */
    itemAt(index) {
        if (index < 0 || (index !== 0 && index >= this._kidsCount)) {
            throw Error('Index out of range.');
        }
        let item;
        if (this._parsedItems.has(index)) {
            item = this._parsedItems.get(index);
        }
        else {
            let dictionary;
            if (index >= 0 && this._kids && this._kids.length > 0 && index < this._kids.length) {
                const ref = this._kids[Number.parseInt(index.toString(), 10)];
                if (ref && ref instanceof _PdfReference) {
                    dictionary = this._crossReference._fetch(ref);
                }
                if (dictionary) {
                    item = PdfRadioButtonListItem._load(dictionary, this._crossReference, this);
                    item._ref = ref;
                    item._index = index;
                    this._parsedItems.set(index, item);
                }
            }
        }
        return item;
    }
    add(value, bounds) {
        if (value instanceof PdfRadioButtonListItem) {
            value._field = this;
            value._dictionary.update('Parent', this._ref);
            value._setField(this);
            return this._kidsCount;
        }
        else {
            return new PdfRadioButtonListItem(value, bounds, this);
        }
    }
    /**
     * Remove the radio button list item from the specified index.
     *
     * @param {number} index Item index to remove.
     * @returns {void} Nothing.
     *
     * ```typescript
     * // Load an existing PDF document
     * let document: PdfDocument = new PdfDocument(data, password);
     * // Access the form field at index 0
     * let field: PdfField = document.form.fieldAt(0);
     * // Remove the first item of the form field
     * field.removeItemAt(0);
     * // Save the document
     * document.save('output.pdf');
     * // Destroy the document
     * document.destroy();
     * ```
     */
    removeItemAt(index) {
        const item = this.itemAt(index);
        if (item && item._ref) {
            const page = item._getPage();
            if (page) {
                page._removeAnnotation(item._ref);
            }
            this._kids.splice(index, 1);
            this._dictionary.set('Kids', this._kids);
            this._dictionary._updated = true;
            this._parsedItems.delete(index);
            if (this._parsedItems.size > 0) {
                const parsedItems = new Map();
                this._parsedItems.forEach((value, key) => {
                    if (key > index) {
                        parsedItems.set(key - 1, value);
                    }
                    else {
                        parsedItems.set(key, value);
                    }
                });
                this._parsedItems = parsedItems;
            }
            if (this._dictionary.has('Opt')) {
                const options = this._dictionary.getArray('Opt');
                if (options && options.length > 0) {
                    options.splice(index, 1);
                    this._dictionary.set('Opt', options);
                }
            }
        }
    }
    /**
     * Remove the specified radio button list field item.
     *
     * @param {PdfRadioButtonListItem} item Item to remove.
     * @returns {void} Nothing.
     *
     * ```typescript
     * // Load an existing PDF document
     * let document: PdfDocument = new PdfDocument(data, password);
     * // Access the form field at index 0
     * let field: PdfField = document.form.fieldAt(0);
     * // Remove the first item of the form field
     * field.removeItem(field.itemAt(0));
     * // Save the document
     * document.save('output.pdf');
     * // Destroy the document
     * document.destroy();
     * ```
     */
    removeItem(item) {
        if (item && item._ref) {
            const index = this._kids.indexOf(item._ref);
            if (index !== -1) {
                this.removeItemAt(index);
            }
        }
    }
    _initialize(page, name) {
        this._defaultIndex = 0;
        this._crossReference = page._crossReference;
        this._page = page;
        this._name = name;
        this._dictionary = new _PdfDictionary(this._crossReference);
        this._ref = this._crossReference._getNextReference();
        this._crossReference._cacheMap.set(this._ref, this._dictionary);
        this._dictionary.objId = this._ref.toString();
        this._dictionary.update('FT', _PdfName.get('Btn'));
        this._dictionary.update('T', name);
        this._parsedItems = new Map();
        this._fieldFlags |= _FieldFlag.radio;
    }
    _retrieveOptionValue() {
        if (this._dictionary.has('Opt')) {
            const options = this._dictionary.getArray('Opt');
            if (options && options.length > 0) {
                const itemsCount = this._kidsCount;
                const count = options.length <= itemsCount ? options.length : itemsCount;
                for (let i = 0; i < count; i++) {
                    if (options[Number.parseInt(i.toString(), 10)]) {
                        this.itemAt(i)._optionValue = options[Number.parseInt(i.toString(), 10)];
                    }
                }
            }
        }
    }
    _obtainSelectedIndex() {
        let index = -1;
        for (let i = 0; i < this._kidsCount; ++i) {
            const item = this.itemAt(i);
            if (item) {
                const checkName = _getInheritableProperty(item._dictionary, 'V', false, true, 'Parent');
                if (checkName && item._dictionary.has('AS')) {
                    const asName = item._dictionary.get('AS');
                    if (asName && asName.name.toLowerCase() !== 'off') {
                        if (checkName instanceof _PdfName && checkName.name.toLowerCase() !== 'off') {
                            if (asName.name === checkName.name || item._optionValue === checkName.name) {
                                index = i;
                                break;
                            }
                        }
                        else if (typeof checkName === 'string' && checkName.toLowerCase() !== 'off') {
                            if (asName.name === checkName || item._optionValue === checkName) {
                                index = i;
                                break;
                            }
                        }
                    }
                }
            }
        }
        return index;
    }
    _doPostProcess(isFlatten = false) {
        const count = this._kidsCount;
        if (this._isLoaded) {
            if (count > 0) {
                for (let i = 0; i < count; i++) {
                    const item = this.itemAt(i);
                    if (item && !this._checkFieldFlag(item._dictionary)) {
                        if (isFlatten) {
                            let template;
                            const state = this.selectedIndex === i ?
                                _PdfCheckFieldState.checked :
                                _PdfCheckFieldState.unchecked;
                            if (this._setAppearance || this._form._setAppearance || !item._dictionary.has('AP')) {
                                template = this._createAppearance(item, state);
                            }
                            else {
                                template = _getStateTemplate(state, this);
                            }
                            this._drawTemplate(template, item._getPage(), item.bounds);
                        }
                        else if (this._setAppearance || this._form._setAppearance || !item._isLoaded) {
                            item._postProcess(this.selectedIndex === i ? item.value : 'Off');
                            this._drawAppearance(item);
                        }
                        item._dictionary._updated = !isFlatten;
                    }
                }
            }
            else {
                const style = this.selectedIndex !== -1 ?
                    _PdfCheckFieldState.checked :
                    _PdfCheckFieldState.unchecked;
                this._drawTemplate(_getStateTemplate(style, this), this.page, this.bounds);
            }
        }
        else {
            for (let i = 0; i < count; i++) {
                const item = this.itemAt(i);
                const state = this.selectedIndex === i ? _PdfCheckFieldState.checked : _PdfCheckFieldState.unchecked;
                item._dictionary.update('AS', _PdfName.get(this.selectedIndex === i ? item.value : 'Off'));
                if (isFlatten) {
                    const template = this._createAppearance(item, state);
                    this._drawTemplate(template, item._getPage(), item.bounds);
                }
                else {
                    item._postProcess(this.selectedIndex === i ? item.value : 'Off');
                    this._drawAppearance(item);
                }
                item._dictionary._updated = !isFlatten;
            }
        }
        this._dictionary._updated = !isFlatten;
    }
    _createAppearance(widget, state) {
        const bounds = widget.bounds;
        const parameter = new _PaintParameter();
        parameter.bounds = [0, 0, bounds.width, bounds.height];
        const backcolor = widget.backColor;
        if (backcolor) {
            parameter.backBrush = new PdfBrush(backcolor);
        }
        parameter.foreBrush = new PdfBrush(widget.color);
        const border = widget.border;
        parameter.borderPen = new PdfPen(widget.borderColor, border.width);
        parameter.borderStyle = border.style;
        parameter.borderWidth = border.width;
        if (backcolor) {
            const shadowColor = [backcolor[0] - 64, backcolor[1] - 64, backcolor[2] - 64];
            const color = [shadowColor[0] >= 0 ? shadowColor[0] : 0,
                shadowColor[1] >= 0 ? shadowColor[1] : 0,
                shadowColor[2] >= 0 ? shadowColor[2] : 0];
            parameter.shadowBrush = new PdfBrush(color);
        }
        parameter.rotationAngle = widget.rotate;
        const template = new PdfTemplate(parameter.bounds, this._crossReference);
        const graphics = template.graphics;
        this._drawRadioButton(graphics, parameter, _styleToString(widget.style), state);
        return template;
    }
    _drawAppearance(item) {
        let appearance = new _PdfDictionary();
        if (item._dictionary.has('AP')) {
            appearance = item._dictionary.get('AP');
            if (appearance) {
                if (appearance.has('N')) {
                    _removeReferences(appearance.get('N'), this._crossReference, item.value, 'Off');
                }
                if (appearance.has('D')) {
                    _removeReferences(appearance.get('D'), this._crossReference, item.value, 'Off');
                }
            }
            _removeDuplicateReference(appearance, this._crossReference, 'N');
            _removeDuplicateReference(appearance, this._crossReference, 'D');
        }
        else {
            const reference = this._crossReference._getNextReference();
            appearance = new _PdfDictionary(this._crossReference);
            this._crossReference._cacheMap.set(reference, appearance);
            item._dictionary.update('AP', reference);
        }
        const normalChecked = this._createAppearance(item, _PdfCheckFieldState.checked);
        const normalCheckedReference = this._crossReference._getNextReference();
        this._crossReference._cacheMap.set(normalCheckedReference, normalChecked._content);
        const normalUnchecked = this._createAppearance(item, _PdfCheckFieldState.unchecked);
        const normalUncheckedReference = this._crossReference._getNextReference();
        this._crossReference._cacheMap.set(normalUncheckedReference, normalUnchecked._content);
        const normalDictionary = new _PdfDictionary(this._crossReference);
        normalDictionary.update(item.value, normalCheckedReference);
        normalDictionary.update('Off', normalUncheckedReference);
        const normalReference = this._crossReference._getNextReference();
        this._crossReference._cacheMap.set(normalReference, normalDictionary);
        appearance.update('N', normalReference);
        const pressChecked = this._createAppearance(item, _PdfCheckFieldState.pressedChecked);
        const pressCheckedReference = this._crossReference._getNextReference();
        this._crossReference._cacheMap.set(pressCheckedReference, pressChecked._content);
        const pressUnchecked = this._createAppearance(item, _PdfCheckFieldState.pressedUnchecked);
        const pressUncheckedReference = this._crossReference._getNextReference();
        this._crossReference._cacheMap.set(pressUncheckedReference, pressUnchecked._content);
        const pressedDictionary = new _PdfDictionary(this._crossReference);
        pressedDictionary.update(item.value, pressCheckedReference);
        pressedDictionary.update('Off', pressUncheckedReference);
        const pressedReference = this._crossReference._getNextReference();
        this._crossReference._cacheMap.set(pressedReference, pressedDictionary);
        appearance.update('D', pressedReference);
        item._dictionary._updated = true;
    }
}
/**
 * Represents the base class for list box and combo box fields.
 *
 * ```typescript
 * // Load an existing PDF document
 * let document: PdfDocument = new PdfDocument(data);
 * // Gets the first page of the document
 * let page: PdfPage = document.getPage(0);
 * // Access the PDF form
 * let form: PdfForm = document.form;
 * // Access the combo box field
 * let comboBoxField: PdfListField = form.fieldAt(0) as PdfListField;
 * // Gets the count of the loaded combo box field items.
 * let comboItemsCount: number = comboBoxField.itemsCount;
 * // Access the list box field
 * let listBoxField: PdfListField = form.fieldAt(1) as PdfListField;
 * // Gets the count of the loaded list box field items.
 * let ListItemsCount: number = listBoxField.itemsCount;
 * // Save the document
 * document.save('output.pdf');
 * // Destroy the document
 * document.destroy();
 * ```
 */
class PdfListField extends PdfField {
    /**
     * Gets the count of the loaded field items (Read only).
     *
     * @returns {number} Items count.
     * ```typescript
     * // Load an existing PDF document
     * let document: PdfDocument = new PdfDocument(data);
     * // Gets the first page of the document
     * let page: PdfPage = document.getPage(0);
     * // Access the PDF form
     * let form: PdfForm = document.form;
     * // Access the combo box field
     * let comboBoxField: PdfComboBoxField = form.fieldAt(0) as PdfComboBoxField;
     * // Gets the count of the loaded combo box field items.
     * let comboItemsCount: number = comboBoxField.itemsCount;
     * // Access the list box field
     * let listBoxField: PdfListBoxField = form.fieldAt(1) as PdfListBoxField;
     * // Gets the count of the loaded list box field items.
     * let ListItemsCount: number = listBoxField.itemsCount;
     * // Save the document
     * document.save('output.pdf');
     * // Destroy the document
     * document.destroy();
     * ```
     */
    get itemsCount() {
        return this._options.length;
    }
    /**
     * Gets the bounds.
     *
     * @returns {{ x: number, y: number, width: number, height: number }} Bounds.
     * ```typescript
     * // Load an existing PDF document
     * let document: PdfDocument = new PdfDocument(data);
     * // Gets the first page of the document
     * let page: PdfPage = document.getPage(0);
     * // Access the PDF form
     * let form: PdfForm = document.form;
     * // Access the combo box field
     * let comboBoxField: PdfComboBoxField = form.fieldAt(0) as PdfComboBoxField;
     * // Gets the bounds of combo box field.
     * let comboBoxBounds: {x: number, y: number, width: number, height: number} = comboBoxField.bounds;
     * // Access the combo box field
     * let listBoxField: PdfListBoxField = form.fieldAt(1) as PdfListBoxField;
     * // Gets the bounds of list box field.
     * let listBoxBounds: {x: number, y: number, width: number, height: number} = listBoxField.bounds;
     * // Save the document
     * document.save('output.pdf');
     * // Destroy the document
     * document.destroy();
     * ```
     */
    get bounds() {
        let value;
        const widget = this.itemAt(this._defaultIndex);
        if (widget) {
            widget._page = this.page;
        }
        if (widget && widget.bounds) {
            value = widget.bounds;
        }
        else if (this._dictionary.has('Rect')) {
            value = _calculateBounds(this._dictionary, this.page);
        }
        if (value) {
            return value;
        }
        else if (this._bounds) {
            return this._bounds;
        }
        return value;
    }
    /**
     * Sets the bounds.
     *
     * @param {{ x: number, y: number, width: number, height: number }} value bounds.
     * ```typescript
     * // Load an existing PDF document
     * let document: PdfDocument = new PdfDocument(data);
     * // Gets the first page of the document
     * let page: PdfPage = document.getPage(0);
     * // Access the PDF form
     * let form: PdfForm = document.form;
     * // Access the combo box field
     * let comboBoxField: PdfComboBoxField = form.fieldAt(0) as PdfComboBoxField;
     * // Sets the bounds of combo box field.
     * comboBoxField.bounds = {x: 10, y: 10, width: 100, height: 30};
     * // Access the list box field
     * let listBoxField: PdfListBoxField = form.fieldAt(1) as PdfListBoxField;
     * // Sets the bounds of list box field.
     * listBoxField.bounds = {x: 10, y: 50, width: 100, height: 30};
     * // Save the document
     * document.save('output.pdf');
     * // Destroy the document
     * document.destroy();
     * ```
     */
    set bounds(value) {
        if (value.x === 0 && value.y === 0 && value.width === 0 && value.height === 0) {
            throw new Error('Cannot set empty bounds');
        }
        const widget = this.itemAt(this._defaultIndex);
        if (this._isLoaded) {
            if (typeof widget === 'undefined' || this._dictionary.has('Rect')) {
                this._dictionary.update('Rect', _getUpdatedBounds([value.x, value.y, value.width, value.height], this.page));
            }
            else {
                widget._page = this.page;
                widget.bounds = value;
            }
        }
        else {
            if (widget) {
                widget._page = this.page;
                widget.bounds = value;
            }
            else {
                this._bounds = value;
            }
        }
    }
    /**
     * Gets the selected item index or indexes.
     *
     * @returns {number | number[]} Index.
     * ```typescript
     * // Load an existing PDF document
     * let document: PdfDocument = new PdfDocument(data);
     * // Gets the first page of the document
     * let page: PdfPage = document.getPage(0);
     * // Access the PDF form
     * let form: PdfForm = document.form;
     * // Access the combo box field
     * let comboBoxfield: PdfComboBoxField = form.fieldAt(0) as PdfComboBoxField;
     * // Gets the selected item index or indexes from combo box field.
     * let comboBoxIndex: number = comboBoxfield.selectedIndex;
     * // Access the list box field
     * let listBoxField: PdfListBoxField = form.fieldAt(1) as PdfListBoxField;
     * // Gets the selected item index or indexes from list box field.
     * let listBoxIndex: number = listBoxField.selectedIndex;
     * // Save the document
     * document.save('output.pdf');
     * // Destroy the document
     * document.destroy();
     * ```
     */
    get selectedIndex() {
        const value = this._dictionary.get('I');
        if (typeof value === 'undefined') {
            return [];
        }
        else {
            if (value.length === 1) {
                return value[0];
            }
            else {
                return value;
            }
        }
    }
    /**
     * Sets the selected item index or indexes.
     *
     * @param {number | number[]} value Selected index.
     * ```typescript
     * // Load an existing PDF document
     * let document: PdfDocument = new PdfDocument(data);
     * // Gets the first page of the document
     * let page: PdfPage = document.getPage(0);
     * // Access the PDF form
     * let form: PdfForm = document.form;
     * // Create a new list box field
     * let listField: PdfListField = new PdfListBoxField(page, 'list1', {x: 100, y: 60, width: 100, height: 50});
     * // Add list items to the field.
     * listField.addItem(new PdfListFieldItem('English', 'English'));
     * listField.addItem(new PdfListFieldItem('French', 'French'));
     * listField.addItem(new PdfListFieldItem('German', 'German'));
     * // Sets the selected index
     * listField.selectedIndex = 2;
     * // Sets the flag indicates whether the list box allows multiple selections.
     * listField.multiSelect = true;
     * // Add the field into PDF form
     * form.add(listField);
     * // Create a new combo box field
     * let comboField: PdfComboBoxField = new PdfComboBoxField(page, 'list1', {x: 100, y: 160, width: 100, height: 50});
     * // Add list items to the field.
     * comboField.addItem(new PdfListFieldItem('English', 'English'));
     * comboField.addItem(new PdfListFieldItem('French', 'French'));
     * comboField.addItem(new PdfListFieldItem('German', 'German'));
     * // Sets the selected index
     * comboField.selectedIndex = 2;
     * // Sets the flag indicates whether the combo box allows multiple selections.
     * comboField.multiSelect = true;
     * // Add the field into PDF form
     * form.add(comboField);
     * // Save the document
     * document.save('output.pdf');
     * // Destroy the document
     * document.destroy();
     * ```
     */
    set selectedIndex(value) {
        const length = this._options.length;
        if (typeof value === 'number') {
            this._checkIndex(value, length);
            this._dictionary.update('I', [value]);
            this._dictionary.update('V', [this._options[Number.parseInt(value.toString(), 10)][0]]);
        }
        else {
            const values = [];
            value.forEach((entry) => {
                this._checkIndex(entry, length);
                values.push(this._options[Number.parseInt(entry.toString(), 10)][0]);
            });
            this._dictionary.update('I', value);
            this._dictionary.update('V', values);
        }
    }
    /**
     * Gets the selected item value or values.
     *
     * @returns {string | string[]} Selected values.
     * ```typescript
     * // Load an existing PDF document
     * let document: PdfDocument = new PdfDocument(data);
     * // Gets the first page of the document
     * let page: PdfPage = document.getPage(0);
     * // Access the PDF form
     * let form: PdfForm = document.form;
     * // Access the list box field
     * let listBoxField: PdfListBoxField = form.fieldAt(0) as PdfListBoxField;
     * // Gets the selected item value or values from list box field.
     * if (listBoxField.multiSelect) {
     *     let listBoxValues: string[]; = listBoxField.selectedValue;
     * } else {
     *    let listBoxValues: string = listBoxField.selectedValue;
     * }
     * // Save the document
     * document.save('output.pdf');
     * // Destroy the document
     * document.destroy();
     * ```
     */
    get selectedValue() {
        const values = [];
        if (this._dictionary.has('V')) {
            const value = this._dictionary.getArray('V'); // eslint-disable-line
            if (typeof value !== 'undefined') {
                if (Array.isArray(value)) {
                    value.forEach((element) => {
                        values.push(element);
                    });
                }
                else if (typeof value === 'string') {
                    values.push(value);
                }
            }
        }
        if (values.length === 0 && this._dictionary.has('I')) {
            const value = this._dictionary.get('I');
            if (value && value.length > 0) {
                value.forEach((index) => {
                    values.push(this._options[Number.parseInt(index.toString(), 10)][0]);
                });
            }
        }
        if (values.length === 1) {
            return values[0];
        }
        else {
            return values;
        }
    }
    /**
     * Sets the selected item value or values.
     *
     * @param {string | string[]} value Selected values.
     * ```typescript
     * // Load an existing PDF document
     * let document: PdfDocument = new PdfDocument(data);
     * // Gets the first page of the document
     * let page: PdfPage = document.getPage(0);
     * // Access the PDF form
     * let form: PdfForm = document.form;
     * // Create a new list box field
     * let listField: PdfListField = new PdfListBoxField(page, 'list1', {x: 100, y: 60, width: 100, height: 50});
     * // Add list items to the field.
     * listField.addItem(new PdfListFieldItem('English', 'English'));
     * listField.addItem(new PdfListFieldItem('French', 'French'));
     * listField.addItem(new PdfListFieldItem('German', 'German'));
     * // Sets the flag indicates whether the list box allows multiple selections.
     * listField.multiSelect = true;
     * // Sets the selected values
     * listField.selectedValue = ['English', 'German'];
     * // Add the field into PDF form
     * form.add(listField);
     * // Create a new combo box field
     * let comboField: PdfComboBoxField = new PdfComboBoxField(page, 'list1', {x: 100, y: 160, width: 100, height: 50});
     * // Add list items to the field.
     * comboField.addItem(new PdfListFieldItem('English', 'English'));
     * comboField.addItem(new PdfListFieldItem('French', 'French'));
     * comboField.addItem(new PdfListFieldItem('German', 'German'));
     * // Sets the selected value
     * comboField.selectedValue = ['French'];
     * // Add the field into PDF form
     * form.add(comboField);
     * // Save the document
     * document.save('output.pdf');
     * // Destroy the document
     * document.destroy();
     * ```
     */
    set selectedValue(value) {
        if (typeof value === 'string') {
            const index = this._tryGetIndex(value);
            if (index !== -1) {
                this._dictionary.update('I', [index]);
                this._dictionary.update('V', [value]);
            }
        }
        else {
            const values = [];
            const indices = [];
            value.forEach((entry) => {
                const index = this._tryGetIndex(entry);
                if (index !== -1) {
                    indices.push(index);
                    values.push(entry);
                }
            });
            if (values.length > 0) {
                this._dictionary.update('I', indices);
                this._dictionary.update('V', values);
            }
        }
    }
    /**
     * Gets the flag indicates whether the list field allows multiple selections.
     *
     * @returns {boolean} Value indicates whether the list field allows multiple selections.
     * ```typescript
     * // Load an existing PDF document
     * let document: PdfDocument = new PdfDocument(data);
     * // Gets the first page of the document
     * let page: PdfPage = document.getPage(0);
     * // Access the PDF form
     * let form: PdfForm = document.form;
     * // Access the combo box field
     * let comboBoxField: PdfComboBoxField = form.fieldAt(0) as PdfComboBoxField;
     * // Gets the flag indicates whether the combo box allows multiple selections.
     * let comboBoxFlag: Boolean = comboBoxField.multiSelect;
     * // Access the list box field
     * let listBoxField: PdfListBoxField = form.fieldAt(1) as PdfListBoxField;
     * // Gets the flag indicates whether the list box allows multiple selections.
     * let listBoxFlag: boolean = listBoxField.multiSelect;
     * // Save the document
     * document.save('output.pdf');
     * // Destroy the document
     * document.destroy();
     * ```
     */
    get multiSelect() {
        if (this._isLoaded) {
            return (this._fieldFlags & _FieldFlag.multiSelect) !== 0;
        }
        else {
            return this._multiSelect;
        }
    }
    /**
     * Sets the flag indicates whether the list field allows multiple selections.
     *
     * @param {boolean} value Indicates whether the list field allows multiple selections.
     * ```typescript
     * // Load an existing PDF document
     * let document: PdfDocument = new PdfDocument(data);
     * // Gets the first page of the document
     * let page: PdfPage = document.getPage(0);
     * // Access the PDF form
     * let form: PdfForm = document.form;
     * // Create a new list box field
     * let listField: PdfListField = new PdfListBoxField(page, 'list1', {x: 100, y: 60, width: 100, height: 50});
     * // Add list items to the field.
     * listField.addItem(new PdfListFieldItem('English', 'English'));
     * listField.addItem(new PdfListFieldItem('French', 'French'));
     * listField.addItem(new PdfListFieldItem('German', 'German'));
     * // Sets the selected index
     * listField.selectedIndex = 2;
     * // Sets the flag indicates whether the list box allows multiple selections.
     * listField.multiSelect = true;
     * // Add the field into PDF form
     * form.add(listField);
     * // Create a new combo box field
     * let comboField: PdfComboBoxField = new PdfComboBoxField(page, 'list1', {x: 100, y: 160, width: 100, height: 50});
     * // Add list items to the field.
     * comboField.addItem(new PdfListFieldItem('English', 'English'));
     * comboField.addItem(new PdfListFieldItem('French', 'French'));
     * comboField.addItem(new PdfListFieldItem('German', 'German'));
     * // Sets the selected index
     * comboField.selectedIndex = 2;
     * // Sets the flag indicates whether the combo box allows multiple selections.
     * comboField.multiSelect = true;
     * // Add the field into PDF form
     * form.add(comboField);
     * // Save the document
     * document.save('output.pdf');
     * // Destroy the document
     * document.destroy();
     * ```
     */
    set multiSelect(value) {
        if (this.multiSelect !== value) {
            this._multiSelect = value;
            if (value) {
                this._fieldFlags |= _FieldFlag.multiSelect;
            }
            else {
                this._fieldFlags &= ~_FieldFlag.multiSelect;
            }
        }
    }
    /**
     * Gets the flag indicates whether the list field is editable.
     *
     * @returns {boolean} Value indicates whether the list field is editable.
     * ```typescript
     * // Load an existing PDF document
     * let document: PdfDocument = new PdfDocument(data);
     * // Gets the first page of the document
     * let page: PdfPage = document.getPage(0);
     * // Access the PDF form
     * let form: PdfForm = document.form;
     * // Access the combo box field
     * let comboBoxField: PdfComboBoxField = form.fieldAt(0) as PdfComboBoxField;
     * // Gets the flag indicates whether the combo box is editable.
     * let comboBoxFlag: Boolean = comboBoxField.editable;
     * // Access the list box field
     * let listBoxField: PdfListBoxField = form.fieldAt(1) as PdfListBoxField;
     * // Gets the flag indicates whether the list box is editable.
     * let listBoxFlag: boolean = listBoxField.editable;
     * // Save the document
     * document.save('output.pdf');
     * // Destroy the document
     * document.destroy();
     * ```
     */
    get editable() {
        if (this._isLoaded) {
            return (this._fieldFlags & _FieldFlag.edit) !== 0;
        }
        else {
            return this._editable;
        }
    }
    /**
     * Sets the flag indicates whether the list field is editable.
     *
     * @param {boolean} value Indicates whether the list field is editable.
     * ```typescript
     * // Load an existing PDF document
     * let document: PdfDocument = new PdfDocument(data);
     * // Gets the first page of the document
     * let page: PdfPage = document.getPage(0);
     * // Access the PDF form
     * let form: PdfForm = document.form;
     * // Create a new list box field
     * let listField: PdfListField = new PdfListBoxField(page, 'list1', {x: 100, y: 60, width: 100, height: 50});
     * // Add list items to the field.
     * listField.addItem(new PdfListFieldItem('English', 'English'));
     * listField.addItem(new PdfListFieldItem('French', 'French'));
     * listField.addItem(new PdfListFieldItem('German', 'German'));
     * // Sets the selected index
     * listField.selectedIndex = 2;
     * // Sets the flag indicates whether the list box is editable.
     * listField.editable = true;
     * // Add the field into PDF form
     * form.add(listField);
     * // Create a new combo box field
     * let comboField: PdfComboBoxField = new PdfComboBoxField(page, 'list1', {x: 100, y: 160, width: 100, height: 50});
     * // Add list items to the field.
     * comboField.addItem(new PdfListFieldItem('English', 'English'));
     * comboField.addItem(new PdfListFieldItem('French', 'French'));
     * comboField.addItem(new PdfListFieldItem('German', 'German'));
     * // Sets the selected index
     * comboField.selectedIndex = 2;
     * // Sets the flag indicates whether the combo box is editable.
     * comboField.editable = true;
     * // Add the field into PDF form
     * form.add(comboField);
     * // Save the document
     * document.save('output.pdf');
     * // Destroy the document
     * document.destroy();
     * ```
     */
    set editable(value) {
        if (this._editable !== value) {
            this._editable = value;
            if (value) {
                this._fieldFlags |= _FieldFlag.edit;
            }
            else {
                this._fieldFlags &= ~_FieldFlag.edit;
            }
        }
    }
    /**
     * Gets the font of the field.
     *
     * @returns {PdfFont} font.
     *
     * ```typescript
     * // Load an existing PDF document
     * let document: PdfDocument = new PdfDocument(data, password);
     * // Access the form field at index 0
     * let field: PdfListBoxField = document.form.fieldAt(0) as PdfListBoxField;
     * // Gets the font of the field.
     * let font: PdfFont = field.font;
     * // Save the document
     * document.save('output.pdf');
     * // Destroy the document
     * document.destroy();
     * ```
     */
    get font() {
        if (this._font) {
            return this._font;
        }
        else {
            const widget = this.itemAt(this._defaultIndex);
            this._font = _obtainFontDetails(this._form, widget, this);
        }
        return this._font;
    }
    /**
     * Sets the font of the field.
     *
     * @param {PdfFont} value font.
     *
     * ```typescript
     * // Load an existing PDF document
     * let document: PdfDocument = new PdfDocument(data, password);
     * // Access the form field at index 0
     * let field: PdfListBoxField = document.form.fieldAt(0) as PdfListBoxField;
     * // Sets the font of the field
     * field.font = new PdfStandardFont(PdfFontFamily.helvetica, 12, PdfFontStyle.bold);
     * // Save the document
     * document.save('output.pdf');
     * // Destroy the document
     * document.destroy();
     * ```
     */
    set font(value) {
        if (value && value instanceof PdfFont) {
            this._font = value;
            this._initializeFont(value);
        }
    }
    /**
     * Gets the text alignment in a combo box field.
     *
     * @returns {PdfTextAlignment} Text alignment.
     *
     * ```typescript
     * // Load an existing PDF document
     * let document: PdfDocument = new PdfDocument(data);
     * // Access combo box field
     * let field: PdfComboBoxField = document.form.fieldAt(0) as PdfComboBoxField;
     * // Gets the text alignment from combo box field
     * let alignment: PdfTextAlignment = field.textAlignment;
     * // Save the document
     * document.save('output.pdf');
     * // Destroy the document
     * document.destroy();
     * ```
     */
    get textAlignment() {
        return this._getTextAlignment();
    }
    /**
     * Sets the text alignment in a combo box field.
     *
     * @param {PdfTextAlignment} value Text alignment.
     *
     * ```typescript
     * // Load an existing PDF document
     * let document: PdfDocument = new PdfDocument(data);
     * // Access combo box field
     * let field: PdfComboBoxField = document.form.fieldAt(0) as PdfComboBoxField;
     * // Sets the text alignment of form field as center
     * field.textAlignment = PdfTextAlignment.center;
     * // Save the document
     * document.save('output.pdf');
     * // Destroy the document
     * document.destroy();
     * ```
     */
    set textAlignment(value) {
        if (this._textAlignment !== value) {
            this._setTextAlignment(value);
        }
    }
    /**
     * Gets the background color of the field.
     *
     * @returns {number[]} R, G, B color values in between 0 to 255.
     * ```typescript
     * // Load an existing PDF document
     * let document: PdfDocument = new PdfDocument(data, password);
     * // Access the form field at index 0
     * let field: PdfField = document.form.fieldAt(0);
     * // Gets the background color of the field.
     * let backColor: number[] = field.backColor;
     * // Save the document
     * document.save('output.pdf');
     * // Destroy the document
     * document.destroy();
     * ```
     */
    get backColor() {
        return this._parseBackColor(true);
    }
    /**
     * Sets the background color of the field.
     *
     * @param {number[]} value Array with R, G, B, A color values in between 0 to 255. For optional A (0-254), it signifies transparency.
     * ```typescript
     * // Load an existing PDF document
     * let document: PdfDocument = new PdfDocument(data, password);
     * // Access the list field at index 0
     * let list1: PdfField = document.form.fieldAt(0);
     * // Sets the background color of the field.
     * list1.backColor = [255, 0, 0];
     * // Access the list field at index 1
     * let list2: PdfField = document.form.fieldAt(1);
     * // Sets the background color of the field to transparent.
     * list2.backColor = [0, 0, 0, 0];
     * // Save the document
     * document.save('output.pdf');
     * // Destroy the document
     * document.destroy();
     * ```
     */
    set backColor(value) {
        this._updateBackColor(value, true);
    }
    get _options() {
        if (!this._optionArray) {
            if (this._dictionary.has('Opt')) {
                this._optionArray = this._dictionary.getArray('Opt');
            }
            else {
                this._optionArray = [];
                this._dictionary.update('Opt', this._optionArray);
            }
        }
        return this._optionArray;
    }
    /**
     * Gets the item at the specified index.
     *
     * @param {number} index Index of the field item.
     * @returns {PdfListFieldItem} Field item at the index.
     * ```typescript
     * // Load an existing PDF document
     * let document: PdfDocument = new PdfDocument(data);
     * // Gets the first page of the document
     * let page: PdfPage = document.getPage(0);
     * // Access the PDF form
     * let form: PdfForm = document.form;
     * // Access the list box field
     * let listBox: PdfListBoxField = form.fieldAt(0) as PdfListBoxField;
     * // Gets the first list item.
     * let listBoxItem: PdfListFieldItem = listBox.itemAt(0);
     * // Access the combo box field
     * let comboBox: PdfComboBoxField = form.fieldAt(1) as PdfComboBoxField;
     * // Gets the first list item.
     * let comboBoxItem: PdfListFieldItem = comboBox.itemAt(0);
     * // Save the document
     * document.save('output.pdf');
     * // Destroy the document
     * document.destroy();
     * ```
     */
    itemAt(index) {
        let item;
        if (index < this._kidsCount) {
            if (this._parsedItems.has(index)) {
                item = this._parsedItems.get(index);
            }
            else {
                let dictionary;
                const reference = this._kids[Number.parseInt(index.toString(), 10)];
                if (reference && reference instanceof _PdfReference) {
                    dictionary = this._crossReference._fetch(reference);
                }
                if (dictionary) {
                    item = PdfListFieldItem._load(dictionary, this._crossReference, this);
                    item._index = index;
                    item._ref = reference;
                    if (this._options && this._options.length > 0 && index < this._options.length) {
                        item._text = this._options[Number.parseInt(index.toString(), 10)][1];
                    }
                    else {
                        item._text = '';
                    }
                    this._parsedItems.set(index, item);
                }
            }
        }
        else {
            if (this._parsedItems.has(index)) {
                item = this._parsedItems.get(index);
            }
            else if (this._kidsCount > 0 && this._kids && this._kids.length > 0) {
                let dictionary;
                let reference;
                if (this._kidsCount === 1) {
                    reference = this._kids[0];
                }
                else {
                    reference = this._kids[Number.parseInt(index.toString(), 10)];
                }
                if (reference && reference instanceof _PdfReference) {
                    dictionary = this._crossReference._fetch(reference);
                }
                if (dictionary) {
                    item = PdfListFieldItem._load(dictionary, this._crossReference, this);
                    item._index = index;
                    item._ref = reference;
                    if (this._options && this._options.length > 0 && index < this._options.length) {
                        item._text = this._options[Number.parseInt(index.toString(), 10)][1];
                    }
                    else {
                        item._text = '';
                    }
                    this._parsedItems.set(index, item);
                }
            }
        }
        return item;
    }
    /**
     * Add list item.
     *
     * @param {PdfListFieldItem} item Item to add.
     * @returns {number} Index of the field item.
     * ```typescript
     * // Load an existing PDF document
     * let document: PdfDocument = new PdfDocument(data);
     * // Gets the first page of the document
     * let page: PdfPage = document.getPage(0);
     * // Access the PDF form
     * let form: PdfForm = document.form;
     * // Create a new list box field
     * let listField: PdfListField = new PdfListBoxField(page, 'list1', {x: 100, y: 60, width: 100, height: 50});
     * // Add list items to the field.
     * listField.addItem(new PdfListFieldItem('English', 'English'));
     * listField.addItem(new PdfListFieldItem('French', 'French'));
     * listField.addItem(new PdfListFieldItem('German', 'German'));
     * // Sets the selected index
     * listField.selectedIndex = 2;
     * // Sets the flag indicates whether the list box allows multiple selections.
     * listField.multiSelect = true;
     * // Add the field into PDF form
     * form.add(listField);
     * // Create a new combo box field
     * let comboField: PdfComboBoxField = new PdfComboBoxField(page, 'list1', {x: 100, y: 160, width: 100, height: 50});
     * // Add list items to the field.
     * comboField.addItem(new PdfListFieldItem('English', 'English'));
     * comboField.addItem(new PdfListFieldItem('French', 'French'));
     * comboField.addItem(new PdfListFieldItem('German', 'German'));
     * // Sets the selected index
     * comboField.selectedIndex = 2;
     * // Sets the flag indicates whether the combo box allows multiple selections.
     * comboField.multiSelect = true;
     * // Add the field into PDF form
     * form.add(comboField);
     * // Save the document
     * document.save('output.pdf');
     * // Destroy the document
     * document.destroy();
     * ```
     */
    addItem(item) {
        this._addToOptions(item, this);
        return this._listValues.length - 1;
    }
    /**
     * Remove the list item from the specified index.
     *
     * @param {number} index Item index to remove.
     * @returns {void} Nothing.
     * ```typescript
     * // Load an existing PDF document
     * let document: PdfDocument = new PdfDocument(data);
     * // Gets the first page of the document
     * let page: PdfPage = document.getPage(0);
     * // Access the PDF form
     * let form: PdfForm = document.form;
     * // Access the list box field
     * let listBoxField: PdfListBoxField = form.fieldAt(0) as PdfListBoxField;
     * // Remove the list item from the list box field
     * listBoxField.removeItemAt(1);
     * // Access the combo box field
     * let comboBoxField: PdfComboBoxField = form.fieldAt(1) as PdfComboBoxField;
     * // Remove the list item from the combo box field
     * comboBoxField.removeItemAt(0);
     * // Save the document
     * document.save('output.pdf');
     * // Destroy the document
     * document.destroy();
     * ```
     */
    removeItemAt(index) {
        const item = this.itemAt(index);
        if (item && item._ref) {
            this._parsedItems.delete(index);
            if (this._parsedItems.size > 0) {
                const parsedItems = new Map();
                this._parsedItems.forEach((value, key) => {
                    if (key > index) {
                        parsedItems.set(key - 1, value);
                    }
                    else {
                        parsedItems.set(key, value);
                    }
                });
                this._parsedItems = parsedItems;
            }
            if (this._dictionary.has('Opt')) {
                const options = this._options;
                if (options && options.length > 0) {
                    options.splice(index, 1);
                    this._dictionary.set('Opt', options);
                    this._optionArray = options;
                    this._dictionary._updated = true;
                }
            }
        }
    }
    /**
     * Remove the list item.
     *
     * @param {PdfListFieldItem} item Item to remove.
     * @returns {void} Nothing.
     * ```typescript
     * // Load an existing PDF document
     * let document: PdfDocument = new PdfDocument(data);
     * // Gets the first page of the document
     * let page: PdfPage = document.getPage(0);
     * // Access the PDF form
     * let form: PdfForm = document.form;
     * // Access the list box field
     * let listBoxField: PdfListBoxField = form.fieldAt(0) as PdfListBoxField;
     * // Remove the list item from the list box field
     * listBoxField.removeItem(listBoxField.itemAt(1));
     * // Access the combo box field
     * let comboBoxField: PdfComboBoxField = form.fieldAt(1) as PdfComboBoxField;
     * // Remove the list item from the combo box field
     * comboBoxField.removeItem(comboBoxField.itemAt(0));
     * // Save the document
     * document.save('output.pdf');
     * // Destroy the document
     * document.destroy();
     * ```
     */
    removeItem(item) {
        if (item && item.text) {
            let index;
            for (let i = 0; i < this.itemsCount; i++) {
                const fieldItem = this.itemAt(i);
                if (fieldItem && item === fieldItem && fieldItem.text === item.text) {
                    index = i;
                    break;
                }
            }
            if (index !== -1) {
                this.removeItemAt(index);
            }
        }
    }
    _initialize(page, name, bounds) {
        this._defaultIndex = 0;
        this._crossReference = page._crossReference;
        this._page = page;
        this._name = name;
        this._dictionary = new _PdfDictionary(this._crossReference);
        this._ref = this._crossReference._getNextReference();
        this._crossReference._cacheMap.set(this._ref, this._dictionary);
        this._dictionary.objId = this._ref.toString();
        this._dictionary.update('FT', _PdfName.get('Ch'));
        this._dictionary.update('T', name);
        this._parsedItems = new Map();
        this._listValues = [];
        this._kids = [];
        this.bounds = bounds;
        this._addEmptyWidget();
    }
    _obtainFont(item) {
        let fontFamily = '';
        let fontSize = 1;
        if (item && (item._dictionary.has('DS') || item._dictionary.has('DA'))) {
            if (item._dictionary.has('DS')) {
                const collection = item._dictionary.get('DS').split(';');
                for (let i = 0; i < collection.length; i++) {
                    const entry = collection[Number.parseInt(i.toString(), 10)].split(':');
                    if (collection[Number.parseInt(i.toString(), 10)].indexOf('font-family') !== -1) {
                        fontFamily = entry[1];
                    }
                    else if (collection[Number.parseInt(i.toString(), 10)].indexOf('font-size') !== -1) {
                        if (entry[1].endsWith('pt')) {
                            fontSize = Number.parseFloat(entry[1].replace('pt', ''));
                        }
                    }
                    else if (collection[Number.parseInt(i.toString(), 10)].indexOf('font-style') === -1 && collection[Number.parseInt(i.toString(), 10)].indexOf('font') !== -1) {
                        const name = entry[1];
                        const split = name.split(' ');
                        for (let j = 0; j < split.length; j++) {
                            if (split[Number.parseInt(j.toString(), 10)] !== '' && !split[Number.parseInt(j.toString(), 10)].endsWith('pt')) {
                                fontFamily += split[Number.parseInt(j.toString(), 10)] + ' ';
                            }
                            if (split[Number.parseInt(j.toString(), 10)].endsWith('pt')) {
                                fontSize = Number.parseFloat(split[Number.parseInt(j.toString(), 10)].replace('pt', ''));
                            }
                        }
                        while (fontFamily !== ' ' && fontFamily.endsWith(' ')) {
                            fontFamily = fontFamily.substring(0, fontFamily.length - 2);
                        }
                        if (fontFamily.indexOf(',') !== -1) {
                            fontFamily = fontFamily.split(',')[0];
                        }
                    }
                }
            }
            else {
                const value = item._dictionary.get('DA');
                if (value && value !== '' && value.indexOf('Tf') !== -1) {
                    const textCollection = value.split(' ');
                    for (let i = 0; i < textCollection.length; i++) {
                        if (textCollection[Number.parseInt(i.toString(), 10)].indexOf('Tf') !== -1) {
                            fontFamily = textCollection[i - 2];
                            while (fontFamily !== '' && fontFamily.length > 1 && fontFamily[0] === '/') {
                                fontFamily = fontFamily.substring(1);
                            }
                            fontSize = Number.parseFloat(textCollection[i - 1]);
                        }
                    }
                    let height = 0.0;
                    if (fontSize === 0) {
                        const font = new PdfStandardFont(PdfFontFamily.helvetica, height);
                        if (font !== null) {
                            height = this._getFontHeight(font._fontFamily);
                            if (Number.isNaN(height) || height === 0) {
                                height = 12;
                            }
                            font._size = height;
                            fontSize = height;
                        }
                    }
                }
            }
            fontFamily = fontFamily.trim();
            switch (fontFamily) {
                case 'Helv':
                    this._font = new PdfStandardFont(PdfFontFamily.helvetica, fontSize, PdfFontStyle.regular);
                    break;
                case 'Courier':
                case 'Cour':
                    this._font = new PdfStandardFont(PdfFontFamily.courier, fontSize, PdfFontStyle.regular);
                    break;
                case 'Symb':
                    this._font = new PdfStandardFont(PdfFontFamily.symbol, fontSize, PdfFontStyle.regular);
                    break;
                case 'TiRo':
                    this._font = new PdfStandardFont(PdfFontFamily.timesRoman, fontSize, PdfFontStyle.regular);
                    break;
                case 'ZaDb':
                    this._font = new PdfStandardFont(PdfFontFamily.zapfDingbats, fontSize, PdfFontStyle.regular);
                    break;
                default:
                    this._font = new PdfStandardFont(PdfFontFamily.helvetica, fontSize, PdfFontStyle.regular);
                    break;
            }
        }
        return this._font;
    }
    _obtainSelectedValue() {
        const result = [];
        if (this._dictionary.has('V')) {
            const primitive = this._dictionary.get('V'); // eslint-disable-line
            const array = this._dictionary.getArray('V'); // eslint-disable-line
            if (primitive !== null && typeof primitive !== 'undefined') {
                if (typeof primitive === 'string') {
                    result.push(primitive);
                }
                else if (Array.isArray(primitive)) {
                    array.forEach((element) => {
                        result.push(element);
                    });
                }
            }
        }
        else {
            const selectedIndexes = this._dictionary.get('I');
            if (selectedIndexes !== null &&
                typeof selectedIndexes !== 'undefined' &&
                selectedIndexes.length > 0 &&
                selectedIndexes[0] > -1 &&
                this._options &&
                this._options.length > 0) {
                selectedIndexes.forEach((index) => {
                    result.push(this._options[Number.parseInt(index.toString(), 10)][0]);
                });
            }
        }
        return result;
    }
    _doPostProcess(isFlatten = false) {
        if (isFlatten || this._setAppearance || this._form._setAppearance) {
            const count = this._kidsCount;
            if (this._kids && this._kids.length > 0) {
                if (count > 1) {
                    for (let i = 0; i < count; i++) {
                        const item = this.itemAt(i);
                        if (item && !this._checkFieldFlag(item._dictionary)) {
                            const template = this._createAppearance(item);
                            if (isFlatten) {
                                const page = item._getPage();
                                if (page) {
                                    this._drawTemplate(template, page, item.bounds);
                                }
                            }
                            else {
                                this._addAppearance(item._dictionary, template, 'N');
                            }
                            item._dictionary._updated = !isFlatten;
                        }
                    }
                }
                else {
                    const item = this.itemAt(0);
                    const template = this._createAppearance();
                    if (isFlatten) {
                        const page = this.page;
                        if (page) {
                            this._drawTemplate(template, page, this.bounds);
                        }
                    }
                    else {
                        this._addAppearance(item._dictionary, template, 'N');
                    }
                    item._dictionary._updated = !isFlatten;
                }
            }
            else if (this._dictionary) {
                const template = this._createAppearance();
                if (isFlatten) {
                    const page = this.page;
                    if (page) {
                        this._drawTemplate(template, page, this.bounds);
                    }
                }
                else {
                    this._addAppearance(this._dictionary, template, 'N');
                }
            }
            this._dictionary._updated = !isFlatten;
        }
    }
    _tryGetIndex(value) {
        let index = -1;
        if (this._options && this._options.length > 0) {
            for (let i = 0; i < this._options.length; i++) {
                if (value === this._options[Number.parseInt(i.toString(), 10)][0]) {
                    index = i;
                    break;
                }
            }
        }
        return index;
    }
    _addEmptyWidget() {
        const widget = new PdfWidgetAnnotation();
        widget._create(this._page, this.bounds, this);
        this._addToKid(widget);
        widget._dictionary.update('MK', new _PdfDictionary(this._crossReference));
        widget._mkDictionary.update('BC', [0, 0, 0]);
        widget._mkDictionary.update('BG', [1, 1, 1]);
        widget._dictionary.update('DA', '/TiRo 0 Tf 0 0 0 rg');
    }
}
/**
 * `PdfComboBoxField` class represents the combo box field objects.
 * ```typescript
 * // Load an existing PDF document
 * let document: PdfDocument = new PdfDocument(data);
 * // Gets the first page of the document
 * let page: PdfPage = document.getPage(0);
 * // Access the PDF form
 * let form: PdfForm = document.form;
 * // Create a new combo box field
 * let field: PdfComboBoxField = new PdfComboBoxField(page, 'list1', {x: 100, y: 60, width: 100, height: 50});
 * // Add list items to the field.
 * field.addItem(new PdfListFieldItem('English', 'English'));
 * field.addItem(new PdfListFieldItem('French', 'French'));
 * field.addItem(new PdfListFieldItem('German', 'German'));
 * // Sets the selected index
 * field.selectedIndex = 2;
 * // Sets the flag indicates whether the combo box allows multiple selections.
 * field.multiSelect = true;
 * // Add the field into PDF form
 * form.add(field);
 * // Save the document
 * document.save('output.pdf');
 * // Destroy the document
 * document.destroy();
 * ```
 */
class PdfComboBoxField extends PdfListField {
    constructor(page, name, bounds) {
        super();
        if (page && name && bounds) {
            this._initialize(page, name, bounds);
            this._fieldFlags |= _FieldFlag.combo;
        }
    }
    /**
     * Gets the boolean flag indicates whether the combo box field is auto size.
     *
     * @private
     * @returns {boolean} Returns the boolean value to check auto size.
     */
    get _isAutoFontSize() {
        let isAutoFontSize = false;
        if (this._isLoaded && this._form) {
            const acroForm = this._form._dictionary;
            if (acroForm && acroForm.has('DA')) {
                let fontString = acroForm.get('DA');
                if (fontString) {
                    let defaultAppearance = new _PdfDefaultAppearance(fontString);
                    if (defaultAppearance.fontSize === 0) {
                        if (this._kids && this._kids.length > 0) {
                            let fontSize = false;
                            if (this._dictionary.has('DA')) {
                                fontString = this._dictionary.get('DA');
                                if (fontString) {
                                    defaultAppearance = new _PdfDefaultAppearance(fontString);
                                    if (defaultAppearance && defaultAppearance.fontSize > 0) {
                                        fontSize = true;
                                    }
                                }
                            }
                            if (!fontSize) {
                                for (let i = 0; i < this._kids.length; i++) {
                                    let dictionary;
                                    const reference = this._kids[Number.parseInt(i.toString(), 10)];
                                    if (reference && reference instanceof _PdfReference) {
                                        dictionary = this._crossReference._fetch(reference);
                                    }
                                    if (dictionary) {
                                        if (dictionary.has('DA')) {
                                            fontString = dictionary.get('DA');
                                            let height = 0;
                                            if (fontString) {
                                                defaultAppearance = new _PdfDefaultAppearance(fontString);
                                                if (defaultAppearance) {
                                                    height = defaultAppearance.fontSize;
                                                }
                                            }
                                            if (height === 0) {
                                                isAutoFontSize = true;
                                            }
                                        }
                                        else {
                                            isAutoFontSize = true;
                                        }
                                    }
                                }
                            }
                        }
                        else {
                            if (this._dictionary.has('DA')) {
                                fontString = this._dictionary.get('DA');
                                let height = 0;
                                if (fontString) {
                                    defaultAppearance = new _PdfDefaultAppearance(fontString);
                                    if (defaultAppearance) {
                                        height = defaultAppearance.fontSize;
                                    }
                                }
                                if (height === 0) {
                                    isAutoFontSize = true;
                                }
                            }
                            else {
                                isAutoFontSize = true;
                            }
                        }
                    }
                }
            }
        }
        return isAutoFontSize;
    }
    /**
     * Parse an existing combo box field.
     *
     * @private
     * @param {PdfForm} form Form object.
     * @param {_PdfDictionary} dictionary Field dictionary.
     * @param {_PdfCrossReference} crossReference Cross reference object.
     * @param {_PdfReference} reference Field reference.
     * @returns {PdfComboBoxField} Combo box field.
     */
    static _load(form, dictionary, crossReference, reference) {
        const field = new PdfComboBoxField();
        field._isLoaded = true;
        field._form = form;
        field._dictionary = dictionary;
        field._crossReference = crossReference;
        field._ref = reference;
        if (field._dictionary.has('Kids')) {
            field._kids = field._dictionary.get('Kids');
        }
        const options = field._dictionary.getArray('Opt');
        if (options !== null && typeof options !== 'undefined') {
            field._listValues = new Array(options.length);
        }
        field._defaultIndex = 0;
        field._parsedItems = new Map();
        if (field._kidsCount > 0) {
            field._retrieveOptionValue();
        }
        return field;
    }
    _retrieveOptionValue() {
        if (this._dictionary.has('Opt')) {
            const options = this._dictionary.getArray('Opt');
            if (options && options.length > 0) {
                const itemsCount = this._kidsCount;
                const count = options.length <= itemsCount ? options.length : itemsCount;
                for (let i = 0; i < count; i++) {
                    const text = options[Number.parseInt(i.toString(), 10)][1];
                    if (text) {
                        this.itemAt(i)._text = text ? text : '';
                    }
                }
            }
        }
    }
    _createAppearance(item) {
        const parameter = new _PaintParameter();
        if (item) {
            const bounds = item.bounds;
            const page = item._getPage();
            if (item._isLoaded && page && typeof page.rotation !== 'undefined' && page.rotation !== PdfRotationAngle.angle0) {
                parameter.bounds = this._rotateTextBox([bounds.x, bounds.y, bounds.width, bounds.height], page.size, page.rotation);
            }
            else {
                parameter.bounds = [0, 0, bounds.width, bounds.height];
            }
            const backcolor = item.backColor;
            if (backcolor) {
                parameter.backBrush = new PdfBrush(backcolor);
            }
            parameter.foreBrush = new PdfBrush(item.color);
            const border = item.border;
            parameter.borderPen = new PdfPen(item.borderColor, border.width);
            parameter.borderStyle = border.style;
            parameter.borderWidth = border.width;
            if (backcolor) {
                const shadowColor = [backcolor[0] - 64, backcolor[1] - 64, backcolor[2] - 64];
                const color = [shadowColor[0] >= 0 ? shadowColor[0] : 0,
                    shadowColor[1] >= 0 ? shadowColor[1] : 0,
                    shadowColor[2] >= 0 ? shadowColor[2] : 0];
                parameter.shadowBrush = new PdfBrush(color);
            }
            parameter.rotationAngle = item.rotate;
            const alignment = typeof item.textAlignment !== 'undefined' ? item.textAlignment : PdfTextAlignment.left;
            const verticalAlignment = this.multiSelect ? PdfVerticalAlignment.top : PdfVerticalAlignment.middle;
            parameter.stringFormat = new PdfStringFormat(alignment, verticalAlignment);
        }
        else {
            const bounds = this.bounds;
            if (bounds) {
                if (this._isLoaded &&
                    this.page &&
                    typeof this.page.rotation !== 'undefined' &&
                    this.page.rotation !== PdfRotationAngle.angle0) {
                    parameter.bounds = this._rotateTextBox([bounds.x, bounds.y, bounds.width, bounds.height], this.page.size, this.page.rotation);
                }
                else {
                    parameter.bounds = [0, 0, bounds.width, bounds.height];
                }
            }
            const backcolor = this.backColor;
            if (backcolor) {
                parameter.backBrush = new PdfBrush(backcolor);
            }
            parameter.foreBrush = new PdfBrush(this.color);
            const border = this.border;
            parameter.borderPen = new PdfPen(this.borderColor, border.width);
            parameter.borderStyle = border.style;
            parameter.borderWidth = border.width;
            if (backcolor) {
                const shadowColor = [backcolor[0] - 64, backcolor[1] - 64, backcolor[2] - 64];
                const color = [shadowColor[0] >= 0 ? shadowColor[0] : 0,
                    shadowColor[1] >= 0 ? shadowColor[1] : 0,
                    shadowColor[2] >= 0 ? shadowColor[2] : 0];
                parameter.shadowBrush = new PdfBrush(color);
            }
            parameter.rotationAngle = this.rotationAngle;
            const alignment = typeof this.textAlignment !== 'undefined' ? this.textAlignment : PdfTextAlignment.left;
            const verticalAlignment = this.multiSelect ? PdfVerticalAlignment.top : PdfVerticalAlignment.middle;
            parameter.stringFormat = new PdfStringFormat(alignment, verticalAlignment);
        }
        parameter.required = this.required;
        if (parameter.bounds === null || typeof parameter.bounds === 'undefined') {
            parameter.bounds = [0, 0, 0, 0];
        }
        const template = new PdfTemplate(parameter.bounds, this._crossReference);
        const graphics = template.graphics;
        graphics._sw._clear();
        if (!this.required) {
            graphics._sw._beginMarkupSequence('Tx');
            graphics._initializeCoordinates();
        }
        if (this._isLoaded) {
            let font;
            if (item) {
                font = this._obtainFont(item);
            }
            if (typeof font === 'undefined' || font === null) {
                font = this._appearanceFont;
            }
            this._drawComboBox(graphics, parameter, font, parameter.stringFormat);
        }
        else {
            if (!this._font) {
                this._font = new PdfStandardFont(PdfFontFamily.timesRoman, this._getFontHeight(PdfFontFamily.helvetica));
            }
            this._drawComboBox(graphics, parameter, this._font, parameter.stringFormat);
        }
        if (!this.required) {
            graphics._sw._endMarkupSequence();
        }
        return template;
    }
    _drawComboBox(graphics, parameter, font, stringFormat) {
        if (graphics._isTemplateGraphics && parameter.required) {
            graphics.save();
            graphics._initializeCoordinates();
        }
        this._drawRectangularControl(graphics, parameter);
        if (graphics._isTemplateGraphics && parameter.required) {
            graphics.restore();
            graphics.save();
            graphics._sw._beginMarkupSequence('Tx');
            graphics._initializeCoordinates();
        }
        const options = this._options;
        const selectedIndexes = this._dictionary.get('I');
        let i = -1;
        if (selectedIndexes && selectedIndexes.length > 0) {
            i = selectedIndexes[0];
        }
        if (i >= 0 && i < options.length) {
            const item = options[Number.parseInt(i.toString(), 10)]; // eslint-disable-line 
            const location = [0, 0];
            const borderWidth = parameter.borderWidth;
            const doubleBorderWidth = 2 * borderWidth;
            const defaultPadding = 2;
            const padding = (parameter.borderStyle === PdfBorderStyle.inset || parameter.borderStyle === PdfBorderStyle.beveled);
            if (padding) {
                location[0] = 2 * doubleBorderWidth;
                location[1] = 2 * borderWidth;
            }
            else {
                location[0] = doubleBorderWidth + defaultPadding;
                location[1] = 1 * borderWidth + (defaultPadding - 1);
            }
            let brush = parameter.foreBrush;
            const rect = parameter.bounds;
            let width = rect[2] - doubleBorderWidth;
            let rectangle = rect;
            if (padding) {
                rectangle[3] -= doubleBorderWidth;
            }
            else {
                rectangle[3] -= borderWidth;
            }
            graphics.setClip(rectangle, PdfFillMode.winding);
            if (parameter.rotationAngle === 0) {
                let x = rect[0] + borderWidth;
                if (padding) {
                    x += borderWidth;
                    width -= doubleBorderWidth;
                }
                brush = new PdfBrush([153, 193, 218]);
                graphics.drawRectangle(x, location[1], width, rect[3], brush);
                brush = new PdfBrush([0, 0, 0]);
            }
            let value;
            if (item && Array.isArray(item)) {
                value = item[1] ? item[1] : item[0];
            }
            else {
                value = item;
            }
            if (value) {
                const itemTextBound = [location[0], location[1], width - location[0], rect[3]];
                if (parameter.rotationAngle > 0) {
                    const state = graphics.save();
                    if (parameter.rotationAngle === 90) {
                        graphics.translateTransform(0, graphics._size[1]);
                        graphics.rotateTransform(-90);
                        const x = graphics._size[1] - (rectangle[1] + rectangle[3]);
                        const y = rectangle[0];
                        rectangle = [x, y, rectangle[3] + rectangle[2], rectangle[2]];
                    }
                    else if (parameter.rotationAngle === 270) {
                        graphics.translateTransform(graphics._size[0], 0);
                        graphics.rotateTransform(-270);
                        const x = rectangle[1];
                        const y = graphics._size[0] - (rectangle[0] + rectangle[2]);
                        rectangle = [x, y, rectangle[3] + rectangle[2], rectangle[2]];
                    }
                    else if (parameter.rotationAngle === 180) {
                        graphics.translateTransform(graphics._size[0], graphics._size[1]);
                        graphics.rotateTransform(-180);
                        const x = graphics._size[0] - (rectangle[0] + rectangle[2]);
                        const y = graphics._size[1] - (rectangle[1] + rectangle[3]);
                        rectangle = [x, y, rectangle[2], rectangle[3]];
                    }
                    let x = rect[0] + borderWidth;
                    if (padding) {
                        x += borderWidth;
                        width -= doubleBorderWidth;
                    }
                    brush = new PdfBrush([153, 193, 218]);
                    graphics.drawRectangle(x, location[1], width, rect[3], brush);
                    brush = new PdfBrush([0, 0, 0]);
                    graphics.drawString(value, font, itemTextBound, null, brush, stringFormat);
                    graphics.restore(state);
                }
                else {
                    graphics.drawString(value, font, itemTextBound, null, brush, stringFormat);
                }
            }
        }
        if (graphics._isTemplateGraphics && parameter.required) {
            graphics._sw._endMarkupSequence();
            graphics.restore();
        }
    }
    _getFontHeight(fontFamily) {
        const values = this._dictionary.get('I');
        let s;
        let itemFont;
        let format;
        let options;
        let bounds;
        const borderWidth = this.border.width;
        if (this._isLoaded) {
            itemFont = new PdfStandardFont(fontFamily, 12);
            format = new PdfStringFormat(PdfTextAlignment.center, PdfVerticalAlignment.middle);
            options = this._dictionary.getArray('Opt');
            bounds = this.bounds;
            const widths = [];
            if (values && values.length > 0) {
                values.forEach((entry) => {
                    widths.push(itemFont.measureString(options[Number.parseInt(entry.toString(), 10)][1], [0, 0], format, 0, 0)[0]);
                });
            }
            else if (options.length > 0) {
                let max = itemFont.measureString(options[0][1], [0, 0], format, 0, 0)[0];
                for (let i = 1; i < options.length; ++i) {
                    const width = itemFont.measureString(options[Number.parseInt(i.toString(), 10)][1], [0, 0], format, 0, 0)[0];
                    max = Math.max(max, width);
                    widths.push(max);
                }
            }
            s = (widths.length > 0) ? ((12 * (bounds.width - 4 * borderWidth)) / ((widths.sort())[widths.length - 1])) : 12;
        }
        else {
            s = 0;
            if (values && values.length > 0) {
                itemFont = new PdfStandardFont(fontFamily, 12);
                format = new PdfStringFormat(PdfTextAlignment.center, PdfVerticalAlignment.middle);
                options = this._dictionary.getArray('Opt');
                const width = itemFont.measureString(options[values[0]][1], [0, 0], format, 0, 0)[0];
                bounds = this.bounds;
                if (width) {
                    s = (12 * (bounds.width - 4 * borderWidth)) / width;
                }
                else {
                    s = 12;
                }
            }
            else {
                return s;
            }
        }
        let fontSize = 0;
        if (values && values.length > 0) {
            if (s !== 12) {
                itemFont = new PdfStandardFont(fontFamily, s);
                const text = options[values[0]][1];
                const textSize = itemFont.measureString(text, [0, 0], format, 0, 0);
                if (textSize[0] > bounds.width || textSize[1] > bounds.height) {
                    const width = bounds.width - 4 * borderWidth;
                    const h = bounds.height - 4 * borderWidth;
                    const min = 0.248;
                    for (let i = 1; i <= bounds.height; i++) {
                        itemFont._size = i;
                        let size = itemFont.measureString(text, [0, 0], format, 0, 0);
                        if (size[0] > bounds.width || size[1] > h) {
                            fontSize = i;
                            do {
                                fontSize = fontSize - 0.001;
                                itemFont._size = fontSize;
                                const textWidth = itemFont.getLineWidth(text, format);
                                if (fontSize < min) {
                                    itemFont._size = min;
                                    break;
                                }
                                size = itemFont.measureString(text, [0, 0], format, 0, 0);
                                if (textWidth < width && size[1] < h) {
                                    itemFont._size = fontSize;
                                    break;
                                }
                            } while (fontSize > min);
                            s = fontSize;
                            break;
                        }
                    }
                }
            }
        }
        else if (s > 12) {
            s = 12;
        }
        return s;
    }
}
/**
 * `PdfListBoxField` class represents the list box field objects.
 * ```typescript
 * // Load an existing PDF document
 * let document: PdfDocument = new PdfDocument(data);
 * // Gets the first page of the document
 * let page: PdfPage = document.getPage(0);
 * // Access the PDF form
 * let form: PdfForm = document.form;
 * // Create a new list box field
 * let field: PdfListBoxField = new PdfListBoxField(page, 'list1', {x: 100, y: 60, width: 100, height: 50});
 * // Add list items to the field.
 * field.addItem(new PdfListFieldItem('English', 'English'));
 * field.addItem(new PdfListFieldItem('French', 'French'));
 * field.addItem(new PdfListFieldItem('German', 'German'));
 * // Sets the selected index
 * field.selectedIndex = 2;
 * // Sets the flag indicates whether the list box allows multiple selections.
 * field.multiSelect = true;
 * // Add the field into PDF form
 * form.add(field);
 * // Save the document
 * document.save('output.pdf');
 * // Destroy the document
 * document.destroy();
 * ```
 */
class PdfListBoxField extends PdfListField {
    constructor(page, name, bounds) {
        super();
        if (page && name && bounds) {
            this._initialize(page, name, bounds);
        }
    }
    /**
     * Parse an existing list box field of the PDF document.
     *
     * @private
     * @param {number} form maximum length.
     * @param {_PdfDictionary} dictionary maximum length.
     * @param {_PdfCrossReference} crossReference maximum length.
     * @param {_PdfReference} reference maximum length.
     * @returns {PdfListBoxField} List box field.
     */
    static _load(form, dictionary, crossReference, reference) {
        const field = new PdfListBoxField();
        field._isLoaded = true;
        field._form = form;
        field._dictionary = dictionary;
        field._crossReference = crossReference;
        field._ref = reference;
        if (field._dictionary.has('Kids')) {
            field._kids = field._dictionary.get('Kids');
        }
        const options = field._dictionary.getArray('Opt');
        if (options !== null && typeof options !== 'undefined') {
            field._listValues = new Array(options.length);
        }
        field._defaultIndex = 0;
        field._parsedItems = new Map();
        if (field._kidsCount > 0) {
            field._retrieveOptionValue();
        }
        return field;
    }
    _retrieveOptionValue() {
        if (this._dictionary.has('Opt')) {
            const options = this._dictionary.getArray('Opt');
            if (options && options.length > 0) {
                const index = this._dictionary.get('I');
                for (let i = 0; i < options.length; i++) {
                    if (typeof index !== 'undefined' && index !== null) {
                        this._listValues[Number.parseInt(i.toString(), 10)] = options[Number.parseInt(i.toString(), 10)][1];
                        if (i === index) {
                            this.itemAt(i)._text = this._listValues[Number.parseInt(i.toString(), 10)];
                            this._selectedIndex = i;
                        }
                        else {
                            this.itemAt(i)._text = this._listValues[Number.parseInt(i.toString(), 10)];
                        }
                    }
                    else {
                        this.itemAt(i)._text = '';
                    }
                }
            }
        }
    }
    _createAppearance(item) {
        const parameter = new _PaintParameter();
        if (item) {
            const bounds = item.bounds;
            const page = item._getPage();
            if (item._isLoaded && page && typeof page.rotation !== 'undefined' && page.rotation !== PdfRotationAngle.angle0) {
                parameter.bounds = this._rotateTextBox([bounds.x, bounds.y, bounds.width, bounds.height], page.size, page.rotation);
            }
            else {
                parameter.bounds = [0, 0, bounds.width, bounds.height];
            }
            const backcolor = item.backColor;
            if (backcolor) {
                parameter.backBrush = new PdfBrush(backcolor);
            }
            parameter.foreBrush = new PdfBrush(item.color);
            const border = item.border;
            parameter.borderPen = new PdfPen(item.borderColor, border.width);
            parameter.borderStyle = border.style;
            parameter.borderWidth = border.width;
            if (backcolor) {
                const shadowColor = [backcolor[0] - 64, backcolor[1] - 64, backcolor[2] - 64];
                const color = [shadowColor[0] >= 0 ? shadowColor[0] : 0,
                    shadowColor[1] >= 0 ? shadowColor[1] : 0,
                    shadowColor[2] >= 0 ? shadowColor[2] : 0];
                parameter.shadowBrush = new PdfBrush(color);
            }
            parameter.rotationAngle = item.rotate;
            const alignment = typeof item.textAlignment !== 'undefined' ? item.textAlignment : PdfTextAlignment.left;
            const verticalAlignment = this.multiSelect ? PdfVerticalAlignment.top : PdfVerticalAlignment.middle;
            parameter.stringFormat = new PdfStringFormat(alignment, verticalAlignment);
        }
        else {
            const bounds = this.bounds;
            if (this._isLoaded &&
                this.page &&
                typeof this.page.rotation !== 'undefined' &&
                this.page.rotation !== PdfRotationAngle.angle0) {
                parameter.bounds = this._rotateTextBox([bounds.x, bounds.y, bounds.width, bounds.height], this.page.size, this.page.rotation);
            }
            else {
                parameter.bounds = [0, 0, bounds.width, bounds.height];
            }
            const backcolor = this.backColor;
            if (backcolor) {
                parameter.backBrush = new PdfBrush(backcolor);
            }
            parameter.foreBrush = new PdfBrush(this.color);
            const border = this.border;
            parameter.borderPen = new PdfPen(this.borderColor, border.width);
            parameter.borderStyle = border.style;
            parameter.borderWidth = border.width;
            if (backcolor) {
                const shadowColor = [backcolor[0] - 64, backcolor[1] - 64, backcolor[2] - 64];
                const color = [shadowColor[0] >= 0 ? shadowColor[0] : 0,
                    shadowColor[1] >= 0 ? shadowColor[1] : 0,
                    shadowColor[2] >= 0 ? shadowColor[2] : 0];
                parameter.shadowBrush = new PdfBrush(color);
            }
            parameter.rotationAngle = this.rotationAngle;
            const alignment = typeof this.textAlignment !== 'undefined' ? this.textAlignment : PdfTextAlignment.left;
            const verticalAlignment = this.multiSelect ? PdfVerticalAlignment.top : PdfVerticalAlignment.middle;
            parameter.stringFormat = new PdfStringFormat(alignment, verticalAlignment);
        }
        parameter.required = this.required;
        const template = new PdfTemplate(parameter.bounds, this._crossReference);
        const graphics = template.graphics;
        graphics._sw._clear();
        if (!this.required) {
            graphics._sw._beginMarkupSequence('Tx');
            graphics._initializeCoordinates();
        }
        if (this._isLoaded) {
            let font = this._obtainFont(item);
            if ((typeof font === 'undefined' || font === null) || (!this._isLoaded && font.size === 1)) {
                font = this._appearanceFont;
            }
            this._drawListBox(graphics, parameter, font, parameter.stringFormat);
        }
        else {
            if (!this._font) {
                this._font = this._defaultItemFont;
            }
            this._drawListBox(graphics, parameter, this._font, parameter.stringFormat);
        }
        if (!this.required) {
            graphics._sw._endMarkupSequence();
        }
        return template;
    }
    _drawListBox(graphics, parameter, font, stringFormat) {
        if (graphics._isTemplateGraphics && parameter.required) {
            graphics.save();
            graphics._initializeCoordinates();
        }
        this._drawRectangularControl(graphics, parameter);
        if (graphics._isTemplateGraphics && parameter.required) {
            graphics.restore();
            graphics.save();
            graphics._sw._beginMarkupSequence('Tx');
            graphics._initializeCoordinates();
        }
        const options = this._options;
        for (let index = 0; index < options.length; ++index) {
            const item = options[Number.parseInt(index.toString(), 10)];
            const location = [];
            const borderWidth = parameter.borderWidth;
            const doubleBorderWidth = 2 * borderWidth;
            const defaultPadding = 2;
            const padding = (parameter.borderStyle === PdfBorderStyle.inset || parameter.borderStyle === PdfBorderStyle.beveled);
            if (padding) {
                location.push(2 * doubleBorderWidth);
                location.push((index + 2) * borderWidth + font._metrics._getHeight() * index);
            }
            else {
                location.push(doubleBorderWidth + defaultPadding);
                location.push((index + 1) * borderWidth + font._metrics._getHeight() * index + (defaultPadding - 1));
            }
            let brush = parameter.foreBrush;
            const rect = parameter.bounds;
            let width = rect[2] - doubleBorderWidth;
            let rectangle = rect;
            if (padding) {
                rectangle[3] -= doubleBorderWidth;
            }
            else {
                rectangle[3] -= borderWidth;
            }
            graphics.setClip(rectangle, PdfFillMode.winding);
            let selected = false;
            const selectedIndexes = this._dictionary.get('I');
            if (selectedIndexes !== null && typeof selectedIndexes !== 'undefined' && selectedIndexes.length > 0) {
                selectedIndexes.forEach((selectedIndex) => {
                    selected = selected || (selectedIndex === index);
                });
            }
            if (parameter.rotationAngle === 0) {
                if (selected) {
                    let x = rect[0] + borderWidth;
                    if (padding) {
                        x += borderWidth;
                        width -= doubleBorderWidth;
                    }
                    brush = new PdfBrush([153, 193, 218]);
                    graphics.drawRectangle(x, location[1], width, font._metrics._getHeight(), brush);
                    brush = new PdfBrush([0, 0, 0]);
                }
            }
            const value = item[1] ? item[1] : item[0];
            const itemTextBound = [location[0], location[1], width - location[0], font._metrics._getHeight()];
            if (parameter.rotationAngle > 0) {
                const state = graphics.save();
                if (parameter.rotationAngle === 90) {
                    graphics.translateTransform(0, graphics._size[1]);
                    graphics.rotateTransform(-90);
                    const x = graphics._size[1] - (rectangle[1] + rectangle[3]);
                    const y = rectangle[0];
                    rectangle = [x, y, rectangle[3] + rectangle[2], rectangle[2]];
                }
                else if (parameter.rotationAngle === 270) {
                    graphics.translateTransform(graphics._size[0], 0);
                    graphics.rotateTransform(-270);
                    const x = rectangle[1];
                    const y = graphics._size[0] - (rectangle[0] + rectangle[2]);
                    rectangle = [x, y, rectangle[3] + rectangle[2], rectangle[2]];
                }
                else if (parameter.rotationAngle === 180) {
                    graphics.translateTransform(graphics._size[0], graphics._size[1]);
                    graphics.rotateTransform(-180);
                    const x = graphics._size[0] - (rectangle[0] + rectangle[2]);
                    const y = graphics._size[1] - (rectangle[1] + rectangle[3]);
                    rectangle = [x, y, rectangle[2], rectangle[3]];
                }
                if (selected) {
                    let x = rect[0] + borderWidth;
                    if (padding) {
                        x += borderWidth;
                        width -= doubleBorderWidth;
                    }
                    brush = new PdfBrush([153, 193, 218]);
                    graphics.drawRectangle(x, location[1], width, font._metrics._getHeight(), brush);
                    brush = new PdfBrush([0, 0, 0]);
                }
                graphics.drawString(value, font, itemTextBound, null, brush, stringFormat);
                graphics.restore(state);
            }
            else {
                graphics.drawString(value, font, itemTextBound, null, brush, stringFormat);
            }
        }
        if (graphics._isTemplateGraphics && parameter.required) {
            graphics._sw._endMarkupSequence();
            graphics.restore();
        }
    }
    _getFontHeight(fontFamily) {
        const itemFont = new PdfStandardFont(fontFamily, 12, PdfFontStyle.regular);
        const format = new PdfStringFormat(PdfTextAlignment.left, PdfVerticalAlignment.middle);
        let s = 0;
        if (this._listValues.length > 0) {
            let max = itemFont.measureString(this._listValues[0], [0, 0], format, 0, 0)[0];
            for (let i = 1; i < this._listValues.length; ++i) {
                const value = itemFont.measureString(this._listValues[Number.parseInt(i.toString(), 10)], [0, 0], format, 0, 0)[0];
                max = (max > value) ? max : value;
            }
            s = ((12 * (this.bounds.width - 4 * this.border.width)) / max);
            s = (s > 12) ? 12 : s;
        }
        return s;
    }
}
/**
 * `PdfSignatureField` class represents the signature field objects.
 * ```typescript
 * // Load an existing PDF document
 * let document: PdfDocument = new PdfDocument(data);
 * // Gets the first page of the document
 * let page: PdfPage = document.getPage(0);
 * // Access the PDF form
 * let form: PdfForm = document.form;
 * // Create a new signature field
 * let field: PdfSignatureField = new PdfSignatureField(page, 'Signature', {x: 10, y: 10, width: 100, height: 50});
 * // Add the field into PDF form
 * form.add(field);
 * // Save the document
 * document.save('output.pdf');
 * // Destroy the document
 * document.destroy();
 * ```
 */
class PdfSignatureField extends PdfField {
    constructor(page, name, bounds) {
        super();
        this._isSigned = false;
        if (page && name && bounds) {
            this._initialize(page, name, bounds);
        }
    }
    /**
     * Gets the flag to indicate whether the field is signed or not.
     *
     * @returns {boolean} Returns true if the field is signed; otherwise, false.
     *
     * ```typescript
     * // Load an existing PDF document
     * let document: PdfDocument = new PdfDocument(data, password);
     * // Access the loaded signature field
     * let field: PdfSignatureField = document.form.fieldAt(0) as PdfSignatureField;
     * // Get the signed status of the field
     * let isSigned: boolean = field.isSigned;
     * // Destroy the document
     * document.destroy();
     * ```
     */
    get isSigned() {
        if (!this._isSigned) {
            this._checkSigned();
        }
        return this._isSigned;
    }
    /**
     * Gets the background color of the field.
     *
     * @returns {number[]} R, G, B color values in between 0 to 255.
     * ```typescript
     * // Load an existing PDF document
     * let document: PdfDocument = new PdfDocument(data, password);
     * // Access the form field at index 0
     * let field: PdfField = document.form.fieldAt(0);
     * // Gets the background color of the field.
     * let backColor: number[] = field.backColor;
     * // Save the document
     * document.save('output.pdf');
     * // Destroy the document
     * document.destroy();
     * ```
     */
    get backColor() {
        return this._parseBackColor(true);
    }
    /**
     * Sets the background color of the field.
     *
     * @param {number[]} value Array with R, G, B, A color values in between 0 to 255. For optional A (0-254), it signifies transparency.
     * ```typescript
     * // Load an existing PDF document
     * let document: PdfDocument = new PdfDocument(data, password);
     * // Access the signature field at index 0
     * let field1: PdfField = document.form.fieldAt(0);
     * // Sets the background color of the field.
     * field1.backColor = [255, 0, 0];
     * // Access the signature field at index 1
     * let field2: PdfField = document.form.fieldAt(1);
     * // Sets the background color of the field to transparent.
     * field2.backColor = [0, 0, 0, 0];
     * // Save the document
     * document.save('output.pdf');
     * // Destroy the document
     * document.destroy();
     * ```
     */
    set backColor(value) {
        this._updateBackColor(value, true);
    }
    static _load(form, dictionary, crossReference, reference) {
        const field = new PdfSignatureField();
        field._isLoaded = true;
        field._form = form;
        field._dictionary = dictionary;
        field._crossReference = crossReference;
        field._ref = reference;
        if (field._dictionary.has('Kids')) {
            field._kids = field._dictionary.get('Kids');
        }
        field._defaultIndex = 0;
        field._parsedItems = new Map();
        return field;
    }
    _initialize(page, name, bounds) {
        this._crossReference = page._crossReference;
        this._page = page;
        this._name = name;
        this._dictionary = new _PdfDictionary(this._crossReference);
        this._ref = this._crossReference._getNextReference();
        this._crossReference._cacheMap.set(this._ref, this._dictionary);
        this._dictionary.objId = this._ref.toString();
        this._dictionary.update('FT', _PdfName.get('Sig'));
        this._dictionary.update('T', name);
        this._defaultIndex = 0;
        this._initializeFont(this._defaultFont);
        this._createItem(bounds);
    }
    _createItem(bounds) {
        const widget = new PdfWidgetAnnotation();
        widget._create(this._page, bounds, this);
        widget._dictionary.update('MK', new _PdfDictionary(this._crossReference));
        widget._mkDictionary.update('BC', [0, 0, 0]);
        widget._mkDictionary.update('BG', [1, 1, 1]);
        widget._dictionary.update('DA', `${this._fontName} 8 Tf 0 0 0 rg`);
        this._addToKid(widget);
    }
    _doPostProcess(isFlatten = false) {
        const needAppearance = this._setAppearance || this._form._setAppearance;
        if (!this._isLoaded && (isFlatten || needAppearance)) {
            const count = this._kidsCount;
            if (count > 0) {
                for (let i = 0; i < count; i++) {
                    const item = this.itemAt(i);
                    if (item && item._dictionary && (needAppearance || (isFlatten && !item._dictionary.has('AP')))) {
                        const template = this._createAppearance(item, isFlatten);
                        this._addAppearance(item._dictionary, template, 'N');
                    }
                }
            }
        }
        if (isFlatten) {
            const count = this._kidsCount;
            if (count > 0) {
                let firstItemTemplate;
                for (let i = 0; i < count; i++) {
                    const item = this.itemAt(i);
                    if (item && item._dictionary) {
                        const page = item._getPage();
                        if (page) {
                            if (!firstItemTemplate && i === 0) {
                                firstItemTemplate = this._getItemTemplate(item._dictionary);
                            }
                            this._flattenSignature(item._dictionary, page, item.bounds, firstItemTemplate);
                        }
                    }
                }
            }
            else {
                this._flattenSignature(this._dictionary, this.page, this.bounds);
            }
        }
    }
    _createAppearance(widget, isFlatten) {
        const bounds = widget.bounds;
        const template = new PdfTemplate([0, 0, bounds.width, bounds.height], this._crossReference);
        _setMatrix(template, null);
        template._writeTransformation = false;
        const graphics = template.graphics;
        const parameter = new _PaintParameter();
        parameter.bounds = [0, 0, bounds.width, bounds.height];
        const backcolor = widget.backColor;
        if (isFlatten && backcolor) {
            parameter.backBrush = new PdfBrush(backcolor);
        }
        parameter.foreBrush = new PdfBrush(widget.color);
        const border = widget.border;
        parameter.borderPen = new PdfPen(widget.borderColor, border.width);
        parameter.borderStyle = border.style;
        parameter.borderWidth = border.width;
        if (backcolor) {
            const shadowColor = [backcolor[0] - 64, backcolor[1] - 64, backcolor[2] - 64];
            const color = [shadowColor[0] >= 0 ? shadowColor[0] : 0,
                shadowColor[1] >= 0 ? shadowColor[1] : 0,
                shadowColor[2] >= 0 ? shadowColor[2] : 0];
            parameter.shadowBrush = new PdfBrush(color);
        }
        parameter.rotationAngle = widget.rotate;
        graphics.save();
        graphics._initializeCoordinates();
        this._drawRectangularControl(graphics, parameter);
        graphics.restore();
        return template;
    }
    _flattenSignature(dictionary, page, bounds, signatureTemplate) {
        let template;
        if (dictionary.has('AP')) {
            const appearanceDictionary = dictionary.get('AP');
            if (appearanceDictionary && appearanceDictionary.has('N')) {
                const appearanceStream = appearanceDictionary.get('N');
                const reference = appearanceDictionary.getRaw('N');
                if (reference && appearanceStream) {
                    appearanceStream.reference = reference;
                }
                if (appearanceStream) {
                    if (signatureTemplate) {
                        template = signatureTemplate;
                    }
                    else {
                        template = new PdfTemplate(appearanceStream, this._crossReference);
                    }
                    if (template && page) {
                        const graphics = page.graphics;
                        const state = graphics.save();
                        if (page.rotation !== PdfRotationAngle.angle0) {
                            graphics._drawTemplate(template, this._calculateTemplateBounds(bounds, page, template, graphics));
                        }
                        else {
                            graphics._drawTemplate(template, bounds);
                        }
                        graphics.restore(state);
                    }
                }
            }
        }
        else if (signatureTemplate && page) {
            const graphics = page.graphics;
            const state = graphics.save();
            if (page.rotation !== PdfRotationAngle.angle0) {
                graphics._drawTemplate(template, this._calculateTemplateBounds(bounds, page, template, graphics));
            }
            else {
                graphics._drawTemplate(template, bounds);
            }
            graphics.restore(state);
        }
    }
    _calculateTemplateBounds(bounds, page, template, graphics) {
        let x = bounds.x;
        let y = bounds.y;
        if (page) {
            const graphicsRotation = this._obtainGraphicsRotation(graphics._matrix);
            if (graphicsRotation === 90) {
                graphics.translateTransform(template._size[1], 0);
                graphics.rotateTransform(90);
                x = bounds.x;
                y = -(page._size[1] - bounds.y - bounds.height);
            }
            else if (graphicsRotation === 180) {
                graphics.translateTransform(template._size[0], template._size[1]);
                graphics.rotateTransform(180);
                x = -(page._size[0] - (bounds.x + template._size[0]));
                y = -(page._size[1] - bounds.y - template._size[1]);
            }
            else if (graphicsRotation === 270) {
                graphics.translateTransform(0, template._size[0]);
                graphics.rotateTransform(270);
                x = -(page._size[0] - bounds.x - bounds.width);
                y = bounds.y;
            }
        }
        return { x: x, y: y, width: bounds.width, height: bounds.height };
    }
    _obtainGraphicsRotation(matrix) {
        let angle = Math.round(Math.atan2(matrix._matrix._elements[2], matrix._matrix._elements[0]) * 180 / Math.PI);
        switch (angle) {
            case -90:
                angle = 90;
                break;
            case -180:
                angle = 180;
                break;
            case 90:
                angle = 270;
                break;
        }
        return angle;
    }
    _getItemTemplate(dictionary) {
        let template;
        if (dictionary.has('AP')) {
            const appearanceDictionary = dictionary.get('AP');
            if (appearanceDictionary && appearanceDictionary.has('N')) {
                const appearanceStream = appearanceDictionary.get('N');
                const reference = appearanceDictionary.getRaw('N');
                if (reference) {
                    appearanceStream.reference = reference;
                }
                if (appearanceStream) {
                    template = new PdfTemplate(appearanceStream, this._crossReference);
                }
            }
        }
        return template;
    }
    _checkSigned() {
        if (this._dictionary && this._dictionary.has('V')) {
            const dictionary = this._dictionary.get('V');
            if (dictionary !== null && typeof dictionary !== 'undefined' && dictionary.size > 0) {
                this._isSigned = true;
            }
        }
    }
}
class _PdfDefaultAppearance {
    constructor(da) {
        let color;
        let fontName = '';
        let fontSize = 0;
        if (da && typeof da === 'string' && da !== '') {
            const sliced = da.split(' ');
            for (let i = 0; i < sliced.length; i++) {
                switch (sliced[Number.parseInt(i.toString(), 10)]) {
                    case 'g':
                        color = [Number.parseFloat(sliced[i - 1])];
                        break;
                    case 'rg':
                        color = [Number.parseFloat(sliced[i - 3]), Number.parseFloat(sliced[i - 2]), Number.parseFloat(sliced[i - 1])];
                        break;
                    case 'k':
                        color = [Number.parseFloat(sliced[i - 4]), Number.parseFloat(sliced[i - 3]), Number.parseFloat(sliced[i - 2]),
                            Number.parseFloat(sliced[i - 1])];
                        break;
                    case 'Tf':
                        fontSize = Number.parseFloat(sliced[i - 1]);
                        fontName = sliced[i - 2].substring(1);
                        if (fontName.includes('#2C')) {
                            fontName.replace('#2C', ',');
                        }
                        break;
                }
            }
        }
        this.fontName = fontName;
        this.fontSize = fontSize;
        this.color = (typeof color !== 'undefined') ? _parseColor(color) : [0, 0, 0];
    }
    toString() {
        const color = [Number.parseFloat((this.color[0] / 255).toFixed(3)),
            Number.parseFloat((this.color[1] / 255).toFixed(3)),
            Number.parseFloat((this.color[2] / 255).toFixed(3))];
        return '/' +
            this.fontName +
            ' ' +
            this.fontSize +
            ' Tf ' +
            color[0].toString() +
            ' ' +
            color[1].toString() +
            ' ' +
            color[2].toString() +
            ' rg';
    }
}

/**
 * `PdfAppearance` class represents the appearance of the annotation.
 * ```typescript
 * // Load an existing PDF document
 * let document: PdfDocument = new PdfDocument(data, password);
 * // Get the first page
 * let page: PdfPage = document.getPage(0) as PdfPage;
 * // Create a new rubber stamp annotation
 * const annotation: PdfRubberStampAnnotation = new PdfRubberStampAnnotation(50, 100, 100, 50);
 * // Get the appearance of the annotation
 * let appearance: PdfAppearance = annotation.appearance;
 * // Create new image object by using JPEG image data as Base64 string format
 * let image: PdfImage = new PdfBitmap('/9j/4AAQSkZJRgABAQEAkACQAAD/4....QB//Z');
 * // Draw the image as the custom appearance for the annotation
 * appearance.normal.graphics.drawImage(image, 0, 0, 100, 50);
 * // Add annotation to the page
 * page.annotations.add(annotation);
 * // Save the document
 * document.save('output.pdf');
 * // Destroy the document
 * document.destroy();
 * ```
 */
class PdfAppearance {
    /**
     * Initializes a new instance of the `PdfAppearance` class.
     *
     * @param {PdfAnnotation} annot - The annotation.
     * @param {number[]} bounds - The bounds.
     * @private
     */
    constructor(annot, bounds) {
        this._dictionary = new _PdfDictionary();
        this._annotations = annot;
        this._crossReference = annot._crossReference;
        if (typeof bounds !== 'undefined') {
            this._bounds = bounds;
        }
        this._initialize();
    }
    /**
     * Get the normal appearance of the annotation.
     *
     * @returns {PdfTemplate} Returns the normal appearance of the annotation.
     * ```typescript
     * // Load an existing PDF document
     * let document: PdfDocument = new PdfDocument(data, password);
     * // Get the first page
     * let page: PdfPage = document.getPage(0) as PdfPage;
     * // Create a new rubber stamp annotation
     * const annotation: PdfRubberStampAnnotation = new PdfRubberStampAnnotation(50, 100, 100, 50);
     * // Get the appearance of the annotation
     * let appearance: PdfAppearance = annotation.appearance;
     * // Access the normal template of the appearance
     * let template: PdfTemplate = appearance.normal;
     * // Create new image object by using JPEG image data as Base64 string format
     * let image: PdfImage = new PdfBitmap('/9j/4AAQSkZJRgABAQEAkACQAAD/4....QB//Z');
     * // Draw the image as the custom appearance for the annotation
     * template.graphics.drawImage(image, 0, 0, 100, 50);
     * // Add annotation to the page
     * page.annotations.add(annotation);
     * // Save the document
     * document.save('output.pdf');
     * // Destroy the document
     * document.destroy();
     * ```
     */
    get normal() {
        if (!this._templateNormal && this._dictionary.has('AP')) {
            this._templateNormal = this._dictionary.get('N');
        }
        return this._templateNormal;
    }
    /**
     * Set the normal appearance of the annotation.
     *
     * @param {PdfTemplate} value The normal appearance of the annotation.
     * ```typescript
     * // Load an existing PDF document
     * let document: PdfDocument = new PdfDocument(data, password);
     * // Get the first page
     * let page: PdfPage = document.getPage(0) as PdfPage;
     * // Create a new rubber stamp annotation
     * const annotation: PdfRubberStampAnnotation = new PdfRubberStampAnnotation(50, 100, 100, 50);
     * // Get the appearance of the annotation
     * let appearance: PdfAppearance = annotation.appearance;
     * // Access the normal template of the appearance
     * let template: PdfTemplate = appearance.normal;
     * // Create new image object by using JPEG image data as Base64 string format
     * let image: PdfImage = new PdfBitmap('/9j/4AAQSkZJRgABAQEAkACQAAD/4....QB//Z');
     * // Draw the image as the custom appearance for the annotation
     * template.graphics.drawImage(image, 0, 0, 100, 50);
     * // Add annotation to the page
     * page.annotations.add(annotation);
     * // Add a new rubber stamp annotation to the page
     * const annotation2: PdfRubberStampAnnotation = new PdfRubberStampAnnotation(50, 200, 100, 50);
     * // Set the normal appearance of the annotation
     * annotation2.appearance.normal = annotation.appearance.normal;
     * // Add annotation to the page
     * page.annotations.add(annotation2);
     * // Save the document
     * document.save('output.pdf');
     * // Destroy the document
     * document.destroy();
     * ```
     */
    set normal(value) {
        if (value) {
            this._templateNormal = value;
            this._dictionary.set('N', this._templateNormal);
        }
    }
    _initialize() {
        this.normal = new PdfTemplate(this._bounds, this._crossReference);
    }
}

/**
 * Represents the base class for annotation objects.
 * ```typescript
 * // Load an existing PDF document
 * let document: PdfDocument = new PdfDocument(data, password);
 * // Access first page
 * let page: PdfPage = document.getPage(0);
 * // Access the annotation at index 0
 * let annotation: PdfAnnotation = page.annotations.at(0);
 * // Save the document
 * document.save('output.pdf');
 * // Destroy the document
 * document.destroy();
 * ```
 */
class PdfAnnotation {
    constructor() {
        this._isImported = false;
        this._isLoaded = false;
        this._setAppearance = false;
        this._isExport = false;
        this._opacity = 1;
        this._isAllRotation = true;
        this._flatten = false;
        this._hasData = false;
        this._popUpFont = new PdfStandardFont(PdfFontFamily.helvetica, 10.5);
        this._authorBoldFont = new PdfStandardFont(PdfFontFamily.helvetica, 10.5, PdfFontStyle.bold);
        this._lineCaptionFont = new PdfStandardFont(PdfFontFamily.helvetica, 10, PdfFontStyle.regular);
        this._circleCaptionFont = new PdfStandardFont(PdfFontFamily.helvetica, 8, PdfFontStyle.regular);
    }
    /**
     * Gets the author of the annotation.
     *
     * @returns {string} Author.
     *
     * ```typescript
     * // Load an existing PDF document
     * let document: PdfDocument = new PdfDocument(data, password);
     * // Get the first page
     * let page: PdfPage = document.getPage(0) as PdfPage;
     * // Get the first annotation of the page
     * let annotation: PdfLineAnnotation = page.annotations.at(0) as PdfLineAnnotation;
     * //Get the author of the annotation.
     * let author: string = annotation.author;
     * // Destroy the document
     * document.destroy();
     * ```
     */
    get author() {
        if (typeof this._author === 'undefined' && this._dictionary.has('Author')) {
            const author = this._dictionary.get('Author');
            if (author) {
                this._author = author;
            }
        }
        if (typeof this._author === 'undefined' && this._dictionary.has('T')) {
            const author = this._dictionary.get('T');
            if (author) {
                this._author = author;
            }
        }
        return this._author;
    }
    /**
     * Sets the author of the annotation.
     *
     * @param {string} value Author.
     * ```typescript
     * // Load an existing PDF document
     * let document: PdfDocument = new PdfDocument(data, password);
     * // Get the first page
     * let page: PdfPage = document.getPage(0) as PdfPage;
     * // Get the first annotation of the page
     * let annotation: PdfLineAnnotation = page.annotations.at(0) as PdfLineAnnotation;
     * // Sets the author of the annotation.
     * annotation.author = ‘Syncfusion’;
     * // Destroy the document
     * document.destroy();
     * ```
     */
    set author(value) {
        if (this._isLoaded && typeof value === 'string' && value !== this.author) {
            let hasKey = false;
            if (this._dictionary.has('T')) {
                this._dictionary.update('T', value);
                this._author = value;
                hasKey = true;
            }
            if (this._dictionary.has('Author')) {
                this._dictionary.update('Author', value);
                this._author = value;
                hasKey = true;
            }
            if (!hasKey) {
                this._dictionary.update('T', value);
                this._author = value;
            }
        }
        if (!this._isLoaded && typeof value === 'string') {
            this._dictionary.update('T', value);
        }
    }
    /**
     * Gets the border of the annotation.
     *
     * @returns {PdfAnnotationBorder} Annotation border.
     * ```typescript
     * // Load an existing PDF document
     * let document: PdfDocument = new PdfDocument(data, password);
     * // Get the first page
     * let page: PdfPage = document.getPage(0) as PdfPage;
     * // Get the first annotation of the page
     * let annotation: PdfLineAnnotation = page.annotations.at(0) as PdfLineAnnotation;
     * // Gets the border of the annotation.
     * let border: PdfAnnotationBorder = annotation.border;
     * // Destroy the document
     * document.destroy();
     * ```
     */
    get border() {
        if (typeof this._border === 'undefined') {
            const value = new PdfAnnotationBorder();
            value._dictionary = this._dictionary;
            if (this._dictionary.has('Border')) {
                const border = this._dictionary.getArray('Border');
                if (border && border.length >= 3) {
                    value._hRadius = border[0];
                    value._vRadius = border[1];
                    value._width = border[2];
                }
            }
            if (this._dictionary.has('BS')) {
                const border = this._dictionary.get('BS');
                if (border) {
                    if (border.has('W')) {
                        const width = border.get('W');
                        if (typeof width !== 'undefined' && !Number.isNaN(width)) {
                            value._width = width;
                        }
                    }
                    if (border.has('S')) {
                        const style = border.get('S');
                        if (style) {
                            switch (style.name) {
                                case 'D':
                                    value._style = PdfBorderStyle.dashed;
                                    break;
                                case 'B':
                                    value._style = PdfBorderStyle.beveled;
                                    break;
                                case 'I':
                                    value._style = PdfBorderStyle.inset;
                                    break;
                                case 'U':
                                    value._style = PdfBorderStyle.underline;
                                    break;
                                default:
                                    value._style = PdfBorderStyle.solid;
                                    break;
                            }
                        }
                    }
                    if (border.has('D')) {
                        const dash = border.getArray('D');
                        if (dash) {
                            value._dash = dash;
                        }
                    }
                }
            }
            this._border = value;
        }
        return this._border;
    }
    /**
     * Sets the border of the annotation.
     *
     * @param {PdfAnnotationBorder} value Border.
     * ```typescript
     * // Load an existing PDF document
     * let document: PdfDocument = new PdfDocument(data, password);
     * // Get the first page
     * let page: PdfPage = document.getPage(0) as PdfPage;
     * // Get the first annotation of the page
     * let annotation: PdfLineAnnotation = page.annotations.at(0) as PdfLineAnnotation;
     * // Initializes a new instance of the ` PdfAnnotationBorder ` class.
     * let border: PdfAnnotationBorder = new PdfAnnotationBorder ();
     * //Sets the width of the annotation border.
     * border.width = 10;
     * //Sets the style of the annotation border.
     * border.style = PdfBorderStyle.dashed;
     * //Sets the dash pattern of the annotation border.
     * border.dash = [1, 2, 1];
     * // Sets the border to the PDF annotation
     * annotation.border = border;
     * // Destroy the document
     * document.destroy();
     * ```
     */
    set border(value) {
        const current = this.border;
        let width;
        if (!this._isLoaded || (typeof value.width !== 'undefined' && current.width !== value.width)) {
            width = value.width;
        }
        let hRadius;
        if (!this._isLoaded || (typeof value.hRadius !== 'undefined' && current.hRadius !== value.hRadius)) {
            hRadius = value.hRadius;
        }
        let vRadius;
        if (!this._isLoaded || (typeof value.vRadius !== 'undefined' && current.vRadius !== value.vRadius)) {
            vRadius = value.vRadius;
        }
        let style;
        if (!this._isLoaded || (typeof value.style !== 'undefined' && current.style !== value.style)) {
            style = value.style;
        }
        let dash;
        if (typeof value.dash !== 'undefined' && current.dash !== value.dash) {
            dash = value.dash;
        }
        if (!this._isWidget && (this._dictionary.has('Border') || (width || vRadius || hRadius))) {
            this._border._hRadius = typeof hRadius !== 'undefined' ? hRadius : current.hRadius;
            this._border._vRadius = typeof vRadius !== 'undefined' ? vRadius : current.vRadius;
            this._border._width = typeof width !== 'undefined' ? width : current.width;
            this._dictionary.update('Border', [this._border.hRadius, this._border.vRadius, this._border.width]);
        }
        if (this._dictionary.has('BS') || (width || style || dash)) {
            this._border._width = typeof width !== 'undefined' ? width : current.width;
            this._border._style = typeof style !== 'undefined' ? style : current.style;
            this._border._dash = typeof dash !== 'undefined' ? dash : current.dash;
            const bs = this._dictionary.has('BS') ? this._dictionary.get('BS') : new _PdfDictionary(this._crossReference);
            bs.update('Type', _PdfName.get('Border'));
            bs.update('W', this._border.width);
            bs.update('S', _mapBorderStyle(this._border.style));
            if (typeof this._border.dash !== 'undefined') {
                bs.update('D', this._border.dash);
            }
            this._dictionary.update('BS', bs);
            this._dictionary._updated = true;
        }
    }
    /**
     * Gets the flags of the annotation.
     *
     * @returns {PdfAnnotationFlag} Annotation flag.
     * ```typescript
     * // Load an existing PDF document
     * let document: PdfDocument = new PdfDocument(data, password);
     * // Get the first page
     * let page: PdfPage = document.getPage(0) as PdfPage;
     * // Get the first annotation of the page
     * let annotation: PdfLineAnnotation = page.annotations.at(0) as PdfLineAnnotation;
     * // Gets the flags of the annotation.
     * let flag: PdfAnnotationFlag = annotation.flags;
     * // Destroy the document
     * document.destroy();
     * ```
     */
    get flags() {
        if (typeof this._annotFlags === 'undefined') {
            this._annotFlags = PdfAnnotationFlag.default;
            if (this._dictionary.has('F')) {
                this._annotFlags = this._dictionary.get('F');
            }
        }
        return this._annotFlags;
    }
    /**
     * Sets the flags of the annotation.
     *
     * @param {PdfAnnotationFlag} value flag value.
     * ```typescript
     * // Load an existing PDF document
     * let document: PdfDocument = new PdfDocument(data, password);
     * // Get the first page
     * let page: PdfPage = document.getPage(0) as PdfPage;
     * // Get the first annotation of the page
     * let annotation: PdfLineAnnotation = page.annotations.at(0) as PdfLineAnnotation;
     * // Sets the flags of the annotation.
     * annotation.flags = PdfAnnotationFlag.print;
     * // Destroy the document
     * document.destroy();
     * ```
     */
    set flags(value) {
        if (typeof value !== 'undefined' && value !== this._annotFlags) {
            this._annotFlags = value;
            this._dictionary.update('F', value);
        }
    }
    /**
     * Gets the fore color of the annotation.
     *
     * @returns {number[]} R, G, B color values in between 0 to 255.
     * ```typescript
     * // Load an existing PDF document
     * let document: PdfDocument = new PdfDocument(data, password);
     * // Get the first page
     * let page: PdfPage = document.getPage(0) as PdfPage;
     * // Get the first annotation of the page
     * let annotation: PdfLineAnnotation = page.annotations.at(0) as PdfLineAnnotation;
     * // Gets the color of the annotation.
     * let color: number[] = annotation.color;
     * // Destroy the document
     * document.destroy();
     * ```
     */
    get color() {
        if (typeof this._color === 'undefined' && this._dictionary.has('C')) {
            this._color = _parseColor(this._dictionary.getArray('C'));
        }
        return this._color;
    }
    /**
     * Sets the fore color of the annotation.
     *
     * @param {number[]} value R, G, B color values in between 0 to 255.
     * ```typescript
     * // Load an existing PDF document
     * let document: PdfDocument = new PdfDocument(data, password);
     * // Get the first page
     * let page: PdfPage = document.getPage(0) as PdfPage;
     * // Get the first annotation of the page
     * let annotation: PdfLineAnnotation = page.annotations.at(0) as PdfLineAnnotation;
     * // Sets the color of the annotation.
     * annotation.color = [255, 0, 0];
     * // Destroy the document
     * document.destroy();
     * ```
     */
    set color(value) {
        if (typeof value !== 'undefined' && value.length === 3) {
            const extColor = this.color;
            if (!this._isLoaded || typeof extColor === 'undefined' || (extColor[0] !== value[0] || extColor[1] !== value[1] || extColor[2] !== value[2])) {
                this._color = value;
                this._dictionary.update('C', [Number.parseFloat((value[0] / 255).toFixed(7)),
                    Number.parseFloat((value[1] / 255).toFixed(7)),
                    Number.parseFloat((value[2] / 255).toFixed(7))]);
            }
        }
    }
    /**
     * Gets the inner color of the annotation.
     *
     * @returns {number[]} R, G, B color values in between 0 to 255.
     * ```typescript
     * // Load an existing PDF document
     * let document: PdfDocument = new PdfDocument(data, password);
     * // Get the first page
     * let page: PdfPage = document.getPage(0) as PdfPage;
     * // Get the first annotation of the page
     * let annotation: PdfLineAnnotation = page.annotations.at(0) as PdfLineAnnotation;
     * // Gets the inner color of the annotation.
     * let innerColor: number[] = annotation.innerColor;
     * // Destroy the document
     * document.destroy();
     * ```
     */
    get innerColor() {
        if (typeof this._innerColor === 'undefined' && this._dictionary.has('IC')) {
            this._innerColor = _parseColor(this._dictionary.getArray('IC'));
        }
        return this._innerColor;
    }
    /**
     * Sets the inner color of the annotation.
     *
     * @param {number[]} value R, G, B color values in between 0 to 255.
     * ```typescript
     * // Load an existing PDF document
     * let document: PdfDocument = new PdfDocument(data, password);
     * // Get the first page
     * let page: PdfPage = document.getPage(0) as PdfPage;
     * // Get the first annotation of the page
     * let annotation: PdfLineAnnotation = page.annotations.at(0) as PdfLineAnnotation;
     * // Sets the inner color of the annotation.
     * annotation.innerColor = [255, 0, 0];
     * // Destroy the document
     * document.destroy();
     * ```
     */
    set innerColor(value) {
        if (typeof value !== 'undefined' && value.length === 3) {
            const extColor = this.innerColor;
            if (!this._isLoaded ||
                typeof extColor === 'undefined' ||
                (extColor[0] !== value[0] || extColor[1] !== value[1] || extColor[2] !== value[2])) {
                this._innerColor = value;
                this._dictionary.update('IC', [Number.parseFloat((value[0] / 255).toFixed(7)),
                    Number.parseFloat((value[1] / 255).toFixed(7)),
                    Number.parseFloat((value[2] / 255).toFixed(7))]);
            }
        }
    }
    /**
     * Gets the creation date of the annotation.
     *
     * @returns {Date} Creation date.
     * ```typescript
     * // Load an existing PDF document
     * let document: PdfDocument = new PdfDocument(data, password);
     * // Get the first page
     * let page: PdfPage = document.getPage(0) as PdfPage;
     * // Get the first annotation of the page
     * let annotation: PdfLineAnnotation = page.annotations.at(0) as PdfLineAnnotation;
     * //Get the creation date of the annotation.
     * let creationDate: Date = annotation.creationDate;
     * // Destroy the document
     * document.destroy();
     * ```
     */
    get creationDate() {
        if ((typeof this._creationDate === 'undefined' || this._creationDate === null) && this._dictionary.has('CreationDate')) {
            const value = this._dictionary.get('CreationDate'); // eslint-disable-line
            if (value !== null && typeof value === 'string') {
                this._creationDate = this._stringToDate(value);
            }
        }
        return this._creationDate;
    }
    /**
     * Sets the creation date of the annotation.
     *
     * @param {Date} value Creation date.
     * ```typescript
     * // Load an existing PDF document
     * let document: PdfDocument = new PdfDocument(data, password);
     * // Get the first page
     * let page: PdfPage = document.getPage(0) as PdfPage;
     * // Get the first annotation of the page
     * let annotation: PdfLineAnnotation = page.annotations.at(0) as PdfLineAnnotation;
     * //Set the creation date of the annotation.
     * annotation.creationDate = new Date();
     * // Destroy the document
     * document.destroy();
     * ```
     */
    set creationDate(value) {
        this._creationDate = value;
        this._dictionary.update('CreationDate', this._dateToString(value));
    }
    /**
     * Gets the modification date of the annotation.
     *
     * @returns {Date} Modified date.
     * ```typescript
     * // Load an existing PDF document
     * let document: PdfDocument = new PdfDocument(data, password);
     * // Get the first page
     * let page: PdfPage = document.getPage(0) as PdfPage;
     * // Get the first annotation of the page
     * let annotation: PdfLineAnnotation = page.annotations.at(0) as PdfLineAnnotation;
     * //Get the modified date of the annotation.
     * let modifiedDate: Date = annotation.modifiedDate;
     * // Destroy the document
     * document.destroy();
     * ```
     */
    get modifiedDate() {
        if ((typeof this._modifiedDate === 'undefined' || this._modifiedDate === null)) {
            let value; // eslint-disable-line
            if (this._dictionary.has('ModDate')) {
                value = this._dictionary.get('ModDate');
            }
            else if (this._dictionary.has('M')) {
                value = this._dictionary.get('M');
            }
            if (value !== null && typeof value === 'string') {
                this._modifiedDate = this._stringToDate(value);
            }
        }
        return this._modifiedDate;
    }
    /**
     * Sets the modification date of the annotation.
     *
     * @param {Date} value Modified date.
     * ```typescript
     * // Load an existing PDF document
     * let document: PdfDocument = new PdfDocument(data, password);
     * // Get the first page
     * let page: PdfPage = document.getPage(0) as PdfPage;
     * // Get the first annotation of the page
     * let annotation: PdfLineAnnotation = page.annotations.at(0) as PdfLineAnnotation;
     * //Set the modified date of the annotation.
     * annotation.modifiedDate = new Date();
     * // Destroy the document
     * document.destroy();
     * ```
     */
    set modifiedDate(value) {
        this._modifiedDate = value;
        this._dictionary.update('M', this._dateToString(value));
    }
    /**
     * Gets the bounds of the annotation.
     *
     * @returns {{x: number, y: number, width: number, height: number}} Bounds.
     * ```typescript
     * // Load an existing PDF document
     * let document: PdfDocument = new PdfDocument(data, password);
     * // Get the first page
     * let page: PdfPage = document.getPage(0) as PdfPage;
     * // Get the first annotation of the page
     * let annotation: PdfLineAnnotation = page.annotations.at(0) as PdfLineAnnotation;
     * // Gets the bounds of the annotation.
     * let bounds: {x: number, y: number, width: number, height: number} = annotation.bounds;
     * // Destroy the document
     * document.destroy();
     * ```
     */
    get bounds() {
        if (this._isLoaded) {
            this._bounds = _calculateBounds(this._dictionary, this._page);
        }
        return this._bounds;
    }
    /**
     * Sets the bounds of the annotation.
     *
     * @param {{x: number, y: number, width: number, height: number}} value bounds.
     * ```typescript
     * // Load an existing PDF document
     * let document: PdfDocument = new PdfDocument(data, password);
     * // Get the first page
     * let page: PdfPage = document.getPage(0) as PdfPage;
     * // Get the first annotation of the page
     * let annotation: PdfLineAnnotation = page.annotations.at(0) as PdfLineAnnotation;
     * // Sets the bounds of the annotation.
     * annotation.bounds = {x: 10, y: 10, width: 150, height: 5};
     * // Destroy the document
     * document.destroy();
     * ```
     */
    set bounds(value) {
        if (value) {
            this._isBounds = true;
            if (this._isLoaded) {
                if ((value.x !== this.bounds.x) || (value.y !== this.bounds.y) ||
                    (value.width !== this.bounds.width) || (value.height !== this.bounds.height)) {
                    const size = this._page.size;
                    if (size) {
                        const y = size[1] - (value.y + value.height);
                        const height = y + value.height;
                        this._dictionary.update('Rect', [value.x, y, value.x + value.width, height]);
                        this._bounds = value;
                    }
                }
            }
            else {
                this._bounds = value;
            }
        }
    }
    /**
     * Gets the caption of the annotation.
     *
     * @returns {PdfAnnotationCaption} Annotation caption.
     * ```typescript
     * // Load an existing PDF document
     * let document: PdfDocument = new PdfDocument(data, password);
     * // Get the first page
     * let page: PdfPage = document.getPage(0) as PdfPage;
     * // Get the first annotation of the page
     * let annotation: PdfLineAnnotation = page.annotations.at(0) as PdfLineAnnotation;
     * // Gets the caption of the annotation.
     * let caption: PdfAnnotationCaption = annotation.caption;
     * // Destroy the document
     * document.destroy();
     * ```
     */
    get caption() {
        if (typeof this._caption === 'undefined') {
            const value = new PdfAnnotationCaption();
            value._dictionary = this._dictionary;
            if (this._dictionary.has('Cap')) {
                value._cap = this._dictionary.get('Cap');
            }
            if (this._dictionary.has('CP')) {
                const capType = this._dictionary.get('CP');
                if (capType) {
                    value._type = capType.name === 'Top' ? PdfLineCaptionType.top : PdfLineCaptionType.inline;
                }
            }
            if (this._dictionary.has('CO')) {
                value._offset = this._dictionary.getArray('CO');
            }
            this._caption = value;
        }
        return this._caption;
    }
    /**
     * Sets the caption of the annotation.
     *
     * @param {PdfAnnotationCaption} value Annottion caption.
     * ```typescript
     * // Load an existing PDF document
     * let document: PdfDocument = new PdfDocument(data, password);
     * // Get the first page
     * let page: PdfPage = document.getPage(0) as PdfPage;
     * // Get the first annotation of the page
     * let annotation: PdfLineAnnotation = page.annotations.at(0) as PdfLineAnnotation;
     * // Create and set annotation caption values
     * annotation.caption = new PdfAnnotationCaption(true, PdfLineCaptionType.inline, [10, 10]);
     * // Destroy the document
     * document.destroy();
     * ```
     */
    set caption(value) {
        const current = this.caption;
        if (value) {
            if (!this._isLoaded || value.cap !== current.cap) {
                this._caption.cap = value.cap;
            }
            if (!this._isLoaded || value.type !== current.type) {
                this._caption.type = value.type;
            }
            if (!this._isLoaded || value.offset !== current.offset) {
                this._caption.offset = value.offset;
            }
        }
    }
    /**
     * Gets the opacity of the annotation.
     *
     * @returns {number} Opacity in between 0 t0 1.
     * ```typescript
     * // Load an existing PDF document
     * let document: PdfDocument = new PdfDocument(data, password);
     * // Get the first page
     * let page: PdfPage = document.getPage(0) as PdfPage;
     * // Get the first annotation of the page
     * let annotation: PdfLineAnnotation = page.annotations.at(0) as PdfLineAnnotation;
     * //Get the opacity of the annotation.
     * let opacity: number = annotation.opacity;
     * // Destroy the document
     * document.destroy();
     * ```
     */
    get opacity() {
        if (this._dictionary.has('CA')) {
            const opacity = this._dictionary.get('CA');
            if (typeof opacity !== 'undefined') {
                this._opacity = opacity;
            }
        }
        return this._opacity;
    }
    /**
     * Sets the opacity of the annotation.
     *
     * @param {number} value opacity in between 0 t0 1.
     * ```typescript
     * // Load an existing PDF document
     * let document: PdfDocument = new PdfDocument(data, password);
     * // Get the first page
     * let page: PdfPage = document.getPage(0) as PdfPage;
     * // Get the first annotation of the page
     * let annotation: PdfLineAnnotation = page.annotations.at(0) as PdfLineAnnotation;
     * // Sets the opacity of the annotation.
     * annotation.opacity = 0.5;
     * // Destroy the document
     * document.destroy();
     * ```
     */
    set opacity(value) {
        if (typeof value !== 'undefined' && !Number.isNaN(value)) {
            if (value >= 0 && value <= 1) {
                this._dictionary.update('CA', value);
                this._opacity = value;
            }
            else if (value < 0) {
                this._dictionary.update('CA', 0);
            }
            else {
                this._dictionary.update('CA', 1);
            }
        }
    }
    /**
     * Gets the subject of the annotation.
     *
     * @returns {string} Subject.
     * ```typescript
     * // Load an existing PDF document
     * let document: PdfDocument = new PdfDocument(data, password);
     * // Get the first page
     * let page: PdfPage = document.getPage(0) as PdfPage;
     * // Get the first annotation of the page
     * let annotation: PdfLineAnnotation = page.annotations.at(0) as PdfLineAnnotation;
     * //Get the subject of the annotation.
     * let subject: string = annotation.subject;
     * // Destroy the document
     * document.destroy();
     * ```
     */
    get subject() {
        if (typeof this._subject === 'undefined') {
            this._subject = this._dictionary.get('Subject', 'Subj');
        }
        return this._subject;
    }
    /**
     * Sets the subject of the annotation.
     *
     * @param {string} value Subject.
     * ```typescript
     * // Load an existing PDF document
     * let document: PdfDocument = new PdfDocument(data, password);
     * // Get the first page
     * let page: PdfPage = document.getPage(0) as PdfPage;
     * // Get the first annotation of the page
     * let annotation: PdfLineAnnotation = page.annotations.at(0) as PdfLineAnnotation;
     * // Sets the subject of the annotation.
     * annotation.subject = 'Line Annotation';
     * // Destroy the document
     * document.destroy();
     * ```
     */
    set subject(value) {
        if (typeof value === 'string') {
            let hasKey = false;
            if (this._dictionary.has('Subj')) {
                this._dictionary.update('Subj', value);
                this._subject = value;
                hasKey = true;
            }
            if (!hasKey || this._dictionary.has('Subject')) {
                this._dictionary.update('Subject', value);
                this._subject = value;
            }
        }
    }
    /**
     * Gets the name of the annotation.
     *
     * @returns {string} Name.
     * ```typescript
     * // Load an existing PDF document
     * let document: PdfDocument = new PdfDocument(data, password);
     * // Get the first page
     * let page: PdfPage = document.getPage(0) as PdfPage;
     * // Get the first annotation of the page
     * let annotation: PdfLineAnnotation = page.annotations.at(0) as PdfLineAnnotation;
     * //Get the name of the annotation.
     * let name: string = annotation.name;
     * // Destroy the document
     * document.destroy();
     * ```
     */
    get name() {
        if (typeof this._name === 'undefined' && this._dictionary.has('NM')) {
            this._name = this._dictionary.get('NM');
        }
        return this._name;
    }
    /**
     * Sets the name of the annotation.
     *
     * @param {string} value Name.
     * ```typescript
     * // Load an existing PDF document
     * let document: PdfDocument = new PdfDocument(data, password);
     * // Get the first page
     * let page: PdfPage = document.getPage(0) as PdfPage;
     * // Get the first annotation of the page
     * let annotation: PdfLineAnnotation = page.annotations.at(0) as PdfLineAnnotation;
     * // Sets the name of the annotation.
     * annotation.name = 'LineAnnotation';
     * // Destroy the document
     * document.destroy();
     * ```
     */
    set name(value) {
        if (typeof value === 'string') {
            this._dictionary.update('NM', value);
            this._name = value;
        }
    }
    /**
     * Gets the text of the annotation.
     *
     * @returns {string} Text.
     * ```typescript
     * // Load an existing PDF document
     * let document: PdfDocument = new PdfDocument(data, password);
     * // Get the first page
     * let page: PdfPage = document.getPage(0) as PdfPage;
     * // Get the first annotation of the page
     * let annotation: PdfLineAnnotation = page.annotations.at(0) as PdfLineAnnotation;
     * //Get the text of the annotation.
     * let text: string = annotation.text;
     * // Destroy the document
     * document.destroy();
     * ```
     */
    get text() {
        if (typeof this._text === 'undefined' && this._dictionary.has('Contents')) {
            this._text = this._dictionary.get('Contents');
        }
        return this._text;
    }
    /**
     * Sets the text of the annotation.
     *
     * @param {string} value Text.
     * ```typescript
     * // Load an existing PDF document
     * let document: PdfDocument = new PdfDocument(data, password);
     * // Get the first page
     * let page: PdfPage = document.getPage(0) as PdfPage;
     * // Get the first annotation of the page
     * let annotation: PdfLineAnnotation = page.annotations.at(0) as PdfLineAnnotation;
     * // Sets the text of the annotation.
     * annotation.text = ‘LineAnnotation’;
     * // Destroy the document
     * document.destroy();
     * ```
     */
    set text(value) {
        if (typeof value === 'string') {
            this._text = this._dictionary.get('Contents');
            if (value !== this._text) {
                this._dictionary.update('Contents', value);
                this._text = value;
            }
        }
    }
    /**
     * Gets the rotation of the annotation.
     *
     * @returns {PdfRotationAngle} Rotation angle.
     * ```typescript
     * // Load an existing PDF document
     * let document: PdfDocument = new PdfDocument(data, password);
     * // Get the first page
     * let page: PdfPage = document.getPage(0) as PdfPage;
     * // Get the first annotation of the page
     * let annotation: PdfLineAnnotation = page.annotations.at(0) as PdfLineAnnotation;
     * //Get the rotation angle of the annotation.
     * let rotationAngle: PdfRotationAngle = annotation.rotationAngle;
     * // Destroy the document
     * document.destroy();
     * ```
     */
    get rotationAngle() {
        if (typeof this._rotate === 'undefined' && this._dictionary.has('Rotate')) {
            this._rotate = (this._dictionary.get('Rotate') / 90);
        }
        if (this._rotate === null || typeof this._rotate === 'undefined') {
            this._rotate = PdfRotationAngle.angle0;
        }
        return this._rotate;
    }
    /**
     * Sets the rotation of the annotation.
     *
     * @param {PdfRotationAngle} value rotation angle.
     * ```typescript
     * // Load an existing PDF document
     * let document: PdfDocument = new PdfDocument(data, password);
     * // Get the first page
     * let page: PdfPage = document.getPage(0) as PdfPage;
     * // Get the first annotation of the page
     * let annotation: PdfLineAnnotation = page.annotations.at(0) as PdfLineAnnotation;
     * // Sets the rotation angle of the annotation.
     * annotation.rotationAngle = PdfRotationAngle.angle180;
     * // Destroy the document
     * document.destroy();
     * ```
     */
    set rotationAngle(value) {
        const prevRotate = this.rotationAngle;
        if (typeof value !== 'undefined' && typeof prevRotate !== 'undefined') {
            value = ((value + prevRotate) % 4);
        }
        this._dictionary.update('Rotate', value * 90);
        this._rotate = value;
    }
    /**
     * Gets the rotation angle of the annotation (Read only).
     *
     * @returns {number} Rotation angle.
     * ```typescript
     * // Load an existing PDF document
     * let document: PdfDocument = new PdfDocument(data, password);
     * // Get the first page
     * let page: PdfPage = document.getPage(0) as PdfPage;
     * // Get the first annotation of the page
     * let annotation: PdfLineAnnotation = page.annotations.at(0) as PdfLineAnnotation;
     * //Get the rotation angle of the annotation.
     * let rotate: number = annotation.rotate;
     * // Destroy the document
     * document.destroy();
     * ```
     */
    get rotate() {
        let angle = this._getRotationAngle();
        if (angle < 0) {
            angle = 360 + angle;
        }
        if (angle >= 360) {
            angle = 360 - angle;
        }
        return angle;
    }
    /**
     * Gets the boolean flag indicating whether annotation's popup have been flattened or not.
     *
     * @returns {boolean} Flatten Popup.
     * ```typescript
     * // Load an existing PDF document
     * let document: PdfDocument = new PdfDocument(data, password);
     * // Get the first page
     * let page: PdfPage = document.getPage(0) as PdfPage;
     * // Get the first annotation of the page
     * let annotation: PdfLineAnnotation = page.annotations.at(0) as PdfLineAnnotation;
     * // Gets the boolean flag indicating whether annotation's popup have been flattened or not.
     * let flattenPopups: boolean = annotation.flattenPopups;
     * // Destroy the document
     * document.destroy();
     * ```
     */
    get flattenPopups() {
        return this._isFlattenPopups;
    }
    /**
     * Sets the boolean flag indicating whether the annotation’s popup have been flattened or not.
     *
     * @param {boolean} value Flatten Popup.
     * ```typescript
     * // Load an existing PDF document
     * let document: PdfDocument = new PdfDocument(data, password);
     * // Get the first page
     * let page: PdfPage = document.getPage(0) as PdfPage;
     * // Get the first annotation of the page
     * let annotation: PdfLineAnnotation = page.annotations.at(0) as PdfLineAnnotation;
     * // Sets the boolean flag indicating whether the annotation’s popup have been flattened or not.
     * annotation.flattenPopups = false;
     * // Destroy the document
     * document.destroy();
     * ```
     */
    set flattenPopups(value) {
        if (typeof value !== 'undefined') {
            this._isFlattenPopups = value;
        }
    }
    /**
     * Gets the boolean flag indicating whether the annotation have been flattened or not.
     *
     * @returns {boolean} Flatten.
     *
     * ```typescript
     * // Load an existing PDF document
     * let document: PdfDocument = new PdfDocument(data, password);
     * // Get the first page
     * let page: PdfPage = document.getPage(0) as PdfPage;
     * // Get the first annotation of the page
     * let annotation: PdfLineAnnotation = page.annotations.at(0) as PdfLineAnnotation;
     * // Gets the boolean flag indicating whether the annotation have been flattened or not.
     * let flatten: boolean = annotation.flatten;
     * // Destroy the document
     * document.destroy();
     * ```
     */
    get flatten() {
        return this._flatten;
    }
    /**
     * Sets the boolean flag indicating whether the annotation have been flattened or not.
     *
     * @param {boolean} value Flatten.
     *
     * ```typescript
     * // Load an existing PDF document
     * let document: PdfDocument = new PdfDocument(data, password);
     * // Get the first page
     * let page: PdfPage = document.getPage(0) as PdfPage;
     * // Get the first annotation of the page
     * let annotation: PdfLineAnnotation = page.annotations.at(0) as PdfLineAnnotation;
     * // Sets the boolean flag indicating whether the annotation have been flattened or not.
     * annotation.flatten = true;
     * // Destroy the document
     * document.destroy();
     * ```
     */
    set flatten(value) {
        this._flatten = value;
    }
    get _hasFlags() {
        return this._dictionary.has('F');
    }
    get _degreeToRadian() {
        if (typeof this._ratio === 'undefined') {
            this._ratio = Math.PI / 180;
        }
        return this._ratio;
    }
    /**
     * Set the boolean flag to create a new appearance stream for annotations.
     *
     * @param {boolean} value Set appearance.
     * @returns {void} Nothing.
     *
     * ```typescript
     * // Load an existing PDF document
     * let document: PdfDocument = new PdfDocument(data, password);
     * // Set the boolean flag to create a new appearance stream for annotations.
     * document.getPage(0).annotations.at(0).setAppearance(true);
     * // Save the document
     * document.save('output.pdf');
     * // Destroy the document
     * document.destroy();
     * ```
     */
    setAppearance(value) {
        this._setAppearance = value;
        if (value) {
            this._dictionary._updated = true;
        }
    }
    /**
     * Gets the values associated with the specified key.
     *
     * @param {string} name Key.
     * @returns {string[]} Values associated with the key.
     *
     * ```typescript
     * // Load an existing PDF document
     * let document: PdfDocument = new PdfDocument(data, password);
     * // Gets the values associated with the key 'Author'.
     * let values: string[] = document.getPage(0).annotations.at(0).getValues('Author');
     * // Save the document
     * document.save('output.pdf');
     * // Destroy the document
     * document.destroy();
     * ```
     */
    getValues(name) {
        const values = [];
        if (this._dictionary.has(name)) {
            let value = this._dictionary.get(name); // eslint-disable-line
            if (Array.isArray(value)) {
                value = this._dictionary.getArray(name);
                for (let i = 0; i < value.length; i++) {
                    const element = value[Number.parseInt(i.toString(), 10)]; // eslint-disable-line
                    if (element instanceof _PdfName) {
                        values.push(element.name);
                    }
                    else if (typeof element === 'string') {
                        values.push(element);
                    }
                    else if (typeof element === 'number') {
                        values.push(element.toString());
                    }
                }
            }
            else if (value instanceof _PdfName) {
                values.push(value.name);
            }
            else if (typeof value === 'string') {
                values.push(value);
            }
            else {
                throw new Error('PdfException: ' + name + ' is not found');
            }
        }
        else {
            throw new Error('PdfException: ' + name + ' is not found');
        }
        return values;
    }
    /**
     * Sets the values associated with the specified key.
     *
     * @param {string} name Key.
     * @param {string} value Value associated with the key..
     * @returns {void} Nothing.
     *
     * ```typescript
     * // Load an existing PDF document
     * let document: PdfDocument = new PdfDocument(data, password);
     * // Access the annotation at index 0
     * let annotation: PdfAnnotation = document.getPage(0).annotations.at(0);
     * // Set Unknown state and model
     * annotation.setValues('State', 'StateModel');
     * annotation.setValues('StateModel', 'CustomState');
     * // Save the document
     * document.save('output.pdf');
     * // Destroy the document
     * document.destroy();
     * ```
     */
    setValues(name, value) {
        if (name && name !== '' && value && value !== '') {
            this._dictionary.update(name, value);
        }
    }
    //Implementation
    _initialize(page, dictionary) {
        this._page = page;
        this._crossReference = page._crossReference;
        if (dictionary) {
            this._dictionary = dictionary;
        }
        if (!this._isLoaded) {
            this._dictionary.set('P', this._page._ref);
            this._dictionary.assignXref(this._crossReference);
        }
    }
    _getRotationAngle() {
        let angle = 0;
        if (this._dictionary.has('Rotate')) {
            angle = this._dictionary.get('Rotate');
        }
        else if (this._dictionary.has('Rotation')) {
            angle = this._dictionary.get('Rotation');
        }
        return angle;
    }
    _getBoundsValue(linePoints) {
        const count = linePoints.length;
        const x = [];
        const y = [];
        if (linePoints && count > 0) {
            const points = [];
            for (let i = 0; i < linePoints.length; i++) {
                const value = linePoints[Number.parseInt(i.toString(), 10)];
                points.push(value);
            }
            let x1 = 0;
            let y1 = 0;
            for (let i = 0; i < points.length; i++) {
                if (i % 2 === 0) {
                    x[Number.parseInt(x1.toString(), 10)] = points[Number.parseInt(i.toString(), 10)];
                    x1++;
                }
                else {
                    y[Number.parseInt(y1.toString(), 10)] = points[Number.parseInt(i.toString(), 10)];
                    y1++;
                }
            }
        }
        x.sort((a, b) => a > b ? 1 : -1);
        y.sort((a, b) => a > b ? 1 : -1);
        return { x: x[0], y: y[0], width: x[x.length - 1] - x[0], height: y[y.length - 1] - y[0] };
    }
    _validateTemplateMatrix(dictionary, template) {
        let isRotatedMatrix = false;
        let isValidMatrix = true;
        if (template === null || typeof template === 'undefined') {
            if (dictionary && dictionary.has('Matrix')) {
                const matrix = dictionary.getArray('Matrix');
                if (matrix && matrix.length > 3) {
                    if (typeof matrix[0] !== 'undefined' &&
                        typeof matrix[1] !== 'undefined' &&
                        typeof matrix[2] !== 'undefined' &&
                        typeof matrix[3] !== 'undefined') {
                        if (matrix[0] === 1 && matrix[1] === 0 && matrix[2] === 0 && matrix[3] === 1) {
                            isRotatedMatrix = true;
                            let locationX = 0;
                            let locationY = 0;
                            let templateX = 0;
                            let templateY = 0;
                            if (matrix.length > 4) {
                                templateX = -matrix[4];
                                if (matrix.length > 5) {
                                    templateY = -matrix[5];
                                }
                            }
                            let annotationBounds;
                            if (this._dictionary.has('Rect')) {
                                annotationBounds = this._dictionary.getArray('Rect');
                                if (annotationBounds && annotationBounds.length > 1) {
                                    locationX = annotationBounds[0];
                                    locationY = annotationBounds[1];
                                }
                            }
                            if (!(locationX === templateX && locationY === templateY) && templateX === 0 && templateY === 0) {
                                this._locationDisplaced = true;
                            }
                        }
                    }
                }
            }
            else {
                isRotatedMatrix = true;
            }
            return isRotatedMatrix;
        }
        else {
            const point = this.bounds;
            if (dictionary && dictionary.has('Matrix')) {
                const box = dictionary.getArray('BBox');
                const matrix = dictionary.getArray('Matrix');
                if (matrix && box && matrix.length > 3 && box.length > 2) {
                    if (typeof matrix[0] !== 'undefined' &&
                        typeof matrix[1] !== 'undefined' &&
                        typeof matrix[2] !== 'undefined' &&
                        typeof matrix[3] !== 'undefined') {
                        if (matrix[0] === 1 && matrix[1] === 0 && matrix[2] === 0 && matrix[3] === 1) {
                            if (typeof box[0] !== 'undefined' &&
                                typeof box[1] !== 'undefined' &&
                                typeof box[2] !== 'undefined' &&
                                typeof box[3] !== 'undefined') {
                                if (box[0] !== -(matrix[4]) && box[1] !== -(matrix[5]) || (box[0] === 0 && -matrix[4] === 0)) {
                                    const graphics = this._page.graphics;
                                    const state = graphics.save();
                                    if (typeof this.opacity !== 'undefined' && this._opacity < 1) {
                                        graphics.setTransparency(this._opacity);
                                    }
                                    point.x -= box[0];
                                    point.y += box[1];
                                    graphics._drawTemplate(template, point);
                                    graphics.restore(state);
                                    this._removeAnnotationFromPage(this._page, this);
                                    isValidMatrix = false;
                                }
                            }
                        }
                    }
                }
            }
            return isValidMatrix;
        }
    }
    _flattenAnnotationTemplate(template, isNormalMatrix) {
        const graphics = this._page.graphics;
        let currentBounds = this.bounds;
        if (this._type === _PdfAnnotationType.lineAnnotation && !this._dictionary.has('AP')) {
            currentBounds = _toRectangle([this.bounds.x, this.bounds.y,
                this.bounds.width, this.bounds.height]);
            if (this._page) {
                const size = this._page.size;
                const mBox = this._page.mediaBox;
                const cropBox = this._page.cropBox;
                if (cropBox && Array.isArray(cropBox) && cropBox.length === 4 && this._page._pageDictionary.has('CropBox')) {
                    if ((cropBox[0] !== 0 || cropBox[1] !== 0 || size[0] === cropBox[2] ||
                        size[1] === cropBox[3]) && (currentBounds.x !== cropBox[0])) {
                        currentBounds.x -= cropBox[0];
                        currentBounds.y = cropBox[3] - (currentBounds.y + currentBounds.height);
                    }
                    else {
                        currentBounds.y = size[1] - (currentBounds.y + currentBounds.height);
                    }
                }
                else if (mBox && Array.isArray(mBox) && mBox.length === 4 && this._page._pageDictionary.has('MediaBox')) {
                    if (mBox[0] > 0 || mBox[1] > 0 || size[0] === mBox[2] || size[1] === mBox[3]) {
                        currentBounds.x -= mBox[0];
                        currentBounds.y = mBox[3] - (currentBounds.y + currentBounds.height);
                    }
                    else {
                        currentBounds.y = size[1] - (currentBounds.y + currentBounds.height);
                    }
                }
                else {
                    currentBounds.y = size[1] - (currentBounds.y + currentBounds.height);
                }
            }
            else {
                currentBounds.y = currentBounds.y + currentBounds.height;
            }
        }
        if (typeof currentBounds !== 'undefined' && currentBounds !== null) {
            const state = graphics.save();
            this._page._needInitializeGraphics = true;
            if (this._type === _PdfAnnotationType.rubberStampAnnotation) {
                let needScale = true;
                if (this._dictionary.has('AP')) {
                    const dictionary = this._dictionary.get('AP');
                    if (dictionary && dictionary.has('N')) {
                        const appearanceStream = dictionary.get('N');
                        if (this.rotate === PdfRotationAngle.angle270 && this._page.rotation === PdfRotationAngle.angle270
                            && appearanceStream.dictionary.has('Matrix')) {
                            const matrix = appearanceStream.dictionary.getArray('Matrix');
                            if (matrix && matrix.length === 6 && matrix[4] === 0 && matrix[5] !== 0) {
                                needScale = false;
                            }
                        }
                    }
                    if (!isNormalMatrix && this.rotate !== PdfRotationAngle.angle180 && needScale) {
                        template._isAnnotationTemplate = true;
                        template._needScale = true;
                    }
                }
            }
            if (!isNormalMatrix && this._type !== _PdfAnnotationType.rubberStampAnnotation) {
                template._isAnnotationTemplate = true;
                template._needScale = true;
            }
            if (typeof this.opacity !== 'undefined' && this._opacity < 1) {
                graphics.setTransparency(this._opacity);
            }
            const bounds = this._calculateTemplateBounds(currentBounds, this._page, template, isNormalMatrix, graphics);
            if (this._type === _PdfAnnotationType.rubberStampAnnotation) {
                let size;
                let location;
                if (this.rotate === PdfRotationAngle.angle0) {
                    size = [bounds.width, bounds.height];
                    location = [bounds.x, bounds.y];
                }
                else {
                    size = template._size;
                    location = [bounds.x, bounds.y];
                }
                let isRotatedMatrix = false;
                if (this.rotate !== PdfRotationAngle.angle0 && template._content) {
                    if (template._content.dictionary.has('Matrix')) {
                        const matrix = template._content.dictionary.getArray('Matrix');
                        if (matrix && matrix.length === 6 && matrix[4] === 0 && matrix[5] !== 0) {
                            isRotatedMatrix = true;
                        }
                    }
                }
                const scaleX = (template._size[0] > 0) ? bounds.width / template._size[0] : 1;
                const scaleY = (template._size[1] > 0) ? bounds.height / template._size[1] : 1;
                const needScale = !(scaleX === 1 && scaleY === 1);
                if (this.rotate !== PdfRotationAngle.angle0 && isRotatedMatrix) {
                    if (this.rotate === PdfRotationAngle.angle90) {
                        if (this._page.rotation === PdfRotationAngle.angle270) {
                            if (needScale && !(bounds.x === 0 && bounds.y === 0)) {
                                location[0] += (size[0] - size[1]);
                                location[1] += size[0];
                            }
                            else {
                                location[0] += size[1];
                                location[1] += (size[0] - size[1]) + (size[0] - size[1]);
                            }
                        }
                        else if (!needScale) {
                            location[0] += size[1];
                        }
                    }
                    else if (this.rotate === PdfRotationAngle.angle270) {
                        if (this._page.rotation === PdfRotationAngle.angle270) {
                            if (needScale && template._isAnnotationTemplate) {
                                location[1] = bounds.y - bounds.width;
                            }
                            else if (needScale) {
                                location[1] += (size[0] - size[1]);
                            }
                        }
                        else {
                            if (!needScale && !(bounds.x === 0 && bounds.y === 0)) {
                                location[1] += -(size[0]);
                            }
                            else {
                                location[1] += -(size[0] - size[1]);
                            }
                        }
                    }
                    else if (this.rotate === PdfRotationAngle.angle180) {
                        location[0] += size[0];
                        location[1] += -(size[1]);
                    }
                }
            }
            graphics._drawTemplate(template, bounds);
            graphics.restore(state);
        }
        this._removeAnnotationFromPage(this._page, this);
    }
    _calculateTemplateBounds(bounds, page, template, isNormalMatrix, graphics) {
        let annotationBounds = bounds;
        let x = bounds.x;
        let y = bounds.y;
        let width = bounds.width;
        let height = bounds.height;
        if (!isNormalMatrix) {
            const rect = this._dictionary.getArray('Rect');
            if (rect) {
                annotationBounds = _toRectangle(rect);
            }
        }
        if (typeof page !== 'undefined') {
            const graphicsRotation = this._obtainGraphicsRotation(graphics._matrix);
            if (graphicsRotation === 90) {
                graphics.translateTransform(template._size[1], 0);
                graphics.rotateTransform(90);
                if (isNormalMatrix || (typeof this._rotate !== 'undefined' && this._rotate === PdfRotationAngle.angle180)) {
                    x = bounds.x;
                    if (!this._locationDisplaced) {
                        y = -(page.size[1] - bounds.y - bounds.height);
                    }
                    else if (page._origin && page._o[1] !== 0) {
                        y = bounds.y + bounds.height;
                    }
                    else {
                        y = -(page.size[1] - (bounds.height + bounds.y) + (bounds.height - template._size[1]));
                    }
                }
                else {
                    x = bounds.x;
                    y = -(page.size[1] - (bounds.height + bounds.y) + (bounds.width - template._size[1]));
                    width = bounds.height;
                    height = bounds.width;
                }
            }
            else if (graphicsRotation === 180) {
                graphics.translateTransform(template._size[0], template._size[1]);
                graphics.rotateTransform(180);
                if (isNormalMatrix) {
                    x = -(page.size[0] - (bounds.x + bounds.width));
                    y = -(page.size[1] - bounds.y - bounds.height);
                }
                else {
                    x = -(page.size[0] - (bounds.x + template._size[0]));
                    y = -(page.size[1] - bounds.y - template._size[1]);
                    if (typeof this.rotationAngle !== 'undefined' &&
                        (this._rotate === PdfRotationAngle.angle90 ||
                            this._rotate === PdfRotationAngle.angle270)) {
                        y = (-(page.size[1] - bounds.y - template._size[1]) - (bounds.width - bounds.height));
                        width = bounds.height;
                        height = bounds.width;
                    }
                }
            }
            else if (graphicsRotation === 270) {
                graphics.translateTransform(0, template._size[0]);
                graphics.rotateTransform(270);
                if (isNormalMatrix || (typeof this.rotationAngle !== 'undefined' && this._rotate === PdfRotationAngle.angle180)) {
                    x = -(page.size[0] - bounds.x - bounds.width);
                    y = bounds.y;
                }
                else {
                    x = -(page.size[0] - annotationBounds.x - template._size[0]);
                    const matrix = template._content.dictionary.getArray('Matrix');
                    const box = template._content.dictionary.getArray('BBox');
                    if (matrix && box && matrix[5] !== box[2]) {
                        y = bounds.y - (bounds.height - bounds.width);
                    }
                    else {
                        y = (bounds.y + bounds.height) - bounds.width;
                    }
                    width = bounds.height;
                    height = bounds.width;
                }
            }
            else if (graphicsRotation === 0) {
                if (!isNormalMatrix &&
                    (typeof this.rotationAngle !== 'undefined' &&
                        (this.rotationAngle === PdfRotationAngle.angle90 ||
                            this.rotationAngle === PdfRotationAngle.angle270))) {
                    x = bounds.x;
                    y = (bounds.y + bounds.height - bounds.width);
                    width = bounds.height;
                    height = bounds.width;
                }
            }
        }
        return { x: x, y: y, width: width, height: height };
    }
    _obtainGraphicsRotation(matrix) {
        const radians = Math.atan2(matrix._matrix._elements[2], matrix._matrix._elements[0]);
        let angle = Math.round(radians * 180 / Math.PI);
        switch (angle) {
            case -90:
                angle = 90;
                break;
            case -180:
                angle = 180;
                break;
            case 90:
                angle = 270;
                break;
        }
        return angle;
    }
    _removeAnnotationFromPage(page, annotation) {
        let annotations = [];
        if (page._pageDictionary && page._pageDictionary.has('Annots')) {
            annotations = page._pageDictionary.get('Annots');
        }
        annotation._dictionary.set('P', page._ref);
        const index = annotations.indexOf(annotation._ref);
        if (index !== -1) {
            annotations.splice(index, 1);
            if (this._crossReference._cacheMap.has(annotation._ref)) {
                this._crossReference._cacheMap.delete(annotation._ref);
            }
        }
        page._pageDictionary.set('Annots', annotations);
    }
    _removeAnnotation(page, annotation) {
        if (page && annotation) {
            this._removeAnnotationFromPage(page, annotation);
            page._pageDictionary._updated = true;
        }
    }
    _drawCloudStyle(graphics, brush, pen, radius, overlap, points, isAppearance) {
        if (this._isClockWise(points)) {
            const sortedPoints = [];
            for (let i = points.length - 1; i >= 0; i--) {
                sortedPoints.push(points[Number.parseInt(i.toString(), 10)]);
            }
            points = sortedPoints;
        }
        const circles = [];
        const circleOverlap = 2 * radius * overlap;
        let previousPoint = points[points.length - 1];
        for (let i = 0; i < points.length; i++) {
            const currentPoint = points[Number.parseInt(i.toString(), 10)];
            let dx = currentPoint[0] - previousPoint[0];
            let dy = currentPoint[1] - previousPoint[1];
            const length = Math.sqrt(dx * dx + dy * dy);
            dx = dx / length;
            dy = dy / length;
            for (let a = 0; a + 0.1 * circleOverlap < length; a += circleOverlap) {
                const cur = new _CloudStyleArc();
                cur.point = [previousPoint[0] + a * dx, previousPoint[1] + a * dy];
                circles.push(cur);
            }
            previousPoint = currentPoint;
        }
        let previousCurvedStyleArc = circles[circles.length - 1];
        for (let i = 0; i < circles.length; i++) {
            const currentCurvedStyleArc = circles[Number.parseInt(i.toString(), 10)];
            const angle = this._getIntersectionDegrees(previousCurvedStyleArc.point, currentCurvedStyleArc.point, radius);
            previousCurvedStyleArc.endAngle = angle[0];
            currentCurvedStyleArc.startAngle = angle[1];
            previousCurvedStyleArc = currentCurvedStyleArc;
        }
        let path = new _PdfPath();
        for (let i = 0; i < circles.length; i++) {
            const current = circles[Number.parseInt(i.toString(), 10)];
            const startAngle = current.startAngle % 360;
            const endAngle = current.endAngle % 360;
            let sweepAngel = 0;
            if (startAngle > 0 && endAngle < 0) {
                sweepAngel = (180 - startAngle) + (180 - (endAngle < 0 ? -endAngle : endAngle));
            }
            else if (startAngle < 0 && endAngle > 0) {
                sweepAngel = -startAngle + endAngle;
            }
            else if (startAngle > 0 && endAngle > 0) {
                let difference = 0;
                if (startAngle > endAngle) {
                    difference = startAngle - endAngle;
                    sweepAngel = 360 - difference;
                }
                else {
                    sweepAngel = endAngle - startAngle;
                }
            }
            else if (startAngle < 0 && endAngle < 0) {
                let difference = 0;
                if (startAngle > endAngle) {
                    difference = startAngle - endAngle;
                    sweepAngel = 360 - difference;
                }
                else {
                    sweepAngel = -(startAngle + (-endAngle));
                }
            }
            if (sweepAngel < 0) {
                sweepAngel = -sweepAngel;
            }
            current.endAngle = sweepAngel;
            path._addArc(current.point[0] - radius, current.point[1] - radius, 2 * radius, 2 * radius, startAngle, sweepAngel);
        }
        path._closeFigure();
        let tempPoints = [];
        if (isAppearance) {
            for (let i = 0; i < path._points.length; i++) {
                tempPoints.push([path._points[Number.parseInt(i.toString(), 10)][0], -path._points[Number.parseInt(i.toString(), 10)][1]]);
            }
        }
        let pdfpath;
        if (isAppearance) {
            pdfpath = new _PdfPath();
            pdfpath._points = tempPoints;
            pdfpath._pathTypes = path._pathTypes;
        }
        else {
            pdfpath = new _PdfPath();
            pdfpath._points = path._points;
            pdfpath._pathTypes = path._pathTypes;
        }
        if (brush !== null) {
            graphics._drawPath(pdfpath, null, brush);
        }
        const incise = 180 / (Math.PI * 3);
        path = new _PdfPath();
        for (let i = 0; i < circles.length; i++) {
            const current = circles[Number.parseInt(i.toString(), 10)];
            path._addArc(current.point[0] - radius, current.point[1] - radius, 2 * radius, 2 * radius, current.startAngle, current.endAngle + incise);
        }
        path._closeFigure();
        tempPoints = [];
        if (isAppearance) {
            for (let i = 0; i < path._points.length; i++) {
                tempPoints.push([path._points[Number.parseInt(i.toString(), 10)][0], -path._points[Number.parseInt(i.toString(), 10)][1]]);
            }
        }
        if (isAppearance) {
            pdfpath = new _PdfPath();
            pdfpath._points = tempPoints;
            pdfpath._pathTypes = path._pathTypes;
        }
        else {
            pdfpath = new _PdfPath();
            pdfpath._points = path._points;
            pdfpath._pathTypes = path._pathTypes;
        }
        graphics._drawPath(pdfpath, pen, null);
    }
    _isClockWise(points) {
        let sum = 0;
        for (let i = 0; i < points.length; i++) {
            const first = points[Number.parseInt(i.toString(), 10)];
            const second = points[(i + 1) % points.length];
            sum += (second[0] - first[0]) * (second[1] + first[1]);
        }
        return sum > 0;
    }
    _getIntersectionDegrees(first, second, radius) {
        const dx = second[0] - first[0];
        const dy = second[1] - first[1];
        const length = Math.sqrt(dx * dx + dy * dy);
        let a = 0.5 * length / radius;
        if (a < -1) {
            a = -1;
        }
        else if (a > 1) {
            a = 1;
        }
        const radian = Math.atan2(dy, dx);
        const cosvalue = Math.acos(a);
        return [(radian - cosvalue) * (180 / Math.PI), (Math.PI + radian + cosvalue) * (180 / Math.PI)];
    }
    _obtainStyle(borderPen, rectangle, borderWidth, parameter) {
        const dash = this.border.dash;
        if (dash && dash.length > 0) {
            const dashPattern = [];
            let isDash = false;
            for (let i = 0; i < dash.length; i++) {
                dashPattern[Number.parseInt(i.toString(), 10)] = dash[Number.parseInt(i.toString(), 10)];
                if (dashPattern[Number.parseInt(i.toString(), 10)] > 0) {
                    isDash = true;
                }
            }
            if (isDash && this.border.style === PdfBorderStyle.dashed) {
                borderPen._dashStyle = PdfDashStyle.dash;
                borderPen._dashPattern = dashPattern;
            }
        }
        if (parameter) {
            if (parameter instanceof _PaintParameter) {
                if (!this._isBounds && this._dictionary.has('RD')) {
                    const array = this._dictionary.getArray('RD');
                    if (array) {
                        rectangle[0] = rectangle[0] + array[0];
                        rectangle[1] = rectangle[1] + borderWidth + array[1];
                        rectangle[2] = rectangle[2] - (array[0] + array[2]);
                        rectangle[3] = rectangle[3] - (array[1] + array[3]);
                    }
                }
                else {
                    rectangle[0] = rectangle[0] + borderWidth;
                    rectangle[1] = rectangle[1] + borderWidth;
                    rectangle[2] = rectangle[2] - this.border.width;
                    rectangle[3] = rectangle[3] - this.border.width;
                }
                parameter.bounds = rectangle;
            }
            else {
                if (parameter.intensity !== 0 && parameter.style === PdfBorderEffectStyle.cloudy) {
                    const radius = parameter.intensity * 5;
                    rectangle[0] = rectangle[0] + radius + borderWidth;
                    rectangle[1] = rectangle[1] + radius + borderWidth;
                    rectangle[2] = rectangle[2] - (2 * radius) - 2 * borderWidth;
                    rectangle[3] = rectangle[3] - (2 * radius) - 2 * borderWidth;
                }
                else {
                    rectangle[0] = rectangle[0] + borderWidth;
                    rectangle[1] = rectangle[1] + borderWidth;
                    rectangle[2] = rectangle[2] - this.border.width;
                    rectangle[3] = this.bounds.height - this.border.width;
                }
            }
        }
        else {
            if (!this._isBounds && this._dictionary.has('RD')) {
                const array = this._dictionary.getArray('RD');
                if (array) {
                    rectangle[0] = rectangle[0] + array[0];
                    rectangle[1] = rectangle[1] + borderWidth + array[1];
                    rectangle[2] = rectangle[2] - (2 * array[2]);
                    rectangle[3] = rectangle[3] - this.border.width;
                    rectangle[3] = rectangle[3] - (2 * array[3]);
                }
            }
            else {
                rectangle[1] = rectangle[1] + borderWidth;
                rectangle[3] = this.bounds.height - this.border.width;
            }
        }
        return rectangle;
    }
    _createRectangleAppearance(borderEffect) {
        const width = this.border.width;
        let rdArray = this._dictionary.getArray('RD');
        if (!rdArray && borderEffect.intensity !== 0 && borderEffect.style === PdfBorderEffectStyle.cloudy) {
            const cloudRectangle = { x: this.bounds.x - borderEffect.intensity * 5 - width / 2,
                y: this.bounds.y - borderEffect.intensity * 5 - width / 2,
                width: this.bounds.width + borderEffect.intensity * 10 + width,
                height: this.bounds.height + borderEffect.intensity * 10 + width };
            const radius = borderEffect.intensity * 5;
            rdArray = [radius + width / 2, radius + width / 2, radius + width / 2, radius + width / 2];
            this._dictionary.set('RD', rdArray);
            this.bounds = cloudRectangle;
        }
        if (!this._isBounds && rdArray) {
            const cloudRectangle = { x: this.bounds.x + rdArray[0],
                y: this.bounds.y + rdArray[1],
                width: this.bounds.width - rdArray[2] * 2,
                height: this.bounds.height - rdArray[3] * 2 };
            if (borderEffect.intensity !== 0 && borderEffect.style === PdfBorderEffectStyle.cloudy) {
                cloudRectangle.x = cloudRectangle.x - borderEffect.intensity * 5 - width / 2;
                cloudRectangle.y = cloudRectangle.y - borderEffect.intensity * 5 - width / 2;
                cloudRectangle.width = cloudRectangle.width + borderEffect.intensity * 10 + width;
                cloudRectangle.height = cloudRectangle.height + borderEffect.intensity * 10 + width;
                const radius = borderEffect.intensity * 5;
                this._dictionary.set('RD', [radius + width / 2, radius + width / 2, radius + width / 2, radius + width / 2]);
            }
            else {
                delete this._dictionary._map.RD;
            }
            this.bounds = cloudRectangle;
        }
        const borderWidth = width / 2;
        const nativeRectangle = [0, 0, this.bounds.width, this.bounds.height];
        const template = new PdfTemplate(nativeRectangle, this._crossReference);
        _setMatrix(template, this._getRotationAngle());
        if (borderEffect.intensity !== 0 && borderEffect.style === PdfBorderEffectStyle.cloudy) {
            template._writeTransformation = false;
        }
        const graphics = template.graphics;
        const parameter = new _PaintParameter();
        if (this.innerColor) {
            parameter.backBrush = new PdfBrush(this._innerColor);
        }
        if (width > 0 && this.color) {
            parameter.borderPen = new PdfPen(this._color, width);
        }
        if (this.color) {
            parameter.foreBrush = new PdfBrush(this._color);
        }
        const rectangle = this._obtainStyle(parameter.borderPen, nativeRectangle, borderWidth, borderEffect);
        if (typeof this.opacity !== 'undefined' && this._opacity < 1) {
            graphics.save();
            graphics.setTransparency(this._opacity);
        }
        if (borderEffect.intensity !== 0 && borderEffect.style === PdfBorderEffectStyle.cloudy) {
            this._drawRectangleAppearance(rectangle, graphics, parameter, borderEffect.intensity);
        }
        else {
            graphics.drawRectangle(rectangle[0], rectangle[1], rectangle[2], rectangle[3], parameter.borderPen, parameter.backBrush);
        }
        if (typeof this.opacity !== 'undefined' && this._opacity < 1) {
            graphics.restore();
        }
        return template;
    }
    _drawRectangleAppearance(rectangle, graphics, parameter, intensity) {
        let graphicsPath = new _PdfPath();
        graphicsPath._addRectangle(rectangle[0], rectangle[1], rectangle[2], rectangle[3]);
        const radius = intensity * 4.25;
        if (radius > 0) {
            const points = [];
            for (let i = 0; i < graphicsPath._points.length; i++) {
                const sublist = [graphicsPath._points[Number.parseInt(i.toString(), 10)][0],
                    -graphicsPath._points[Number.parseInt(i.toString(), 10)][1]];
                points.push(sublist);
            }
            graphicsPath = new _PdfPath();
            graphicsPath._addPolygon(points);
            this._drawCloudStyle(graphics, parameter.backBrush, parameter.borderPen, radius, 0.833, graphicsPath._points, false);
        }
        else {
            graphics.drawRectangle(rectangle[0], rectangle[1], rectangle[2], rectangle[3], parameter.borderPen, parameter.backBrush);
        }
    }
    _createCircleAppearance() {
        const nativeBounds = [0, 0, this.bounds.width, this.bounds.height];
        const template = new PdfTemplate(nativeBounds, this._crossReference);
        _setMatrix(template, this._getRotationAngle());
        if (this._dictionary.has('BE')) {
            template._writeTransformation = false;
        }
        const graphics = template.graphics;
        const width = this.border.width;
        const borderPen = new PdfPen(this.color, width);
        const parameter = new _PaintParameter();
        if (this.innerColor) {
            parameter.backBrush = new PdfBrush(this._innerColor);
        }
        if (width > 0) {
            parameter.borderPen = borderPen;
        }
        if (this.color) {
            parameter.foreBrush = new PdfBrush(this._color);
        }
        parameter.borderWidth = width;
        const borderWidth = width / 2;
        const rectangle = this._obtainStyle(borderPen, nativeBounds, borderWidth);
        if (typeof this.opacity !== 'undefined' && this._opacity < 1) {
            graphics.save();
            graphics.setTransparency(this._opacity);
        }
        if (this._dictionary.has('BE')) {
            this._drawCircleAppearance(rectangle, borderWidth, graphics, parameter);
        }
        else {
            graphics.drawEllipse(rectangle[0] + borderWidth, rectangle[1], rectangle[2] - width, rectangle[3], parameter.borderPen, parameter.backBrush);
        }
        if (typeof this._opacity !== 'undefined' && this._opacity < 1) {
            graphics.restore();
        }
        return template;
    }
    _drawCircleAppearance(rectangle, borderWidth, graphics, parameter) {
        let radius = 0;
        if (this._dictionary.has('RD')) {
            const array = this._dictionary.getArray('RD');
            if (array && array.length > 0) {
                radius = array[0];
            }
        }
        if (radius > 0) {
            const rect = [rectangle[0] + borderWidth,
                -rectangle[1] - rectangle[3],
                rectangle[2] - this.border.width,
                rectangle[3]];
            const left = rect[0];
            const top = rect[1];
            const right = rect[0] + rect[2];
            const bottom = rect[1] + rect[3];
            const controlPointList = [];
            controlPointList.push([right, bottom]);
            controlPointList.push([left, bottom]);
            controlPointList.push([left, top]);
            controlPointList.push([right, top]);
            const startPointList = [];
            startPointList.push([right, top + (rect[3] / 2)]);
            startPointList.push([left + rect[2] / 2, bottom]);
            startPointList.push([left, top + (rect[3] / 2)]);
            startPointList.push([left + (rect[2] / 2), top]);
            const endPointList = [];
            endPointList.push([left + rect[2] / 2, bottom]);
            endPointList.push([left, top + (rect[3] / 2)]);
            endPointList.push([left + (rect[2] / 2), top]);
            endPointList.push([right, top + (rect[3] / 2)]);
            const points = [];
            for (let i = 0; i < controlPointList.length; i++) {
                this._createBezier(startPointList[Number.parseInt(i.toString(), 10)], controlPointList[Number.parseInt(i.toString(), 10)], endPointList[Number.parseInt(i.toString(), 10)], points);
            }
            this._drawCloudStyle(graphics, parameter.backBrush, parameter.borderPen, radius, 0.833, points, false);
        }
        else {
            graphics.drawEllipse(rectangle[0] + borderWidth, -rectangle[1], rectangle[2] - this.border.width, -rectangle[3], parameter.borderPen, parameter.backBrush);
        }
    }
    _createBezier(first, second, third, bezierPoints) {
        bezierPoints.push(first);
        this._populateBezierPoints(first, second, third, 0, bezierPoints);
        bezierPoints.push(third);
    }
    _populateBezierPoints(first, second, third, currentIteration, bezierPoints) {
        if (currentIteration < 2) {
            const midPoint1 = this._midPoint(first, second);
            const midPoint2 = this._midPoint(second, third);
            const midPoint3 = this._midPoint(midPoint1, midPoint2);
            currentIteration++;
            this._populateBezierPoints(first, midPoint1, midPoint3, currentIteration, bezierPoints);
            bezierPoints.push(midPoint3);
            this._populateBezierPoints(midPoint3, midPoint2, third, currentIteration, bezierPoints);
        }
    }
    _midPoint(first, second) {
        return [(first[0] + second[0]) / 2, (first[1] + second[1]) / 2];
    }
    _getAngle(linePoints) {
        const x1 = linePoints[0];
        const y1 = linePoints[1];
        const x2 = linePoints[2];
        const y2 = linePoints[3];
        let angle = 0;
        if (x2 - x1 === 0) {
            angle = (y2 > y1) ? 90 : 270;
        }
        else {
            const angleRatio = (y2 - y1) / (x2 - x1);
            const radians = Math.atan(angleRatio);
            angle = radians * (180 / Math.PI);
            if ((x2 - x1) < 0 || (y2 - y1) < 0) {
                angle += 180;
            }
            if ((x2 - x1) > 0 && (y2 - y1) < 0) {
                angle -= 180;
            }
            if (angle < 0) {
                angle += 360;
            }
        }
        return angle;
    }
    _getAxisValue(value, angle, length) {
        return [value[0] + Math.cos(angle * this._degreeToRadian) * length,
            value[1] + Math.sin(angle * this._degreeToRadian) * length];
    }
    _drawLineEndStyle(axisPoint, graphics, angle, pen, brush, style, length, isBegin) {
        let arraowAngle;
        let count;
        let startPoint;
        let first;
        let second;
        let third;
        let fourth;
        let path;
        switch (style) {
            case PdfLineEndingStyle.square:
                graphics.drawRectangle(axisPoint[0] - (3 * length), -(axisPoint[1] + (3 * length)), (6 * length), (6 * length), pen, brush);
                break;
            case PdfLineEndingStyle.circle:
                graphics.drawEllipse(axisPoint[0] - (3 * length), -(axisPoint[1] + (3 * length)), (6 * length), (6 * length), pen, brush);
                break;
            case PdfLineEndingStyle.openArrow:
                arraowAngle = isBegin ? 30 : 150;
                count = 9 * length;
                startPoint = this._getAxisValue(axisPoint, angle, (isBegin ? length : (-length)));
                first = this._getAxisValue(startPoint, (angle + arraowAngle), count);
                second = this._getAxisValue(startPoint, (angle - arraowAngle), count);
                path = new _PdfPath();
                path._pen = pen;
                path._addLine(startPoint[0], -startPoint[1], first[0], -first[1]);
                path._addLine(startPoint[0], -startPoint[1], second[0], -second[1]);
                graphics._stateControl(pen, null, null);
                graphics._buildUpPath(path._points, path._pathTypes);
                graphics._drawGraphicsPath(pen, null, path._fillMode, false);
                break;
            case PdfLineEndingStyle.closedArrow:
                arraowAngle = isBegin ? 30 : 150;
                count = 9 * length;
                startPoint = this._getAxisValue(axisPoint, angle, (isBegin ? length : (-length)));
                first = this._getAxisValue(startPoint, (angle + arraowAngle), count);
                second = this._getAxisValue(startPoint, (angle - arraowAngle), count);
                graphics.drawPolygon([[startPoint[0], -startPoint[1]], [first[0], -first[1]], [second[0], -second[1]]], pen, brush);
                break;
            case PdfLineEndingStyle.rOpenArrow:
                arraowAngle = isBegin ? 150 : 30;
                count = 9 * length;
                startPoint = this._getAxisValue(axisPoint, angle, (isBegin ? (-length) : length));
                first = this._getAxisValue(startPoint, (angle + arraowAngle), count);
                second = this._getAxisValue(startPoint, (angle - arraowAngle), count);
                path = new _PdfPath();
                path._pen = pen;
                path._addLine(startPoint[0], -startPoint[1], first[0], -first[1]);
                path._addLine(startPoint[0], -startPoint[1], second[0], -second[1]);
                graphics._stateControl(pen, null, null);
                graphics._buildUpPath(path._points, path._pathTypes);
                graphics._drawGraphicsPath(pen, null, path._fillMode, false);
                break;
            case PdfLineEndingStyle.rClosedArrow:
                arraowAngle = isBegin ? 150 : 30;
                count = 9 * length;
                startPoint = this._getAxisValue(axisPoint, angle, (isBegin ? (-length) : length));
                first = this._getAxisValue(startPoint, (angle + arraowAngle), count);
                second = this._getAxisValue(startPoint, (angle - arraowAngle), count);
                graphics.drawPolygon([[startPoint[0], -startPoint[1]], [first[0], -first[1]], [second[0], -second[1]]], pen, brush);
                break;
            case PdfLineEndingStyle.slash:
                count = 9 * length;
                first = this._getAxisValue(startPoint, (angle + 60), count);
                second = this._getAxisValue(startPoint, (angle - 120), count);
                graphics.drawLine(pen, axisPoint[0], -axisPoint[1], first[0], -first[1]);
                graphics.drawLine(pen, axisPoint[0], -axisPoint[1], second[0], -second[1]);
                break;
            case PdfLineEndingStyle.diamond:
                count = 3 * length;
                first = this._getAxisValue(axisPoint, 180, count);
                second = this._getAxisValue(axisPoint, 90, count);
                third = this._getAxisValue(axisPoint, 0, count);
                fourth = this._getAxisValue(axisPoint, -90, count);
                graphics.drawPolygon([[first[0], -first[1]], [second[0], -second[1]], [third[0], -third[1]], [fourth[0], -fourth[1]]], pen, brush);
                break;
            case PdfLineEndingStyle.butt:
                count = 3 * length;
                first = this._getAxisValue(axisPoint, (angle + 90), count);
                second = this._getAxisValue(axisPoint, (angle - 90), count);
                graphics.drawLine(pen, first[0], -first[1], second[0], -second[1]);
                break;
        }
    }
    _drawLineStyle(start, end, graphics, angle, pen, brush, lineStyle, length) {
        if (length === 0) {
            length = 1;
            pen = null;
        }
        this._drawLineEndStyle(start, graphics, angle, pen, brush, lineStyle.begin, length, true);
        this._drawLineEndStyle(end, graphics, angle, pen, brush, lineStyle.end, length, false);
    }
    _obtainFontDetails() {
        let fontFamily = '';
        let fontSize;
        let style = PdfFontStyle.regular;
        if (this._dictionary.has('DS') || this._dictionary.has('DA')) {
            let fontStyle;
            if (this._dictionary.has('DS')) {
                const collection = this._dictionary.get('DS').split(';');
                for (let i = 0; i < collection.length; i++) {
                    const entry = collection[Number.parseInt(i.toString(), 10)].split(':');
                    if (collection[Number.parseInt(i.toString(), 10)].indexOf('font-family') !== -1) {
                        fontFamily = entry[1];
                    }
                    else if (collection[Number.parseInt(i.toString(), 10)].indexOf('font-size') !== -1) {
                        if (entry[1].endsWith('pt')) {
                            fontSize = Number.parseFloat(entry[1].replace('pt', ''));
                        }
                    }
                    else if (collection[Number.parseInt(i.toString(), 10)].indexOf('font-style') !== -1 || collection[Number.parseInt(i.toString(), 10)].indexOf('style') !== -1) {
                        fontStyle = collection[Number.parseInt(i.toString(), 10)];
                    }
                    else if (collection[Number.parseInt(i.toString(), 10)].indexOf('font') !== -1) {
                        const name = entry[1];
                        const split = name.split(' ');
                        for (let j = 0; j < split.length; j++) {
                            if (split[Number.parseInt(j.toString(), 10)] !== '' && !split[Number.parseInt(j.toString(), 10)].endsWith('pt')) {
                                fontFamily += split[Number.parseInt(j.toString(), 10)] + ' ';
                            }
                            if (split[Number.parseInt(j.toString(), 10)].endsWith('pt')) {
                                fontSize = Number.parseFloat(split[Number.parseInt(j.toString(), 10)].replace('pt', ''));
                            }
                        }
                        while (fontFamily !== ' ' && fontFamily.endsWith(' ')) {
                            fontFamily = fontFamily.substring(0, fontFamily.length - 1);
                        }
                        if (fontFamily.indexOf(',') !== -1) {
                            fontFamily = fontFamily.split(',')[0];
                        }
                    }
                }
            }
            else {
                const value = this._dictionary.get('DA');
                if (value && value !== '' && value.indexOf('Tf') !== -1) {
                    const textCollection = value.split(' ');
                    for (let i = 0; i < textCollection.length; i++) {
                        if (textCollection[Number.parseInt(i.toString(), 10)].indexOf('Tf') !== -1) {
                            fontFamily = textCollection[i - 2];
                            while (fontFamily !== '' && fontFamily.length > 1 && fontFamily[0] === '/') {
                                fontFamily = fontFamily.substring(1);
                            }
                            fontSize = Number.parseFloat(textCollection[i - 1]);
                        }
                    }
                }
            }
            if (fontStyle && fontStyle !== '') {
                let styleArray;
                if (fontStyle.includes(':')) {
                    styleArray = fontStyle.split(':');
                }
                else if (fontStyle.includes(',')) {
                    styleArray = fontStyle.split(',');
                }
                if (styleArray) {
                    styleArray.forEach((entry) => {
                        switch (entry.toLowerCase()) {
                            case 'bold':
                                style |= PdfFontStyle.bold;
                                break;
                            case 'italic':
                                style |= PdfFontStyle.italic;
                                break;
                            case 'strikeout':
                                style |= PdfFontStyle.strikeout;
                                break;
                            case 'underline':
                                style |= PdfFontStyle.underline;
                                break;
                        }
                    });
                }
            }
            if (fontFamily) {
                fontFamily = fontFamily.trim();
            }
        }
        return { name: fontFamily, size: fontSize, style: style };
    }
    _obtainFont() {
        const fontData = this._obtainFontDetails();
        return _mapFont(fontData.name, fontData.size, fontData.style, this);
    }
    _getEqualPdfGraphicsUnit(measurementUnit, unitString) {
        let graphicsUnit;
        switch (measurementUnit) {
            case PdfMeasurementUnit.inch:
                graphicsUnit = _PdfGraphicsUnit.inch;
                unitString = 'in';
                break;
            case PdfMeasurementUnit.centimeter:
                graphicsUnit = _PdfGraphicsUnit.centimeter;
                unitString = 'cm';
                break;
            case PdfMeasurementUnit.millimeter:
                graphicsUnit = _PdfGraphicsUnit.millimeter;
                unitString = 'mm';
                break;
            case PdfMeasurementUnit.pica:
                graphicsUnit = _PdfGraphicsUnit.pica;
                unitString = 'p';
                break;
            case PdfMeasurementUnit.point:
                graphicsUnit = _PdfGraphicsUnit.point;
                unitString = 'pt';
                break;
            default:
                graphicsUnit = _PdfGraphicsUnit.inch;
                unitString = 'in';
                break;
        }
        return { graphicsUnit: graphicsUnit, unitString: unitString };
    }
    _createMeasureDictionary(unitString) {
        const d = new _PdfDictionary();
        d.set('C', 1);
        d.set('D', 100);
        d.set('F', _PdfName.get('D'));
        d.set('RD', '.');
        d.set('RT', '');
        d.set('SS', '');
        d.set('U', unitString);
        const a = new _PdfDictionary();
        a.set('C', 1);
        a.set('D', 100);
        a.set('F', _PdfName.get('D'));
        a.set('RD', '.');
        a.set('RT', '');
        a.set('SS', '');
        a.set('U', 'sq ' + unitString);
        const x = new _PdfDictionary();
        if (unitString === 'in') {
            x.set('C', 0.0138889);
        }
        else if (unitString === 'cm') {
            x.set('C', 0.0352778);
        }
        else if (unitString === 'mm') {
            x.set('C', 0.352778);
        }
        else if (unitString === 'pt') {
            x.set('C', 1);
        }
        else if (unitString === 'p') {
            x.set('C', 0.0833333);
        }
        x.set('D', 100);
        x.set('F', _PdfName.get('D'));
        x.set('RD', '.');
        x.set('RT', '');
        x.set('SS', '');
        x.set('U', unitString);
        const measureDictionary = new _PdfDictionary();
        measureDictionary.set('A', [a]);
        measureDictionary.set('D', [d]);
        measureDictionary.set('R', '1 ' + unitString + ' = 1 ' + unitString);
        measureDictionary.set('Type', _PdfName.get('Measure'));
        measureDictionary.set('X', [x]);
        return measureDictionary;
    }
    _colorToHex(col) {
        if (col) {
            return '#' + this._componentToHex(col[0]) + this._componentToHex(col[1]) + this._componentToHex(col[2]);
        }
        else {
            return '#' + this._componentToHex(0) + this._componentToHex(0) + this._componentToHex(0);
        }
    }
    _componentToHex(c) {
        const hex = c.toString(16);
        return hex.length === 1 ? '0' + hex : hex;
    }
    _getRotatedBounds(bounds, rotateAngle) {
        if (bounds.width > 0 && bounds.height > 0) {
            const matrix = new _PdfTransformationMatrix();
            matrix._rotate(rotateAngle);
            const corners = [];
            corners.push([bounds.x, bounds.y]);
            corners.push([bounds.x + bounds.width, bounds.y]);
            corners.push([bounds.x + bounds.width, bounds.y + bounds.height]);
            corners.push([bounds.x, bounds.y + bounds.height]);
            for (let i = 0; i < corners.length; i++) {
                corners[Number.parseInt(i.toString(), 10)] = matrix._matrix._transform(corners[Number.parseInt(i.toString(), 10)]);
            }
            const path = new _PdfPath();
            path._addRectangle(bounds.x, bounds.y, bounds.width, bounds.height);
            for (let i = 0; i < 4; i++) {
                path._points[Number.parseInt(i.toString(), 10)] = corners[Number.parseInt(i.toString(), 10)];
            }
            let minX = corners[0][0];
            let maxX = corners[3][0];
            let minY = corners[0][1];
            let maxY = corners[3][1];
            for (let i = 0; i < 4; i++) {
                if (corners[Number.parseInt(i.toString(), 10)][0] < minX) {
                    minX = corners[Number.parseInt(i.toString(), 10)][0];
                }
                if (corners[Number.parseInt(i.toString(), 10)][0] > maxX) {
                    maxX = corners[Number.parseInt(i.toString(), 10)][0];
                }
                if (corners[Number.parseInt(i.toString(), 10)][1] < minY) {
                    minY = corners[Number.parseInt(i.toString(), 10)][1];
                }
                if (corners[Number.parseInt(i.toString(), 10)][1] > maxY) {
                    maxY = corners[Number.parseInt(i.toString(), 10)][1];
                }
            }
            return { x: bounds.x, y: bounds.y, width: maxX - minX, height: maxY - minY };
        }
        return bounds;
    }
    _flattenPopUp() {
        this._flattenPop(this._page, this.color, this.bounds, this.border, this.author, this.subject, this.text);
    }
    _flattenPop(_page, color, boundsValue, border, author, subject, text) {
        let clientSize = [0, 0];
        clientSize = _page.size;
        const x = clientSize[0] - 180;
        const annotBounds = boundsValue;
        const y = (annotBounds.y + 142) < clientSize[1] ? annotBounds.y : clientSize[1] - 142;
        let bounds = [x, y, 180, 142];
        if (this._dictionary.has('Popup')) {
            const dictionary = this._dictionary.get('Popup');
            if (dictionary) {
                const rectValue = this._dictionary.getArray('Rect');
                if (rectValue && rectValue.length === 4) {
                    const left = rectValue[0];
                    const top = rectValue[1];
                    const width = rectValue[2];
                    const height = rectValue[3];
                    bounds = [left, top, width - left, height - top];
                }
            }
        }
        if (typeof color === 'undefined') {
            color = [0, 0, 0];
        }
        const backBrush = new PdfBrush(color);
        const borderWidth = border.width / 2;
        const pen = new PdfPen([0, 0, 0], 1);
        let track = 0;
        const aBrush = new PdfBrush(this._getForeColor(color));
        if (typeof author !== 'undefined' && author !== null && author !== '') {
            track = this._drawAuthor(author, subject, bounds, backBrush, aBrush, _page, track, border);
        }
        else if (typeof subject !== 'undefined' && subject !== null && subject !== '') {
            const titleRect = [bounds[0] + borderWidth, bounds[1] + borderWidth, bounds[2] - border.width, 40];
            this._saveGraphics(_page, PdfBlendMode.hardLight);
            _page.graphics.drawRectangle(titleRect[0], titleRect[1], titleRect[2], titleRect[3], pen, backBrush);
            _page.graphics.restore();
            let contentRect = [titleRect[0] + 11, titleRect[1], titleRect[2], titleRect[3] / 2];
            contentRect = [contentRect[0], (contentRect[1] + contentRect[3] - 2), contentRect[2], titleRect[3] / 2];
            this._saveGraphics(_page, PdfBlendMode.normal);
            this._drawSubject(subject, contentRect, _page);
            _page.graphics.restore();
            track = 40;
        }
        else {
            this._saveGraphics(_page, PdfBlendMode.hardLight);
            const titleRect = [bounds[0] + borderWidth, bounds[1] + borderWidth, bounds[2] - border.width, 20];
            _page.graphics.drawRectangle(titleRect[0], titleRect[1], titleRect[2], titleRect[3], pen, backBrush);
            track = 20;
            _page.graphics.restore();
        }
        const rect = [bounds[0] + borderWidth, bounds[1] + borderWidth + track,
            bounds[2] - border.width, bounds[3] - (track + border.width)];
        this._saveGraphics(_page, PdfBlendMode.hardLight);
        _page.graphics.drawRectangle(rect[0], rect[1], rect[2], rect[3], new PdfPen([0, 0, 0], 1), new PdfBrush([255, 255, 255]));
        rect[0] += 11;
        rect[1] += 5;
        rect[2] -= 22;
        _page.graphics.restore();
        this._saveGraphics(_page, PdfBlendMode.normal);
        if (typeof text !== 'undefined' && text !== null && text !== '') {
            _page.graphics.drawString(text, this._popUpFont, rect, null, new PdfBrush([0, 0, 0]), null);
        }
        _page.graphics.restore();
    }
    _flattenLoadedPopUp() {
        let content = '';
        if (this._dictionary.has('Contents')) {
            content = this._dictionary.get('Contents');
        }
        const author = this.author;
        const subject = this.subject;
        const pen = new PdfPen([0, 0, 0], 1);
        if (!this._dictionary.has('Popup')) {
            this._flattenPop(this._page, this.color, this.bounds, this.border, author, subject, content);
            this._removeAnnotationFromPage(this._page, this);
        }
        else {
            const bounds = this._getRectangleBoundsValue();
            if (typeof this.color === 'undefined') {
                this.color = [0, 0, 0];
            }
            const backBrush = new PdfBrush(this.color);
            const borderWidth = this.border.width / 2;
            let track = 0;
            const aBrush = new PdfBrush(this._getForeColor(this.color));
            if (typeof this.author !== 'undefined' && this.author !== null && this.author !== '') {
                track = this._drawAuthor(this.author, this.subject, bounds, backBrush, aBrush, this._page, track, this.border);
            }
            else if (typeof this.subject !== 'undefined' && this.subject !== null && this.subject !== '') {
                const titleRect = [bounds[0] + borderWidth, bounds[1] + borderWidth, bounds[2] - this.border.width, 40];
                this._saveGraphics(this._page, PdfBlendMode.hardLight);
                this._page.graphics.drawRectangle(titleRect[0], titleRect[1], titleRect[2], titleRect[3], pen, backBrush);
                this._page.graphics.restore();
                let contentRect = [titleRect[0] + 11, titleRect[1], titleRect[2], titleRect[3] / 2];
                contentRect = [contentRect[0], (contentRect[1] + contentRect[3] - 2), contentRect[2], titleRect[3] / 2];
                this._saveGraphics(this._page, PdfBlendMode.normal);
                this._drawSubject(this.subject, contentRect, this._page);
                track = 40;
                this._page.graphics.restore();
            }
            else {
                this._saveGraphics(this._page, PdfBlendMode.hardLight);
                const titleRect = [bounds[0] + borderWidth, bounds[1] + borderWidth, bounds[2] - this.border.width, 20];
                this._page.graphics.drawRectangle(titleRect[0], titleRect[1], titleRect[2], titleRect[3], pen, backBrush);
                track = 20;
                this._page.graphics.restore();
            }
            this._saveGraphics(this._page, PdfBlendMode.hardLight);
            const rect = [bounds[0] + borderWidth, bounds[1] + borderWidth + track,
                bounds[2] - this.border.width, bounds[3] - (track + this.border.width)];
            this._page.graphics.drawRectangle(rect[0], rect[1], rect[2], rect[3], pen, new PdfBrush([255, 255, 255]));
            rect[0] += 11;
            rect[1] += 5;
            rect[2] -= 22;
            this._page.graphics.restore();
            this._saveGraphics(this._page, PdfBlendMode.normal);
            this._page.graphics.restore();
            //let xmlData: Array<any> = Array<any>();
            // if (this._dictionary.has('RC')) {
            //     //xmlData = this.parseXMLData();
            // }
            // if (xmlData !== null) {
            //     // Need to add xml data code
            // } else {
            if (typeof content !== 'undefined' && content !== null && content !== '') {
                this._page.graphics.drawString(content, this._popUpFont, rect, null, new PdfBrush([0, 0, 0]), null);
            }
            // }
            this._page.graphics.restore();
            this._removeAnnotationFromPage(this._page, this);
        }
    }
    _getRectangleBoundsValue() {
        if (this._dictionary.has('Popup')) {
            const dic = this._dictionary.get('Popup');
            const rect = dic.getArray('Rect');
            if (rect !== null) {
                if (this._page !== null) {
                    if (rect[1] === 0 && rect[3] === 0) {
                        rect[1] = rect[1] + rect[3];
                    }
                    else {
                        rect[1] = this._page._size[1] - (rect[1] + rect[3]);
                    }
                }
                else {
                    rect[1] = (rect[1] - rect[3]);
                }
                return rect;
            }
            else {
                return [0, 0, 0, 0];
            }
        }
        else {
            return [0, 0, 0, 0];
        }
    }
    _getForeColor(color) {
        const fore = (((color[0] + color[1] + color[2]) / 3) > 128) ? [0, 0, 0] : [255, 255, 255];
        return fore;
    }
    _drawAuthor(author, subject, bounds, backBrush, aBrush, _page, trackingHeight, border) {
        const borderWidth = this.border.width / 2;
        const pen = new PdfPen([0, 0, 0], 1);
        const format = new PdfStringFormat(PdfTextAlignment.left, PdfVerticalAlignment.middle);
        const titleRect = [bounds[0] + borderWidth, bounds[1] + borderWidth, bounds[2] - border.width, 20];
        if (typeof subject !== 'undefined' && subject !== null && subject !== '') {
            titleRect[3] += 20;
            trackingHeight = titleRect[3];
            this._saveGraphics(_page, PdfBlendMode.hardLight);
            _page.graphics.drawRectangle(titleRect[0], titleRect[1], titleRect[2], titleRect[3], pen, backBrush);
            _page.graphics.restore();
            let contentRect = [titleRect[0] + 11, titleRect[1], titleRect[2], titleRect[3] / 2];
            this._saveGraphics(this._page, PdfBlendMode.normal);
            _page.graphics.drawString(author, this._authorBoldFont, contentRect, null, aBrush, format);
            contentRect = [contentRect[0], (contentRect[1] + contentRect[3] - 2), contentRect[2], titleRect[3] / 2];
            this._drawSubject(subject, contentRect, _page);
            _page.graphics.restore();
        }
        else {
            this._saveGraphics(_page, PdfBlendMode.hardLight);
            _page.graphics.drawRectangle(titleRect[0], titleRect[1], titleRect[2], titleRect[3], pen, backBrush);
            _page.graphics.restore();
            const contentRect = [titleRect[0] + 11, titleRect[1], titleRect[2], titleRect[3]];
            this._saveGraphics(_page, PdfBlendMode.normal);
            _page.graphics.drawString(author, this._popUpFont, contentRect, null, aBrush, format);
            trackingHeight = titleRect[3];
            _page.graphics.restore();
        }
        return trackingHeight;
    }
    _drawSubject(subject, contentRect, _page) {
        const format = new PdfStringFormat(PdfTextAlignment.left, PdfVerticalAlignment.middle);
        _page.graphics.drawString(subject, this._authorBoldFont, contentRect, null, new PdfBrush([0, 0, 0]), format);
    }
    _saveGraphics(_page, blendMode) {
        _page.graphics.save();
        _page.graphics.setTransparency(0.8, 0.8, blendMode);
    }
    _getBorderColorString(color) {
        return (color[0] / 255).toFixed(3) + ' ' + (color[1] / 255).toFixed(3) + ' ' + (color[2] / 255).toFixed(3) + ' rg ';
    }
    _stringToDate(date) {
        let dateFormat = new Date();
        if (date[0] === 'D' && date[1] === ':') {
            const year = date.substring(2, 6);
            const month = date.substring(6, 8);
            const day = date.substring(8, 10);
            const hour = date.substring(10, 12);
            const minute = date.substring(12, 14);
            const second = date.substring(14, 16);
            let difference = 0;
            if (date.length === 23) {
                const timeZone = date.substring(16, 22);
                if (timeZone !== '+05\'30\'') {
                    const signature = timeZone[0];
                    const timeZoneHour = timeZone.substring(1, 3);
                    const timeZonMinute = timeZone.substring(4, 6);
                    difference = 5.5 - (signature === '-' ? -1 : 1) * (parseInt(timeZoneHour, 10) + (parseInt(timeZonMinute, 10) / 60));
                }
            }
            dateFormat = new Date(year + '-' + month + '-' + day + 'T' + hour + ':' + minute + ':' + second);
            if (difference !== 0) {
                dateFormat.setTime(dateFormat.getTime() + (difference * 60 * 60 * 1000));
            }
        }
        else if (date.indexOf('/') !== -1) {
            const list = date.split('/');
            const year = list[2].split(' ')[0];
            let month = list[0];
            if (month !== '10' && month !== '11' && month !== '12') {
                month = '0' + month;
            }
            const day = list[1];
            const hour = list[2].split(' ')[1].split(':')[0];
            const minute = list[2].split(' ')[1].split(':')[1];
            const second = list[2].split(' ')[1].split(':')[2];
            dateFormat = new Date(year + '-' + month + '-' + day + 'T' + hour + ':' + minute + ':' + second);
        }
        else {
            dateFormat = new Date(date);
        }
        return dateFormat;
    }
    _dateToString(dateTime) {
        let month = (dateTime.getMonth() + 1).toString();
        if (month !== '10' && month !== '11' && month !== '12') {
            month = '0' + month;
        }
        let date = (dateTime.getDate()).toString();
        if (Number.parseInt(date) < 10) { // eslint-disable-line
            date = '0' + date;
        }
        let hours = (dateTime.getHours()).toString();
        if (Number.parseInt(hours) < 10) { // eslint-disable-line
            hours = '0' + hours;
        }
        let minutes = (dateTime.getMinutes()).toString();
        if (Number.parseInt(minutes) < 10) { // eslint-disable-line
            minutes = '0' + minutes;
        }
        let seconds = (dateTime.getSeconds()).toString();
        if (Number.parseInt(seconds) < 10) { // eslint-disable-line
            seconds = '0' + seconds;
        }
        return 'D:' + dateTime.getFullYear().toString() + month + date + hours + minutes + seconds + '+05\'30\'';
    }
    _obtainNativeRectangle() {
        const rect = [this._bounds.x, this._bounds.y, this.bounds.x + this._bounds.width, this.bounds.y + this._bounds.height];
        let cropBoxOrMediaBox;
        if (this._page) {
            const size = this._page.size;
            rect[1] = size[1] - rect[3];
            const cropBox = this._page.cropBox;
            if (cropBox && _areNotEqual(cropBox, [0, 0, 0, 0])) {
                cropBoxOrMediaBox = cropBox;
            }
            else {
                const mBox = this._page.mediaBox;
                if (mBox && _areNotEqual(mBox, [0, 0, 0, 0])) {
                    cropBoxOrMediaBox = mBox;
                }
            }
            if (cropBoxOrMediaBox && cropBoxOrMediaBox.length > 2 && (cropBoxOrMediaBox[0] !== 0 || cropBoxOrMediaBox[1] !== 0)) {
                rect[0] += cropBoxOrMediaBox[0];
                rect[1] += cropBoxOrMediaBox[1];
            }
        }
        return rect;
    }
}
/**
 * Represents the annotations which have comments and review history.
 * ```typescript
 * // Load an existing PDF document
 * let document: PdfDocument = new PdfDocument(data, password);
 * // Get the first page
 * let page: PdfPage = document.getPage(0);
 * // Access the annotation at index 0
 * let annotation: PdfComment = page.annotations.at(0) as PdfComment;
 * // Gets the comments of annotation
 * let comment : PdfPopupAnnotationCollection = annotation.comments;
 * // Save the document
 * document.save('output.pdf');
 * // Destroy the document
 * document.destroy();
 * ```
 */
class PdfComment extends PdfAnnotation {
    /**
     * Gets the comments of the PDF annotation (Read only).
     *
     * @returns {PdfPopupAnnotationCollection} Annotation comments
     * ```typescript
     * // Load an existing PDF document
     * let document: PdfDocument = new PdfDocument(data);
     * // Access first page
     * let page: PdfPage = document.getPage(0);
     * // Access the annotation at index 0
     * let annotation: PdfRectangleAnnotation = page.annotations.at(0) as PdfRectangleAnnotation;
     * // Gets the comments of the PDF annotation
     * let comments: PdfPopupAnnotationCollection = annotation.comments;
     * // Save the document
     * document.save('output.pdf');
     * // Destroy the document
     * document.destroy();
     * ```
     */
    get comments() {
        if (this._comments) {
            return this._comments;
        }
        else {
            return this._comments = new PdfPopupAnnotationCollection(this, false);
        }
    }
    /**
     * Gets the review history of the PDF annotation (Read only).
     *
     * @returns {PdfPopupAnnotationCollection} Annotation review history.
     * ```typescript
     * // Load an existing PDF document
     * let document: PdfDocument = new PdfDocument(data);
     * // Access first page
     * let page: PdfPage = document.getPage(0);
     * // Access the annotation at index 0
     * let annotation: PdfRectangleAnnotation = page.annotations.at(0) as PdfRectangleAnnotation;
     * // Gets the comments of the PDF annotation
     * let comments: PdfPopupAnnotationCollection = annotation.reviewHistory;
     * // Save the document
     * document.save('output.pdf');
     * // Destroy the document
     * document.destroy();
     * ```
     */
    get reviewHistory() {
        if (this._reviewHistory) {
            return this._reviewHistory;
        }
        else {
            return this._reviewHistory = new PdfPopupAnnotationCollection(this, true);
        }
    }
}
/**
 * `PdfLineAnnotation` class represents the line annotation objects.
 * ```typescript
 * // Load an existing PDF document
 * let document: PdfDocument = new PdfDocument(data);
 * // Get the first page
 * let page: PdfPage = document.getPage(0) as PdfPage;
 * // Create a new line annotation with line points
 * const annotation: PdfLineAnnotation = new PdfLineAnnotation([10, 50, 250, 50]);
 * // Add annotation to the page
 * page.annotations.add(annotation);
 * // Destroy the document
 * document.destroy();
 * ```
 */
class PdfLineAnnotation extends PdfComment {
    constructor(linePoints) {
        super();
        this._unit = PdfMeasurementUnit.centimeter;
        this._unitString = '';
        this._dictionary = new _PdfDictionary();
        this._dictionary.update('Type', _PdfName.get('Annot'));
        this._dictionary.update('Subtype', _PdfName.get('Line'));
        if (typeof linePoints !== 'undefined') {
            this.linePoints = linePoints;
        }
        this._type = _PdfAnnotationType.lineAnnotation;
    }
    /**
     * Gets the line points of the line annotation.
     *
     * @returns {number[]} Line points.
     * ```typescript
     * // Load an existing PDF document
     * let document: PdfDocument = new PdfDocument(data, password);
     * // Get the first page
     * let page: PdfPage = document.getPage(0) as PdfPage;
     * // Get the first annotation of the page
     * let annotation: PdfLineAnnotation = page.annotations.at(0) as PdfLineAnnotation;
     * // Gets the line points of the line annotation.
     * let linePoints : number[] = annotation.linePoints;
     * // Destroy the document
     * document.destroy();
     * ```
     */
    get linePoints() {
        if (typeof this._linePoints === 'undefined' && this._dictionary.has('L')) {
            const points = this._dictionary.getArray('L');
            if (points) {
                this._linePoints = points;
            }
        }
        return this._linePoints;
    }
    /**
     * Sets the line points of the line annotation.
     *
     * @param {number[]} value Line points.
     * ```typescript
     * // Load an existing PDF document
     * let document: PdfDocument = new PdfDocument(data, password);
     * // Get the first page
     * let page: PdfPage = document.getPage(0) as PdfPage;
     * // Get the first annotation of the page
     * let annotation: PdfLineAnnotation = page.annotations.at(0) as PdfLineAnnotation;
     * // Sets the line points of the line annotation.
     * annotation.linePoints = [10, 50, 250, 50];
     * // Destroy the document
     * document.destroy();
     * ```
     */
    set linePoints(value) {
        if (Array.isArray(value) && (typeof this._linePoints === 'undefined' || _areNotEqual(value, this._linePoints))) {
            if (value.length === 4) {
                this._dictionary.update('L', value);
                this._linePoints = value;
            }
            else {
                throw new Error('Line points length should be 4.');
            }
        }
    }
    /**
     * Gets the line extension of the line annotation.
     *
     * @returns {number} Leader line extension.
     * ```typescript
     * // Load an existing PDF document
     * let document: PdfDocument = new PdfDocument(data, password);
     * // Get the first page
     * let page: PdfPage = document.getPage(0) as PdfPage;
     * // Get the first annotation of the page
     * let annotation: PdfLineAnnotation = page.annotations.at(0) as PdfLineAnnotation;
     * // Gets the line extension of the line annotation.
     * let leaderExt: number = annotation.leaderExt;
     * // Destroy the document
     * document.destroy();
     * ```
     */
    get leaderExt() {
        if (typeof this._leaderExt === 'undefined' && this._dictionary.has('LLE')) {
            const leaderExt = this._dictionary.get('LLE');
            if (typeof leaderExt !== 'undefined') {
                this._leaderExt = leaderExt;
            }
        }
        return this._leaderExt;
    }
    /**
     * Sets the line extension of the line annotation.
     *
     * @param {number} value Line extension.
     * ```typescript
     * // Load an existing PDF document
     * let document: PdfDocument = new PdfDocument(data, password);
     * // Get the first page
     * let page: PdfPage = document.getPage(0) as PdfPage;
     * // Get the first annotation of the page
     * let annotation: PdfLineAnnotation = page.annotations.at(0) as PdfLineAnnotation;
     * // Sets the line extension of the line annotation.
     * annotation.leaderExt = 4;
     * // Destroy the document
     * document.destroy();
     * ```
     */
    set leaderExt(value) {
        if (!Number.isNaN(value)) {
            this._dictionary.update('LLE', value);
            this._leaderExt = value;
        }
    }
    /**
     * Gets the leader line of the line annotation.
     *
     * @returns {number} Leader line.
     * ```typescript
     * // Load an existing PDF document
     * let document: PdfDocument = new PdfDocument(data, password);
     * // Get the first page
     * let page: PdfPage = document.getPage(0) as PdfPage;
     * // Get the first annotation of the page
     * let annotation: PdfLineAnnotation = page.annotations.at(0) as PdfLineAnnotation;
     * // Gets the leader line of the line annotation.
     * let leaderLine: number = annotation.leaderLine;
     * // Destroy the document
     * document.destroy();
     * ```
     */
    get leaderLine() {
        if (typeof this._leaderLine === 'undefined' && this._dictionary.has('LL')) {
            const leaderLine = this._dictionary.get('LL');
            if (typeof leaderLine !== 'undefined') {
                this._leaderLine = leaderLine;
            }
        }
        return this._leaderLine;
    }
    /**
     * Sets the leader line of the line annotation.
     *
     * @param {number} value Leader line.
     * ```typescript
     * // Load an existing PDF document
     * let document: PdfDocument = new PdfDocument(data, password);
     * // Get the first page
     * let page: PdfPage = document.getPage(0) as PdfPage;
     * // Get the first annotation of the page
     * let annotation: PdfLineAnnotation = page.annotations.at(0) as PdfLineAnnotation;
     * // Sets the leader line of the line annotation.
     * annotation.leaderLine = 5;
     * // Destroy the document
     * document.destroy();
     * ```
     */
    set leaderLine(value) {
        if (!Number.isNaN(value) && this.leaderExt !== 0) {
            this._dictionary.update('LL', value);
            this._leaderLine = value;
        }
    }
    /**
     * Gets the line ending style of the line annotation.
     *
     * @returns {PdfAnnotationLineEndingStyle} Line ending style.
     * ```typescript
     * // Load an existing PDF document
     * let document: PdfDocument = new PdfDocument(data, password);
     * // Get the first page
     * let page: PdfPage = document.getPage(0) as PdfPage;
     * // Get the first annotation of the page
     * let annotation: PdfLineAnnotation = page.annotations.at(0) as PdfLineAnnotation;
     * // Gets the line ending style of the line annotation.
     * let lineEndingStyle: PdfAnnotationLineEndingStyle = annotation.lineEndingStyle;
     * // Destroy the document
     * document.destroy();
     * ```
     */
    get lineEndingStyle() {
        if (typeof this._lineEndingStyle === 'undefined') {
            const value = new PdfAnnotationLineEndingStyle();
            value._dictionary = this._dictionary;
            if (this._dictionary.has('LE')) {
                const lineStyles = this._dictionary.getArray('LE');
                if (lineStyles && Array.isArray(lineStyles)) {
                    value._begin = _mapLineEndingStyle(lineStyles[0].name);
                    value._end = _mapLineEndingStyle(lineStyles[1].name);
                }
            }
            this._lineEndingStyle = value;
        }
        return this._lineEndingStyle;
    }
    /**
     * Sets the line ending style of the line annotation.
     *
     * @param {PdfAnnotationLineEndingStyle} value Line ending style.
     * ```typescript
     * // Load an existing PDF document
     * let document: PdfDocument = new PdfDocument(data, password);
     * // Get the first page
     * let page: PdfPage = document.getPage(0) as PdfPage;
     * // Get the first annotation of the page
     * let annotation: PdfLineAnnotation = page.annotations.at(0) as PdfLineAnnotation;
     * // Sets the line ending style of the line annotation.
     * annotation.lineEndingStyle = new PdfAnnotationLineEndingStyle(PdfLineEndingStyle.openArrow, PdfLineEndingStyle.closeArrow);
     * // Destroy the document
     * document.destroy();
     * ```
     */
    set lineEndingStyle(value) {
        const style = this.lineEndingStyle;
        if (style.begin !== value.begin || style.end !== value.end) {
            style.begin = value.begin;
            style.end = value.end;
        }
    }
    /**
     * Gets the leader offset of the line annotation.
     *
     * @returns {number} Leader offset.
     * ```typescript
     * // Load an existing PDF document
     * let document: PdfDocument = new PdfDocument(data, password);
     * // Get the first page
     * let page: PdfPage = document.getPage(0) as PdfPage;
     * // Get the first annotation of the page
     * let annotation: PdfLineAnnotation = page.annotations.at(0) as PdfLineAnnotation;
     * // Gets the leader offset value of the line annotation
     * let leaderOffset: number = annotation.leaderOffset;
     * // Destroy the document
     * document.destroy();
     * ```
     */
    get leaderOffset() {
        if (typeof this._leaderOffset === 'undefined' && this._dictionary.has('LLO')) {
            const leaderOffset = this._dictionary.get('LLO');
            if (typeof leaderOffset !== 'undefined' && leaderOffset >= 0) {
                this._leaderOffset = leaderOffset;
            }
        }
        return this._leaderOffset;
    }
    /**
     * Sets the leader offset of the line annotation.
     *
     * @param {number} value Leader line offset.
     * ```typescript
     * // Load an existing PDF document
     * let document: PdfDocument = new PdfDocument(data, password);
     * // Get the first page
     * let page: PdfPage = document.getPage(0) as PdfPage;
     * // Get the first annotation of the page
     * let annotation: PdfLineAnnotation = page.annotations.at(0) as PdfLineAnnotation;
     * // Sets the leader offset of the line annotation.
     * annotation.leaderOffset = 1;
     * // Destroy the document
     * document.destroy();
     * ```
     */
    set leaderOffset(value) {
        if (!Number.isNaN(value)) {
            this._dictionary.update('LLO', value);
            this._leaderOffset = value;
        }
    }
    /**
     * Gets the line intent of the line annotation.
     *
     * @returns {PdfLineIntent} Line intent.
     * ```typescript
     * // Load an existing PDF document
     * let document: PdfDocument = new PdfDocument(data, password);
     * // Get the first page
     * let page: PdfPage = document.getPage(0) as PdfPage;
     * // Get the first annotation of the page
     * let annotation: PdfLineAnnotation = page.annotations.at(0) as PdfLineAnnotation;
     * // Gets the line intent value of the line annotation
     * let lineIntent: PdfLineIntent = annotation.lineIntent;
     * // Destroy the document
     * document.destroy();
     * ```
     */
    get lineIntent() {
        if (typeof this._lineIntent === 'undefined' && this._dictionary.has('IT')) {
            const lineIntent = this._dictionary.get('IT');
            if (lineIntent) {
                this._lineIntent = lineIntent.name === 'LineDimension' ? PdfLineIntent.lineDimension : PdfLineIntent.lineArrow;
            }
        }
        return this._lineIntent;
    }
    /**
     * Sets the line intent of the line annotation.
     *
     * @param {PdfLineIntent} value Line intent.
     * ```typescript
     * // Load an existing PDF document
     * let document: PdfDocument = new PdfDocument(data, password);
     * // Get the first page
     * let page: PdfPage = document.getPage(0) as PdfPage;
     * // Get the first annotation of the page
     * let annotation: PdfLineAnnotation = page.annotations.at(0) as PdfLineAnnotation;
     * // Sets the line intent of the line annotation.
     * annotation.lineIntent = PdfLineIntent.lineDimension;
     * // Destroy the document
     * document.destroy();
     * ```
     */
    set lineIntent(value) {
        if (typeof value !== 'undefined' && value !== this.lineIntent) {
            this._lineIntent = value;
            this._dictionary.update('IT', _PdfName.get(value === PdfLineIntent.lineDimension ? 'LineDimension' : 'LineArrow'));
        }
    }
    /**
     * Gets the flag to have measurement dictionary of the line annotation.
     *
     * @returns {boolean} measure.
     * ```typescript
     * // Load an existing PDF document
     * let document: PdfDocument = new PdfDocument(data, password);
     * // Get the first page
     * let page: PdfPage = document.getPage(0) as PdfPage;
     * // Get the first annotation of the page
     * let annotation: PdfLineAnnotation = page.annotations.at(0) as PdfLineAnnotation;
     * // Gets the flag to have measurement dictionary of the line annotation.
     * let measure: boolean = annotation.measure;
     * // Destroy the document
     * document.destroy();
     * ```
     */
    get measure() {
        if (typeof this._measure === 'undefined') {
            this._measure = this._dictionary.has('Measure');
        }
        return this._measure;
    }
    /**
     * Sets the flag to add measurement dictionary to the line annotation.
     *
     * @param {boolean} value Measure.
     * ```typescript
     * // Load an existing PDF document
     * let document: PdfDocument = new PdfDocument(data, password);
     * // Get the first page
     * let page: PdfPage = document.getPage(0) as PdfPage;
     * // Get the first annotation of the page
     * let annotation: PdfLineAnnotation = page.annotations.at(0) as PdfLineAnnotation;
     * // Sets the flag to have measurement dictionary of the line annotation.
     * annotation.measure = true;
     * // Destroy the document
     * document.destroy();
     * ```
     */
    set measure(value) {
        if (value) {
            if (!this._isLoaded) {
                this._measure = value;
                this.caption.cap = true;
            }
        }
    }
    /**
     * Gets the measurement unit of the annotation.
     *
     * @returns {PdfMeasurementUnit} Measurement unit.
     * ```typescript
     * // Load an existing PDF document
     * let document: PdfDocument = new PdfDocument(data, password);
     * // Get the first page
     * let page: PdfPage = document.getPage(0) as PdfPage;
     * // Get the first annotation of the page
     * let annotation: PdfLineAnnotation = page.annotations.at(0) as PdfLineAnnotation;
     * // Gets the measurement unit of the annotation.
     * let unit: PdfMeasurementUnit = annotation.unit;
     * // Destroy the document
     * document.destroy();
     * ```
     */
    get unit() {
        if (typeof this._unit === 'undefined') {
            this._unit = PdfMeasurementUnit.centimeter;
            if (this._dictionary.has('Contents')) {
                const text = this._dictionary.get('Contents');
                this._unitString = text.substring(text.length - 2);
                this._unit = _mapMeasurementUnit(this._unitString);
            }
        }
        return this._unit;
    }
    /**
     * Sets the measurement unit of the line annotation.
     *
     * @param {PdfMeasurementUnit} value Measurement unit.
     * ```typescript
     * // Load an existing PDF document
     * let document: PdfDocument = new PdfDocument(data, password);
     * // Get the first page
     * let page: PdfPage = document.getPage(0) as PdfPage;
     * // Get the first annotation of the page
     * let annotation: PdfLineAnnotation = page.annotations.at(0) as PdfLineAnnotation;
     * // Sets the measurement unit of the annotation.
     * annotation.unit = PdfMeasurementUnit.centimeter;
     * // Destroy the document
     * document.destroy();
     * ```
     */
    set unit(value) {
        if (this._measure) {
            if (!this._isLoaded && typeof value !== 'undefined') {
                this._unit = value;
            }
        }
    }
    static _load(page, dictionary) {
        const annot = new PdfLineAnnotation();
        annot._isLoaded = true;
        annot._initialize(page, dictionary);
        return annot;
    }
    _initialize(page, dictionary) {
        super._initialize(page, dictionary);
    }
    _postProcess(flatten) {
        if (typeof this.linePoints === 'undefined' || this.linePoints === null) {
            throw new Error('Line points cannot be null or undefined');
        }
        if (!this._dictionary.has('Cap')) {
            this._dictionary.set('Cap', false);
        }
        if (!this._dictionary.has('CP')) {
            this._dictionary.set('CP', _PdfName.get('Inline'));
        }
        if (!this._dictionary.has('LE')) {
            this.lineEndingStyle = new PdfAnnotationLineEndingStyle();
        }
        if (!this._dictionary.has('LL')) {
            this.leaderLine = 0;
        }
        if (!this._dictionary.has('LLE')) {
            this.leaderExt = 0;
        }
        if (!this._dictionary.has('C')) {
            this.color = [0, 0, 0];
        }
        let borderWidth;
        if (this._dictionary.has('BS')) {
            borderWidth = this.border.width;
        }
        else {
            const dictionary = new _PdfDictionary(this._crossReference);
            dictionary.set('Type', _PdfName.get('Border'));
            this._dictionary.set('BS', dictionary);
        }
        if (typeof borderWidth === 'undefined') {
            borderWidth = 1;
        }
        if (this._measure) {
            this._appearanceTemplate = this._createLineMeasureAppearance(flatten);
        }
        else {
            if (this._setAppearance) {
                this._appearanceTemplate = this._createAppearance();
            }
            const boundsArray = this._obtainLineBounds();
            const bounds = { x: boundsArray[0],
                y: boundsArray[1], width: boundsArray[2], height: boundsArray[3] };
            this._bounds = bounds;
            const updatedBounds = [this._bounds.x,
                this._bounds.y,
                this._bounds.x + this._bounds.width,
                this._bounds.y + this._bounds.height];
            this._dictionary.update('Rect', updatedBounds);
        }
    }
    _doPostProcess(isFlatten = false) {
        if (this._isLoaded) {
            if (this._setAppearance || (isFlatten && !this._dictionary.has('AP'))) {
                if (this._dictionary.has('Measure')) {
                    this._appearanceTemplate = this._createLineMeasureAppearance(isFlatten);
                }
                else {
                    this._appearanceTemplate = this._createAppearance();
                }
            }
            if (!this._appearanceTemplate && isFlatten && this._dictionary.has('AP')) {
                const dictionary = this._dictionary.get('AP');
                if (dictionary && dictionary.has('N')) {
                    const appearanceStream = dictionary.get('N');
                    if (appearanceStream) {
                        const reference = dictionary.getRaw('N');
                        if (reference) {
                            appearanceStream.reference = reference;
                        }
                        this._appearanceTemplate = new PdfTemplate(appearanceStream, this._crossReference);
                    }
                }
            }
        }
        else {
            this._postProcess(isFlatten);
            if (!this._appearanceTemplate) {
                if (isFlatten) {
                    if (!this._dictionary.has('AP')) {
                        this._appearanceTemplate = this._createAppearance();
                    }
                    else {
                        const dictionary = this._dictionary.get('AP');
                        if (dictionary && dictionary.has('N')) {
                            const appearanceStream = dictionary.get('N');
                            if (appearanceStream) {
                                const reference = dictionary.getRaw('N');
                                if (reference) {
                                    appearanceStream.reference = reference;
                                }
                                this._appearanceTemplate = new PdfTemplate(appearanceStream, this._crossReference);
                            }
                        }
                    }
                }
            }
        }
        if (typeof this.flattenPopups !== 'undefined' && this.flattenPopups && !this.measure) {
            if (this._isLoaded && !this._dictionary.has('Measure')) {
                this._flattenLoadedPopUp();
            }
            else {
                this._flattenPopUp();
            }
        }
        if (isFlatten && this._appearanceTemplate) {
            const isNormalMatrix = this._validateTemplateMatrix(this._appearanceTemplate._content.dictionary);
            this._flattenAnnotationTemplate(this._appearanceTemplate, isNormalMatrix);
        }
        if (!isFlatten && this._setAppearance && !this.measure) {
            let appearance;
            if (this._dictionary.has('AP')) {
                appearance = this._dictionary.get('AP');
            }
            else {
                const reference = this._crossReference._getNextReference();
                appearance = new _PdfDictionary(this._crossReference);
                this._crossReference._cacheMap.set(reference, appearance);
                this._dictionary.update('AP', reference);
            }
            _removeDuplicateReference(appearance, this._crossReference, 'N');
            const reference = this._crossReference._getNextReference();
            this._crossReference._cacheMap.set(reference, this._appearanceTemplate._content);
            appearance.update('N', reference);
        }
    }
    _createLineMeasureAppearance(_isFlatten) {
        let nativeRectangle = [0, 0, 0, 0];
        const area = this._convertToUnit();
        const linePoints1 = this._obtainLinePoints();
        const points = [];
        for (let j = 0; j < linePoints1.length; j = j + 2) {
            points.push([linePoints1[Number.parseInt(j.toString(), 10)], (linePoints1[j + 1])]);
        }
        const graphicsPath = new _PdfPath();
        graphicsPath._points = points;
        graphicsPath._pathTypes = [0, 1];
        const rectPath = graphicsPath._getBounds();
        this._bounds = { x: rectPath[0], y: rectPath[1], width: rectPath[2], height: rectPath[3] };
        const borderPen = new PdfPen(typeof this.color !== 'undefined' ? this._color : [0, 0, 0], this.border.width);
        let backBrush;
        if (this.innerColor) {
            backBrush = new PdfBrush(this._innerColor);
        }
        nativeRectangle = this._obtainLineBounds();
        const template = new PdfTemplate(nativeRectangle, this._crossReference);
        _setMatrix(template, this._getRotationAngle());
        const parameter = new _PaintParameter();
        template._writeTransformation = false;
        const graphics = template.graphics;
        parameter.borderPen = borderPen;
        parameter.backBrush = backBrush;
        parameter.foreBrush = new PdfBrush(this.color);
        const linePoints = this._obtainLinePoints();
        let font = this._obtainFont();
        if ((typeof font === 'undefined' || font === null) || (!this._isLoaded && font.size === 1)) {
            font = this._lineCaptionFont;
            this._pdfFont = font;
        }
        if (typeof linePoints !== 'undefined' && linePoints.length === 4) {
            const format = new PdfStringFormat(PdfTextAlignment.center, PdfVerticalAlignment.middle);
            const fontSize = font.measureString(area.toFixed(2) + ' ' + this._unitString, [0, 0], format, 0, 0);
            const angle = this._getAngle(this._linePoints);
            let leaderLine = 0;
            let lineAngle = 0;
            if (this.leaderLine < 0) {
                leaderLine = -(this.leaderLine);
                lineAngle = angle + 180;
            }
            else {
                leaderLine = this.leaderLine;
                lineAngle = angle;
            }
            const offset = (typeof this.leaderOffset !== 'undefined') ? (leaderLine + this.leaderOffset) : leaderLine;
            const startPoint = this._getAxisValue([this._linePoints[0], this._linePoints[1]], (lineAngle + 90), offset);
            const endPoint = this._getAxisValue([this._linePoints[2], this._linePoints[3]], (lineAngle + 90), offset);
            const lineDistance = (Math.sqrt(Math.pow((endPoint[0] - startPoint[0]), 2) +
                Math.pow((endPoint[1] - startPoint[1]), 2)));
            const centerWidth = lineDistance / 2 - ((fontSize[0] / 2) + this.border.width);
            const first = this._getAxisValue(startPoint, angle, centerWidth);
            const second = this._getAxisValue(endPoint, (angle + 180), centerWidth);
            const start = (this.lineEndingStyle.begin === PdfLineEndingStyle.openArrow ||
                this.lineEndingStyle.begin === PdfLineEndingStyle.closedArrow) ?
                this._getAxisValue(startPoint, angle, this.border.width) :
                startPoint;
            const end = (this.lineEndingStyle.end === PdfLineEndingStyle.openArrow ||
                this.lineEndingStyle.end === PdfLineEndingStyle.closedArrow) ?
                this._getAxisValue(endPoint, angle, -this.border.width) :
                endPoint;
            let state;
            if (this.opacity && this._opacity < 1) {
                state = graphics.save();
                graphics.setTransparency(this._opacity);
            }
            if (this.caption.type === PdfLineCaptionType.top || (!this.caption.cap && this.caption.type === PdfLineCaptionType.inline)) {
                graphics.drawLine(borderPen, start[0], -start[1], end[0], -end[1]);
            }
            else {
                graphics.drawLine(borderPen, start[0], -start[1], first[0], -first[1]);
                graphics.drawLine(borderPen, end[0], -end[1], second[0], -second[1]);
            }
            if (this.opacity && this._opacity < 1) {
                graphics.restore(state);
            }
            this._drawLineStyle(startPoint, endPoint, graphics, angle, borderPen, backBrush, this.lineEndingStyle, this.border.width);
            const leaderExt = (typeof this.leaderExt !== 'undefined' ? this._leaderExt : 0);
            const beginLineExt = this._getAxisValue(startPoint, (lineAngle + 90), leaderExt);
            graphics.drawLine(borderPen, startPoint[0], -startPoint[1], beginLineExt[0], -beginLineExt[1]);
            const endLineExt = this._getAxisValue(endPoint, (lineAngle + 90), leaderExt);
            graphics.drawLine(borderPen, endPoint[0], -endPoint[1], endLineExt[0], -endLineExt[1]);
            const beginLeaderLine = this._getAxisValue(startPoint, (lineAngle - 90), leaderLine);
            graphics.drawLine(borderPen, startPoint[0], -startPoint[1], beginLeaderLine[0], -beginLeaderLine[1]);
            const endLeaderLine = this._getAxisValue(endPoint, (lineAngle - 90), leaderLine);
            graphics.drawLine(borderPen, endPoint[0], -endPoint[1], endLeaderLine[0], -endLeaderLine[1]);
            const midpoint = lineDistance / 2;
            const centerPoint = this._getAxisValue(startPoint, angle, midpoint);
            let captionPosition;
            const height = font._metrics._getHeight();
            if (this.caption.type === PdfLineCaptionType.top) {
                captionPosition = this._getAxisValue(centerPoint, (angle + 90), height);
            }
            else {
                captionPosition = this._getAxisValue(centerPoint, (angle + 90), (height / 2));
            }
            graphics.translateTransform(captionPosition[0], -captionPosition[1]);
            graphics.rotateTransform(-angle);
            graphics.drawString(area.toFixed(2) + ' ' + this._unitString, font, [(-fontSize[0] / 2), 0, 0, 0], null, parameter.foreBrush);
            graphics.restore();
        }
        if ((typeof _isFlatten !== 'undefined' && !_isFlatten) || !this._isLoaded) {
            template._content.dictionary._updated = true;
            const ref = this._crossReference._getNextReference();
            this._crossReference._cacheMap.set(ref, template._content);
            template._content.reference = ref;
            const nativeRectangle1 = [this.bounds.x,
                this.bounds.y + this.bounds.height,
                this.bounds.width,
                this.bounds.height];
            const size = this._page.size;
            nativeRectangle1[1] = size[1] - (this.bounds.y + this.bounds.height);
            if (this._isBounds && !this.measure) {
                nativeRectangle = nativeRectangle1;
                this._dictionary.update('Rect', [nativeRectangle1[0], nativeRectangle1[1], nativeRectangle1[2], nativeRectangle1[3]]);
            }
            else {
                this._dictionary.update('Rect', [nativeRectangle[0], nativeRectangle[1], nativeRectangle[2], nativeRectangle[3]]);
            }
            const ds = 'font:' +
                font._metrics._postScriptName +
                ' ' +
                font._size +
                'pt; color:' +
                this._colorToHex(this.color);
            this._dictionary.update('DS', ds);
            if (typeof _isFlatten !== 'undefined' && !_isFlatten) {
                if (this._dictionary.has('AP')) {
                    _removeDuplicateReference(this._dictionary.get('AP'), this._crossReference, 'N');
                }
                const dic = new _PdfDictionary();
                dic.set('N', ref);
                dic._updated = true;
                this._dictionary.set('AP', dic);
                const measureDictionary = this._createMeasureDictionary(this._unitString);
                const reference = this._crossReference._getNextReference();
                this._crossReference._cacheMap.set(reference, measureDictionary);
                measureDictionary._updated = true;
                if (this._dictionary.has('Measure')) {
                    _removeDuplicateReference(this._dictionary, this._crossReference, 'Measure');
                }
                this._dictionary.update('Measure', reference);
            }
            const lineStyles = [];
            lineStyles.push(_PdfName.get(_reverseMapEndingStyle(this.lineEndingStyle.begin)));
            lineStyles.push(_PdfName.get(_reverseMapEndingStyle(this.lineEndingStyle.end)));
            this._dictionary.update('LE', lineStyles);
            if (this._linePoints !== null) {
                this._dictionary.update('L', this._linePoints);
            }
            else {
                throw new Error('LinePoints cannot be null');
            }
            this._dictionary.update('C', [Number.parseFloat((this.color[0] / 255).toFixed(3)),
                Number.parseFloat((this.color[1] / 255).toFixed(3)),
                Number.parseFloat((this.color[2] / 255).toFixed(3))]);
            const offset = this._dictionary.has('LLO') ? this.leaderOffset : 0;
            this._dictionary.update('Subtype', new _PdfName('Line'));
            if (this._text && this._text !== '') {
                this._dictionary.update('Contents', this._text + ' ' + area.toFixed(2) + ' ' + this._unitString);
            }
            else {
                this._dictionary.update('Contents', area.toFixed(2) + ' ' + this._unitString);
            }
            this._dictionary.update('IT', new _PdfName('LineDimension'));
            this._dictionary.update('LLE', this.leaderExt);
            this._dictionary.update('LLO', offset);
            this._dictionary.update('LL', this.leaderLine);
            this._dictionary.update('CP', _PdfName.get(this.caption.type === PdfLineCaptionType.top ? 'Top' : 'Inline'));
            this._dictionary.update('Cap', this.caption.cap);
            const bounds = [nativeRectangle[0],
                nativeRectangle[1],
                nativeRectangle[0] + nativeRectangle[2],
                nativeRectangle[1] + nativeRectangle[3]];
            this._dictionary.update('Rect', bounds);
            this._bounds = { x: bounds[0], y: bounds[1], width: bounds[2], height: bounds[3] };
        }
        return template;
    }
    _calculateAngle(startPointX, startPointY, endPointX, endPointY) {
        return -(Math.atan2((endPointY - startPointY), (endPointX - startPointX)) * (180 / Math.PI));
    }
    _calculateLineBounds(linePoints, leaderLineExt, leaderLine, leaderOffset, lineStyle, borderWidth) {
        let bounds = { x: 0, y: 0, width: 0, height: 0 };
        if (linePoints && linePoints.length === 4) {
            const angle = this._getAngle(linePoints);
            let leaderLines = 0;
            let lineAngle = 0;
            if (leaderLine < 0) {
                leaderLines = -(leaderLine);
                lineAngle = angle + 180;
            }
            else {
                leaderLines = leaderLine;
                lineAngle = angle;
            }
            const x1y1 = [linePoints[0], linePoints[1]];
            const x2y2 = [linePoints[2], linePoints[3]];
            if (leaderOffset !== 0) {
                const offsetPoint1 = this._getAxisValue(x1y1, (lineAngle + 90), leaderOffset);
                const offsetPoint2 = this._getAxisValue(x2y2, (lineAngle + 90), leaderOffset);
                linePoints[0] = offsetPoint1[0];
                linePoints[1] = offsetPoint1[1];
                linePoints[2] = offsetPoint2[0];
                linePoints[3] = offsetPoint2[1];
            }
            const startingPoint = this._getAxisValue(x1y1, (lineAngle + 90), leaderLines + leaderOffset);
            const endingPoint = this._getAxisValue(x2y2, (lineAngle + 90), leaderLines + leaderOffset);
            const beginLineLeader = this._getAxisValue(x1y1, (lineAngle + 90), leaderLineExt + leaderLines + leaderOffset);
            const endLineLeader = this._getAxisValue(x2y2, (lineAngle + 90), leaderLineExt + leaderLines + leaderOffset);
            const beginLinePoint = this._getLinePoint(lineStyle.begin, borderWidth);
            const endLinePoint = this._getLinePoint(lineStyle.end, borderWidth);
            const widthX = [];
            const heightY = [];
            if ((lineAngle >= 45 && lineAngle <= 135) || (lineAngle >= 225 && lineAngle <= 315)) {
                widthX[0] = beginLinePoint.y;
                heightY[0] = beginLinePoint.x;
                widthX[1] = endLinePoint.y;
                heightY[1] = endLinePoint.x;
            }
            else {
                widthX[0] = beginLinePoint.x;
                heightY[0] = beginLinePoint.y;
                widthX[1] = endLinePoint.x;
                heightY[1] = endLinePoint.y;
            }
            let width = Math.max(widthX[0], widthX[1]);
            let height = Math.max(heightY[0], heightY[1]);
            if (width === 0) {
                width = 1;
            }
            if (height === 0) {
                height = 1;
            }
            if (startingPoint[0] === Math.min(startingPoint[0], endingPoint[0])) {
                startingPoint[0] -= width * borderWidth;
                endingPoint[0] += width * borderWidth;
                startingPoint[0] = Math.min(startingPoint[0], linePoints[0]);
                startingPoint[0] = Math.min(startingPoint[0], beginLineLeader[0]);
                endingPoint[0] = Math.max(endingPoint[0], linePoints[2]);
                endingPoint[0] = Math.max(endingPoint[0], endLineLeader[0]);
            }
            else {
                startingPoint[0] += width * borderWidth;
                endingPoint[0] -= width * borderWidth;
                startingPoint[0] = Math.max(startingPoint[0], linePoints[0]);
                startingPoint[0] = Math.max(startingPoint[0], beginLineLeader[0]);
                endingPoint[0] = Math.min(endingPoint[0], linePoints[2]);
                endingPoint[0] = Math.min(endingPoint[0], endLineLeader[0]);
            }
            if (startingPoint[1] === Math.min(startingPoint[1], endingPoint[1])) {
                startingPoint[1] -= height * borderWidth;
                endingPoint[1] += height * borderWidth;
                startingPoint[1] = Math.min(startingPoint[1], linePoints[1]);
                startingPoint[1] = Math.min(startingPoint[1], beginLineLeader[1]);
                endingPoint[1] = Math.max(endingPoint[1], linePoints[3]);
                endingPoint[1] = Math.max(endingPoint[1], endLineLeader[1]);
            }
            else {
                startingPoint[1] += height * borderWidth;
                endingPoint[1] -= height * borderWidth;
                startingPoint[1] = Math.max(startingPoint[1], linePoints[1]);
                startingPoint[1] = Math.max(startingPoint[1], beginLineLeader[1]);
                endingPoint[1] = Math.min(endingPoint[1], linePoints[3]);
                endingPoint[1] = Math.min(endingPoint[1], endLineLeader[1]);
            }
            bounds = this._getBounds([{ x: startingPoint[0], y: startingPoint[1] }, { x: endingPoint[0], y: endingPoint[1] }]);
        }
        return bounds;
    }
    _getLinePoint(style, borderWidth) {
        const point = { x: 0, y: 0 };
        if (style) {
            switch (style) {
                case PdfLineEndingStyle.square:
                case PdfLineEndingStyle.circle:
                case PdfLineEndingStyle.diamond:
                    point.x = 3;
                    point.y = 3;
                    break;
                case PdfLineEndingStyle.openArrow:
                case PdfLineEndingStyle.closedArrow:
                    point.x = 1;
                    point.y = 5;
                    break;
                case PdfLineEndingStyle.rOpenArrow:
                case PdfLineEndingStyle.rClosedArrow:
                    point.x = 9 + (borderWidth / 2);
                    point.y = 5 + (borderWidth / 2);
                    break;
                case PdfLineEndingStyle.slash:
                    point.x = 5;
                    point.y = 9;
                    break;
                case PdfLineEndingStyle.butt:
                    point.x = 1;
                    point.y = 3;
                    break;
                default:
                    point.x = 0;
                    point.y = 0;
                    break;
            }
        }
        return point;
    }
    _getBounds(points) {
        const bounds = { x: 0, y: 0, width: 0, height: 0 };
        if (points.length > 0) {
            let xmin = points[0].x;
            let xmax = points[0].x;
            let ymin = points[0].y;
            let ymax = points[0].y;
            for (let i = 1; i < points.length; ++i) {
                const point = points[Number.parseInt(i.toString(), 10)];
                xmin = Math.min(point.x, xmin);
                xmax = Math.max(point.x, xmax);
                ymin = Math.min(point.y, ymin);
                ymax = Math.max(point.y, ymax);
            }
            bounds.x = xmin;
            bounds.y = ymin;
            bounds.width = xmax - xmin;
            bounds.height = ymax - ymin;
        }
        return bounds;
    }
    _obtainLineBounds() {
        let bounds = this.bounds;
        if (typeof this.linePoints !== 'undefined' && this._linePoints.length === 4) {
            const leaderOffset = this._dictionary.has('LLO') ? this.leaderOffset : 0;
            const leaderExt = this._dictionary.has('LLE') ? this.leaderExt : 0;
            const leaderLine = this._dictionary.has('LL') ? this.leaderLine : 0;
            bounds = this._calculateLineBounds(this._linePoints, leaderExt, leaderLine, leaderOffset, this.lineEndingStyle, this.border.width);
            bounds = { x: bounds.x - 8, y: bounds.y - 8, width: (bounds.width + 2 * 8), height: (bounds.height + 2 * 8) };
        }
        return [bounds.x, bounds.y, bounds.width, bounds.height];
    }
    _createAppearance() {
        const template = new PdfTemplate(this._obtainLineBounds(), this._crossReference);
        const parameter = new _PaintParameter();
        _setMatrix(template, this._getRotationAngle());
        template._writeTransformation = false;
        const graphics = template.graphics;
        const pen = new PdfPen(typeof this.color !== 'undefined' ? this._color : [0, 0, 0], this.border.width);
        if (this.border.style === PdfBorderStyle.dashed) {
            pen._dashStyle = PdfDashStyle.dash;
        }
        else if (this.border.style === PdfBorderStyle.dot) {
            pen._dashStyle = PdfDashStyle.dot;
        }
        parameter.borderPen = pen;
        parameter.foreBrush = new PdfBrush(this.color);
        const brush = new PdfBrush(typeof this.innerColor !== 'undefined' ? this._innerColor : [0, 0, 0]);
        let font = this._obtainFont();
        if ((typeof font === 'undefined' || font === null) || (!this._isLoaded && font.size === 1)) {
            font = this._lineCaptionFont;
            this._pdfFont = font;
        }
        if (!this.text && !this._dictionary.has('Contents')) {
            this.text = this.subject;
        }
        const format = new PdfStringFormat(PdfTextAlignment.center, PdfVerticalAlignment.middle);
        const lineWidth = font.measureString(this.text ? this.text : '', [0, 0], format, 0, 0)[0]; //66.71001;
        if (typeof this.linePoints !== 'undefined' && this._linePoints.length === 4) {
            const angle = this._getAngle(this._linePoints);
            let leaderLine = 0;
            let lineAngle = 0;
            if (this.leaderLine < 0) {
                leaderLine = -(this.leaderLine);
                lineAngle = angle + 180;
            }
            else {
                leaderLine = this.leaderLine;
                lineAngle = angle;
            }
            const offset = (typeof this.leaderOffset !== 'undefined') ? (leaderLine + this.leaderOffset) : leaderLine;
            const startPoint = this._getAxisValue([this._linePoints[0], this._linePoints[1]], (lineAngle + 90), offset);
            const endPoint = this._getAxisValue([this._linePoints[2], this._linePoints[3]], (lineAngle + 90), offset);
            const lineDistance = (Math.sqrt(Math.pow((endPoint[0] - startPoint[0]), 2) +
                Math.pow((endPoint[1] - startPoint[1]), 2)));
            const centerWidth = lineDistance / 2 - ((lineWidth / 2) + this.border.width);
            const first = this._getAxisValue(startPoint, angle, centerWidth);
            const second = this._getAxisValue(endPoint, (angle + 180), centerWidth);
            const start = (this.lineEndingStyle.begin === PdfLineEndingStyle.openArrow ||
                this.lineEndingStyle.begin === PdfLineEndingStyle.closedArrow) ?
                this._getAxisValue(startPoint, angle, this.border.width) :
                startPoint;
            const end = (this.lineEndingStyle.end === PdfLineEndingStyle.openArrow ||
                this.lineEndingStyle.end === PdfLineEndingStyle.closedArrow) ?
                this._getAxisValue(endPoint, angle, -this.border.width) :
                endPoint;
            if (this.opacity && this._opacity < 1) {
                const state = graphics.save();
                graphics.setTransparency(this._opacity);
                this._drawLine(graphics, pen, start, end, first, second);
                graphics.restore(state);
            }
            else {
                this._drawLine(graphics, pen, start, end, first, second);
            }
            this._drawLineStyle(startPoint, endPoint, graphics, angle, pen, brush, this.lineEndingStyle, this.border.width);
            const leaderExt = (typeof this.leaderExt !== 'undefined' ? this._leaderExt : 0);
            const beginLineExt = this._getAxisValue(startPoint, (lineAngle + 90), leaderExt);
            graphics.drawLine(pen, startPoint[0], -startPoint[1], beginLineExt[0], -beginLineExt[1]);
            const endLineExt = this._getAxisValue(endPoint, (lineAngle + 90), leaderExt);
            graphics.drawLine(pen, endPoint[0], -endPoint[1], endLineExt[0], -endLineExt[1]);
            const beginLeaderLine = this._getAxisValue(startPoint, (lineAngle - 90), leaderLine);
            graphics.drawLine(pen, startPoint[0], -startPoint[1], beginLeaderLine[0], -beginLeaderLine[1]);
            const endLeaderLine = this._getAxisValue(endPoint, (lineAngle - 90), leaderLine);
            graphics.drawLine(pen, endPoint[0], -endPoint[1], endLeaderLine[0], -endLeaderLine[1]);
            const midpoint = lineDistance / 2;
            const centerPoint = this._getAxisValue(startPoint, angle, midpoint);
            let captionPosition;
            const height = font._metrics._getHeight();
            if (this.caption.type === PdfLineCaptionType.top) {
                if (this._dictionary.has('Measure')) {
                    captionPosition = this._getAxisValue(centerPoint, (angle + 90), 2 * height);
                }
                else {
                    captionPosition = this._getAxisValue(centerPoint, (angle + 90), height);
                }
            }
            else {
                if (this._dictionary.has('Measure')) {
                    captionPosition = this._getAxisValue(centerPoint, (angle + 90), 3 * (height / 2));
                }
                else {
                    captionPosition = this._getAxisValue(centerPoint, (angle + 90), (height / 2));
                }
            }
            graphics.translateTransform(captionPosition[0], -captionPosition[1]);
            graphics.rotateTransform(-angle);
            if (this.caption.cap) {
                graphics.drawString(this.text, font, [(-lineWidth / 2), 0, 0, 0], null, parameter.foreBrush);
            }
            graphics.restore();
            const bounds = this._obtainLineBounds();
            const rectangleBounds = _fromRectangle({ x: bounds[0], y: bounds[1], width: bounds[2], height: bounds[3] });
            this.bounds = { x: rectangleBounds[0], y: rectangleBounds[1], width: rectangleBounds[2], height: rectangleBounds[3] };
        }
        return template;
    }
    _drawLine(graphics, pen, start, end, first, second) {
        if (typeof this.text === 'undefined' ||
            this._text === '' ||
            this.caption.type === PdfLineCaptionType.top ||
            (!this.caption.cap && this.caption.type === PdfLineCaptionType.inline)) {
            graphics.drawLine(pen, start[0], -start[1], end[0], -end[1]);
        }
        else {
            graphics.drawLine(pen, start[0], -start[1], first[0], -first[1]);
            graphics.drawLine(pen, end[0], -end[1], second[0], -second[1]);
        }
    }
    _convertToUnit() {
        const points = this._obtainLinePoints();
        const data = new Array(points.length / 2);
        let count = 0;
        for (let j = 0; j < points.length; j = j + 2) {
            data[Number.parseInt(count.toString(), 10)] = [points[Number.parseInt(j.toString(), 10)], (points[j + 1])];
            count++;
        }
        const distance = Math.sqrt(Math.pow((data[1][0] - data[0][0]), 2) + Math.pow((data[1][1] - data[0][1]), 2));
        const value = this._getEqualPdfGraphicsUnit(this._unit, this._unitString);
        this._unitString = value.unitString;
        return (new _PdfUnitConvertor())._convertUnits(distance, _PdfGraphicsUnit.point, value.graphicsUnit);
    }
    _obtainLinePoints() {
        const points = [];
        if (this.linePoints) {
            for (let i = 0; i < this._linePoints.length; i++) {
                points[Number.parseInt(i.toString(), 10)] = this._linePoints[Number.parseInt(i.toString(), 10)];
            }
        }
        return points;
    }
}
/**
 * `PdfCircleAnnotation` class represents the circle annotation objects.
 * ```typescript
 * // Load an existing PDF document
 * let document: PdfDocument = new PdfDocument(data, password);
 * // Get the first page
 * let page: PdfPage = document.getPage(0) as PdfPage;
 * // Create a new circle annotation with circle bounds
 * const annotation: PdfCircleAnnotation = new PdfCircleAnnotation(10, 10, 100, 100);
 * // Add annotation to the page
 * page.annotations.add(annotation);
 * // Destroy the document
 * document.destroy();
 * ```
 */
class PdfCircleAnnotation extends PdfComment {
    constructor(x, y, width, height) {
        super();
        this._unit = PdfMeasurementUnit.centimeter;
        this._measureType = PdfCircleMeasurementType.diameter;
        this._unitString = '';
        this._dictionary = new _PdfDictionary();
        this._dictionary.update('Type', _PdfName.get('Annot'));
        this._dictionary.update('Subtype', _PdfName.get('Circle'));
        if (typeof x !== 'undefined' && typeof y !== 'undefined' && typeof width !== 'undefined' && typeof height !== 'undefined') {
            this.bounds = { x, y, width, height };
        }
        this._type = _PdfAnnotationType.circleAnnotation;
    }
    /**
     * Gets the flag to have measurement dictionary of the circle annotation.
     *
     * @returns {boolean} measure.
     * ```typescript
     * // Load an existing PDF document
     * let document: PdfDocument = new PdfDocument(data, password);
     * // Get the first page
     * let page: PdfPage = document.getPage(0) as PdfPage;
     * // Get the first annotation of the page
     * let annotation: PdfCircleAnnotation = page.annotations.at(0) as PdfCircleAnnotation;
     * // Gets the flag to have measurement dictionary of the circle annotation.
     * let measure: boolean = annotation.measure;
     * // Destroy the document
     * document.destroy();
     * ```
     */
    get measure() {
        if (typeof this._measure === 'undefined' && this._dictionary.has('Measure')) {
            this._measure = this._dictionary.get('Measure');
        }
        return this._measure;
    }
    /**
     * Sets the flag to add measurement dictionary to the annotation.
     *
     * @param {boolean} value Measure.
     * ```typescript
     * // Load an existing PDF document
     * let document: PdfDocument = new PdfDocument(data, password);
     * // Get the first page
     * let page: PdfPage = document.getPage(0) as PdfPage;
     * // Get the first annotation of the page
     * let annotation: PdfCircleAnnotation = page.annotations.at(0) as PdfCircleAnnotation;
     * // Sets the flag to have measurement dictionary of the circle annotation.
     * annotation.measure = true;
     * // Destroy the document
     * document.destroy();
     * ```
     */
    set measure(value) {
        if (value) {
            if (!this._isLoaded) {
                this._measure = value;
            }
        }
    }
    /**
     * Gets the measurement unit of the annotation.
     *
     * @returns {PdfMeasurementUnit} Measurement unit.
     * ```typescript
     * // Load an existing PDF document
     * let document: PdfDocument = new PdfDocument(data, password);
     * // Get the first page
     * let page: PdfPage = document.getPage(0) as PdfPage;
     * // Get the first annotation of the page
     * let annotation: PdfCircleAnnotation = page.annotations.at(0) as PdfCircleAnnotation;
     * // Gets the measurement unit of the annotation.
     * let unit: PdfMeasurementUnit = annotation.unit;
     * // Destroy the document
     * document.destroy();
     * ```
     */
    get unit() {
        if (typeof this._unit === 'undefined') {
            this._unit = PdfMeasurementUnit.centimeter;
            if (this._dictionary.has('Contents')) {
                const text = this._dictionary.get('Contents');
                this._unitString = text.substring(text.length - 2);
                this._unit = _mapMeasurementUnit(this._unitString);
            }
        }
        return this._unit;
    }
    /**
     * Sets the measurement unit of the annotation.
     *
     * @param {PdfMeasurementUnit} value Measurement unit.
     * ```typescript
     * // Load an existing PDF document
     * let document: PdfDocument = new PdfDocument(data, password);
     * // Get the first page
     * let page: PdfPage = document.getPage(0) as PdfPage;
     * // Get the first annotation of the page
     * let annotation: PdfCircleAnnotation = page.annotations.at(0) as PdfCircleAnnotation;
     * // Sets the measurement unit of the annotation.
     * annotation.unit = PdfMeasurementUnit.centimeter;
     * // Destroy the document
     * document.destroy();
     * ```
     */
    set unit(value) {
        if (this._measure) {
            if (!this._isLoaded && typeof value !== 'undefined') {
                this._unit = value;
            }
        }
    }
    /**
     * Gets the measurement type of the annotation.
     *
     * @returns {PdfCircleMeasurementType} Measurement type.
     * ```typescript
     * // Load an existing PDF document
     * let document: PdfDocument = new PdfDocument(data, password);
     * // Get the first page
     * let page: PdfPage = document.getPage(0) as PdfPage;
     * // Get the first annotation of the page
     * let annotation: PdfCircleAnnotation = page.annotations.at(0) as PdfCircleAnnotation;
     * // Gets the measurement type of the annotation.
     * let type: PdfCircleMeasurementType = annotation.type;
     * // Destroy the document
     * document.destroy();
     * ```
     */
    get measureType() {
        if (this._dictionary.has('Contents')) {
            const text = this._dictionary.get('Contents');
            this._unitString = text.substring(text.length - 2);
            this._unit = _mapMeasurementUnit(this._unitString);
            const value = text.substring(0, text.length - 2);
            const converter = new _PdfUnitConvertor();
            const radius = converter._convertUnits(this.bounds.width / 2, _PdfGraphicsUnit.point, _mapGraphicsUnit(this._unitString));
            if (radius.toString() === value) {
                this._measureType = PdfCircleMeasurementType.radius;
            }
            else {
                this._measureType = PdfCircleMeasurementType.diameter;
            }
        }
        return this._measureType;
    }
    /**
     * Sets the measurement type of the annotation.
     *
     * @param {PdfCircleMeasurementType} value Measurement type.
     * ```typescript
     * // Load an existing PDF document
     * let document: PdfDocument = new PdfDocument(data, password);
     * // Get the first page
     * let page: PdfPage = document.getPage(0) as PdfPage;
     * // Get the first annotation of the page
     * let annotation: PdfCircleAnnotation = page.annotations.at(0) as PdfCircleAnnotation;
     * // Sets the measurement type of the annotation.
     * annotation.type = PdfCircleMeasurementType.diameter;
     * // Destroy the document
     * document.destroy();
     * ```
     */
    set measureType(value) {
        if (this._measure) {
            if (!this._isLoaded && typeof value !== 'undefined') {
                this._measureType = value;
            }
        }
    }
    static _load(page, dictionary) {
        const annot = new PdfCircleAnnotation();
        annot._isLoaded = true;
        annot._initialize(page, dictionary);
        return annot;
    }
    _initialize(page, dictionary) {
        super._initialize(page, dictionary);
    }
    _postProcess(isFlatten) {
        if (typeof this.bounds === 'undefined' || this.bounds === null) {
            throw new Error('Bounds cannot be null or undefined');
        }
        let borderWidth;
        if (this._dictionary.has('BS')) {
            borderWidth = this.border.width;
        }
        else {
            const dictionary = new _PdfDictionary(this._crossReference);
            dictionary.set('Type', _PdfName.get('Border'));
            this._dictionary.set('BS', dictionary);
        }
        if (!this._dictionary.has('C')) {
            this.color = [0, 0, 0];
        }
        if (typeof borderWidth === 'undefined') {
            borderWidth = 1;
        }
        if (this._measure) {
            this._appearanceTemplate = this._createCircleMeasureAppearance(isFlatten);
        }
        else {
            if (this._setAppearance || (isFlatten && !this._dictionary.has('AP'))) {
                this._appearanceTemplate = this._createCircleAppearance();
            }
            const size = this._page.size;
            const rect = [this.bounds.x,
                size[1] - (this.bounds.y + this.bounds.height),
                this.bounds.width,
                this.bounds.height];
            this._dictionary.update('Rect', [rect[0], rect[1], rect[0] + rect[2], rect[1] + rect[3]]);
        }
    }
    _doPostProcess(isFlatten = false) {
        if (this._isLoaded) {
            if (this._setAppearance || (isFlatten && !this._dictionary.has('AP'))) {
                if (this._dictionary.has('Measure')) {
                    this._appearanceTemplate = this._createCircleMeasureAppearance(isFlatten);
                }
                else {
                    this._appearanceTemplate = this._createCircleAppearance();
                }
            }
            if (!this._appearanceTemplate && isFlatten && this._dictionary.has('AP')) {
                const dictionary = this._dictionary.get('AP');
                if (dictionary && dictionary.has('N')) {
                    const appearanceStream = dictionary.get('N');
                    const reference = dictionary.getRaw('N');
                    if (appearanceStream) {
                        if (reference) {
                            appearanceStream.reference = reference;
                        }
                        this._appearanceTemplate = new PdfTemplate(appearanceStream, this._crossReference);
                    }
                }
            }
        }
        else {
            this._postProcess(isFlatten);
            if (!this._appearanceTemplate && isFlatten) {
                if (!this._dictionary.has('AP')) {
                    this._appearanceTemplate = this._createCircleAppearance();
                }
                else {
                    const dictionary = this._dictionary.get('AP');
                    if (dictionary && dictionary.has('N')) {
                        const appearanceStream = dictionary.get('N');
                        const reference = dictionary.getRaw('N');
                        if (appearanceStream) {
                            if (reference) {
                                appearanceStream.reference = reference;
                            }
                            this._appearanceTemplate = new PdfTemplate(appearanceStream, this._crossReference);
                        }
                    }
                }
            }
        }
        if (typeof this.flattenPopups !== 'undefined' && this.flattenPopups && !this.measure) {
            if (this._isLoaded && !this._dictionary.has('Measure')) {
                this._flattenLoadedPopUp();
            }
            else {
                this._flattenPopUp();
            }
        }
        if (isFlatten && this._appearanceTemplate) {
            const isNormalMatrix = this._validateTemplateMatrix(this._appearanceTemplate._content.dictionary);
            this._flattenAnnotationTemplate(this._appearanceTemplate, isNormalMatrix);
        }
        if (!isFlatten && this._setAppearance && !this.measure) {
            let appearance;
            if (this._dictionary.has('AP')) {
                appearance = this._dictionary.get('AP');
            }
            else {
                const reference = this._crossReference._getNextReference();
                appearance = new _PdfDictionary(this._crossReference);
                this._crossReference._cacheMap.set(reference, appearance);
                this._dictionary.update('AP', reference);
            }
            _removeDuplicateReference(appearance, this._crossReference, 'N');
            const reference = this._crossReference._getNextReference();
            this._crossReference._cacheMap.set(reference, this._appearanceTemplate._content);
            appearance.update('N', reference);
        }
    }
    _createCircleMeasureAppearance(_isFlatten) {
        const borderWidth = this.border.width;
        let font = this._obtainFont();
        if ((typeof font === 'undefined' || font === null) || (!this._isLoaded && font.size === 1)) {
            font = this._circleCaptionFont;
            this._pdfFont = font;
        }
        const area = this._convertToUnit();
        const format = new PdfStringFormat(PdfTextAlignment.center, PdfVerticalAlignment.middle);
        const str = area.toFixed(2) + ' ' + this._unitString;
        const fontsize = font.measureString(str, [0, 0], format, 0, 0);
        const borderPen = new PdfPen(this.color, borderWidth);
        let nativeRectangle = [this.bounds.x,
            (this.bounds.y + this.bounds.height),
            this.bounds.width,
            this.bounds.height];
        nativeRectangle[1] = nativeRectangle[1] - nativeRectangle[3];
        const template = new PdfTemplate(nativeRectangle, this._crossReference);
        const parameter = new _PaintParameter();
        template._writeTransformation = false;
        const graphics = template.graphics;
        const width = borderWidth / 2;
        parameter.borderPen = borderPen;
        if (this.innerColor) {
            parameter.backBrush = new PdfBrush(this._innerColor);
        }
        parameter.foreBrush = new PdfBrush(this.color);
        const rect = [nativeRectangle[0],
            -nativeRectangle[1] - nativeRectangle[3],
            nativeRectangle[2],
            nativeRectangle[3]];
        graphics.save();
        graphics.drawEllipse(rect[0] + width, rect[1] + width, rect[2] - borderWidth, rect[3] - borderWidth, new PdfPen(this.color, this.border.width));
        if (this._measureType === PdfCircleMeasurementType.diameter) {
            graphics.save();
            graphics.translateTransform(nativeRectangle[0], -nativeRectangle[1]);
            const x = (nativeRectangle[3] / 2) - (fontsize[0] / 2);
            graphics.drawLine(parameter.borderPen, 0, -nativeRectangle[3] / 2, nativeRectangle[0] + nativeRectangle[2], -nativeRectangle[3] / 2);
            graphics.translateTransform(x, -(nativeRectangle[3] / 2) - font._metrics._getHeight());
            graphics.drawString(area.toFixed(2) + ' ' + this._unitString, font, [0, 0, 0, 0], null, parameter.foreBrush);
            graphics.restore();
        }
        else {
            graphics.save();
            graphics.translateTransform(nativeRectangle[0], -nativeRectangle[1]);
            const x = (nativeRectangle[2] / 2) + ((nativeRectangle[2] / 4) - (fontsize[0] / 2));
            graphics.drawLine(parameter.borderPen, nativeRectangle[2] / 2, -nativeRectangle[3] / 2, nativeRectangle[0] + nativeRectangle[2], -nativeRectangle[3] / 2);
            graphics.translateTransform(x, -(nativeRectangle[3] / 2) - font._metrics._getHeight());
            graphics.drawString(area.toFixed(2) + ' ' + this._unitString, font, [0, 0, 0, 0], null, parameter.foreBrush);
            graphics.restore();
        }
        graphics.restore();
        if ((typeof _isFlatten !== 'undefined' && !_isFlatten) || !this._isLoaded) {
            if (this._dictionary.has('AP')) {
                _removeDuplicateReference(this._dictionary.get('AP'), this._crossReference, 'N');
            }
            const dic = new _PdfDictionary();
            graphics._template._content.dictionary._updated = true;
            const ref = this._crossReference._getNextReference();
            this._crossReference._cacheMap.set(ref, graphics._template._content);
            graphics._template._content.reference = ref;
            dic.set('N', ref);
            dic._updated = true;
            this._dictionary.set('AP', dic);
            const size = this._page.size;
            const rect1 = [this.bounds.x,
                size[1] - (this.bounds.y + this.bounds.height),
                this.bounds.width,
                this.bounds.height];
            if (this._isBounds) {
                nativeRectangle = rect1;
            }
            this._dictionary.update('Rect', [rect1[0], rect1[1], rect1[0] + rect1[2], rect1[1] + rect1[3]]);
            if (this._dictionary.has('Measure')) {
                _removeDuplicateReference(this._dictionary, this._crossReference, 'Measure');
            }
            const measureDictionary = this._createMeasureDictionary(this._unitString);
            const reference = this._crossReference._getNextReference();
            this._crossReference._cacheMap.set(reference, measureDictionary);
            measureDictionary._updated = true;
            this._dictionary.update('Measure', reference);
            this._dictionary.update('Subtype', new _PdfName('Circle'));
            if (this._text && this._text !== '') {
                this._dictionary.update('Contents', this._text + ' ' + area.toFixed(2) + ' ' + this._unitString);
            }
            else {
                this._dictionary.update('Contents', area.toFixed(2) + ' ' + this._unitString);
            }
            const ds = 'font:' +
                font._metrics._postScriptName +
                ' ' +
                font._size +
                'pt; color:' +
                this._colorToHex(this.color);
            this._dictionary.update('DS', ds);
        }
        return template;
    }
    _convertToUnit() {
        const converter = new _PdfUnitConvertor();
        const value = this._getEqualPdfGraphicsUnit(this._unit, this._unitString);
        this._unitString = value.unitString;
        let radius = converter._convertUnits(this.bounds.width / 2, _PdfGraphicsUnit.point, value.graphicsUnit);
        if (this._measureType === PdfCircleMeasurementType.diameter) {
            radius = 2 * radius;
        }
        return radius;
    }
}
/**
 * `PdfEllipseAnnotation` class represents the ellipse annotation objects.
 * ```typescript
 * // Load an existing PDF document
 * let document: PdfDocument = new PdfDocument(data, password);
 * // Get the first page
 * let page: PdfPage = document.getPage(0) as PdfPage;
 * // Create a new ellipse annotation with bounds
 * const annotation: PdfEllipseAnnotation = new PdfEllipseAnnotation(10, 10, 100, 100);
 * // Add annotation to the page
 * page.annotations.add(annotation);
 * // Destroy the document
 * document.destroy();
 * ```
 */
class PdfEllipseAnnotation extends PdfComment {
    constructor(x, y, width, height) {
        super();
        this._dictionary = new _PdfDictionary();
        this._dictionary.update('Type', _PdfName.get('Annot'));
        this._dictionary.update('Subtype', _PdfName.get('Circle'));
        if (typeof x !== 'undefined' && typeof y !== 'undefined' && typeof width !== 'undefined' && typeof height !== 'undefined') {
            this.bounds = { x, y, width, height };
        }
        this._type = _PdfAnnotationType.ellipseAnnotation;
    }
    static _load(page, dictionary) {
        const annot = new PdfEllipseAnnotation();
        annot._isLoaded = true;
        annot._initialize(page, dictionary);
        return annot;
    }
    _initialize(page, dictionary) {
        super._initialize(page, dictionary);
    }
    _postProcess(isFlatten) {
        if (typeof this.bounds === 'undefined' || this.bounds === null) {
            throw new Error('Bounds cannot be null or undefined');
        }
        let borderWidth;
        if (this._dictionary.has('BS')) {
            borderWidth = this.border.width;
        }
        else {
            const dictionary = new _PdfDictionary(this._crossReference);
            dictionary.set('Type', _PdfName.get('Border'));
            this._dictionary.set('BS', dictionary);
        }
        if (!this._dictionary.has('C')) {
            this.color = [0, 0, 0];
        }
        if (typeof borderWidth === 'undefined') {
            borderWidth = 1;
        }
        if (this._setAppearance || (isFlatten && !this._dictionary.has('AP'))) {
            this._appearanceTemplate = this._createCircleAppearance();
        }
        const size = this._page.size;
        const rect = [this.bounds.x,
            size[1] - (this.bounds.y + this.bounds.height),
            this.bounds.width,
            this.bounds.height];
        this._dictionary.update('Rect', [rect[0], rect[1], rect[0] + rect[2], rect[1] + rect[3]]);
    }
    _doPostProcess(isFlatten = false) {
        if (this._isLoaded) {
            if (this._setAppearance || (isFlatten && !this._dictionary.has('AP'))) {
                this._appearanceTemplate = this._createCircleAppearance();
            }
            if (!this._appearanceTemplate && isFlatten && this._dictionary.has('AP')) {
                const dictionary = this._dictionary.get('AP');
                if (dictionary && dictionary.has('N')) {
                    const appearanceStream = dictionary.get('N');
                    const reference = dictionary.getRaw('N');
                    if (appearanceStream) {
                        if (reference) {
                            appearanceStream.reference = reference;
                        }
                        this._appearanceTemplate = new PdfTemplate(appearanceStream, this._crossReference);
                    }
                }
            }
        }
        else {
            this._postProcess(isFlatten);
            if (!this._appearanceTemplate && isFlatten) {
                if (!this._dictionary.has('AP')) {
                    this._appearanceTemplate = this._createCircleAppearance();
                }
                else {
                    const dictionary = this._dictionary.get('AP');
                    if (dictionary && dictionary.has('N')) {
                        const appearanceStream = dictionary.get('N');
                        const reference = dictionary.getRaw('N');
                        if (appearanceStream) {
                            if (reference) {
                                appearanceStream.reference = reference;
                            }
                            this._appearanceTemplate = new PdfTemplate(appearanceStream, this._crossReference);
                        }
                    }
                }
            }
        }
        if (typeof this.flattenPopups !== 'undefined' && this.flattenPopups) {
            if (this._isLoaded) {
                this._flattenLoadedPopUp();
            }
            else {
                this._flattenPopUp();
            }
        }
        if (isFlatten && this._appearanceTemplate) {
            const isNormalMatrix = this._validateTemplateMatrix(this._appearanceTemplate._content.dictionary);
            this._flattenAnnotationTemplate(this._appearanceTemplate, isNormalMatrix);
        }
        if (!isFlatten && this._setAppearance) {
            let appearance;
            if (this._dictionary.has('AP')) {
                appearance = this._dictionary.get('AP');
            }
            else {
                const reference = this._crossReference._getNextReference();
                appearance = new _PdfDictionary(this._crossReference);
                this._crossReference._cacheMap.set(reference, appearance);
                this._dictionary.update('AP', reference);
            }
            _removeDuplicateReference(appearance, this._crossReference, 'N');
            const reference = this._crossReference._getNextReference();
            this._crossReference._cacheMap.set(reference, this._appearanceTemplate._content);
            appearance.update('N', reference);
        }
    }
}
/**
 * `PdfSquareAnnotation` class represents the square annotation objects.
 * ```typescript
 * // Load an existing PDF document
 * let document: PdfDocument = new PdfDocument(data, password);
 * // Get the first page
 * let page: PdfPage = document.getPage(0) as PdfPage;
 * // Create a new square annotation with bounds
 * const annotation: PdfSquareAnnotation = new PdfSquareAnnotation(10, 10, 100, 100);
 * // Add annotation to the page
 * page.annotations.add(annotation);
 * // Destroy the document
 * document.destroy();
 * ```
 */
class PdfSquareAnnotation extends PdfComment {
    constructor(x, y, width, height) {
        super();
        this._unit = PdfMeasurementUnit.centimeter;
        this._dictionary = new _PdfDictionary();
        this._dictionary.update('Type', _PdfName.get('Annot'));
        this._dictionary.update('Subtype', _PdfName.get('Square'));
        if (typeof x !== 'undefined' && typeof y !== 'undefined' && typeof width !== 'undefined' && typeof height !== 'undefined') {
            this.bounds = { x, y, width, height };
        }
        this._type = _PdfAnnotationType.squareAnnotation;
    }
    /**
     * Gets the border effect of the square annotation.
     *
     * @returns {PdfBorderEffect} Border effect.
     * ```typescript
     * // Load an existing PDF document
     * let document: PdfDocument = new PdfDocument(data);
     * // Get the first page
     * let page: PdfPage = document.getPage(0) as PdfPage;
     * // Get the first annotation of the page
     * let annotation: PdfSquareAnnotation = page.annotations.at(0) as PdfSquareAnnotation;
     * // Gets the border effect of the square annotation.
     * let borderEffect : PdfBorderEffect = annotation.borderEffect;
     * // Destroy the document
     * document.destroy();
     * ```
     */
    get borderEffect() {
        if (typeof this._borderEffect === 'undefined') {
            const value = new PdfBorderEffect();
            value._dictionary = this._dictionary;
            if (this._dictionary.has('BE')) {
                const dictionary = this._dictionary.get('BE');
                value._intensity = dictionary.get('I');
                value._style = _mapBorderEffectStyle(dictionary.get('S').name);
            }
            this._borderEffect = value;
        }
        return this._borderEffect;
    }
    /**
     * Sets the border effect of the square annotation.
     *
     * @param {PdfBorderEffect} value Border effect.
     * ```typescript
     * // Load an existing PDF document
     * let document: PdfDocument = new PdfDocument(data);
     * // Get the first page
     * let page: PdfPage = document.getPage(0) as PdfPage;
     * // Get the first annotation of the page
     * let annotation: PdfSquareAnnotation = page.annotations.at(0) as PdfSquareAnnotation;
     * // Sets the border effect of the square annotation.
     * annotation.borderEffect.intensity = 1;
     * // Save the document
     * document.save('output.pdf');
     * // Destroy the document
     * document.destroy();
     * ```
     */
    set borderEffect(value) {
        if (typeof value !== 'undefined') {
            this._borderEffect = value;
        }
    }
    /**
     * Gets the flag to have measurement dictionary of the Square annotation.
     *
     * @returns {boolean} measure.
     * ```typescript
     * // Load an existing PDF document
     * let document: PdfDocument = new PdfDocument(data, password);
     * // Get the first page
     * let page: PdfPage = document.getPage(0) as PdfPage;
     * // Get the first annotation of the page
     * let annotation: PdfSquareAnnotation = page.annotations.at(0) as PdfSquareAnnotation;
     * // Gets the flag to have measurement dictionary of the square annotation.
     * let measure: boolean = annotation.measure;
     * // Destroy the document
     * document.destroy();
     * ```
     */
    get measure() {
        if (typeof this._measure === 'undefined' && this._dictionary.has('Measure')) {
            this._measure = this._dictionary.get('Measure');
        }
        return this._measure;
    }
    /**
     * Sets the flag to add measurement dictionary to the annotation.
     *
     * @param {boolean} value Measure.
     * ```typescript
     * // Load an existing PDF document
     * let document: PdfDocument = new PdfDocument(data, password);
     * // Get the first page
     * let page: PdfPage = document.getPage(0) as PdfPage;
     * // Get the first annotation of the page
     * let annotation: PdfSquareAnnotation = page.annotations.at(0) as PdfSquareAnnotation;
     * // Sets the flag to have measurement dictionary of the square annotation.
     * annotation.measure = true;
     * // Destroy the document
     * document.destroy();
     * ```
     */
    set measure(value) {
        if (typeof value !== 'undefined') {
            if (!this._isLoaded) {
                this._measure = value;
            }
        }
    }
    /**
     * Gets the measurement unit of the annotation.
     *
     * @returns {PdfMeasurementUnit} Measurement unit.
     * ```typescript
     * // Load an existing PDF document
     * let document: PdfDocument = new PdfDocument(data, password);
     * // Get the first page
     * let page: PdfPage = document.getPage(0) as PdfPage;
     * // Get the first annotation of the page
     * let annotation: PdfSquareAnnotation = page.annotations.at(0) as PdfSquareAnnotation;
     * // Gets the measurement unit of the annotation.
     * let unit: PdfMeasurementUnit = annotation.unit;
     * // Destroy the document
     * document.destroy();
     * ```
     */
    get unit() {
        if (typeof this._unit === 'undefined') {
            this._unit = PdfMeasurementUnit.centimeter;
            if (this._dictionary.has('Contents')) {
                const text = this._dictionary.get('Contents');
                this._unitString = text.substring(text.length - 2);
                this._unit = _mapMeasurementUnit(this._unitString);
            }
        }
        return this._unit;
    }
    /**
     * Sets the measurement unit of the annotation.
     *
     * @param {PdfMeasurementUnit} value Measurement unit.
     * ```typescript
     * // Load an existing PDF document
     * let document: PdfDocument = new PdfDocument(data, password);
     * // Get the first page
     * let page: PdfPage = document.getPage(0) as PdfPage;
     * // Get the first annotation of the page
     * let annotation: PdfSquareAnnotation = page.annotations.at(0) as PdfSquareAnnotation;
     * // Sets the measurement unit of the annotation.
     * annotation.unit = PdfMeasurementUnit.centimeter;
     * // Destroy the document
     * document.destroy();
     * ```
     */
    set unit(value) {
        if (this._measure) {
            if (!this._isLoaded && typeof value !== 'undefined') {
                this._unit = value;
            }
        }
    }
    static _load(page, dictionary) {
        const annot = new PdfSquareAnnotation();
        annot._isLoaded = true;
        annot._initialize(page, dictionary);
        return annot;
    }
    _initialize(page, dictionary) {
        super._initialize(page, dictionary);
    }
    _postProcess(isFlatten) {
        if (typeof this.bounds === 'undefined' || this.bounds === null) {
            throw new Error('Bounds cannot be null or undefined');
        }
        let borderWidth;
        if (this._dictionary.has('BS')) {
            borderWidth = this.border.width;
        }
        else {
            const dictionary = new _PdfDictionary(this._crossReference);
            dictionary.set('Type', _PdfName.get('Border'));
            this._dictionary.set('BS', dictionary);
        }
        if (!this._dictionary.has('C')) {
            this.color = [0, 0, 0];
        }
        if (typeof borderWidth === 'undefined') {
            borderWidth = 1;
        }
        if (this._measure) {
            this._appearanceTemplate = this._createSquareMeasureAppearance(isFlatten);
        }
        else {
            if (this._setAppearance || (isFlatten && !this._dictionary.has('AP'))) {
                this._appearanceTemplate = this._createRectangleAppearance(this.borderEffect);
            }
            const size = this._page.size;
            const rect = [this.bounds.x,
                size[1] - (this.bounds.y + this.bounds.height),
                this.bounds.width,
                this.bounds.height];
            this._dictionary.update('Rect', [rect[0], rect[1], rect[0] + rect[2], rect[1] + rect[3]]);
            if (typeof this._intensity === 'undefined' &&
                typeof this._borderEffect !== 'undefined' &&
                this._borderEffect.style === PdfBorderEffectStyle.cloudy) {
                const dictionary = new _PdfDictionary(this._crossReference);
                dictionary.set('I', this.borderEffect._intensity);
                if (this.borderEffect._style === PdfBorderEffectStyle.cloudy) {
                    dictionary.set('S', _PdfName.get('C'));
                }
                this._dictionary.update('BE', dictionary);
            }
        }
    }
    _doPostProcess(isFlatten = false) {
        if (this._isLoaded) {
            if (this._setAppearance || (isFlatten && !this._dictionary.has('AP'))) {
                if (this._dictionary.has('Measure')) {
                    this._appearanceTemplate = this._createSquareMeasureAppearance(isFlatten);
                }
                else {
                    this._appearanceTemplate = this._createRectangleAppearance(this.borderEffect);
                }
            }
            if (!this._appearanceTemplate && isFlatten && this._dictionary.has('AP')) {
                const dictionary = this._dictionary.get('AP');
                if (dictionary && dictionary.has('N')) {
                    const appearanceStream = dictionary.get('N');
                    const reference = dictionary.getRaw('N');
                    if (appearanceStream) {
                        if (reference) {
                            appearanceStream.reference = reference;
                        }
                        this._appearanceTemplate = new PdfTemplate(appearanceStream, this._crossReference);
                    }
                }
            }
        }
        else {
            this._postProcess(isFlatten);
            if (!this._appearanceTemplate && isFlatten) {
                if (!this._dictionary.has('AP')) {
                    this._appearanceTemplate = this._createRectangleAppearance(this.borderEffect);
                }
                else {
                    const dictionary = this._dictionary.get('AP');
                    if (dictionary && dictionary.has('N')) {
                        const appearanceStream = dictionary.get('N');
                        const reference = dictionary.getRaw('N');
                        if (appearanceStream) {
                            if (reference) {
                                appearanceStream.reference = reference;
                            }
                            this._appearanceTemplate = new PdfTemplate(appearanceStream, this._crossReference);
                        }
                    }
                }
            }
        }
        if (typeof this.flattenPopups !== 'undefined' && this.flattenPopups && !this.measure) {
            if (this._isLoaded && !this._dictionary.has('Measure')) {
                this._flattenLoadedPopUp();
            }
            else {
                this._flattenPopUp();
            }
        }
        if (isFlatten && this._appearanceTemplate) {
            const isNormalMatrix = this._validateTemplateMatrix(this._appearanceTemplate._content.dictionary);
            this._flattenAnnotationTemplate(this._appearanceTemplate, isNormalMatrix);
        }
        if (!isFlatten && this._setAppearance && !this.measure) {
            let appearance;
            if (this._dictionary.has('AP')) {
                appearance = this._dictionary.get('AP');
            }
            else {
                const reference = this._crossReference._getNextReference();
                appearance = new _PdfDictionary(this._crossReference);
                this._crossReference._cacheMap.set(reference, appearance);
                this._dictionary.update('AP', reference);
            }
            _removeDuplicateReference(appearance, this._crossReference, 'N');
            const reference = this._crossReference._getNextReference();
            this._crossReference._cacheMap.set(reference, this._appearanceTemplate._content);
            appearance.update('N', reference);
        }
    }
    _createSquareMeasureAppearance(_isFlatten) {
        const borderWidth = this.border.width;
        let font = this._obtainFont();
        if ((typeof font === 'undefined' || font === null) || (!this._isLoaded && font.size === 1)) {
            font = this._circleCaptionFont;
            this._pdfFont = font;
        }
        const area = this._calculateAreaOfSquare();
        const format = new PdfStringFormat(PdfTextAlignment.center, PdfVerticalAlignment.middle);
        const str = area.toFixed(2) + ' sq ' + this._unitString;
        const fontsize = font.measureString(str, [0, 0], format, 0, 0);
        const borderPen = new PdfPen(this.color, borderWidth);
        let backBrush;
        if (this.innerColor) {
            backBrush = new PdfBrush(this._innerColor);
        }
        let nativeRectangle = [this.bounds.x,
            (this.bounds.y + this.bounds.height),
            this.bounds.width,
            this.bounds.height];
        const appearanceBounds = [this.bounds.x, this.bounds.y, this.bounds.width, this.bounds.height];
        const appearance = new PdfAppearance(this, appearanceBounds);
        nativeRectangle[1] = nativeRectangle[1] - nativeRectangle[3];
        appearance.normal = new PdfTemplate(nativeRectangle, this._crossReference);
        const template = appearance.normal;
        const parameter = new _PaintParameter();
        template._writeTransformation = false;
        const graphics = appearance.normal.graphics;
        const width = borderWidth / 2;
        parameter.borderPen = borderPen;
        parameter.backBrush = backBrush;
        parameter.foreBrush = new PdfBrush(this.color);
        const rect = [nativeRectangle[0],
            -nativeRectangle[1] - nativeRectangle[3],
            nativeRectangle[2],
            nativeRectangle[3]];
        graphics.drawRectangle(rect[0] + width, rect[1] + width, rect[2] - borderWidth, rect[3] - borderWidth, new PdfPen(this.color, this.border.width));
        graphics.save();
        graphics.translateTransform(nativeRectangle[0], -nativeRectangle[1]);
        const x = (nativeRectangle[2] / 2) - (fontsize[0] / 2);
        const y = (nativeRectangle[3] / 2) - (fontsize[1] / 2);
        graphics.translateTransform(x, -y - font._metrics._getHeight());
        graphics.drawString((area.toFixed(2) + ' sq ' + this._unitString), font, [0, 0, 0, 0], null, parameter.foreBrush);
        graphics.restore();
        if ((typeof _isFlatten !== 'undefined' && !_isFlatten) || !this._isLoaded) {
            if (this._dictionary.has('AP')) {
                _removeDuplicateReference(this._dictionary.get('AP'), this._crossReference, 'N');
            }
            const dic = new _PdfDictionary();
            const tem = graphics._template._content;
            tem.dictionary._updated = true;
            const ref = this._crossReference._getNextReference();
            this._crossReference._cacheMap.set(ref, tem);
            graphics._template._content.reference = ref;
            dic.set('N', ref);
            dic._updated = true;
            this._dictionary.set('AP', dic);
            const nativeRectangle1 = [this.bounds.x, this.bounds.y, this.bounds.width, this.bounds.height];
            const size = this._page.size;
            nativeRectangle1[1] = size[1] - (this.bounds.y + this.bounds.height);
            nativeRectangle1[2] = (this.bounds.x + this.bounds.width);
            nativeRectangle1[3] = size[1] - this.bounds.y;
            if (this._isBounds) {
                nativeRectangle = nativeRectangle1;
            }
            this._dictionary.update('Rect', [nativeRectangle1[0], nativeRectangle1[1], nativeRectangle1[2], nativeRectangle1[3]]);
            if (this._dictionary.has('Measure')) {
                _removeDuplicateReference(this._dictionary, this._crossReference, 'Measure');
            }
            const reference = this._crossReference._getNextReference();
            const measureDictionary = this._createMeasureDictionary(this._unitString);
            this._crossReference._cacheMap.set(reference, measureDictionary);
            measureDictionary._updated = true;
            this._dictionary.update('Measure', reference);
            const ds = 'font:' +
                font._metrics._postScriptName +
                ' ' +
                font._size +
                'pt; color:' +
                this._colorToHex(this.color);
            this._dictionary.update('DS', ds);
            if (this._text && this._text !== '') {
                this._dictionary.update('Contents', this._text + ' ' + area.toFixed(2) + ' sq ' + this._unitString);
            }
            else {
                this._dictionary.update('Contents', area.toFixed(2) + ' sq ' + this._unitString);
            }
            this._dictionary.update('Subject', ('Area Measurement'));
            if (typeof this.subject === 'undefined') {
                this._dictionary.update('Subject', ('Area Measurement'));
            }
            this._dictionary.update('MeasurementTypes', 129);
            this._dictionary.update('Subtype', new _PdfName('Square'));
            this._dictionary.update('IT', new _PdfName('SquareDimension'));
            const elements = this._dictionary.getArray('Rect');
            const vertices = new Array(elements.length * 2);
            vertices[0] = elements[0];
            vertices[1] = elements[3];
            vertices[2] = elements[0];
            vertices[3] = elements[1];
            vertices[4] = elements[2];
            vertices[5] = elements[1];
            vertices[6] = elements[2];
            vertices[7] = elements[3];
            this._dictionary.update('Vertices', vertices);
        }
        return template;
    }
    _calculateAreaOfSquare() {
        let area;
        const converter = new _PdfUnitConvertor();
        let value;
        if (this.bounds.width === this.bounds.height) {
            value = this._getEqualPdfGraphicsUnit(this._unit, this._unitString);
            this._unitString = value.unitString;
            const width = converter._convertUnits(this.bounds.width, _PdfGraphicsUnit.point, value.graphicsUnit);
            area = width * width;
        }
        else {
            value = this._getEqualPdfGraphicsUnit(this._unit, this._unitString);
            this._unitString = value.unitString;
            const width = converter._convertUnits(this.bounds.width, _PdfGraphicsUnit.point, value.graphicsUnit);
            value = this._getEqualPdfGraphicsUnit(this._unit, this._unitString);
            this._unitString = value.unitString;
            const height = converter._convertUnits(this.bounds.height, _PdfGraphicsUnit.point, value.graphicsUnit);
            area = width * height;
        }
        return area;
    }
}
/**
 * `PdfRectangleAnnotation` class represents the rectangle annotation objects.
 * ```typescript
 * // Load an existing PDF document
 * let document: PdfDocument = new PdfDocument(data, password);
 * // Get the first page
 * let page: PdfPage = document.getPage(0) as PdfPage;
 * // Create a new square annotation with bounds
 * const annotation: PdfRectangleAnnotation = new PdfRectangleAnnotation(10, 10, 200, 100);
 * // Add annotation to the page
 * page.annotations.add(annotation);
 * // Destroy the document
 * document.destroy();
 * ```
 */
class PdfRectangleAnnotation extends PdfComment {
    constructor(x, y, width, height) {
        super();
        this._dictionary = new _PdfDictionary();
        this._dictionary.update('Type', _PdfName.get('Annot'));
        this._dictionary.update('Subtype', _PdfName.get('Square'));
        if (typeof x !== 'undefined' && typeof y !== 'undefined' && typeof width !== 'undefined' && typeof height !== 'undefined') {
            this.bounds = { x, y, width, height };
        }
        this._type = _PdfAnnotationType.rectangleAnnotation;
    }
    /**
     * Gets the border effect of the rectangle annotation.
     *
     * @returns {PdfBorderEffect} Border effect.
     * ```typescript
     * // Load an existing PDF document
     * let document: PdfDocument = new PdfDocument(data, password);
     * // Get the first page
     * let page: PdfPage = document.getPage(0) as PdfPage;
     * // Get the first annotation of the page
     * let annotation: PdfRectangleAnnotation = page.annotations.at(0) as PdfRectangleAnnotation;
     * // Gets the border effect of the rectangle annotation.
     * let borderEffect: PdfBorderEffect = annotation.borderEffect;
     * // Destroy the document
     * document.destroy();
     * ```
     */
    get borderEffect() {
        if (typeof this._borderEffect === 'undefined') {
            const value = new PdfBorderEffect();
            value._dictionary = this._dictionary;
            if (this._dictionary.has('BE')) {
                const dictionary = this._dictionary.get('BE');
                value._intensity = dictionary.get('I');
                value._style = _mapBorderEffectStyle(dictionary.get('S').name);
            }
            this._borderEffect = value;
        }
        return this._borderEffect;
    }
    /**
     * Sets the border effect of the rectangle annotation.
     *
     * @param {PdfBorderEffect} value Border effect.
     * ```typescript
     * // Load an existing PDF document
     * let document: PdfDocument = new PdfDocument(data, password);
     * // Get the first page
     * let page: PdfPage = document.getPage(0) as PdfPage;
     * // Get the first annotation of the page
     * let annotation: PdfRectangleAnnotation = page.annotations.at(0) as PdfRectangleAnnotation;
     * // Sets the border effect of rectangle annotation.
     * annotation. borderEffect.style = PdfBorderEffectStyle.cloudy;
     * // Save the document
     * document.save('output.pdf');
     * // Destroy the document
     * document.destroy();
     * ```
     */
    set borderEffect(value) {
        if (typeof value !== 'undefined') {
            this._borderEffect = value;
        }
    }
    static _load(page, dictionary) {
        const annot = new PdfRectangleAnnotation();
        annot._isLoaded = true;
        annot._initialize(page, dictionary);
        return annot;
    }
    _initialize(page, dictionary) {
        super._initialize(page, dictionary);
    }
    _postProcess(isFlatten) {
        if (typeof this.bounds === 'undefined' || this.bounds === null) {
            throw new Error('Bounds cannot be null or undefined');
        }
        let borderWidth;
        if (this._dictionary.has('BS')) {
            borderWidth = this.border.width;
        }
        else {
            const dic = new _PdfDictionary(this._crossReference);
            dic.set('Type', _PdfName.get('Border'));
            this._dictionary.set('BS', dic);
        }
        if (!this._dictionary.has('C')) {
            this.color = [0, 0, 0];
        }
        if (typeof borderWidth === 'undefined') {
            borderWidth = 1;
        }
        if (this._setAppearance || (isFlatten && !this._dictionary.has('AP'))) {
            this._appearanceTemplate = this._createRectangleAppearance(this.borderEffect);
        }
        const size = this._page.size;
        const rect = [this.bounds.x,
            size[1] - (this.bounds.y + this.bounds.height),
            this.bounds.width,
            this.bounds.height];
        this._dictionary.update('Rect', [rect[0], rect[1], rect[0] + rect[2], rect[1] + rect[3]]);
        if (typeof this._intensity === 'undefined' &&
            typeof this._borderEffect !== 'undefined' &&
            this._borderEffect.style === PdfBorderEffectStyle.cloudy) {
            const dic = new _PdfDictionary(this._crossReference);
            dic.set('I', this.borderEffect._intensity);
            if (this.borderEffect._style === PdfBorderEffectStyle.cloudy) {
                dic.set('S', _PdfName.get('C'));
            }
            this._dictionary.update('BE', dic);
        }
    }
    _doPostProcess(isFlatten = false) {
        if (this._isLoaded) {
            if (this._setAppearance || (isFlatten && !this._dictionary.has('AP'))) {
                this._appearanceTemplate = this._createRectangleAppearance(this.borderEffect);
            }
            if (!this._appearanceTemplate && isFlatten && this._dictionary.has('AP')) {
                const dictionary = this._dictionary.get('AP');
                if (dictionary && dictionary.has('N')) {
                    const appearanceStream = dictionary.get('N');
                    const reference = dictionary.getRaw('N');
                    if (appearanceStream) {
                        if (reference) {
                            appearanceStream.reference = reference;
                        }
                        this._appearanceTemplate = new PdfTemplate(appearanceStream, this._crossReference);
                    }
                }
            }
        }
        else {
            this._postProcess(isFlatten);
            if (!this._appearanceTemplate && isFlatten) {
                if (!this._dictionary.has('AP')) {
                    this._appearanceTemplate = this._createRectangleAppearance(this.borderEffect);
                }
                else {
                    const dictionary = this._dictionary.get('AP');
                    if (dictionary && dictionary.has('N')) {
                        const appearanceStream = dictionary.get('N');
                        const reference = dictionary.getRaw('N');
                        if (appearanceStream) {
                            if (reference) {
                                appearanceStream.reference = reference;
                            }
                            this._appearanceTemplate = new PdfTemplate(appearanceStream, this._crossReference);
                        }
                    }
                }
            }
        }
        if (typeof this.flattenPopups !== 'undefined' && this.flattenPopups) {
            if (this._isLoaded) {
                this._flattenLoadedPopUp();
            }
            else {
                this._flattenPopUp();
            }
        }
        if (isFlatten && this._appearanceTemplate) {
            const isNormalMatrix = this._validateTemplateMatrix(this._appearanceTemplate._content.dictionary);
            if (isNormalMatrix && this._page.rotation !== PdfRotationAngle.angle0 ||
                this._isValidTemplateMatrix(this._appearanceTemplate._content.dictionary, this.bounds, this._appearanceTemplate)) {
                this._flattenAnnotationTemplate(this._appearanceTemplate, isNormalMatrix);
            }
        }
        if (!isFlatten && this._setAppearance) {
            let appearance;
            if (this._dictionary.has('AP')) {
                appearance = this._dictionary.get('AP');
            }
            else {
                const reference = this._crossReference._getNextReference();
                appearance = new _PdfDictionary(this._crossReference);
                this._crossReference._cacheMap.set(reference, appearance);
                this._dictionary.update('AP', reference);
            }
            _removeDuplicateReference(appearance, this._crossReference, 'N');
            const reference = this._crossReference._getNextReference();
            this._crossReference._cacheMap.set(reference, this._appearanceTemplate._content);
            appearance.update('N', reference);
        }
    }
    _isValidTemplateMatrix(dictionary, bounds, appearanceTemplate) {
        let isValidMatrix = true;
        const pointF = bounds;
        if (dictionary && dictionary.has('Matrix')) {
            const box = dictionary.getArray('BBox');
            const matrix = dictionary.getArray('Matrix');
            if (matrix && box && matrix.length > 3 && box.length > 2) {
                if (typeof matrix[0] !== 'undefined' &&
                    typeof matrix[1] !== 'undefined' &&
                    typeof matrix[2] !== 'undefined' &&
                    typeof matrix[3] !== 'undefined') {
                    if (matrix[0] === 1 && matrix[1] === 0 && matrix[2] === 0 && matrix[3] === 1) {
                        if (typeof box[0] !== 'undefined' &&
                            typeof box[1] !== 'undefined' &&
                            typeof box[2] !== 'undefined' &&
                            typeof box[3] !== 'undefined') {
                            if (Math.round(box[0]) !== Math.round(-(matrix[4])) && Math.round(box[1]) !== Math.round(-(matrix[5])) ||
                                box[0] === 0 && Math.round(-(matrix[4])) === 0) {
                                const graphics = this._page.graphics;
                                const state = graphics.save();
                                if (typeof this.opacity !== 'undefined' && this._opacity < 1) {
                                    graphics.setTransparency(this._opacity);
                                }
                                pointF.x -= box[0];
                                pointF.y += box[1];
                                graphics._drawTemplate(appearanceTemplate, pointF);
                                graphics.restore(state);
                                this._removeAnnotationFromPage(this._page, this);
                                isValidMatrix = false;
                            }
                        }
                    }
                }
            }
        }
        return isValidMatrix;
    }
}
/**
 * `PdfPolygonAnnotation` class represents the polygon annotation objects.
 * ```typescript
 * // Load an existing PDF document
 * let document: PdfDocument = new PdfDocument(data, password);
 * // Get the first page
 * let page: PdfPage = document.getPage(0) as PdfPage;
 * // Create a new polygon annotation with bounds
 * const annotation: PdfPolygonAnnotation = new PdfPolygonAnnotation([100, 300, 150, 200, 300, 200, 350, 300, 300, 400, 150, 400]);
 * // Add annotation to the page
 * page.annotations.add(annotation);
 * // Destroy the document
 * document.destroy();
 * ```
 */
class PdfPolygonAnnotation extends PdfComment {
    constructor(points) {
        super();
        this._dictionary = new _PdfDictionary();
        this._dictionary.update('Type', _PdfName.get('Annot'));
        this._dictionary.update('Subtype', _PdfName.get('Polygon'));
        if (typeof points !== 'undefined') {
            this._points = points;
        }
        this._type = _PdfAnnotationType.polygonAnnotation;
    }
    /**
     * Gets the border effect of the polygon annotation.
     *
     * @returns {PdfBorderEffect} Border effect.
     * ```typescript
     * // Load an existing PDF document
     * let document: PdfDocument = new PdfDocument(data, password);
     * // Get the first page
     * let page: PdfPage = document.getPage(0) as PdfPage;
     * // Get the first annotation of the page
     * let annotation: PdfPolygonAnnotation = page.annotations.at(0) as PdfPolygonAnnotation;
     * // Gets the border effect of the polygon annotation.
     * let borderEffect: PdfBorderEffect = annotation.borderEffect;
     * // Destroy the document
     * document.destroy();
     * ```
     */
    get borderEffect() {
        if (typeof this._borderEffect === 'undefined') {
            const value = new PdfBorderEffect();
            value._dictionary = this._dictionary;
            if (this._dictionary.has('BE')) {
                const dictionary = this._dictionary.get('BE');
                value._intensity = dictionary.get('I');
                value._style = _mapBorderEffectStyle(dictionary.get('S').name);
            }
            this._borderEffect = value;
        }
        return this._borderEffect;
    }
    /**
     * Sets the border effect of the polygon annotation.
     *
     * @param {PdfBorderEffect} value Border effect.
     * ```typescript
     * // Load an existing PDF document
     * let document: PdfDocument = new PdfDocument(data, password);
     * // Get the first page
     * let page: PdfPage = document.getPage(0) as PdfPage;
     * // Get the first annotation of the page
     * let annotation: PdfPolygonAnnotation = page.annotations.at(0) as PdfPolygonAnnotation;
     * // Sets the border effect of the polygon annotation
     * annotation.borderEffect.style = PdfBorderEffectStyle.cloudy ;
     * // Save the document
     * document.save('output.pdf');
     * // Destroy the document
     * document.destroy();
     * ```
     */
    set borderEffect(value) {
        if (typeof value !== 'undefined') {
            this._borderEffect = value;
        }
    }
    /**
     * Gets the line extension of the polygon annotation.
     *
     * @returns {number} Line extension.
     *  ```typescript
     * // Load an existing PDF document
     * let document: PdfDocument = new PdfDocument(data, password);
     * // Get the first page
     * let page: PdfPage = document.getPage(0) as PdfPage;
     * // Get the first annotation of the page
     * let annotation: PdfPolygonAnnotation = page.annotations.at(0) as PdfPolygonAnnotation;
     * // Gets the line extension of the polygon annotation
     * let lineExtension: number = annotation.lineExtension;
     * // Destroy the document
     * document.destroy();
     * ```
     */
    get lineExtension() {
        if (typeof this._lineExtension === 'undefined' && this._dictionary.has('LLE')) {
            const lineExt = this._dictionary.get('LLE');
            if (typeof lineExt !== 'undefined' && lineExt >= 0) {
                this._lineExtension = lineExt;
            }
        }
        return this._lineExtension;
    }
    /**
     * Sets the line extension of the polygon annotation.
     *
     * @param {number} value Line extension.
     * ```typescript
     * // Load an existing PDF document
     * let document: PdfDocument = new PdfDocument(data, password);
     * // Get the first page
     * let page: PdfPage = document.getPage(0) as PdfPage;
     * // Get the first annotation of the page
     * let annotation: PdfPolygonAnnotation = page.annotations.at(0) as PdfPolygonAnnotation;
     * // Sets the line extension of the polygon annotation
     * annotation.lineExtension = 5;
     * // Save the document
     * document.save('output.pdf');
     * // Destroy the document
     * document.destroy();
     * ```
     */
    set lineExtension(value) {
        if (!Number.isNaN(value)) {
            if (value >= 0) {
                this._dictionary.update('LLE', value);
                this._lineExtension = value;
            }
            else {
                throw new Error('LineExtension should be non negative number');
            }
        }
    }
    //Implementation
    static _load(page, dictionary) {
        const annot = new PdfPolygonAnnotation();
        annot._isLoaded = true;
        annot._initialize(page, dictionary);
        return annot;
    }
    _initialize(page, dictionary) {
        super._initialize(page, dictionary);
    }
    _postProcess(isFlatten) {
        if (typeof this._points === 'undefined' || this._points === null) {
            throw new Error('Points cannot be null or undefined');
        }
        if (!this._dictionary.has('LLE')) {
            this.lineExtension = 0;
        }
        if (!this._dictionary.has('C')) {
            this.color = [0, 0, 0];
        }
        let borderWidth;
        if (this._dictionary.has('BS')) {
            borderWidth = this.border.width;
        }
        else {
            const dic = new _PdfDictionary(this._crossReference);
            dic.set('Type', _PdfName.get('Border'));
            this._dictionary.set('BS', dic);
        }
        if (typeof borderWidth === 'undefined') {
            borderWidth = 1;
        }
        const array = [];
        for (let i = 0; i < this._points.length; i++) {
            const value = this._points[Number.parseInt(i.toString(), 10)];
            array.push(value);
        }
        if (array[0] !== array[array.length - 2] || array[1] !== array[array.length - 1]) {
            array[array.length] = this._points[0];
            array[array.length] = this._points[1];
        }
        this._points = array;
        const polygonBounds = this._getBoundsValue(this._points);
        const bounds = [polygonBounds.x,
            polygonBounds.y,
            polygonBounds.x + polygonBounds.width,
            polygonBounds.y + polygonBounds.height];
        this._dictionary.update('Rect', bounds);
        this._dictionary.update('LLE', this._lineExtension);
        if (this._setAppearance || (isFlatten && !this._dictionary.has('AP'))) {
            this._appearanceTemplate = this._createPolygonAppearance(isFlatten);
        }
        this._dictionary.update('Vertices', this._points);
        if (typeof this._intensity === 'undefined' &&
            typeof this._borderEffect !== 'undefined' &&
            this._borderEffect.style === PdfBorderEffectStyle.cloudy) {
            const dic = new _PdfDictionary(this._crossReference);
            dic.set('I', this.borderEffect._intensity);
            if (this.borderEffect._style === PdfBorderEffectStyle.cloudy) {
                dic.set('S', _PdfName.get('C'));
            }
            this._dictionary.update('BE', dic);
        }
    }
    _doPostProcess(isFlatten = false) {
        if (this._isLoaded) {
            if (this._setAppearance || (isFlatten && !this._dictionary.has('AP'))) {
                this._appearanceTemplate = this._createPolygonAppearance(isFlatten);
            }
            if (!this._appearanceTemplate && isFlatten && this._dictionary.has('AP')) {
                const dictionary = this._dictionary.get('AP');
                if (dictionary && dictionary.has('N')) {
                    const appearanceStream = dictionary.get('N');
                    const reference = dictionary.getRaw('N');
                    if (appearanceStream) {
                        if (reference) {
                            appearanceStream.reference = reference;
                        }
                        this._appearanceTemplate = new PdfTemplate(appearanceStream, this._crossReference);
                    }
                }
            }
        }
        else {
            this._postProcess(isFlatten);
            if (!this._appearanceTemplate && isFlatten) {
                if (!this._dictionary.has('AP')) {
                    this._appearanceTemplate = this._createPolygonAppearance(isFlatten);
                }
                else {
                    const dictionary = this._dictionary.get('AP');
                    if (dictionary && dictionary.has('N')) {
                        const appearanceStream = dictionary.get('N');
                        const reference = dictionary.getRaw('N');
                        if (appearanceStream) {
                            if (reference) {
                                appearanceStream.reference = reference;
                            }
                            this._appearanceTemplate = new PdfTemplate(appearanceStream, this._crossReference);
                        }
                    }
                }
            }
        }
        if (typeof this.flattenPopups !== 'undefined' && this.flattenPopups) {
            if (this._isLoaded) {
                this._flattenLoadedPopUp();
            }
        }
        if (isFlatten) {
            if (this._appearanceTemplate) {
                const isNormalMatrix = this._validateTemplateMatrix(this._appearanceTemplate._content.dictionary);
                if (!this._appearanceTemplate._content.dictionary.has('Matrix')) {
                    const box = this._appearanceTemplate._content.dictionary.getArray('BBox');
                    if (box && box.length >= 2) {
                        this._appearanceTemplate._content.dictionary.update('Matrix', [1, 0, 0, 1, -box[0], -box[1]]);
                    }
                }
                this._flattenAnnotationTemplate(this._appearanceTemplate, isNormalMatrix);
            }
            else {
                this._removeAnnotationFromPage(this._page, this);
            }
        }
        if (!isFlatten && this._setAppearance) {
            let appearance;
            if (this._dictionary.has('AP')) {
                appearance = this._dictionary.get('AP');
            }
            else {
                const reference = this._crossReference._getNextReference();
                appearance = new _PdfDictionary(this._crossReference);
                this._crossReference._cacheMap.set(reference, appearance);
                this._dictionary.update('AP', reference);
            }
            _removeDuplicateReference(appearance, this._crossReference, 'N');
            const reference = this._crossReference._getNextReference();
            this._crossReference._cacheMap.set(reference, this._appearanceTemplate._content);
            appearance.update('N', reference);
        }
    }
    _createPolygonAppearance(flatten) {
        if (typeof flatten !== 'undefined' && flatten) {
            let borderPen;
            if (this.color && this.border.width > 0) {
                borderPen = new PdfPen(this.color, this.border.width);
            }
            let backgroundBrush;
            if (this.innerColor) {
                backgroundBrush = new PdfBrush(this.innerColor);
            }
            const graphics = this._page.graphics;
            if (borderPen || backgroundBrush) {
                let state;
                if (typeof this.opacity !== 'undefined' && this._opacity < 1) {
                    state = graphics.save();
                    graphics.setTransparency(this._opacity);
                }
                if (this.borderEffect.intensity !== 0 && this.borderEffect.style === PdfBorderEffectStyle.cloudy) {
                    const radius = this.borderEffect.intensity * 4 + 0.5 * this.border.width;
                    const graphicsPath = new _PdfPath();
                    graphicsPath._addPolygon(this._getLinePoints());
                    this._drawCloudStyle(graphics, backgroundBrush, borderPen, radius, 0.833, graphicsPath._points, false);
                }
                else {
                    graphics.drawPolygon(this._getLinePoints(), borderPen, backgroundBrush);
                }
                if (typeof this.opacity !== 'undefined' && this._opacity < 1) {
                    graphics.restore(state);
                }
            }
            return graphics._template;
        }
        else {
            let boundsValue;
            const rect = { x: 0, y: 0, width: 0, height: 0 };
            if (typeof this._points === 'undefined' && this._dictionary.has('Vertices')) {
                this._points = this._dictionary.get('Vertices');
                boundsValue = this._getBoundsValue(this._points);
            }
            else {
                boundsValue = this._getBoundsValue(this._points);
            }
            if (typeof this._borderEffect !== 'undefined' &&
                typeof this.borderEffect.intensity !== 'undefined' && this.borderEffect.intensity !== 0 &&
                this._borderEffect.style === PdfBorderEffectStyle.cloudy) {
                rect.x = boundsValue.x - (this.borderEffect.intensity * 5) - this.border.width;
                rect.y = boundsValue.y - (this.borderEffect.intensity * 5) - this.border.width;
                rect.width = boundsValue.width + (this.borderEffect.intensity * 10) + (2 * this.border.width);
                rect.height = boundsValue.height + (this.borderEffect.intensity * 10) + (2 * this.border.width);
            }
            else {
                rect.x = boundsValue.x - this.border.width;
                rect.y = boundsValue.y - this.border.width;
                rect.width = boundsValue.width + (2 * this.border.width);
                rect.height = boundsValue.height + (2 * this.border.width);
            }
            const appearance = new PdfAppearance(this, [rect.x, rect.y, rect.width, rect.height]);
            appearance.normal = new PdfTemplate([rect.x, rect.y, rect.width, rect.height], this._crossReference);
            const template = appearance.normal;
            _setMatrix(template, this._getRotationAngle());
            template._writeTransformation = false;
            const graphics = appearance.normal.graphics;
            const parameter = new _PaintParameter();
            if (this.innerColor) {
                parameter.backBrush = new PdfBrush(this._innerColor);
            }
            if (this.border.width > 0 && this.color) {
                parameter.borderPen = new PdfPen(this._color, this.border.width);
            }
            if (this.color) {
                parameter.foreBrush = new PdfBrush(this._color);
            }
            if (typeof this.opacity !== 'undefined' && this._opacity < 1) {
                graphics.save();
                graphics.setTransparency(this._opacity);
            }
            else {
                graphics.save();
            }
            if (this.borderEffect.intensity !== 0 && this.borderEffect.style === PdfBorderEffectStyle.cloudy) {
                const radius = this.borderEffect.intensity * 4 + 0.5 * this.border.width;
                const graphicsPath = new _PdfPath();
                graphicsPath._addPolygon(this._getLinePoints());
                this._drawCloudStyle(graphics, parameter.backBrush, parameter.borderPen, radius, 0.833, graphicsPath._points, false);
            }
            else {
                graphics.drawPolygon(this._getLinePoints(), parameter.borderPen, parameter.backBrush);
            }
            if (typeof this.opacity !== 'undefined' && this._opacity < 1) {
                graphics.restore();
            }
            graphics.restore();
            if (this._isBounds) {
                template._content.dictionary._updated = true;
                this._dictionary.update('LLE', this.lineExtension);
                this._dictionary.update('Vertices', this._points);
            }
            this._dictionary.update('Rect', [rect.x, rect.y, rect.x + rect.width, rect.y + rect.height]);
            return template;
        }
    }
    _getLinePoints() {
        let polygonPoints;
        const pageSize = this._page.size;
        const pageHeight = pageSize[1];
        const pageWidth = pageSize[0];
        if (this._dictionary.has('Vertices') && !this._isBounds) {
            let rotation;
            if (this._page._pageDictionary.has('Rotate')) {
                rotation = this._page._pageDictionary.get('Rotate');
            }
            if (this._page.rotation) {
                if (this._page.rotation === PdfRotationAngle.angle90) {
                    rotation = 90;
                }
                else if (this._page.rotation === PdfRotationAngle.angle180) {
                    rotation = 180;
                }
                else if (this._page.rotation === PdfRotationAngle.angle270) {
                    rotation = 270;
                }
            }
            const linePoints = this._dictionary.getArray('Vertices');
            if (linePoints) {
                const points = [];
                linePoints.forEach((value) => {
                    points.push(value);
                });
                polygonPoints = [];
                for (let j = 0; j < points.length; j = j + 2) {
                    polygonPoints.push([points[Number.parseInt(j.toString(), 10)], (pageHeight - points[j + 1])]);
                }
                if (rotation) {
                    if (rotation === 270) {
                        for (let k = 0; k < polygonPoints.length; k++) {
                            const x = polygonPoints[Number.parseInt(k.toString(), 10)][0];
                            polygonPoints[Number.parseInt(k.toString(), 10)][0] = polygonPoints[Number.parseInt(k.toString(), 10)][1];
                            polygonPoints[Number.parseInt(k.toString(), 10)][1] = pageWidth - x;
                        }
                    }
                    else if (rotation === 90) {
                        for (let k = 0; k < polygonPoints.length; k++) {
                            const x = polygonPoints[Number.parseInt(k.toString(), 10)][0];
                            if (this._page._origin[1] !== 0) {
                                polygonPoints[Number.parseInt(k.toString(), 10)][0] = pageHeight -
                                    (polygonPoints[Number.parseInt(k.toString(), 10)][1] - pageHeight);
                            }
                            else {
                                polygonPoints[Number.parseInt(k.toString(), 10)][0] = pageHeight -
                                    polygonPoints[Number.parseInt(k.toString(), 10)][1];
                            }
                            polygonPoints[Number.parseInt(k.toString(), 10)][1] = x;
                        }
                    }
                    else if (rotation === 180) {
                        for (let k = 0; k < polygonPoints.length; k++) {
                            const x = polygonPoints[Number.parseInt(k.toString(), 10)][0];
                            polygonPoints[Number.parseInt(k.toString(), 10)][0] = pageWidth - x;
                            polygonPoints[Number.parseInt(k.toString(), 10)][1] = pageHeight -
                                polygonPoints[Number.parseInt(k.toString(), 10)][1];
                        }
                    }
                }
            }
        }
        else if (this._points !== null) {
            const points = [];
            this._points.forEach((value) => {
                points.push(value);
            });
            polygonPoints = [];
            for (let j = 0; j < this._points.length; j = j + 2) {
                if (this.flatten) {
                    polygonPoints.push([points[Number.parseInt(j.toString(), 10)], (pageHeight - points[j + 1])]);
                }
                else {
                    polygonPoints.push([points[Number.parseInt(j.toString(), 10)], -points[j + 1]]);
                }
            }
        }
        return polygonPoints;
    }
}
/**
 * `PdfPolyLineAnnotation` class represents the polyline annotation objects.
 * ```typescript
 * // Load an existing PDF document
 * let document: PdfDocument = new PdfDocument(data, password);
 * // Get the first page
 * let page: PdfPage = document.getPage(0) as PdfPage;
 * // Create a new poly line annotation with bounds
 * const annotation: PdfPolyLineAnnotation = new PdfPolyLineAnnotation ([100, 300, 150, 200, 300, 200, 350, 300, 300, 400, 150, 400]);
 * // Add annotation to the page
 * page.annotations.add(annotation);
 * // Destroy the document
 * document.destroy();
 * ```
 */
class PdfPolyLineAnnotation extends PdfComment {
    constructor(points) {
        super();
        this._beginLine = PdfLineEndingStyle.none;
        this._endLine = PdfLineEndingStyle.none;
        this._dictionary = new _PdfDictionary();
        this._dictionary.update('Type', _PdfName.get('Annot'));
        this._dictionary.update('Subtype', _PdfName.get('PolyLine'));
        if (typeof points !== 'undefined') {
            this._points = points;
        }
        this._type = _PdfAnnotationType.polyLineAnnotation;
    }
    /**
     * Gets the begin line ending style of the annotation.
     *
     * @returns {PdfLineEndingStyle} Begin line ending style.
     * ```typescript
     * // Load an existing PDF document
     * let document: PdfDocument = new PdfDocument(data, password);
     * // Get the first page
     * let page: PdfPage = document.getPage(0) as PdfPage;
     * // Get the first annotation of the page
     * let annotation: PdfPolyLineAnnotation = page.annotations.at(0) as PdfPolyLineAnnotation;
     * // Gets the begin line ending style of the annotation.
     * let beginLineStyle: PdfLineEndingStyle = annotation.beginLineStyle;
     * // Destroy the document
     * document.destroy();
     * ```
     */
    get beginLineStyle() {
        if (this._dictionary.has('LE')) {
            const lineStyles = this._dictionary.getArray('LE');
            if (lineStyles && Array.isArray(lineStyles)) {
                this._beginLine = _mapLineEndingStyle(lineStyles[0].name);
            }
        }
        return this._beginLine;
    }
    /**
     * Sets the begin line ending style of the annotation.
     *
     * @param {PdfLineEndingStyle} value Begin line ending style.
     * ```typescript
     * // Load an existing PDF document
     * let document: PdfDocument = new PdfDocument(data, password);
     * // Get the first page
     * let page: PdfPage = document.getPage(0) as PdfPage;
     * // Get the first annotation of the page
     * let annotation: PdfPolyLineAnnotation = page.annotations.at(0) as PdfPolyLineAnnotation;
     * // Sets the begin line ending style of the annotation.
     * annotation.beginLineStyle = PdfLineEndingStyle.slash;
     * // Save the document
     * document.save('output.pdf');
     * // Destroy the document
     * document.destroy();
     * ```
     */
    set beginLineStyle(value) {
        if (value !== this._beginLine) {
            this._beginLine = value;
            if (this._dictionary) {
                const lineStyle = [];
                lineStyle.push(_PdfName.get(_reverseMapEndingStyle(value)));
                lineStyle.push(_PdfName.get(_reverseMapEndingStyle(this.endLineStyle)));
                this._dictionary.update('LE', lineStyle);
            }
        }
    }
    /**
     * Gets the end line ending style of the annotation.
     *
     * @returns {PdfLineEndingStyle} End line ending style.
     * ```typescript
     * // Load an existing PDF document
     * let document: PdfDocument = new PdfDocument(data, password);
     * // Get the first page
     * let page: PdfPage = document.getPage(0) as PdfPage;
     * // Get the first annotation of the page
     * let annotation: PdfPolyLineAnnotation = page.annotations.at(0) as PdfPolyLineAnnotation;
     * // Gets the end line ending style of the annotation.
     * let endLineStyle: PdfLineEndingStyle = annotation.endLineStyle;
     * // Destroy the document
     * document.destroy();
     * ```
     */
    get endLineStyle() {
        if (this._dictionary.has('LE')) {
            const lineStyles = this._dictionary.getArray('LE');
            if (lineStyles && Array.isArray(lineStyles)) {
                this._endLine = _mapLineEndingStyle(lineStyles[1].name);
            }
        }
        return this._endLine;
    }
    /**
     * Sets the end line ending style of the annotation.
     *
     * @param {PdfLineEndingStyle} value End line ending style.
     * ```typescript
     * // Load an existing PDF document
     * let document: PdfDocument = new PdfDocument(data, password);
     * // Get the first page
     * let page: PdfPage = document.getPage(0) as PdfPage;
     * // Get the first annotation of the page
     * let annotation: PdfPolyLineAnnotation = page.annotations.at(0) as PdfPolyLineAnnotation;
     * // Sets the end line ending style of the annotation.
     * annotation.endLineStyle = PdfLineEndingStyle.square;
     * // Save the document
     * document.save('output.pdf');
     * // Destroy the document
     * document.destroy();
     * ```
     */
    set endLineStyle(value) {
        if (value !== this._endLine) {
            this._endLine = value;
            if (this._dictionary) {
                const lineStyle = [];
                lineStyle.push(_PdfName.get(_reverseMapEndingStyle(this.beginLineStyle)));
                lineStyle.push(_PdfName.get(_reverseMapEndingStyle(value)));
                this._dictionary.update('LE', lineStyle);
            }
        }
    }
    /**
     * Gets the line extension of the square annotation.
     *
     * @returns {number} Line extension.
     * ```typescript
     * // Load an existing PDF document
     * let document: PdfDocument = new PdfDocument(data, password);
     * // Get the first page
     * let page: PdfPage = document.getPage(0) as PdfPage;
     * // Get the first annotation of the page
     * let annotation: PdfPolyLineAnnotation = page.annotations.at(0) as PdfPolyLineAnnotation;
     * // Gets the line extension of annotation.
     * let lineExtension: number = annotation.lineExtension;
     * // Destroy the document
     * document.destroy();
     * ```
     */
    get lineExtension() {
        if (typeof this._lineExtension === 'undefined' && this._dictionary.has('LLE')) {
            const lineExt = this._dictionary.get('LLE');
            if (typeof lineExt !== 'undefined' && lineExt >= 0) {
                this._lineExtension = lineExt;
            }
        }
        return this._lineExtension;
    }
    /**
     * Sets the line extension of the square annotation.
     *
     * @param {number} value Line extension.
     * ```typescript
     * // Load an existing PDF document
     * let document: PdfDocument = new PdfDocument(data, password);
     * // Get the first page
     * let page: PdfPage = document.getPage(0) as PdfPage;
     * // Get the first annotation of the page
     * let annotation: PdfPolyLineAnnotation = page.annotations.at(0) as PdfPolyLineAnnotation;
     * // Sets the line extension of the annotation.
     * annotation.lineExtension = 3;
     * // Save the document
     * document.save('output.pdf');
     * // Destroy the document
     * document.destroy();
     * ```
     */
    set lineExtension(value) {
        if (!Number.isNaN(value)) {
            if (value >= 0) {
                this._dictionary.update('LLE', value);
                this._lineExtension = value;
            }
            else {
                throw new Error('LineExtension should be non negative number');
            }
        }
    }
    static _load(page, dictionary) {
        const annot = new PdfPolyLineAnnotation();
        annot._isLoaded = true;
        annot._initialize(page, dictionary);
        return annot;
    }
    _initialize(page, dictionary) {
        super._initialize(page, dictionary);
    }
    _postProcess(isFlatten) {
        if (typeof this._points === 'undefined' || this._points === null) {
            throw new Error('Points cannot be null or undefined');
        }
        if (!this._dictionary.has('LLE')) {
            this.lineExtension = 0;
        }
        if (!this._dictionary.has('C')) {
            this.color = [0, 0, 0];
        }
        let borderWidth;
        if (this._dictionary.has('BS')) {
            borderWidth = this.border.width;
        }
        else {
            const dictionary = new _PdfDictionary(this._crossReference);
            dictionary.set('Type', _PdfName.get('Border'));
            this._dictionary.set('BS', dictionary);
        }
        if (typeof borderWidth === 'undefined') {
            borderWidth = 1;
        }
        const points = this._getLinePoints();
        const pathTypes = [];
        pathTypes.push(0);
        for (let i = 1; i < points.length; i++) {
            pathTypes.push(1);
        }
        this._polylinePoints = points;
        this._pathTypes = pathTypes;
        const path = new _PdfPath();
        path._points = points;
        path._pathTypes = pathTypes;
        this._dictionary.update('Vertices', this._points);
        const lineStyle = [];
        lineStyle.push(_PdfName.get(_reverseMapEndingStyle(this.beginLineStyle)));
        lineStyle.push(_PdfName.get(_reverseMapEndingStyle(this.endLineStyle)));
        this._dictionary.update('LE', lineStyle);
        this._dictionary.update('LLE', this._lineExtension);
        const polyLineBounds = this._getBoundsValue(this._points);
        const rectangle = [polyLineBounds.x,
            polyLineBounds.y,
            polyLineBounds.x + polyLineBounds.width,
            polyLineBounds.y + polyLineBounds.height];
        this._dictionary.update('Rect', rectangle);
        if (this._setAppearance || (isFlatten && !this._dictionary.has('AP'))) {
            this._appearanceTemplate = this._createPolyLineAppearance(isFlatten);
        }
    }
    _doPostProcess(isFlatten = false) {
        if (this._isLoaded) {
            if (this._setAppearance || (isFlatten && !this._dictionary.has('AP'))) {
                this._appearanceTemplate = this._createPolyLineAppearance(isFlatten);
            }
            if (!this._appearanceTemplate && isFlatten && this._dictionary.has('AP')) {
                const dictionary = this._dictionary.get('AP');
                if (dictionary && dictionary.has('N')) {
                    const appearanceStream = dictionary.get('N');
                    const reference = dictionary.getRaw('N');
                    if (appearanceStream) {
                        if (reference) {
                            appearanceStream.reference = reference;
                        }
                        this._appearanceTemplate = new PdfTemplate(appearanceStream, this._crossReference);
                    }
                }
            }
        }
        else {
            this._postProcess(isFlatten);
            if (!this._appearanceTemplate && isFlatten) {
                if (!this._dictionary.has('AP')) {
                    this._appearanceTemplate = this._createPolyLineAppearance(isFlatten);
                }
                else {
                    const dictionary = this._dictionary.get('AP');
                    if (dictionary && dictionary.has('N')) {
                        const appearanceStream = dictionary.get('N');
                        const reference = dictionary.getRaw('N');
                        if (appearanceStream) {
                            if (reference) {
                                appearanceStream.reference = reference;
                            }
                            this._appearanceTemplate = new PdfTemplate(appearanceStream, this._crossReference);
                        }
                    }
                }
            }
        }
        if (typeof this.flattenPopups !== 'undefined' && this.flattenPopups) {
            if (this._isLoaded) {
                this._flattenLoadedPopUp();
            }
        }
        if (isFlatten) {
            if (this._appearanceTemplate) {
                const isNormalMatrix = this._validateTemplateMatrix(this._appearanceTemplate._content.dictionary);
                if (!this._appearanceTemplate._content.dictionary.has('Matrix')) {
                    const box = this._appearanceTemplate._content.dictionary.getArray('BBox');
                    if (box) {
                        this._appearanceTemplate._content.dictionary.update('Matrix', [1, 0, 0, 1, -box[0], -box[1]]);
                    }
                }
                this._flattenAnnotationTemplate(this._appearanceTemplate, isNormalMatrix);
            }
            else {
                this._removeAnnotationFromPage(this._page, this);
            }
        }
        if (!isFlatten && this._setAppearance) {
            let appearance;
            if (this._dictionary.has('AP')) {
                appearance = this._dictionary.get('AP');
            }
            else {
                const reference = this._crossReference._getNextReference();
                appearance = new _PdfDictionary(this._crossReference);
                this._crossReference._cacheMap.set(reference, appearance);
                this._dictionary.update('AP', reference);
            }
            _removeDuplicateReference(appearance, this._crossReference, 'N');
            const reference = this._crossReference._getNextReference();
            this._crossReference._cacheMap.set(reference, this._appearanceTemplate._content);
            appearance.update('N', reference);
        }
    }
    _createPolyLineAppearance(flatten) {
        if (typeof flatten !== 'undefined' && flatten) {
            let borderPen;
            if (this.color && this.border.width > 0) {
                borderPen = new PdfPen(this.color, this.border.width);
            }
            const graphics = this._page.graphics;
            if (borderPen) {
                let state;
                if (typeof this.opacity !== 'undefined' && this._opacity < 1) {
                    state = graphics.save();
                    graphics.setTransparency(this._opacity);
                }
                const points = this._getLinePoints();
                const pathTypes = [];
                pathTypes.push(0);
                if (points && points.length > 0) {
                    for (let i = 1; i < points.length; i++) {
                        pathTypes.push(1);
                    }
                    const path = new _PdfPath();
                    path._points = points;
                    path._pathTypes = pathTypes;
                    graphics._drawPath(path, borderPen);
                    if (typeof this.opacity !== 'undefined' && this._opacity < 1) {
                        graphics.restore(state);
                    }
                }
            }
            return graphics._template;
        }
        else {
            let boundsValue;
            const rect = { x: 0, y: 0, width: 0, height: 0 };
            if (typeof this._points === 'undefined' && this._dictionary.has('Vertices')) {
                this._points = this._dictionary.get('Vertices');
                boundsValue = this._getBoundsValue(this._points);
            }
            else {
                boundsValue = this._getBoundsValue(this._points);
            }
            rect.x = boundsValue.x - this.border.width;
            rect.y = boundsValue.y - this.border.width;
            rect.width = boundsValue.width + (2 * this.border.width);
            rect.height = boundsValue.height + (2 * this.border.width);
            const appearance = new PdfAppearance(this, [rect.x, rect.y, rect.width, rect.height]);
            appearance.normal = new PdfTemplate([rect.x, rect.y, rect.width, rect.height], this._crossReference);
            const template = appearance.normal;
            _setMatrix(template, this._getRotationAngle());
            template._writeTransformation = false;
            const graphics = appearance.normal.graphics;
            const parameter = new _PaintParameter();
            if (this.innerColor) {
                parameter.backBrush = new PdfBrush(this._innerColor);
            }
            if (this.border.width > 0 && this.color) {
                parameter.borderPen = new PdfPen(this._color, this.border.width);
            }
            if (this.color) {
                parameter.foreBrush = new PdfBrush(this._color);
            }
            if (typeof this.opacity !== 'undefined' && this._opacity < 1) {
                graphics.save();
                graphics.setTransparency(this._opacity);
            }
            else {
                graphics.save();
            }
            const path = new _PdfPath();
            if (typeof this._polylinePoints !== 'undefined' && this._polylinePoints !== null) {
                path._points = this._polylinePoints;
            }
            else {
                path._points = this._getLinePoints();
            }
            if (typeof this._pathTypes !== 'undefined' && this._polylinePoints !== null) {
                path._pathTypes = this._pathTypes;
            }
            else {
                this._pathTypes = [];
                this._pathTypes.push(0);
                for (let i = 1; i < path._points.length; i++) {
                    this._pathTypes.push(1);
                }
                path._pathTypes = this._pathTypes;
            }
            graphics._drawPath(path, parameter.borderPen, parameter.backBrush);
            if (typeof this.opacity !== 'undefined' && this._opacity < 1) {
                graphics.restore();
            }
            graphics.restore();
            if (this._isBounds) {
                template._content.dictionary._updated = true;
                const lineStyle = [];
                lineStyle.push(_PdfName.get(_reverseMapEndingStyle(this.beginLineStyle)));
                lineStyle.push(_PdfName.get(_reverseMapEndingStyle(this.endLineStyle)));
                this._dictionary.update('LE', lineStyle);
                this._dictionary.update('LLE', this.lineExtension);
                this._dictionary.update('Vertices', this._points);
            }
            this._dictionary.update('Rect', [rect.x, rect.y, rect.x + rect.width, rect.y + rect.height]);
            return template;
        }
    }
    _getLinePoints() {
        const pageSize = this._page.size;
        const pageHeight = pageSize[1];
        let points;
        if (this._dictionary.has('Vertices') && !this._isBounds) {
            const linePoints = this._dictionary.getArray('Vertices');
            if (linePoints) {
                points = [];
                for (let j = 0; j < linePoints.length; j = j + 2) {
                    points.push([linePoints[Number.parseInt(j.toString(), 10)], (pageHeight - linePoints[j + 1])]);
                }
            }
        }
        else if (this._points) {
            const polyLinepoints = [];
            this._points.forEach((value) => {
                polyLinepoints.push(value);
            });
            points = [];
            for (let j = 0; j < polyLinepoints.length; j = j + 2) {
                if (this.flatten) {
                    points.push([polyLinepoints[Number.parseInt(j.toString(), 10)], (pageHeight - polyLinepoints[j + 1])]);
                }
                else {
                    points.push([polyLinepoints[Number.parseInt(j.toString(), 10)], -polyLinepoints[j + 1]]);
                }
            }
        }
        return points;
    }
}
/**
 * `PdfAngleMeasurementAnnotation` class represents the angle measurement annotation objects.
 * ```typescript
 * // Load an existing PDF document
 * let document: PdfDocument = new PdfDocument(data, password);
 * // Get the first page
 * let page: PdfPage = document.getPage(0) as PdfPage;
 * // Create a new angle measurement annotation
 * const annotation: PdfAngleMeasurementAnnotation = new PdfAngleMeasurementAnnotation([[100, 700], [150, 650], [100, 600]]);
 * // Add annotation to the page
 * page.annotations.add(annotation);
 * // Destroy the document
 * document.destroy();
 * ```
 */
class PdfAngleMeasurementAnnotation extends PdfComment {
    constructor(points) {
        super();
        this._linePoints = [];
        this._firstIntersectionPoint = [0, 0];
        this._secondIntersectionPoint = [0, 0];
        this._dictionary = new _PdfDictionary();
        this._dictionary.update('Type', _PdfName.get('Annot'));
        this._dictionary.update('Subtype', _PdfName.get('PolyLine'));
        if (typeof points !== 'undefined' && points.length > 0) {
            if (points.length > 6) {
                throw new Error('Points length should not be greater than 3');
            }
            this._pointArray = points;
            for (let i = 0; i < points.length; i++) {
                this._linePoints.push(points[Number.parseInt(i.toString(), 10)][0]);
                this._linePoints.push(points[Number.parseInt(i.toString(), 10)][1]);
            }
        }
        this._type = _PdfAnnotationType.angleMeasurementAnnotation;
    }
    /**
     * Gets the flag to have measurement dictionary of the angle measurement annotation.
     *
     * @returns {boolean} measure.
     * ```typescript
     * // Load an existing PDF document
     * let document: PdfDocument = new PdfDocument(data, password);
     * // Get the first page
     * let page: PdfPage = document.getPage(0) as PdfPage;
     * // Get the first annotation of the page
     * let annotation: PdfAngleMeasurementAnnotation = page.annotations.at(0) as PdfAngleMeasurementAnnotation;
     * // Gets the flag to have measurement dictionary of the angle annotation.
     * let measure: boolean = annotation.measure;
     * // Destroy the document
     * document.destroy();
     * ```
     */
    get measure() {
        if (typeof this._measure === 'undefined' && this._dictionary.has('Measure')) {
            this._measure = this._dictionary.get('Measure');
        }
        return this._measure;
    }
    /**
     * Sets the flag to add measurement dictionary to the annotation.
     *
     * @param {boolean} value Measure.
     * ```typescript
     * // Load an existing PDF document
     * let document: PdfDocument = new PdfDocument(data, password);
     * // Get the first page
     * let page: PdfPage = document.getPage(0) as PdfPage;
     * // Get the first annotation of the page
     * let annotation: PdfAngleMeasurementAnnotation = page.annotations.at(0) as PdfAngleMeasurementAnnotation;
     * // Sets the flag to add measurement dictionary to the annotation.
     * annotation.measure = true;
     * // Save the document
     * document.save('output.pdf');
     * // Destroy the document
     * document.destroy();
     * ```
     */
    set measure(value) {
        if (value && !this._isLoaded) {
            this._measure = value;
            this.caption.cap = true;
        }
    }
    static _load(page, dictionary) {
        const annot = new PdfAngleMeasurementAnnotation();
        annot._isLoaded = true;
        annot._initialize(page, dictionary);
        return annot;
    }
    _initialize(page, dictionary) {
        super._initialize(page, dictionary);
    }
    _postProcess() {
        if (!this._pointArray) {
            throw new Error('Points cannot be null or undefined');
        }
        let borderWidth;
        if (this._dictionary.has('BS')) {
            borderWidth = this.border.width;
        }
        else {
            const dictionary = new _PdfDictionary(this._crossReference);
            dictionary.set('Type', _PdfName.get('Border'));
            this._dictionary.set('BS', dictionary);
        }
        if (!this._dictionary.has('C')) {
            this.color = [0, 0, 0];
        }
        if (typeof borderWidth === 'undefined') {
            borderWidth = 1;
        }
        this._appearanceTemplate = this._createAngleMeasureAppearance();
    }
    _doPostProcess(isFlatten = false) {
        if (this._isLoaded) {
            if (!isFlatten && this._setAppearance) {
                this._appearanceTemplate = this._createAngleMeasureAppearance();
            }
            if (!this._appearanceTemplate && isFlatten && this._dictionary.has('AP')) {
                const dictionary = this._dictionary.get('AP');
                if (dictionary && dictionary.has('N')) {
                    const appearanceStream = dictionary.get('N');
                    const reference = dictionary.getRaw('N');
                    if (appearanceStream) {
                        if (reference) {
                            appearanceStream.reference = reference;
                        }
                        this._appearanceTemplate = new PdfTemplate(appearanceStream, this._crossReference);
                    }
                }
            }
        }
        else {
            this._postProcess();
            if (!this._appearanceTemplate) {
                if (isFlatten) {
                    if (!this._dictionary.has('AP')) {
                        this._appearanceTemplate = this._createAngleMeasureAppearance();
                    }
                    else {
                        const dictionary = this._dictionary.get('AP');
                        if (dictionary && dictionary.has('N')) {
                            const appearanceStream = dictionary.get('N');
                            const reference = dictionary.getRaw('N');
                            if (appearanceStream) {
                                if (reference) {
                                    appearanceStream.reference = reference;
                                }
                                this._appearanceTemplate = new PdfTemplate(appearanceStream, this._crossReference);
                            }
                        }
                    }
                }
            }
        }
        if (isFlatten && this._appearanceTemplate) {
            const isNormalMatrix = this._validateTemplateMatrix(this._appearanceTemplate._content.dictionary);
            if (!this._appearanceTemplate._content.dictionary.has('Matrix')) {
                const box = this._appearanceTemplate._content.dictionary.getArray('BBox');
                if (box) {
                    this._appearanceTemplate._content.dictionary.update('Matrix', [1, 0, 0, 1, -box[0], -box[1]]);
                }
            }
            this._flattenAnnotationTemplate(this._appearanceTemplate, isNormalMatrix);
        }
    }
    _createAngleMeasureAppearance() {
        const borderWidth = this.border.width;
        let font = this._obtainFont();
        if ((typeof font === 'undefined' || font === null) || (!this._isLoaded && font.size === 1)) {
            font = this._circleCaptionFont;
            this._pdfFont = font;
        }
        const format = new PdfStringFormat(PdfTextAlignment.center, PdfVerticalAlignment.middle);
        let angle = (this._calculateAngle() * (180.0 / Math.PI));
        if (angle < 0) {
            angle = -angle;
        }
        if (angle > 180) {
            angle = 360 - angle;
        }
        this._dictionary.update('Vertices', this._linePoints);
        const ds = 'font:' +
            font._metrics._postScriptName +
            ' ' +
            font._size +
            'pt; color:' +
            this._colorToHex(this.color);
        this._dictionary.update('DS', ds);
        if (this.text === (' ' + angle.toFixed(2) + '°')) {
            this._dictionary.update('Contents', this.text);
        }
        else if (this.text) {
            this._dictionary.update('Contents', this.text);
        }
        if (typeof this.subject === 'undefined') {
            this._dictionary.update('Subject', 'Angle Measurement');
        }
        this._dictionary.update('MeasurementTypes', 1152);
        this._dictionary.update('Subtype', new _PdfName('PolyLine'));
        this._dictionary.update('IT', new _PdfName('PolyLineAngle'));
        const measureDictionary = new _PdfDictionary();
        const d = [];
        const t = [];
        const a = [];
        const x = [];
        const v = [];
        measureDictionary.set('Type', _PdfName.get('measureDictionary'));
        measureDictionary.set('R', '1 in = 1 in');
        measureDictionary.set('Subtype', 'RL');
        measureDictionary.set('TargetUnitConversion', 0.1388889);
        const dDictionary = new _PdfDictionary();
        dDictionary.set('U', 'in');
        dDictionary.set('Type', 'NumberFormat');
        dDictionary.set('C', 1);
        dDictionary.set('D', 1);
        dDictionary.set('SS', '');
        d.push(dDictionary);
        const tDictionary = new _PdfDictionary();
        tDictionary.set('U', '°');
        tDictionary.set('Type', 'NumberFormat');
        tDictionary.set('C', 1);
        tDictionary.set('D', 1);
        tDictionary.set('FD', true);
        tDictionary.set('SS', '');
        t.push(tDictionary);
        const aDictionary = new _PdfDictionary();
        aDictionary.set('U', 'sq in');
        aDictionary.set('Type', 'NumberFormat');
        aDictionary.set('C', 1);
        aDictionary.set('D', 1);
        aDictionary.set('FD', true);
        aDictionary.set('SS', '');
        a.push(aDictionary);
        const vDictionary = new _PdfDictionary();
        vDictionary.set('U', 'cu in');
        vDictionary.set('Type', 'NumberFormat');
        vDictionary.set('C', 1);
        vDictionary.set('D', 1);
        vDictionary.set('FD', true);
        vDictionary.set('SS', '');
        v.push(vDictionary);
        const xDictionary = new _PdfDictionary();
        xDictionary.set('U', 'in');
        xDictionary.set('Type', 'NumberFormat');
        xDictionary.set('C', 1);
        xDictionary.set('D', 1);
        xDictionary.set('SS', '');
        x.push(xDictionary);
        measureDictionary.set('D', d);
        measureDictionary.set('T', t);
        measureDictionary.set('A', a);
        measureDictionary.set('X', x);
        measureDictionary.set('V', v);
        if (this._dictionary.has('Measure')) {
            _removeDuplicateReference(this._dictionary, this._crossReference, 'Measure');
        }
        const reference = this._crossReference._getNextReference();
        this._crossReference._cacheMap.set(reference, measureDictionary);
        measureDictionary._updated = true;
        this._dictionary.update('Measure', reference);
        let rectValue = [0, 0, 0, 0];
        const boundsValue = this._getAngleBoundsValue();
        const points = this._obtainLinePoints();
        const pathTypes = [];
        pathTypes.push(0);
        for (let i = 1; i < points.length; i++) {
            pathTypes.push(1);
        }
        const graphicspath = new _PdfPath();
        graphicspath._addRectangle(points[1][0] - this._radius, -(points[1][1] + this._radius), 2 * this._radius, 2 * this._radius);
        const size = font.measureString(angle.toString() + '°', [0, 0], format, 0, 0);
        const midPoint = [(this._firstIntersectionPoint[0] + this._secondIntersectionPoint[0]) / 2,
            ((this._firstIntersectionPoint[1] + this._secondIntersectionPoint[1]) / 2)];
        const center = [points[1][0], -points[1][1]];
        const x1 = points[1][0] + this._radius * Math.cos((this._startAngle + (this._sweepAngle / 2)) * (Math.PI / 180.0));
        const y = points[1][1] + this._radius * Math.sin((this._startAngle + (this._sweepAngle / 2)) * (Math.PI / 180.0));
        const start = [midPoint[0], midPoint[1]];
        const xDiff = start[0] - center[0];
        const yDiff = start[1] - center[1];
        let midpointAngle = ((Math.atan2(yDiff, xDiff)) * (180.0 / Math.PI));
        let left = false;
        let right = false;
        let up = false;
        let down = false;
        if (midpointAngle > 0) {
            if (midpointAngle < 45) {
                right = true;
            }
            else if (midpointAngle >= 45 && midpointAngle < 135) {
                up = true;
            }
            else {
                left = true;
            }
        }
        else {
            midpointAngle = -midpointAngle;
            if (midpointAngle === 0) {
                (new _PdfPath())._addRectangle(boundsValue[0], boundsValue[1], boundsValue[2], boundsValue[3]);
            }
            else if (midpointAngle < 45) {
                right = true;
            }
            else if (midpointAngle >= 45 && midpointAngle < 135) {
                down = true;
            }
            else {
                left = true;
            }
        }
        if (rectValue[0] === 0 && rectValue[1] === 0 && rectValue[2] === 0 && rectValue[3] === 0) {
            rectValue = boundsValue;
            this.bounds = { x: boundsValue[0], y: boundsValue[1], width: boundsValue[2], height: boundsValue[3] };
        }
        const path = new _PdfPath();
        path._pathTypes = pathTypes;
        path._points = points;
        this._dictionary.set('Rect', [rectValue[0], rectValue[1], rectValue[0] + rectValue[2], rectValue[1] + rectValue[3]]);
        const appearance = new PdfAppearance(this, boundsValue);
        appearance.normal = new PdfTemplate(rectValue, this._crossReference);
        const template = appearance.normal;
        template._writeTransformation = false;
        const graphics = appearance.normal.graphics;
        const width = borderWidth / 2;
        const pen = new PdfPen(this._color, width);
        if (this.border.style === PdfBorderStyle.dashed) {
            pen._dashStyle = PdfDashStyle.dash;
        }
        const brush = new PdfBrush(this._color);
        graphics.save();
        path._addArc(points[1][0] - this._radius, points[1][1] - this._radius, 2 * this._radius, 2 * this._radius, this._startAngle, this._sweepAngle);
        graphics._drawPath(path, pen);
        if (up) {
            graphics.drawString(angle.toString() + '°', font, [x1 - (size[0] / 2), -(-y + font._metrics._getHeight() + 2), 0, 0], null, brush);
        }
        else if (right) {
            graphics.drawString(angle.toString() + '°', font, [x1 + 2, -(-y + font._metrics._getHeight() / 2), 0, 0], null, brush);
        }
        else if (left) {
            graphics.drawString(angle.toString() + '°', font, [x1 - size[0] - 2, -(-y + font._metrics._getHeight() / 2), 0, 0], null, brush);
        }
        else if (down) {
            graphics.drawString(angle.toString() + '°', font, [x1 - (size[0] / 2), (y + 2), 0, 0], null, brush);
        }
        graphics.restore();
        graphics._template._content.dictionary._updated = true;
        const reference1 = this._crossReference._getNextReference();
        this._crossReference._cacheMap.set(reference1, graphics._template._content);
        graphics._template._content.reference = reference1;
        if (this._dictionary.has('AP')) {
            _removeDuplicateReference(this._dictionary.get('AP'), this._crossReference, 'N');
        }
        const appearanceDictionary = new _PdfDictionary();
        appearanceDictionary.set('N', reference1);
        appearanceDictionary._updated = true;
        this._dictionary.set('AP', appearanceDictionary);
        return template;
    }
    _getAngleBoundsValue() {
        const points = this._obtainLinePoints();
        for (let i = 0; i < points.length; i++) {
            points[Number.parseInt(i.toString(), 10)][1] = -points[Number.parseInt(i.toString(), 10)][1];
        }
        const path = new _PdfPath();
        path._points = points;
        path._pathTypes = [0, 1, 1];
        return path._getBounds();
    }
    _obtainLinePoints() {
        let points;
        let collection;
        if (this._linePoints) {
            points = new Array(this._linePoints.length);
            for (let i = 0; i < this._linePoints.length; i++) {
                points[Number.parseInt(i.toString(), 10)] = this._linePoints[Number.parseInt(i.toString(), 10)];
            }
            collection = new Array(points.length / 2);
            let count = 0;
            for (let j = 0; j < points.length; j = j + 2) {
                collection[Number.parseInt(count.toString(), 10)] = [points[Number.parseInt(j.toString(), 10)], -points[j + 1]];
                count++;
            }
        }
        return collection;
    }
    _calculateAngle() {
        const points = [0, 0];
        if (typeof this._linePoints !== 'undefined' && this._linePoints.length === 0 && this._isLoaded) {
            if (this._dictionary.has('Vertices')) {
                this._linePoints = this._dictionary.get('Vertices');
            }
        }
        for (let i = 0; i < this._linePoints.length; i++) {
            points[Number.parseInt(i.toString(), 10)] = this._linePoints[Number.parseInt(i.toString(), 10)];
        }
        const collection = [];
        for (let j = 0; j < points.length; j = j + 2) {
            collection.push([points[Number.parseInt(j.toString(), 10)], points[j + 1]]);
        }
        const point1 = collection[0];
        const point2 = collection[1];
        const point3 = collection[2];
        const firstLineDistance = Math.sqrt(Math.pow((point2[0] - point1[0]), 2) + Math.pow((point2[1] - point1[1]), 2));
        const secondLineDistance = Math.sqrt(Math.pow((point2[0] - point3[0]), 2) + Math.pow((point2[1] - point3[1]), 2));
        this._radius = Math.min(firstLineDistance, secondLineDistance) / 4;
        const graphicsPath = new _PdfPath();
        graphicsPath._points = collection;
        graphicsPath._pathTypes = [0, 1, 1];
        let intersectionPoint1;
        let intersectionPoint2;
        let value = this._findLineCircleIntersectionPoints(point2[0], point2[1], this._radius, point1, point2, intersectionPoint1, intersectionPoint2);
        intersectionPoint1 = value.first;
        intersectionPoint2 = value.second;
        if (this._firstIntersectionPoint[0] === 0 && this._firstIntersectionPoint[1] === 0) {
            this._firstIntersectionPoint = intersectionPoint2;
        }
        intersectionPoint1 = [0, 0];
        intersectionPoint2 = [0, 0];
        value = this._findLineCircleIntersectionPoints(point2[0], point2[1], this._radius, point3, point2, intersectionPoint1, intersectionPoint2);
        intersectionPoint1 = value.first;
        intersectionPoint2 = value.second;
        if (this._secondIntersectionPoint[0] === 0 && this._secondIntersectionPoint[1] === 0) {
            this._secondIntersectionPoint = intersectionPoint2;
        }
        let xDiff = this._firstIntersectionPoint[0] - point2[0];
        let yDiff = this._firstIntersectionPoint[1] - point2[1];
        let startAngle = (Math.atan2(yDiff, xDiff) * (180.0 / Math.PI));
        xDiff = this._secondIntersectionPoint[0] - point2[0];
        yDiff = this._secondIntersectionPoint[1] - point2[1];
        let sweepAngle = (Math.atan2(yDiff, xDiff) * (180.0 / Math.PI));
        startAngle = startAngle > 0 ? startAngle = 360 - startAngle : -startAngle;
        sweepAngle = sweepAngle > 0 ? sweepAngle = 360 - sweepAngle : -sweepAngle;
        if (startAngle === 180 && sweepAngle === 0) {
            this._startAngle = startAngle;
            this._sweepAngle = 180;
        }
        else if (startAngle === 0 && sweepAngle === 180) {
            this._startAngle = sweepAngle;
            this._sweepAngle = 180;
        }
        else if (startAngle < 180) {
            if (startAngle > sweepAngle) {
                this._startAngle = sweepAngle;
                this._sweepAngle = startAngle - sweepAngle;
            }
            else if (startAngle + 180 < sweepAngle) {
                this._startAngle = sweepAngle;
                this._sweepAngle = (360 - sweepAngle) + startAngle;
            }
            else {
                this._startAngle = startAngle;
                this._sweepAngle = sweepAngle - startAngle;
            }
        }
        else {
            if (startAngle < sweepAngle) {
                this._startAngle = startAngle;
                this._sweepAngle = sweepAngle - startAngle;
            }
            else if (startAngle - 180 > sweepAngle) {
                this._startAngle = startAngle;
                this._sweepAngle = (360 - startAngle) + sweepAngle;
            }
            else {
                this._startAngle = sweepAngle;
                this._sweepAngle = startAngle - sweepAngle;
            }
        }
        return (Math.atan2((point3[0] - point2[0]), (point3[1] - point2[1])) -
            Math.atan2((point1[0] - point2[0]), (point1[1] - point2[1])));
    }
    _findLineCircleIntersectionPoints(centerX, centerY, radius, point1, point2, intersection1, intersection2) {
        const dx = point2[0] - point1[0];
        const dy = point2[1] - point1[1];
        const a = dx * dx + dy * dy;
        const b = 2 * (dx * (point1[0] - centerX) + dy * (point1[1] - centerY));
        const c = (point1[0] - centerX) * (point1[0] - centerX) + (point1[1] - centerY) * (point1[1] - centerY) - radius * radius;
        const e = b * b - 4 * a * c;
        if ((a <= 0.0000001) || (e < 0)) {
            intersection1 = [Number.NaN, Number.NaN];
            intersection2 = [Number.NaN, Number.NaN];
        }
        else if (e === 0) {
            const t = -b / (2 * a);
            intersection1 = [point1[0] + t * dx, point1[1] + t * dy];
            intersection2 = [Number.NaN, Number.NaN];
        }
        else {
            let t = ((-b + Math.sqrt(e)) / (2 * a));
            intersection1 = [point1[0] + t * dx, point1[1] + t * dy];
            t = ((-b - Math.sqrt(e)) / (2 * a));
            intersection2 = [point1[0] + t * dx, point1[1] + t * dy];
        }
        return { first: intersection1, second: intersection2 };
    }
}
/**
 * `PdfInkAnnotation` class represents the ink annotation objects.
 * ```typescript
 * // Load an existing PDF document
 * let document: PdfDocument = new PdfDocument(data, password);
 * // Get the first page
 * let page: PdfPage = document.getPage(0) as PdfPage;
 * // Create a new ink annotation with the bounds and ink points
 * const annotation: PdfInkAnnotation = new PdfInkAnnotation([0, 0, 300, 400], [40, 300, 60, 100, 40, 50, 40, 300]);
 * // Add annotation to the page
 * page.annotations.add(annotation);
 * // Destroy the document
 * document.destroy();
 * ```
 */
class PdfInkAnnotation extends PdfComment {
    constructor(points, linePoints) {
        super();
        this._inkPointsCollection = [];
        this._previousCollection = [];
        this._isModified = false;
        this._dictionary = new _PdfDictionary();
        this._dictionary.update('Type', _PdfName.get('Annot'));
        this._dictionary.update('Subtype', _PdfName.get('Ink'));
        if (typeof points !== 'undefined') {
            this._points = points;
            this.bounds = { x: points[0], y: points[1], width: points[2], height: points[3] };
        }
        if (typeof linePoints !== 'undefined') {
            this._linePoints = linePoints;
        }
        this._type = _PdfAnnotationType.inkAnnotation;
    }
    /**
     * Gets the ink points collection of the annotation.
     *
     * @returns {Array<number[]>} Ink points collection.
     *
     * ```typescript
     * // Load an existing PDF document
     * let document: PdfDocument = new PdfDocument(data, password);
     * // Get the first page
     * let page: PdfPage = document.getPage(0) as PdfPage;
     * // Get the first annotation of the page
     * let annotation: PdfInkAnnotation = page.annotations.at(0) as PdfInkAnnotation;
     * // Get the ink points collection of the annotation
     * let inkPointsCollection: Array<number[]> = annotation.inkPointsCollection;
     * // Destroy the document
     * document.destroy();
     * ```
     */
    get inkPointsCollection() {
        if (this._inkPointsCollection.length === 0 && this._dictionary.has('InkList')) {
            const inkList = this._dictionary.get('InkList');
            if (Array.isArray(inkList) && inkList.length > 0) {
                this._inkPointsCollection = inkList;
            }
        }
        return this._inkPointsCollection;
    }
    /**
     * Sets the ink points collection of the annotation.
     *
     * @param {Array<number[]>} value Ink points collection.
     *
     * ```typescript
     * // Load an existing PDF document
     * let document: PdfDocument = new PdfDocument(data, password);
     * // Get the first page
     * let page: PdfPage = document.getPage(0) as PdfPage;
     * // Get the first annotation of the page
     * // Create a new ink annotation
     * const annotation: PdfInkAnnotation = new PdfInkAnnotation([0, 0, 300, 400], [40, 300, 60, 100, 40, 50, 40, 300]);
     * // Set the ink points collection of the annotation
     * annotation.inkPointsCollection = [[422, 690, 412, 708, 408, 715, 403, 720, 400, 725], [420, 725, 420, 715, 415, 705, 400, 690, 405, 695]];
     * // Add annotation to the page
     * page.annotations.add(annotation);
     * // Destroy the document
     * document.destroy();
     * ```
     */
    set inkPointsCollection(value) {
        if (Array.isArray(value) && value.length > 0 && value !== this._inkPointsCollection) {
            this._inkPointsCollection = value;
            this._isModified = true;
            if (this._isLoaded) {
                this._dictionary.update('InkList', value);
            }
        }
    }
    static _load(page, dictionary) {
        const annot = new PdfInkAnnotation();
        annot._isLoaded = true;
        annot._initialize(page, dictionary);
        return annot;
    }
    _initialize(page, dictionary) {
        super._initialize(page, dictionary);
    }
    _postProcess() {
        if (typeof this._points === 'undefined' || this._points === null) {
            throw new Error('Points cannot be null or undefined');
        }
        let borderWidth;
        if (this._dictionary.has('BS')) {
            borderWidth = this.border.width;
        }
        else {
            const dictionary = new _PdfDictionary(this._crossReference);
            dictionary.set('Type', _PdfName.get('Border'));
            this._dictionary.set('BS', dictionary);
        }
        if (!this._dictionary.has('C')) {
            this.color = [0, 0, 0];
        }
        if (typeof borderWidth === 'undefined') {
            borderWidth = 1;
        }
        const nativeRectangle = this._addInkPoints();
        const bounds = [nativeRectangle[0],
            nativeRectangle[1],
            nativeRectangle[0] + nativeRectangle[2],
            nativeRectangle[1] + nativeRectangle[3]];
        this._dictionary.update('Rect', bounds);
        if (this._setAppearance) {
            const appearance = new PdfAppearance(this, nativeRectangle);
            appearance.normal = new PdfTemplate(nativeRectangle, this._crossReference);
            const template = appearance.normal;
            _setMatrix(template, this._getRotationAngle());
            template._writeTransformation = false;
            this._appearanceTemplate = this._createInkAppearance(template);
            if (this._dictionary.has('AP')) {
                _removeDuplicateReference(this._dictionary.get('AP'), this._crossReference, 'N');
            }
            const dictionary = new _PdfDictionary();
            this._appearanceTemplate._content.dictionary._updated = true;
            const reference = this._crossReference._getNextReference();
            this._crossReference._cacheMap.set(reference, this._appearanceTemplate._content);
            this._appearanceTemplate._content.reference = reference;
            dictionary.set('N', reference);
            dictionary._updated = true;
            this._dictionary.set('AP', dictionary);
        }
    }
    _doPostProcess(isFlatten = false) {
        this._isFlatten = isFlatten;
        if (this._isLoaded) {
            if (this._setAppearance || (isFlatten && !this._dictionary.has('AP'))) {
                if (this._inkPointsCollection.length === 0) {
                    this._inkPointsCollection = this._obtainInkListCollection();
                }
                const rect = this._getInkBoundsValue();
                const template = new PdfTemplate(rect, this._crossReference);
                _setMatrix(template, this._getRotationAngle());
                template._writeTransformation = false;
                this._appearanceTemplate = this._createInkAppearance(template);
                this._dictionary.update('Rect', [rect[0], rect[1], rect[0] + rect[2], rect[1] + rect[3]]);
                if (!isFlatten) {
                    if (this._dictionary.has('AP')) {
                        _removeDuplicateReference(this._dictionary.get('AP'), this._crossReference, 'N');
                    }
                    const dictionary = new _PdfDictionary();
                    this._appearanceTemplate._content.dictionary._updated = true;
                    const reference = this._crossReference._getNextReference();
                    this._crossReference._cacheMap.set(reference, this._appearanceTemplate._content);
                    this._appearanceTemplate._content.reference = reference;
                    dictionary.set('N', reference);
                    dictionary._updated = true;
                    this._dictionary.set('AP', dictionary);
                }
            }
            if (!this._appearanceTemplate && isFlatten && this._dictionary.has('AP')) {
                const dictionary = this._dictionary.get('AP');
                if (dictionary && dictionary.has('N')) {
                    const appearanceStream = dictionary.get('N');
                    const reference = dictionary.getRaw('N');
                    if (appearanceStream) {
                        if (reference) {
                            appearanceStream.reference = reference;
                        }
                        this._appearanceTemplate = new PdfTemplate(appearanceStream, this._crossReference);
                    }
                }
            }
        }
        else {
            this._postProcess();
            if (!this._appearanceTemplate) {
                if (isFlatten) {
                    if (!this._dictionary.has('AP')) {
                        if (this._inkPointsCollection.length === 0) {
                            this._inkPointsCollection = this._obtainInkListCollection();
                        }
                        const rect = this._getInkBoundsValue();
                        const template = new PdfTemplate(rect, this._crossReference);
                        _setMatrix(template, this._getRotationAngle());
                        template._writeTransformation = false;
                        this._appearanceTemplate = this._createInkAppearance(template);
                        this._dictionary.update('Rect', [rect[0], rect[1], rect[0] + rect[2], rect[1] + rect[3]]);
                    }
                    else {
                        const dictionary = this._dictionary.get('AP');
                        if (dictionary && dictionary.has('N')) {
                            const appearanceStream = dictionary.get('N');
                            const reference = dictionary.getRaw('N');
                            if (appearanceStream) {
                                if (reference) {
                                    appearanceStream.reference = reference;
                                }
                                this._appearanceTemplate = new PdfTemplate(appearanceStream, this._crossReference);
                            }
                        }
                    }
                }
            }
        }
        if (typeof this.flattenPopups !== 'undefined' && this.flattenPopups) {
            if (this._isLoaded) {
                this._flattenLoadedPopUp();
            }
            else {
                this._flattenPopUp();
            }
        }
        if (isFlatten &&
            this._appearanceTemplate &&
            this._appearanceTemplate._size !== null &&
            typeof this._appearanceTemplate._size !== 'undefined') {
            const isNormalMatrix = this._validateTemplateMatrix(this._appearanceTemplate._content.dictionary);
            if (!this._appearanceTemplate._content.dictionary.has('Matrix')) {
                const box = this._appearanceTemplate._content.dictionary.getArray('BBox');
                if (box) {
                    this._appearanceTemplate._content.dictionary.update('Matrix', [1, 0, 0, 1, -box[0], -box[1]]);
                }
            }
            this._flattenAnnotationTemplate(this._appearanceTemplate, isNormalMatrix);
        }
    }
    _createInkAppearance(template) {
        const graphics = template.graphics;
        if (this._inkPointsCollection !== null &&
            this._inkPointsCollection.length > 0 &&
            this.color !== null &&
            typeof this._color !== 'undefined') {
            for (let l = 0; l < this._inkPointsCollection.length; l++) {
                if (this._inkPointsCollection[Number.parseInt(l.toString(), 10)].length % 2 === 0) {
                    let inkPoints = this._inkPointsCollection[Number.parseInt(l.toString(), 10)];
                    if (inkPoints.length === 2) {
                        const locx = inkPoints[0] - 0.5;
                        const locy = inkPoints[1] - 0.5;
                        const locw = inkPoints[0] + 0.5;
                        const loch = inkPoints[1] + 0.5;
                        inkPoints = [locx, locy, locw, loch];
                    }
                    const point = new Array(inkPoints.length / 2);
                    let count = 0;
                    for (let j = 0; j < inkPoints.length; j = j + 2) {
                        point[Number.parseInt(count.toString(), 10)] = [inkPoints[Number.parseInt(j.toString(), 10)], inkPoints[j + 1]];
                        count++;
                    }
                    const pathPointCont = count + (count * 2) - 2;
                    const pathPoints = new Array(pathPointCont);
                    let p1 = [];
                    let p2 = [];
                    const value = this._getControlPoints(point, p1, p2);
                    p1 = value.controlP1;
                    p2 = value.controlP2;
                    let index = 0;
                    for (let i = 0; i < pathPointCont - 1; i = i + 3) {
                        pathPoints[Number.parseInt(i.toString(), 10)] = point[Number.parseInt(index.toString(), 10)];
                        pathPoints[i + 1] = p1[Number.parseInt(index.toString(), 10)];
                        pathPoints[i + 2] = p2[Number.parseInt(index.toString(), 10)];
                        index++;
                    }
                    pathPoints[pathPointCont - 1] = point[point.length - 1];
                    if (pathPoints !== null) {
                        const pointsCollection = pathPoints;
                        for (let k = 0; k < pointsCollection.length; k++) {
                            const point = pointsCollection[Number.parseInt(k.toString(), 10)];
                            pointsCollection[Number.parseInt(k.toString(), 10)] = [point[0], (-point[1])];
                        }
                        const path1 = new _PdfPath();
                        let path2 = null;
                        if (point.length === 2) {
                            const width = point[1][0] - point[0][0];
                            const height = point[1][1] - point[0][1];
                            path1._addEllipse(point[0][0] + (0.5), -(point[0][1] + height + (0.5)), width, height);
                            path2 = new _PdfPath();
                            path2._pathTypes = path1._pathTypes;
                            path2._points = path1._points;
                        }
                        else {
                            path1._addBezierPoints(pointsCollection);
                            path2 = new _PdfPath();
                            path2._pathTypes = path1._pathTypes;
                            path2._points = pointsCollection;
                        }
                        const borderPen = new PdfPen(this.color, this.border.width);
                        if (typeof this.opacity !== 'undefined' && this._opacity < 1) {
                            const state = graphics.save();
                            graphics.setTransparency(this._opacity);
                            if (this._isLoaded) {
                                borderPen._lineCap = PdfLineCap.round;
                            }
                            graphics._drawPath(path2, borderPen);
                            graphics.restore(state);
                        }
                        else {
                            graphics._drawPath(path2, borderPen);
                        }
                    }
                }
            }
            if (this._isFlatten) {
                this.bounds = { x: this.bounds.x,
                    y: (this._page.size[1] - (this.bounds.y + this.bounds.height)),
                    width: this.bounds.width,
                    height: this.bounds.height };
            }
        }
        return template;
    }
    _getControlPoints(point, p1, p2) {
        if (point === null) {
            throw new Error('pointCollection');
        }
        const pointCount = point.length - 1;
        if (pointCount < 1) {
            throw new Error('At least two knot PointFs required pointCollection');
        }
        if (pointCount === 1) {
            p1 = [[((2 * point[0][0] + point[1][0]) / 3), ((2 * point[0][1] + point[1][1]) / 3)]];
            p2 = [[(2 * p1[0][0] - point[0][0]), (2 * p1[0][1] - point[0][1])]];
        }
        const rightVector = [];
        for (let i = 1; i < pointCount - 1; ++i) {
            rightVector[Number.parseInt(i.toString(), 10)] = 4 * point[Number.parseInt(i.toString(), 10)][0] + 2 * point[i + 1][0];
        }
        rightVector[0] = point[0][0] + 2 * point[1][0];
        rightVector[pointCount - 1] = (8 * point[pointCount - 1][0] + point[Number.parseInt(pointCount.toString(), 10)][0]) / 2.0;
        const xValue = this._getSingleControlPoint(rightVector);
        for (let i = 1; i < pointCount - 1; ++i) {
            rightVector[Number.parseInt(i.toString(), 10)] = 4 * point[Number.parseInt(i.toString(), 10)][1] + 2 * point[i + 1][1];
        }
        rightVector[0] = point[0][1] + 2 * point[1][1];
        rightVector[pointCount - 1] = (8 * point[pointCount - 1][1] + point[Number.parseInt(pointCount.toString(), 10)][1]) / 2.0;
        const yValue = this._getSingleControlPoint(rightVector);
        p1 = new Array(pointCount);
        p2 = new Array(pointCount);
        for (let i = 0; i < pointCount; ++i) {
            p1[Number.parseInt(i.toString(), 10)] = [xValue[Number.parseInt(i.toString(), 10)], yValue[Number.parseInt(i.toString(), 10)]];
            if (i < pointCount - 1) {
                p2[Number.parseInt(i.toString(), 10)] = [2 * point[i + 1][0] - xValue[i + 1], 2 * point[i + 1][1] - yValue[i + 1]];
            }
            else {
                const x = (point[Number.parseInt(pointCount.toString(), 10)][0] + xValue[pointCount - 1]) / 2;
                const y = (point[Number.parseInt(pointCount.toString(), 10)][1] + yValue[pointCount - 1]) / 2;
                p2[Number.parseInt(i.toString(), 10)] = [x, y];
            }
        }
        return { controlP1: p1, controlP2: p2 };
    }
    _getSingleControlPoint(rightVector) {
        const count = rightVector.length;
        const vector = [];
        const tmpVector = [];
        let divisor = 2.0;
        vector[0] = rightVector[0] / divisor;
        for (let i = 1; i < count; i++) {
            tmpVector[Number.parseInt(i.toString(), 10)] = 1 / divisor;
            divisor = (i < count - 1 ? 4.0 : 3.5) - tmpVector[Number.parseInt(i.toString(), 10)];
            vector[Number.parseInt(i.toString(), 10)] = (rightVector[Number.parseInt(i.toString(), 10)] - vector[i - 1]) / divisor;
        }
        for (let i = 1; i < count; i++) {
            vector[count - i - 1] -= tmpVector[count - i] * vector[count - i];
        }
        return vector;
    }
    _addInkPoints() {
        const inkCollection = [];
        if (this._linePoints !== null && (this._previousCollection.length === 0 || this._isModified)) {
            this._inkPointsCollection.unshift(this._linePoints);
            this._isModified = false;
        }
        const isEqual = _checkInkPoints(this._inkPointsCollection, this._previousCollection);
        if (this._inkPointsCollection !== null && !isEqual) {
            for (let i = 0; i < this._inkPointsCollection.length; i++) {
                const inkList = this._inkPointsCollection[Number.parseInt(i.toString(), 10)];
                inkCollection.push(inkList);
            }
            this._dictionary.update('InkList', inkCollection);
        }
        if (this._inkPointsCollection.length > 0) {
            this._inkPointsCollection.forEach((inkList) => {
                this._previousCollection.push(inkList);
            });
        }
        return this._getInkBoundsValue();
    }
    _getInkBoundsValue() {
        let bounds = [0, 0, 0, 0];
        if (this._points) {
            this.bounds = { x: this._points[0], y: this._points[1], width: this._points[2], height: this._points[3] };
        }
        bounds = [this.bounds.x, this.bounds.y, this.bounds.width, this.bounds.height];
        const borderWidth = this.border.width;
        if (this._inkPointsCollection !== null) {
            if (this._inkPointsCollection.length > 0) {
                const termsList = [];
                for (let i = 0; i < this._inkPointsCollection.length; i++) {
                    const subList = this._inkPointsCollection[Number.parseInt(i.toString(), 10)];
                    if (subList !== null) {
                        if (subList.length % 2 === 0) {
                            for (let j = 0; j < subList.length; j++) {
                                termsList.push(subList[Number.parseInt(j.toString(), 10)]);
                            }
                        }
                    }
                }
                let isTwoPoints = false;
                if (!this._isLoaded && termsList.length === 2) {
                    isTwoPoints = true;
                    termsList.push((termsList[0] + 1));
                    termsList.push((termsList[1] + 1));
                }
                const pointCollection = new Array(termsList.length / 2);
                let count = 0;
                for (let j = 0; j < termsList.length; j = j + 2) {
                    pointCollection[Number.parseInt(count.toString(), 10)] = [termsList[Number.parseInt(j.toString(), 10)],
                        termsList[j + 1]];
                    count++;
                }
                if (this._isLoaded) {
                    if (pointCollection.length > 0) {
                        let xMin = 0;
                        let yMin = 0;
                        let xMax = 0;
                        let yMax = 0;
                        let first = true;
                        for (let i = 0; i < pointCollection.length; i++) {
                            const point = pointCollection[Number.parseInt(i.toString(), 10)];
                            if (first) {
                                xMin = point[0];
                                yMin = point[1];
                                first = false;
                            }
                            else {
                                if (point[0] < xMin) {
                                    xMin = point[0];
                                }
                                else if (point[0] > xMax) {
                                    xMax = point[0];
                                }
                                if (point[1] < yMin) {
                                    yMin = point[1];
                                }
                                else if (point[1] > yMax) {
                                    yMax = point[1];
                                }
                            }
                        }
                        bounds = [xMin, yMin, xMax - xMin, yMax - yMin];
                        this.bounds = { x: bounds[0], y: bounds[1], width: bounds[2], height: bounds[3] };
                        if (this._isFlatten || this._setAppearance) {
                            bounds[0] = this.bounds.x - borderWidth;
                            bounds[1] = this.bounds.y - borderWidth;
                            bounds[2] = this.bounds.width + (2 * borderWidth);
                            bounds[3] = this.bounds.height + (2 * borderWidth);
                        }
                    }
                    else {
                        if (this._points) {
                            bounds = this._points;
                        }
                        else if (pointCollection.length > 0) {
                            bounds = this._dictionary.get('Rect');
                        }
                        else {
                            bounds = [this.bounds.x, this.bounds.y, this.bounds.width, this.bounds.height];
                        }
                    }
                }
                else {
                    bounds = this._calculateInkBounds(pointCollection, bounds, borderWidth, isTwoPoints);
                }
                this.bounds = { x: bounds[0], y: bounds[1], width: bounds[2], height: bounds[3] };
            }
        }
        return bounds;
    }
    _calculateInkBounds(pointCollection, bounds, borderWidth, isTwoPoints) {
        if (pointCollection.length > 5) {
            let xMin = 0;
            let yMin = 0;
            let xMax = 0;
            let yMax = 0;
            let first = true;
            for (let i = 0; i < pointCollection.length; i++) {
                const point = pointCollection[Number.parseInt(i.toString(), 10)];
                if (first) {
                    xMin = point[0];
                    yMin = point[1];
                    xMax = point[0];
                    yMax = point[1];
                    first = false;
                }
                else {
                    if (point[0] < xMin) {
                        xMin = point[0];
                    }
                    else if (point[0] > xMax) {
                        xMax = point[0];
                    }
                    if (point[1] < yMin) {
                        yMin = point[1];
                    }
                    else if (point[1] > yMax) {
                        yMax = point[1];
                    }
                }
            }
            if (bounds[2] < xMax) {
                xMax = bounds[2];
            }
            if (bounds[3] < yMax) {
                yMax = bounds[3];
            }
            bounds = [xMin, yMin, xMax, yMax];
            if (this._isFlatten || this._setAppearance) {
                const factor = isTwoPoints ? 2 : 3;
                bounds[0] = bounds[0] - borderWidth;
                bounds[1] = bounds[1] - borderWidth;
                bounds[2] = bounds[2] + (factor * borderWidth);
                bounds[3] = bounds[3] + (factor * borderWidth);
            }
        }
        else {
            if (typeof this._points === 'undefined' && pointCollection.length > 0) {
                bounds = this._dictionary.get('Rect');
            }
            else {
                bounds = this._points;
            }
        }
        return bounds;
    }
    _obtainInkListCollection() {
        const path = [];
        if (this._dictionary.has('InkList')) {
            const inkList = this._dictionary.getArray('InkList');
            const list = [];
            for (let i = 0; i < inkList.length; i++) {
                const innerList = inkList[Number.parseInt(i.toString(), 10)];
                for (let j = 0; j < innerList.length; j++) {
                    list.push(innerList[Number.parseInt(j.toString(), 10)]);
                }
                path.push(list);
            }
        }
        return path;
    }
}
/**
 * `PdfPopupAnnotation` class represents the popup annotation objects.
 * ```typescript
 * // Load an existing PDF document
 * let document: PdfDocument = new PdfDocument(data, password);
 * // Get the first page
 * let page: PdfPage = document.getPage(0) as PdfPage;
 * // Create a new popup annotation
 * const annotation: PdfPopupAnnotation = new PdfPopupAnnotation('Test popup annotation', 10, 40, 30, 30);
 * // Add annotation to the page
 * page.annotations.add(annotation);
 * // Destroy the document
 * document.destroy();
 * ```
 */
class PdfPopupAnnotation extends PdfComment {
    constructor(text, x, y, width, height) {
        super();
        this._icon = PdfPopupIcon.note;
        this._iconString = '';
        this._stateModel = PdfAnnotationStateModel.none;
        this._state = PdfAnnotationState.none;
        this._open = false;
        this._isReview = false;
        this._isComment = false;
        this._dictionary = new _PdfDictionary();
        this._dictionary.update('Type', _PdfName.get('Annot'));
        this._dictionary.update('Subtype', _PdfName.get('Text'));
        if (typeof text !== 'undefined') {
            this.text = text;
        }
        if (typeof x !== 'undefined' && typeof y !== 'undefined' && typeof width !== 'undefined' && typeof height !== 'undefined') {
            this.bounds = { x, y, width, height };
        }
        this._type = _PdfAnnotationType.popupAnnotation;
    }
    /**
     * Gets the boolean flag indicating whether annotation has open or not.
     *
     * @returns {boolean} Caption.
     * ```typescript
     * // Load an existing PDF document
     * let document: PdfDocument = new PdfDocument(data, password);
     * // Get the first page
     * let page: PdfPage = document.getPage(0) as PdfPage;
     * // Get the first annotation of the page
     * let annotation: PdfPopupAnnotation = page.annotations.at(0) as PdfPopupAnnotation;
     * // Gets the boolean flag indicating whether annotation has open or not.
     * let open: boolean =  annotation.open;
     * // Destroy the document
     * document.destroy();
     * ```
     */
    get open() {
        if (this._dictionary.has('Open')) {
            this._open = this._dictionary.get('Open');
        }
        return this._open;
    }
    /**
     * Sets the boolean flag indicating whether annotation has open or not.
     *
     * @param {boolean} value Open.
     * ```typescript
     * // Load an existing PDF document
     * let document: PdfDocument = new PdfDocument(data, password);
     * // Get the first page
     * let page: PdfPage = document.getPage(0) as PdfPage;
     * // Get the first annotation of the page
     * let annotation: PdfPopupAnnotation = page.annotations.at(0) as PdfPopupAnnotation;
     * // Sets the boolean flag indicating whether annotation has open or not.
     * annotation.open = true;
     * // Save the document
     * document.save('output.pdf');
     * // Destroy the document
     * document.destroy();
     * ```
     */
    set open(value) {
        if (typeof value !== 'undefined') {
            this._open = value;
            this._dictionary.update('Open', this._open);
        }
    }
    /**
     * Gets the icon type of the popup annotation.
     *
     * @returns {PdfPopupIcon} Annotation icon.
     * ```typescript
     * // Load an existing PDF document
     * let document: PdfDocument = new PdfDocument(data, password);
     * // Get the first page
     * let page: PdfPage = document.getPage(0) as PdfPage;
     * // Get the first annotation of the page
     * let annotation: PdfPopupAnnotation = page.annotations.at(0) as PdfPopupAnnotation;
     * // Gets the icon type of the popup annotation.
     * let icon: PdfPopupIcon = annotation.icon;
     * // Destroy the document
     * document.destroy();
     * ```
     */
    get icon() {
        if (this._dictionary.has('Name')) {
            this._icon = _mapPopupIcon(this._dictionary.get('Name').name);
        }
        return this._icon;
    }
    /**
     * Sets the icon type of the popup annotation.
     *
     * @param {PdfPopupIcon} value Annotation icon.
     * ```typescript
     * // Load an existing PDF document
     * let document: PdfDocument = new PdfDocument(data, password);
     * // Get the first page
     * let page: PdfPage = document.getPage(0) as PdfPage;
     * // Get the first annotation of the page
     * let annotation: PdfPopupAnnotation = page.annotations.at(0) as PdfPopupAnnotation;
     * // Sets the icon type of the popup annotation.
     * annotation.icon = PdfPopupIcon.newParagraph;
     * // Save the document
     * document.save('output.pdf');
     * // Destroy the document
     * document.destroy();
     * ```
     */
    set icon(value) {
        if (typeof value !== 'undefined') {
            this._icon = value;
            this._dictionary.update('Name', _PdfName.get(this._obtainIconName(this._icon)));
        }
    }
    /**
     * Gets the state model of the popup annotation.
     *
     * @returns {PdfAnnotationStateModel} Annotation State Model.
     * ```typescript
     * // Load an existing PDF document
     * let document: PdfDocument = new PdfDocument(data, password);
     * // Get the first page
     * let page: PdfPage = document.getPage(0) as PdfPage;
     * // Get the first annotation of the page
     * let annotation: PdfPopupAnnotation = page.annotations.at(0) as PdfPopupAnnotation;
     * // Gets the state model of the popup annotation.
     * let stateModel: PdfAnnotationStateModel = annotation.stateModel;
     * // Destroy the document
     * document.destroy();
     * ```
     */
    get stateModel() {
        if (this._dictionary.has('StateModel')) {
            this._stateModel = _mapAnnotationStateModel(this._dictionary.get('StateModel'));
        }
        return this._stateModel;
    }
    /**
     * Sets the state model of the popup annotation.
     *
     * @param {PdfAnnotationStateModel} value Annotation State Model.
     * ```typescript
     * // Load an existing PDF document
     * let document: PdfDocument = new PdfDocument(data, password);
     * // Get the first page
     * let page: PdfPage = document.getPage(0) as PdfPage;
     * // Get the first annotation of the page
     * let annotation: PdfPopupAnnotation = page.annotations.at(0) as PdfPopupAnnotation;
     * // Sets the state model of the popup annotation.
     * annotation.stateModel = PdfAnnotationStateModel.marked;
     * // Save the document
     * document.save('output.pdf');
     * // Destroy the document
     * document.destroy();
     * ```
     */
    set stateModel(value) {
        if (typeof value !== 'undefined') {
            this._stateModel = value;
            this._dictionary.update('StateModel', _reverseMapAnnotationStateModel(this._stateModel));
        }
    }
    /**
     * Gets the state of the popup annotation.
     *
     * @returns {PdfAnnotationState} Annotation State.
     * ```typescript
     * // Load an existing PDF document
     * let document: PdfDocument = new PdfDocument(data, password);
     * // Get the first page
     * let page: PdfPage = document.getPage(0) as PdfPage;
     * // Get the first annotation of the page
     * let annotation: PdfPopupAnnotation = page.annotations.at(0) as PdfPopupAnnotation;
     * // Gets the state of the popup annotation.
     * let state: PdfAnnotationState = annotation.state;
     * // Destroy the document
     * document.destroy();
     * ```
     */
    get state() {
        if (this._dictionary.has('State')) {
            this._state = _mapAnnotationState(this._dictionary.get('State'));
        }
        return this._state;
    }
    /**
     * Sets the state of the popup annotation.
     *
     * @param {PdfAnnotationState} value Annotation State.
     * ```typescript
     * // Load an existing PDF document
     * let document: PdfDocument = new PdfDocument(data, password);
     * // Get the first page
     * let page: PdfPage = document.getPage(0) as PdfPage;
     * // Get the first annotation of the page
     * let annotation: PdfPopupAnnotation = page.annotations.at(0) as PdfPopupAnnotation;
     * // Sets the state of the popup annotation.
     * annotation.state = PdfAnnotationState.completed;
     * // Save the document
     * document.save('output.pdf');
     * // Destroy the document
     * document.destroy();
     * ```
     */
    set state(value) {
        if (typeof value !== 'undefined') {
            this._state = value;
            this._dictionary.update('State', _reverseMapAnnotationState(this._state));
        }
    }
    static _load(page, dictionary) {
        const annot = new PdfPopupAnnotation();
        annot._isLoaded = true;
        annot._initialize(page, dictionary);
        if (dictionary.has('IRT')) {
            annot._isReview = _checkReview(dictionary);
            if (!annot._isReview) {
                annot._isComment = _checkComment(dictionary);
            }
        }
        return annot;
    }
    _initialize(page, dictionary) {
        super._initialize(page, dictionary);
    }
    _postProcess() {
        if (typeof this.bounds === 'undefined' || this.bounds === null) {
            this._bounds = { x: 0, y: 0, width: 0, height: 0 };
        }
        let borderWidth;
        if (this._dictionary.has('BS')) {
            borderWidth = this.border.width;
        }
        else {
            const dictionary = new _PdfDictionary(this._crossReference);
            dictionary.set('Type', _PdfName.get('Border'));
            this._dictionary.set('BS', dictionary);
        }
        if (typeof borderWidth === 'undefined') {
            borderWidth = 1;
        }
        const rectangle = [this.bounds.x, this.bounds.y, (this.bounds.x + this.bounds.width),
            (this.bounds.y + this.bounds.height)];
        this._dictionary.update('Rect', rectangle);
        if (this._setAppearance) {
            this._appearanceTemplate = this._createPopupAppearance();
            if (this._appearanceTemplate) {
                if (this._dictionary.has('AP')) {
                    _removeDuplicateReference(this._dictionary.get('AP'), this._crossReference, 'N');
                }
                const dictionary = new _PdfDictionary();
                this._appearanceTemplate._content.dictionary._updated = true;
                const reference = this._crossReference._getNextReference();
                this._crossReference._cacheMap.set(reference, this._appearanceTemplate._content);
                this._appearanceTemplate._content.reference = reference;
                dictionary.set('N', reference);
                dictionary._updated = true;
                this._dictionary.set('AP', dictionary);
            }
        }
        const size = this._page.size;
        const rect = [this.bounds.x,
            size[1] - (this.bounds.y + this.bounds.height),
            this.bounds.width,
            this.bounds.height];
        this._dictionary.update('Rect', [rect[0], rect[1], rect[0] + rect[2], rect[1] + rect[3]]);
    }
    _doPostProcess(isFlatten = false) {
        if (this._isLoaded) {
            if (!this._appearanceTemplate && this._isFlattenPopups && this._dictionary.has('AP')) {
                const dictionary = this._dictionary.get('AP');
                if (dictionary && dictionary.has('N')) {
                    const appearanceStream = dictionary.get('N');
                    const reference = dictionary.getRaw('N');
                    if (appearanceStream) {
                        if (reference) {
                            appearanceStream.reference = reference;
                        }
                        this._appearanceTemplate = new PdfTemplate(appearanceStream, this._crossReference);
                    }
                    if (this._appearanceTemplate !== null) {
                        const state = this._page.graphics.save();
                        if (this.opacity < 1) {
                            this._page.graphics.setTransparency(this.opacity);
                        }
                        this._page.graphics._drawTemplate(this._appearanceTemplate, this.bounds);
                        this._page.graphics.restore(state);
                    }
                }
            }
        }
        else {
            this._postProcess();
            if (!this._appearanceTemplate) {
                if (isFlatten) {
                    if (!this._dictionary.has('AP')) {
                        this._appearanceTemplate = this._createPopupAppearance();
                    }
                    else {
                        const dictionary = this._dictionary.get('AP');
                        if (dictionary && dictionary.has('N')) {
                            const appearanceStream = dictionary.get('N');
                            const reference = dictionary.getRaw('N');
                            if (appearanceStream) {
                                if (reference) {
                                    appearanceStream.reference = reference;
                                }
                                this._appearanceTemplate = new PdfTemplate(appearanceStream, this._crossReference);
                            }
                        }
                    }
                }
            }
        }
        if (typeof this.flattenPopups !== 'undefined' && this.flattenPopups && this.flatten) {
            if (this._isLoaded) {
                this._flattenLoadedPopUp();
            }
            else {
                this._flattenPopUp();
            }
        }
        if (isFlatten) {
            this._removeAnnotation(this._page, this);
        }
    }
    _createPopupAppearance() {
        let template;
        if (this._dictionary.has('Name')) {
            if (this._dictionary.get('Name').name === 'Comment') {
                if (this._dictionary.has('Rect')) {
                    const nativeRectangle = [0, 0, this.bounds.width, this.bounds.height];
                    template = new PdfTemplate(nativeRectangle, this._crossReference);
                    _setMatrix(template, this._getRotationAngle());
                    const graphics = template.graphics;
                    const rectValue = this._dictionary.getArray('Rect');
                    if (rectValue !== null) {
                        const pen = new PdfPen([0, 0, 0], 0.3);
                        let brush = new PdfBrush(this.color);
                        const pen1 = new PdfPen([255, 255, 255], 1);
                        const points = new Array();
                        points.push([6, 8]);
                        points.push([9, 8]);
                        points.push([4, 12]);
                        const path = new _PdfPath();
                        if (this.color[0] === 0 && this.color[0] === 0 && this.color[0] === 0) {
                            brush = new PdfBrush([255, 215, 0]);
                        }
                        graphics.save();
                        const template = new PdfTemplate([0, 0, 15, 14], this._crossReference);
                        template.graphics.drawRectangle(0, 0, 15, 14, pen, brush);
                        template.graphics.drawPolygon(points, pen, new PdfBrush([255, 255, 255]));
                        path._addEllipse(2, 2, 11, 8);
                        template.graphics._drawPath(path, pen, new PdfBrush([255, 255, 255]));
                        template.graphics.drawArc(2, 2, 11, 8, 108, 12.7, pen1);
                        template.graphics.drawLine(pen, 4, 12, 6.5, 10);
                        graphics._drawTemplate(template, { x: 0, y: 0, width: this.bounds.width, height: this.bounds.height });
                        graphics.restore();
                    }
                }
            }
        }
        return template;
    }
    _obtainIconName(icon) {
        switch (icon) {
            case PdfPopupIcon.note:
                this._iconString = 'Note';
                break;
            case PdfPopupIcon.comment:
                this._iconString = 'Comment';
                break;
            case PdfPopupIcon.help:
                this._iconString = 'Help';
                break;
            case PdfPopupIcon.insert:
                this._iconString = 'Insert';
                break;
            case PdfPopupIcon.key:
                this._iconString = 'Key';
                break;
            case PdfPopupIcon.newParagraph:
                this._iconString = 'NewParagraph';
                break;
            case PdfPopupIcon.paragraph:
                this._iconString = 'Paragraph';
                break;
        }
        return this._iconString;
    }
}
/**
 * `PdfFileLinkAnnotation` class represents the link annotation objects.
 * ```typescript
 * // Load an existing PDF document
 * let document: PdfDocument = new PdfDocument(data, password);
 * // Get the first page
 * let page: PdfPage = document.getPage(0) as PdfPage;
 * // Create a new file link annotation
 * let annotation: PdfFileLinkAnnotation = new PdfFileLinkAnnotation(10, 40, 30, 30, "image.png");
 * // Add annotation to the page
 * page.annotations.add(annotation);
 * // Destroy the document
 * document.destroy();
 * ```
 */
class PdfFileLinkAnnotation extends PdfAnnotation {
    constructor(x, y, width, height, fileName) {
        super();
        this._dictionary = new _PdfDictionary();
        this._dictionary.update('Type', _PdfName.get('Annot'));
        this._dictionary.update('Subtype', _PdfName.get('Link'));
        if (typeof x !== 'undefined' && typeof y !== 'undefined' && typeof width !== 'undefined' && typeof height !== 'undefined') {
            this.bounds = { x, y, width, height };
        }
        if (typeof fileName !== 'undefined' && fileName !== null) {
            this._fileName = fileName;
        }
        this._type = _PdfAnnotationType.fileLinkAnnotation;
    }
    /**
     * Gets the action of the annotation.
     *
     * @returns {string} Action.
     * ```typescript
     * // Load an existing PDF document
     * let document: PdfDocument = new PdfDocument(data, password);
     * // Get the first page
     * let page: PdfPage = document.getPage(0) as PdfPage;
     * // Get the first annotation of the page
     * let annotation: PdfFileLinkAnnotation = page.annotations.at(0) as PdfFileLinkAnnotation;
     * // Gets the action of the annotation.
     * let action: string = annotation.action;
     * // Destroy the document
     * document.destroy();
     * ```
     */
    get action() {
        if (typeof this._action === 'undefined' && this._dictionary.has('A')) {
            const dictionary = this._dictionary.get('A');
            if (dictionary && dictionary.has('Next')) {
                const action = dictionary.get('Next');
                if (Array.isArray(action)) {
                    for (let i = 0; i < action.length; i++) {
                        const reference = action[Number.parseInt(i.toString(), 10)];
                        if (reference && reference instanceof _PdfReference) {
                            const actionDictionary = this._crossReference._fetch(reference);
                            if (actionDictionary.has('JS')) {
                                this._action = actionDictionary.get('JS');
                            }
                        }
                    }
                }
            }
        }
        return this._action;
    }
    /**
     * Sets the action of the annotation.
     *
     * @param {string} value Action.
     * ```typescript
     * // Load an existing PDF document
     * let document: PdfDocument = new PdfDocument(data, password);
     * // Get the first page
     * let page: PdfPage = document.getPage(0) as PdfPage;
     * // Get the first annotation of the page
     * let annotation: PdfFileLinkAnnotation = page.annotations.at(0) as PdfFileLinkAnnotation;
     * // Sets the action of the annotation.
     * annotation.action = ‘syncfusion’;
     * // Save the document
     * document.save('output.pdf');
     * // Destroy the document
     * document.destroy();
     * ```
     */
    set action(value) {
        if (!this._isLoaded && typeof value === 'string') {
            this._action = value;
        }
        if (this._isLoaded && typeof value === 'string') {
            if (this.action !== value && this._dictionary.has('A')) {
                const dictionary = this._dictionary.get('A');
                if (dictionary && dictionary.has('Next')) {
                    const action = dictionary.get('Next');
                    if (Array.isArray(action)) {
                        for (let i = 0; i < action.length; i++) {
                            const reference = action[Number.parseInt(i.toString(), 10)];
                            if (reference && reference instanceof _PdfReference) {
                                const actionDictionary = this._crossReference._fetch(reference);
                                if (actionDictionary.has('JS')) {
                                    actionDictionary.update('JS', value);
                                    this._action = value;
                                    this._dictionary._updated = true;
                                }
                            }
                        }
                    }
                }
            }
        }
    }
    static _load(page, dictionary) {
        const annot = new PdfFileLinkAnnotation();
        annot._isLoaded = true;
        annot._initialize(page, dictionary);
        return annot;
    }
    _initialize(page, dictionary) {
        super._initialize(page, dictionary);
    }
    _postProcess() {
        if (typeof this.bounds === 'undefined' || this.bounds === null) {
            throw new Error('Bounds cannot be null or undefined');
        }
        let borderWidth;
        if (this._dictionary.has('BS')) {
            borderWidth = this.border.width;
        }
        else {
            const dictionary = new _PdfDictionary(this._crossReference);
            dictionary.set('Type', _PdfName.get('Border'));
            this._dictionary.set('BS', dictionary);
        }
        if (typeof borderWidth === 'undefined') {
            borderWidth = 1;
        }
        this._addAction();
        const size = this._page.size;
        const rect = [this.bounds.x,
            size[1] - (this.bounds.y + this.bounds.height),
            this.bounds.width,
            this.bounds.height];
        this._dictionary.update('Rect', [rect[0], rect[1], rect[0] + rect[2], rect[1] + rect[3]]);
    }
    _addAction() {
        if (this._dictionary.has('A')) {
            const action = this._dictionary.get('A');
            if (action) {
                if (typeof this._action !== 'undefined' && this._action !== null && action.has('Next')) {
                    const nextAction = action.get('Next');
                    if (Array.isArray(nextAction) && nextAction.length > 0) {
                        nextAction.forEach((reference) => {
                            if (reference && reference instanceof _PdfReference && reference._isNew) {
                                this._crossReference._cacheMap.delete(reference);
                            }
                        });
                    }
                }
                if (action.has('F')) {
                    _removeDuplicateReference(action, this._crossReference, 'F');
                }
            }
            _removeDuplicateReference(this._dictionary, this._crossReference, 'A');
        }
        const dictionary = new _PdfDictionary();
        dictionary.set('Type', _PdfName.get('Action'));
        dictionary.set('S', _PdfName.get('Launch'));
        const fileDictionary = new _PdfDictionary();
        fileDictionary.set('Type', _PdfName.get('Filespec'));
        fileDictionary.set('UF', this._fileName);
        if (typeof this._action !== 'undefined' && this._action !== null) {
            const actionDictionary = new _PdfDictionary();
            actionDictionary.set('Type', _PdfName.get('Action'));
            actionDictionary.set('S', _PdfName.get('JavaScript'));
            actionDictionary.set('JS', this._action);
            const ref = this._crossReference._getNextReference();
            this._crossReference._cacheMap.set(ref, actionDictionary);
            actionDictionary._updated = true;
            dictionary.set('Next', [ref]);
        }
        const reference = this._crossReference._getNextReference();
        this._crossReference._cacheMap.set(reference, fileDictionary);
        fileDictionary._updated = true;
        dictionary.set('F', reference);
        dictionary._updated = true;
        this._dictionary.set('A', dictionary);
    }
    _doPostProcess(isFlatten = false) {
        if (!this._isLoaded) {
            this._postProcess();
        }
        if (isFlatten) {
            let appearanceStream;
            if (this._dictionary.has('AP')) {
                const dictionary = this._dictionary.get('AP');
                if (dictionary && dictionary.has('N')) {
                    appearanceStream = dictionary.get('N');
                    const reference = dictionary.getRaw('N');
                    if (reference && appearanceStream) {
                        appearanceStream.reference = reference;
                    }
                }
            }
            if (appearanceStream) {
                const template = new PdfTemplate(appearanceStream, this._crossReference);
                const isNormalMatrix = this._validateTemplateMatrix(template._content.dictionary);
                this._flattenAnnotationTemplate(template, isNormalMatrix);
            }
            else {
                this._removeAnnotation(this._page, this);
            }
        }
    }
}
/**
 * `PdfUriAnnotation` class represents the URI annotation objects.
 * ```typescript
 * // Load an existing PDF document
 * let document: PdfDocument = new PdfDocument(data, password);
 * // Get the first page
 * let page: PdfPage = document.getPage(0) as PdfPage;
 * // Create a new URI annotation
 * let annotation: PdfUriAnnotation = new PdfUriAnnotation(100, 150, 200, 100, ‘http://www.google.com’);
 * // Add annotation to the page
 * page.annotations.add(annotation);
 * // Destroy the document
 * document.destroy();
 * ```
 */
class PdfUriAnnotation extends PdfAnnotation {
    constructor(x, y, width, height, uri) {
        super();
        this._dictionary = new _PdfDictionary();
        this._dictionary.update('Type', _PdfName.get('Annot'));
        this._dictionary.update('Subtype', _PdfName.get('Link'));
        if (typeof x !== 'undefined' && typeof y !== 'undefined' && typeof width !== 'undefined' && typeof height !== 'undefined') {
            this.bounds = { x, y, width, height };
        }
        if (typeof uri !== 'undefined' && uri !== null) {
            this._uri = uri;
        }
        this._type = _PdfAnnotationType.uriAnnotation;
    }
    /**
     * Gets the uri of the annotation.
     *
     * @returns {string} Uri.
     * ```typescript
     * // Load an existing PDF document
     * let document: PdfDocument = new PdfDocument(data, password);
     * // Get the first page
     * let page: PdfPage = document.getPage(0) as PdfPage;
     * // Get the first annotation of the page
     * let annotation: PdfUriAnnotation = page.annotations.at(0) as PdfUriAnnotation;
     * // Gets the uri of the annotation.
     * let uri: string = annotation.uri;
     * // Destroy the document
     * document.destroy();
     * ```
     */
    get uri() {
        if (typeof this._uri === 'undefined' && this._dictionary.has('A')) {
            const linkDict = this._dictionary.get('A');
            if (linkDict.has('URI')) {
                this._uri = linkDict.get('URI');
            }
        }
        return this._uri;
    }
    /**
     * Sets the uri of the annotation.
     *
     * @param {string} value Uri.
     * ```typescript
     * // Load an existing PDF document
     * let document: PdfDocument = new PdfDocument(data, password);
     * // Get the first page
     * let page: PdfPage = document.getPage(0) as PdfPage;
     * // Create a new URI annotation
     * let annotation: PdfUriAnnotation = new PdfUriAnnotation(100, 150, 200, 100);
     * // Sets the uri of the annotation
     * annotation.uri = ‘http://www.google.com’;
     * // Add annotation to the page
     * page.annotations.add(annotation);
     * // Destroy the document
     * document.destroy();
     * ```
     */
    set uri(value) {
        if (typeof value === 'string') {
            if (this._isLoaded && this._dictionary.has('A') && value !== this.uri) {
                const linkDict = this._dictionary.get('A');
                if (linkDict.has('URI')) {
                    this._uri = value;
                    linkDict.update('URI', value);
                    this._dictionary._updated = true;
                }
            }
            else {
                this._uri = value;
            }
        }
    }
    static _load(page, dictionary) {
        const annot = new PdfUriAnnotation();
        annot._isLoaded = true;
        annot._initialize(page, dictionary);
        return annot;
    }
    _initialize(page, dictionary) {
        super._initialize(page, dictionary);
    }
    _postProcess() {
        if (typeof this.bounds === 'undefined' || this.bounds === null) {
            throw new Error('Bounds cannot be null or undefined');
        }
        let borderWidth;
        if (this._dictionary.has('BS')) {
            borderWidth = this.border.width;
        }
        else {
            const dictionary = new _PdfDictionary(this._crossReference);
            dictionary.set('Type', _PdfName.get('Border'));
            this._dictionary.set('BS', dictionary);
        }
        if (typeof borderWidth === 'undefined') {
            borderWidth = 1;
        }
        this._addAction();
        const size = this._page.size;
        const rect = [this.bounds.x,
            size[1] - (this.bounds.y + this.bounds.height),
            this.bounds.width,
            this.bounds.height];
        this._dictionary.update('Rect', [rect[0], rect[1], rect[0] + rect[2], rect[1] + rect[3]]);
    }
    _addAction() {
        const dictionary = new _PdfDictionary();
        dictionary.set('Type', _PdfName.get('Action'));
        dictionary.set('S', _PdfName.get('URI'));
        if (typeof this._uri !== 'undefined') {
            dictionary.set('URI', this._uri);
        }
        dictionary._updated = true;
        this._dictionary.set('A', dictionary);
        this._dictionary.update('Border', [this.border.hRadius, this.border.vRadius, this.border.width]);
    }
    _doPostProcess(isFlatten = false) {
        if (!this._isLoaded) {
            this._postProcess();
        }
        if (isFlatten) {
            let appearanceStream;
            if (this._dictionary.has('AP')) {
                const dictionary = this._dictionary.get('AP');
                if (dictionary && dictionary.has('N')) {
                    appearanceStream = dictionary.get('N');
                    const reference = dictionary.getRaw('N');
                    if (reference && appearanceStream) {
                        appearanceStream.reference = reference;
                    }
                }
            }
            if (appearanceStream) {
                const template = new PdfTemplate(appearanceStream, this._crossReference);
                const isNormalMatrix = this._validateTemplateMatrix(template._content.dictionary);
                this._flattenAnnotationTemplate(template, isNormalMatrix);
            }
            else {
                this._removeAnnotation(this._page, this);
            }
        }
    }
}
/**
 * `PdfDocumentLinkAnnotation` class represents the document link annotation objects.
 * ```typescript
 * // Load an existing PDF document
 * let document: PdfDocument = new PdfDocument(data, password);
 * // Get the first page
 * let page: PdfPage = document.getPage(0) as PdfPage;
 * // Create a new document link annotation
 * let annotation: PdfDocumentLinkAnnotation = new PdfDocumentLinkAnnotation(100, 150, 40, 60);
 * // Add annotation to the page
 * page.annotations.add(annotation);
 * // Destroy the document
 * document.destroy();
 * ```
 */
class PdfDocumentLinkAnnotation extends PdfAnnotation {
    constructor(x, y, width, height) {
        super();
        this._dictionary = new _PdfDictionary();
        this._dictionary.update('Type', _PdfName.get('Annot'));
        this._dictionary.update('Subtype', _PdfName.get('Link'));
        if (typeof x !== 'undefined' && typeof y !== 'undefined' && typeof width !== 'undefined' && typeof height !== 'undefined') {
            this.bounds = { x, y, width, height };
        }
        this._type = _PdfAnnotationType.documentLinkAnnotation;
    }
    /**
     * Gets the destination of the annotation.
     *
     * @returns {PdfDestination} Destination.
     * ```typescript
     * // Load an existing PDF document
     * let document: PdfDocument = new PdfDocument(data, password);
     * // Get the first page
     * let page: PdfPage = document.getPage(0) as PdfPage;
     * // Get the first annotation of the page
     * let annotation: PdfDocumentLinkAnnotation = page.annotations.at(0) as PdfDocumentLinkAnnotation;
     * // Gets the destination of the annotation.
     * let destination: PdfDestination =annotation.destination;
     * // Destroy the document
     * document.destroy();
     * ```
     */
    get destination() {
        if (this._isLoaded) {
            this.destination = this._obtainDestination();
        }
        return this._destination;
    }
    /**
     * Sets the destination of the annotation.
     *
     * @param {PdfDestination} value Destination.
     * ```typescript
     * // Load an existing PDF document
     * let document: PdfDocument = new PdfDocument(data, password);
     * // Access first page
     * let page: PdfPage = document.getPage(0);
     * // Access the annotation at index 0
     * let annotation: PdfDocumentLinkAnnotation = page.annotations.at(0) as PdfDocumentLinkAnnotation;
     * // Initializes a new instance of the `PdfDestination` class.
     * let destination: PdfDestination = new PdfDestination();
     * // Sets the zoom factor.
     * destination.zoom = 20;
     * // Sets the page where the destination is situated.
     * destination.page = page;
     * // Sets the mode of the destination.
     * destination.mode = PdfDestinationMode.fitToPage;
     * // Sets the location of the destination.
     * destination.location = [20, 20];
     * // Sets the bounds of the destination.
     * destination.destinationBounds = [20, 20, 100, 50];
     * // Sets destination to document link annotation.
     * annotation.destination = destination;
     * // Save the document
     * document.save('output.pdf');
     * // Destroy the document
     * document.destroy();
     * ```
     */
    set destination(value) {
        if (value !== null) {
            this._destination = value;
        }
    }
    static _load(page, dictionary) {
        const annot = new PdfDocumentLinkAnnotation();
        annot._isLoaded = true;
        annot._initialize(page, dictionary);
        return annot;
    }
    _initialize(page, dictionary) {
        super._initialize(page, dictionary);
    }
    _postProcess() {
        if (typeof this.bounds === 'undefined' || this.bounds === null) {
            throw new Error('Bounds cannot be null or undefined');
        }
        this._addDocument();
        const size = this._page.size;
        const rect = [this.bounds.x,
            size[1] - (this.bounds.y + this.bounds.height),
            this.bounds.width,
            this.bounds.height];
        this._dictionary.update('Rect', [rect[0], rect[1], rect[0] + rect[2], rect[1] + rect[3]]);
    }
    _obtainDestination() {
        if (this._dictionary.has('Dest')) {
            const array = this._dictionary.get('Dest'); // eslint-disable-line
            let holder;
            if (array[0] instanceof _PdfReference) {
                holder = array[0];
            }
            if ((typeof holder === 'undefined' || holder === null) && typeof array[0] === 'number') {
                const pageNumber = array[0];
                const page = this._crossReference._document.getPage(pageNumber);
                if (page) {
                    const mode = array[1];
                    if (mode.name === 'XYZ') {
                        const left = array[2];
                        const top = array[3];
                        const zoom = array[4];
                        const topValue = (typeof top !== 'undefined' && top !== null) ? (page.size[1] - top) : 0;
                        const leftValue = (typeof left !== 'undefined' && left !== null) ? left : 0;
                        this._destination = new PdfDestination(page, [leftValue, topValue]);
                        if (typeof zoom !== 'undefined' && zoom !== null) {
                            this._destination.zoom = zoom;
                        }
                        if ((typeof left === 'undefined' && left === null) || (typeof top === 'undefined' && top === null)
                            || (typeof zoom === 'undefined' && zoom === null)) {
                            this._destination._setValidation(false);
                        }
                    }
                    else {
                        this._destination = new PdfDestination(page);
                        this._destination.mode = PdfDestinationMode.fitToPage;
                    }
                }
            }
            if (holder) {
                const index = _getPageIndex(this._crossReference._document, this._crossReference._fetch(holder));
                const page = this._crossReference._document.getPage(index);
                if (array[1] instanceof _PdfName) {
                    const mode = array[1];
                    if (mode) {
                        if (mode.name === 'XYZ') {
                            const left = array[2];
                            const top = array[3];
                            const zoom = array[4];
                            const topValue = (typeof top !== 'undefined' && top !== null) ? (page.size[1] - top) : 0;
                            const leftValue = (typeof left !== 'undefined' && left !== null) ? left : 0;
                            this._destination = new PdfDestination(page, [leftValue, topValue]);
                            if (typeof zoom !== 'undefined' && zoom !== null) {
                                this._destination.zoom = zoom;
                            }
                            if ((typeof left === 'undefined' && left === null) || (typeof top === 'undefined' && top === null)
                                || (typeof zoom === 'undefined' && zoom === null)) {
                                this._destination._setValidation(false);
                            }
                        }
                        else {
                            if (page && mode.name === 'Fit') {
                                this._destination = new PdfDestination(page);
                                this._destination.mode = PdfDestinationMode.fitToPage;
                            }
                        }
                    }
                }
            }
        }
        else if (this._dictionary.has('A') && !this._destination) {
            const action = this._dictionary.get('A');
            if (action.has('D')) {
                const reference = action.get('D'); // eslint-disable-line
                if (reference !== null && typeof reference !== 'undefined') {
                    let referenceArray; // eslint-disable-line
                    if (Array.isArray(reference)) {
                        referenceArray = reference;
                    }
                    else if (reference instanceof _PdfReference) {
                        const referenceValue = this._crossReference._fetch(reference); // eslint-disable-line
                        if (Array.isArray(referenceValue)) {
                            referenceArray = referenceValue;
                        }
                    }
                    if (referenceArray && (referenceArray[0] instanceof _PdfReference || typeof referenceArray[0] === 'number')) {
                        const document = this._crossReference._document;
                        let index;
                        if (referenceArray[0] instanceof _PdfReference) {
                            index = _getPageIndex(document, this._crossReference._fetch(referenceArray[0]));
                        }
                        else {
                            index = referenceArray[0];
                        }
                        const page = document.getPage(index);
                        if (page) {
                            const mode = referenceArray[1];
                            if (mode.name === 'FitBH' || mode.name === 'FitH') {
                                const top = referenceArray[2];
                                const topValue = (typeof top !== 'undefined' && top !== null) ? (page.size[1] - top) : 0;
                                this._destination = new PdfDestination(page, [0, topValue]);
                                if (typeof top === 'undefined' || top === null) {
                                    this._destination._setValidation(false);
                                }
                            }
                            else if (mode.name === 'XYZ') {
                                const left = referenceArray[2];
                                const top = referenceArray[3];
                                const zoom = referenceArray[4];
                                const topValue = (typeof top !== 'undefined' && top !== null) ? (page.size[1] - top) : 0;
                                const leftValue = (typeof left !== 'undefined' && left !== null) ? left : 0;
                                this._destination = new PdfDestination(page, [leftValue, topValue]);
                                if (typeof zoom !== 'undefined' && zoom !== null) {
                                    this._destination.zoom = zoom;
                                }
                                if ((typeof left !== 'undefined' && left !== null) || (typeof top !== 'undefined' && top !== null)
                                    || (typeof zoom !== 'undefined' && zoom !== null)) {
                                    this._destination._setValidation(false);
                                }
                            }
                            else if (mode.name === 'FitR') {
                                if (referenceArray.length === 6) {
                                    const left = referenceArray[2];
                                    const bottom = referenceArray[3];
                                    const right = referenceArray[4];
                                    const top = referenceArray[5];
                                    this._destination = new PdfDestination(page, [left, bottom, right, top]);
                                }
                            }
                            else if (mode.name === 'Fit') {
                                this._destination = new PdfDestination(page);
                                this._destination.mode = PdfDestinationMode.fitToPage;
                            }
                        }
                    }
                }
            }
        }
        return this._destination;
    }
    _addDocument() {
        if (this.destination) {
            this._dictionary.set('Dest', this.destination._array);
        }
    }
    _doPostProcess(isFlatten = false) {
        if (!this._isLoaded) {
            this._postProcess();
        }
        if (isFlatten) {
            let appearanceStream;
            if (this._dictionary.has('AP')) {
                const dictionary = this._dictionary.get('AP');
                if (dictionary && dictionary.has('N')) {
                    appearanceStream = dictionary.get('N');
                    const reference = dictionary.getRaw('N');
                    if (reference && appearanceStream) {
                        appearanceStream.reference = reference;
                    }
                }
            }
            if (appearanceStream) {
                const template = new PdfTemplate(appearanceStream, this._crossReference);
                const isNormalMatrix = this._validateTemplateMatrix(template._content.dictionary);
                this._flattenAnnotationTemplate(template, isNormalMatrix);
            }
            else {
                this._removeAnnotation(this._page, this);
            }
        }
    }
}
/**
 * `PdfTextWebLinkAnnotation` class represents the link annotation objects.
 * ```typescript
 * // Load an existing PDF document
 * let document: PdfDocument = new PdfDocument(data, password);
 * // Get the first page
 * let page: PdfPage = document.getPage(0) as PdfPage;
 * // Create a new PDF string format
 * const format: PdfStringFormat = new PdfStringFormat(PdfTextAlignment.left, PdfVerticalAlignment.top);
 * // Create a new standard font
 * const font: PdfStandardFont = new PdfStandardFont(PdfFontFamily.helvetica, 10, PdfFontStyle.regular);
 * // Get the text size
 * let size: number[] = font.measureString("Syncfusion Site", format, [0, 0], 0, 0);
 * // Create a new text web link annotation
 * let annot: PdfTextWebLinkAnnotation = new PdfTextWebLinkAnnotation(50, 40, size[0], size[1], [0, 0, 0], [165, 42, 42], 1);
 * // Add annotation to the page
 * page.annotations.add(annotation);
 * // Save the document
 * document.save('output.pdf');
 * // Destroy the document
 * document.destroy();
 * ```
 */
class PdfTextWebLinkAnnotation extends PdfAnnotation {
    constructor(x, y, width, height, brushColor, penColor, penWidth, text) {
        super();
        this._isActionAdded = false;
        this._dictionary = new _PdfDictionary();
        this._dictionary.update('Type', _PdfName.get('Annot'));
        this._dictionary.update('Subtype', _PdfName.get('Link'));
        if (typeof x !== 'undefined' && typeof y !== 'undefined' && typeof width !== 'undefined' && typeof height !== 'undefined') {
            this.bounds = { x, y, width, height };
        }
        this._textWebLink = typeof text !== 'undefined' && text !== null ? text : '';
        if (typeof brushColor !== 'undefined' && brushColor !== null) {
            this._brush = new PdfBrush(brushColor);
        }
        if (typeof penColor !== 'undefined' && penColor !== null) {
            this._pen = new PdfPen(penColor, penWidth ? penWidth : 1);
        }
        this._type = _PdfAnnotationType.textWebLinkAnnotation;
    }
    /**
     * Gets the font of the annotation.
     *
     * @returns {PdfFont} font.
     * ```typescript
     * // Load an existing PDF document
     * let document: PdfDocument = new PdfDocument(data, password);
     * // Get the first page
     * let page: PdfPage = document.getPage(0) as PdfPage;
     * // Get the first annotation of the page
     * let annotation: PdfTextWebLinkAnnotation = page.annotations.at(0) as PdfTextWebLinkAnnotation;
     * // Gets the font of the annotation.
     * let font: PdfFont = annotation.font;
     * // Save the document
     * document.save('output.pdf');
     * // Destroy the document
     * document.destroy();
     * ```
     */
    get font() {
        return this._font;
    }
    /**
     * Sets the font of the annotation.
     *
     * @param {PdfFont} value font.
     * ```typescript
     * // Load an existing PDF document
     * let document: PdfDocument = new PdfDocument(data, password);
     * // Get the first page
     * let page: PdfPage = document.getPage(0) as PdfPage;
     * // Get the first annotation of the page
     * let annotation: PdfTextWebLinkAnnotation = page.annotations.at(0) as PdfTextWebLinkAnnotation;
     * // Sets the font of the annotation.
     * annotation.font = new PdfStandardFont(PdfFontFamily.helvetica, 10, PdfFontStyle.regular);
     * // Save the document
     * document.save('output.pdf');
     * // Destroy the document
     * document.destroy();
     * ```
     */
    set font(value) {
        this._font = value;
    }
    /**
     * Gets the url of the annotation.
     *
     * @returns {string} Url.
     * ```typescript
     * // Load an existing PDF document
     * let document: PdfDocument = new PdfDocument(data, password);
     * // Get the first page
     * let page: PdfPage = document.getPage(0) as PdfPage;
     * // Get the first annotation of the page
     * let annotation: PdfTextWebLinkAnnotation = page.annotations.at(0) as PdfTextWebLinkAnnotation;
     * // Gets the URL of the annotation.
     * let url: string = annotation.url;
     * // Save the document
     * document.save('output.pdf');
     * // Destroy the document
     * document.destroy();
     * ```
     */
    get url() {
        if (typeof this._url === 'undefined' && this._dictionary.has('A')) {
            const linkDict = this._dictionary.get('A');
            if (linkDict.has('URI')) {
                this._url = linkDict.get('URI');
            }
        }
        return this._url;
    }
    /**
     * Sets the url of the annotation.
     *
     * @param {string} value Url.
     * ```typescript
     * // Load an existing PDF document
     * let document: PdfDocument = new PdfDocument(data, password);
     * // Get the first page
     * let page: PdfPage = document.getPage(0) as PdfPage;
     * // Get the first annotation of the page
     * let annotation: PdfTextWebLinkAnnotation = page.annotations.at(0) as PdfTextWebLinkAnnotation;
     * // Sets the URL of the annotation.
     * annotation.url = ‘http://www.syncfusion.com’;
     * // Save the document
     * document.save('output.pdf');
     * // Destroy the document
     * document.destroy();
     * ```
     */
    set url(value) {
        if (typeof value === 'string') {
            if (this._isLoaded && this._dictionary.has('A')) {
                const linkSource = this._dictionary._get('A'); // eslint-disable-line
                const linkDict = this._dictionary.get('A');
                if (linkDict && linkDict.has('URI')) {
                    this._url = value;
                    linkDict.update('URI', value);
                    if (!(linkSource instanceof _PdfReference)) {
                        this._dictionary._updated = linkDict._updated;
                    }
                }
            }
            else {
                this._url = value;
            }
        }
    }
    static _load(page, dictionary) {
        const annot = new PdfTextWebLinkAnnotation();
        annot._isLoaded = true;
        annot._initialize(page, dictionary);
        return annot;
    }
    _initialize(page, dictionary) {
        super._initialize(page, dictionary);
    }
    _postProcess() {
        if (typeof this.bounds === 'undefined' || this.bounds === null) {
            throw new Error('Bounds cannot be null or undefined');
        }
        if (!this._isActionAdded) {
            this._addAction();
            this._isActionAdded = true;
        }
        const size = this._page.size;
        const rect = [this.bounds.x, size[1] - (this.bounds.y + this.bounds.height), this.bounds.width, this.bounds.height];
        this._dictionary.update('Rect', [rect[0], rect[1], rect[0] + rect[2], rect[1] + rect[3]]);
    }
    _addAction() {
        const rect = [this.bounds.x, this.bounds.y, this.bounds.width, this.bounds.height];
        if (typeof this.font === 'undefined' || this.font === null) {
            this.font = this._lineCaptionFont;
        }
        const format = new PdfStringFormat(PdfTextAlignment.left, PdfVerticalAlignment.top);
        this._page.graphics.drawString(this._textWebLink, this.font, rect, this._pen, this._brush, format);
        const dictionary = new _PdfDictionary();
        dictionary.set('Type', _PdfName.get('Action'));
        dictionary.set('S', _PdfName.get('URI'));
        if (typeof this._url !== 'undefined') {
            dictionary.set('URI', this._url);
        }
        dictionary._updated = true;
        this._dictionary.set('A', dictionary);
        this._dictionary.update('Border', [0, 0, 0]);
    }
    _doPostProcess(isFlatten = false) {
        if (!this._isLoaded) {
            this._postProcess();
        }
        if (isFlatten) {
            let appearanceStream;
            if (this._dictionary.has('AP')) {
                const dictionary = this._dictionary.get('AP');
                if (dictionary && dictionary.has('N')) {
                    appearanceStream = dictionary.get('N');
                    const reference = dictionary.getRaw('N');
                    if (reference && appearanceStream) {
                        appearanceStream.reference = reference;
                    }
                }
            }
            if (appearanceStream) {
                const template = new PdfTemplate(appearanceStream, this._crossReference);
                const isNormalMatrix = this._validateTemplateMatrix(template._content.dictionary);
                this._flattenAnnotationTemplate(template, isNormalMatrix);
            }
            else {
                this._removeAnnotation(this._page, this);
            }
        }
    }
}
/**
 * `PdfAttachmentAnnotation` class represents the attachment annotation objects.
 * ```typescript
 * // Load an existing PDF document
 * let document: PdfDocument = new PdfDocument(data, password);
 * // Get the first page
 * let page: PdfPage = document.getPage(0) as PdfPage;
 * // Create a new attachment annotation
 * const annotation: PdfAttachmentAnnotation = new PdfAttachmentAnnotation(300, 200, 30, 30, "Nature.jpg", imageData);
 * // Add annotation to the page
 * page.annotations.add(annotation);
 * // Save the document
 * document.save('output.pdf');
 * // Destroy the document
 * document.destroy();
 * ```
 */
class PdfAttachmentAnnotation extends PdfComment {
    constructor(x, y, width, height, fileName, data) {
        super();
        this._icon = PdfAttachmentIcon.pushPin;
        this._iconString = '';
        this._dictionary = new _PdfDictionary();
        this._dictionary.update('Type', _PdfName.get('Annot'));
        this._dictionary.update('Subtype', _PdfName.get('FileAttachment'));
        if (typeof x !== 'undefined' && typeof y !== 'undefined' && typeof width !== 'undefined' && typeof height !== 'undefined') {
            this.bounds = { x, y, width, height };
        }
        if (typeof fileName !== 'undefined') {
            this._fileName = fileName;
        }
        this._stream = new _PdfStream(typeof data === 'string' ? _decode(data) : data);
        this._type = _PdfAnnotationType.fileAttachmentAnnotation;
    }
    /**
     * Gets the icon type of the attachment annotation.
     *
     * @returns {PdfAttachmentIcon} Annotation icon.
     * ```typescript
     * // Load an existing PDF document
     * let document: PdfDocument = new PdfDocument(data, password);
     * // Get the first page
     * let page: PdfPage = document.getPage(0) as PdfPage;
     * // Get the first annotation of the page
     * let annotation: PdfAttachmentAnnotation = page.annotations.at(0) as PdfAttachmentAnnotation;
     * // Gets the icon type of the attachment annotation.
     * let icon: PdfAttachmentIcon = annotation.icon;
     * // Destroy the document
     * document.destroy();
     * ```
     */
    get icon() {
        if (this._dictionary.has('Name')) {
            this._icon = _mapAttachmentIcon(this._dictionary.get('Name').name);
        }
        return this._icon;
    }
    /**
     * Sets the icon type of the attachment annotation.
     *
     * @param {PdfAttachmentIcon} value Annotation icon.
     * ```typescript
     * // Load an existing PDF document
     * let document: PdfDocument = new PdfDocument(data, password);
     * // Get the first page
     * let page: PdfPage = document.getPage(0) as  PdfPage;
     * // Get the first annotation of the page
     * let annotation: PdfAttachmentAnnotation = page.annotations.at(0) as PdfAttachmentAnnotation;
     * // Sets the icon type of the attachment annotation.
     * annotation.icon = PdfAttachmentIcon.pushPin;
     * // Save the document
     * document.save('output.pdf');
     * // Destroy the document
     * document.destroy();
     * ```
     */
    set icon(value) {
        if (typeof value !== 'undefined') {
            this._icon = value;
            this._dictionary.update('Name', _PdfName.get(this._obtainIconName(this._icon)));
        }
    }
    static _load(page, dictionary) {
        const annot = new PdfAttachmentAnnotation();
        annot._isLoaded = true;
        annot._initialize(page, dictionary);
        return annot;
    }
    _initialize(page, dictionary) {
        super._initialize(page, dictionary);
    }
    _postProcess() {
        if (typeof this.bounds === 'undefined' || this.bounds === null) {
            throw new Error('Bounds cannot be null or undefined');
        }
        const size = this._page.size;
        const rect = [this.bounds.x,
            size[1] - (this.bounds.y + this.bounds.height),
            this.bounds.width,
            this.bounds.height];
        this._dictionary.update('Rect', [rect[0], rect[1], rect[0] + rect[2], rect[1] + rect[3]]);
        this._addAttachment();
    }
    _addAttachment() {
        if (this._dictionary.has('FS')) {
            const fileSpecification = this._dictionary.get('FS');
            if (fileSpecification && fileSpecification.has('EF')) {
                const embeddedFile = fileSpecification.get('EF');
                if (embeddedFile && embeddedFile.has('F')) {
                    _removeDuplicateReference(embeddedFile, this._crossReference, 'F');
                }
            }
            _removeDuplicateReference(this._dictionary, this._crossReference, 'FS');
        }
        const fileSpectDictionary = new _PdfDictionary();
        fileSpectDictionary.set('Type', _PdfName.get('Filespec'));
        fileSpectDictionary.set('Desc', this._fileName);
        fileSpectDictionary.set('F', this._fileName);
        fileSpectDictionary.set('UF', this._fileName);
        const fileDictionary = new _PdfDictionary();
        fileDictionary.set('Type', _PdfName.get('EmbeddedFile'));
        const paramsDictionary = new _PdfDictionary();
        const dateTime = new Date();
        paramsDictionary.set('CreationDate', dateTime.toTimeString());
        paramsDictionary.set('ModDate', new Date().toTimeString());
        paramsDictionary.set('Size', this._stream.length);
        fileDictionary.set('Params', paramsDictionary);
        this._stream.dictionary = new _PdfDictionary();
        this._stream.dictionary = fileDictionary;
        fileDictionary._crossReference = this._crossReference;
        const char1 = this._crossReference._newLine.charCodeAt(0);
        const char2 = this._crossReference._newLine.charCodeAt(1);
        const buffer = [char1, char2, 37, 80, 68, 70, 45];
        fileDictionary._crossReference._writeObject(this._stream, buffer);
        const reference = this._crossReference._getNextReference();
        this._crossReference._cacheMap.set(reference, this._stream);
        fileDictionary._updated = true;
        const efileDictionary = new _PdfDictionary();
        efileDictionary.set('F', reference);
        fileSpectDictionary.set('EF', efileDictionary);
        const fsReference = this._crossReference._getNextReference();
        this._crossReference._cacheMap.set(fsReference, fileSpectDictionary);
        fileSpectDictionary._updated = true;
        this._dictionary.update('FS', fsReference);
    }
    _doPostProcess(isFlatten = false) {
        if (!this._isLoaded) {
            this._postProcess();
        }
        if (isFlatten) {
            let appearanceStream;
            if (this._dictionary.has('AP')) {
                const dictionary = this._dictionary.get('AP');
                if (dictionary && dictionary.has('N')) {
                    appearanceStream = dictionary.get('N');
                    const reference = dictionary.getRaw('N');
                    if (reference && appearanceStream) {
                        appearanceStream.reference = reference;
                    }
                }
            }
            if (appearanceStream) {
                const template = new PdfTemplate(appearanceStream, this._crossReference);
                const isNormalMatrix = this._validateTemplateMatrix(template._content.dictionary);
                this._flattenAnnotationTemplate(template, isNormalMatrix);
            }
            else {
                this._removeAnnotation(this._page, this);
            }
        }
    }
    _obtainIconName(icon) {
        switch (icon) {
            case PdfAttachmentIcon.pushPin:
                this._iconString = 'PushPin';
                break;
            case PdfAttachmentIcon.tag:
                this._iconString = 'Tag';
                break;
            case PdfAttachmentIcon.graph:
                this._iconString = 'Graph';
                break;
            case PdfAttachmentIcon.paperClip:
                this._iconString = 'Paperclip';
                break;
        }
        return this._iconString;
    }
}
/**
 * `Pdf3DAnnotation` class represents the 3D annotation objects.
 * ```typescript
 * // Load an existing PDF document
 * let document: PdfDocument = new PdfDocument(data, password);
 * // Access first page
 * let page: PdfPage = document.getPage(0);
 * // Access the annotation at index 0
 * let annotation: Pdf3DAnnotation = page.annotations.at(0) as Pdf3DAnnotation;
 * // Save the document
 * document.save('output.pdf');
 * // Destroy the document
 * document.destroy();
 * ```
 */
class Pdf3DAnnotation extends PdfAnnotation {
    /**
     * Initializes a new instance of the `Pdf3DAnnotation` class.
     *
     * @private
     */
    constructor() {
        super();
        this._type = _PdfAnnotationType.movieAnnotation;
    }
    static _load(page, dictionary) {
        const annot = new Pdf3DAnnotation();
        annot._isLoaded = true;
        annot._initialize(page, dictionary);
        return annot;
    }
    _initialize(page, dictionary) {
        super._initialize(page, dictionary);
    }
    _doPostProcess(isFlatten = false) {
        if (isFlatten) {
            let appearanceStream;
            if (this._dictionary.has('AP')) {
                const dictionary = this._dictionary.get('AP');
                if (dictionary && dictionary.has('N')) {
                    appearanceStream = dictionary.get('N');
                    const reference = dictionary.getRaw('N');
                    if (reference && appearanceStream) {
                        appearanceStream.reference = reference;
                    }
                }
            }
            if (appearanceStream) {
                const template = new PdfTemplate(appearanceStream, this._crossReference);
                const isNormalMatrix = this._validateTemplateMatrix(template._content.dictionary);
                this._flattenAnnotationTemplate(template, isNormalMatrix);
            }
            else {
                this._removeAnnotation(this._page, this);
            }
        }
    }
}
/**
 * `PdfTextMarkupAnnotation` class represents the text markup annotation objects.
 * ```typescript
 * // Load an existing PDF document
 * let document: PdfDocument = new PdfDocument(data, password);
 * // Get the first page
 * let page: PdfPage = document.getPage(0) as PdfPage;
 * // Create a new text markup annotation
 * let annotation: PdfTextMarkupAnnotation = new PdfTextMarkupAnnotation('Text markup', 50, 100, 100, 50);
 * // Add annotation to the page
 * page.annotations.add(annotation);
 * // Save the document
 * document.save('output.pdf');
 * // Destroy the document
 * document.destroy();
 * ```
 */
class PdfTextMarkupAnnotation extends PdfComment {
    constructor(text, x, y, width, height) {
        super();
        this._textMarkupType = PdfTextMarkupAnnotationType.highlight;
        this._quadPoints = new Array(8);
        this._boundsCollection = [];
        this._dictionary = new _PdfDictionary();
        this._dictionary.update('Type', _PdfName.get('Annot'));
        if (typeof text !== 'undefined') {
            this._text = text;
        }
        if (typeof x !== 'undefined' && typeof y !== 'undefined' && typeof width !== 'undefined' && typeof height !== 'undefined') {
            this.bounds = { x, y, width, height };
            this._boundsCollection.push([this.bounds.x, this.bounds.y, this.bounds.width, this.bounds.height]);
        }
        this._type = _PdfAnnotationType.textMarkupAnnotation;
    }
    /**
     * Gets the text markup color of the annotation.
     *
     * @returns {number[]} Text markup color as R, G, B color array in between 0 to 255.
     * ```typescript
     * // Load an existing PDF document
     * let document: PdfDocument = new PdfDocument(data, password);
     * // Get the first page
     * let page: PdfPage = document.getPage(0) as PdfPage;
     * // Get the first annotation of the page
     * let annotation: PdfTextMarkupAnnotation = page.annotations.at(0) as PdfTextMarkupAnnotation;
     * // Gets the textMarkUp Color type of the attachment annotation.
     * let textMarkUpColor: number[] = annotation.textMarkUpColor;
     * // Destroy the document
     * document.destroy();
     * ```
     */
    get textMarkUpColor() {
        if (typeof this._textMarkUpColor === 'undefined' && this._dictionary.has('C')) {
            this._textMarkUpColor = _parseColor(this._dictionary.getArray('C'));
        }
        return this._textMarkUpColor;
    }
    /**
     * Sets the text markup color of the annotation.
     *
     * @param {number[]} value R, G, B color values in between 0 to 255.
     * ```typescript
     * // Load an existing PDF document
     * let document: PdfDocument = new PdfDocument(data, password);
     * // Get the first page
     * let page: PdfPage = document.getPage(0) as PdfPage;
     * // Get the first annotation of the page
     * let annotation: PdfTextMarkupAnnotation = page.annotations.at(0) as PdfTextMarkupAnnotation;
     * // Sets the textMarkUp Color type of the attachment annotation.
     * annotation.textMarkUpColor = [255, 255, 255];
     * // Save the document
     * document.save('output.pdf');
     * // Destroy the document
     * document.destroy();
     * ```
     */
    set textMarkUpColor(value) {
        if (typeof value !== 'undefined' && value.length === 3) {
            const extColor = this.color;
            if (!this._isLoaded ||
                typeof extColor === 'undefined' ||
                (extColor[0] !== value[0] || extColor[1] !== value[1] || extColor[2] !== value[2])) {
                this._color = value;
                this._textMarkUpColor = value;
                this._dictionary.update('C', [Number.parseFloat((value[0] / 255).toFixed(3)),
                    Number.parseFloat((value[1] / 255).toFixed(3)),
                    Number.parseFloat((value[2] / 255).toFixed(3))]);
            }
        }
    }
    /**
     * Gets the markup type of the annotation.
     *
     * @returns {PdfTextMarkupAnnotationType} Markup type.
     * ```typescript
     * // Load an existing PDF document
     * let document: PdfDocument = new PdfDocument(data, password);
     * // Get the first page
     * let page: PdfPage = document.getPage(0) as PdfPage;
     * // Get the first annotation of the page
     * let annotation: PdfTextMarkupAnnotation = page.annotations.at(0) as PdfTextMarkupAnnotation;
     * // Gets the markup type of the annotation.
     * let textMarkupType: PdfTextMarkupAnnotationType = annotation.textMarkupType;
     * // Destroy the document
     * document.destroy();
     * ```
     */
    get textMarkupType() {
        if (this._dictionary.has('Subtype')) {
            const text = this._dictionary.get('Subtype');
            this._textMarkupType = _mapMarkupAnnotationType(text.name);
        }
        return this._textMarkupType;
    }
    /**
     * Sets the markup type of the annotation.
     *
     * @param {PdfTextMarkupAnnotationType} value Markup type.
     * ```typescript
     * // Load an existing PDF document
     * let document: PdfDocument = new PdfDocument(data, password);
     * // Get the first page
     * let page: PdfPage = document.getPage(0) as PdfPage;
     * // Get the first annotation of the page
     * let annotation: PdfTextMarkupAnnotation = page.annotations.at(0) as PdfTextMarkupAnnotation;
     * // Sets the markup type of the annotation.
     * annotation.textMarkupType = PdfTextMarkupAnnotationType.squiggly;
     * // Save the document
     * document.save('output.pdf');
     * // Destroy the document
     * document.destroy();
     * ```
     */
    set textMarkupType(value) {
        if (typeof value !== 'undefined') {
            this._textMarkupType = value;
            this._dictionary.update('Subtype', _PdfName.get(_reverseMarkupAnnotationType(value)));
        }
    }
    /**
     * Gets the markup bounds collection of the annotation.
     *
     * @returns {Array<number[]>} Markup bounds.
     * ```typescript
     * // Load an existing PDF document
     * let document: PdfDocument = new PdfDocument(data, password);
     * // Get the first page
     * let page: PdfPage = document.getPage(0) as  PdfPage;
     * // Get the first annotation of the page
     * let annotation: PdfTextMarkupAnnotation =  page.annotations.at(0) as PdfTextMarkupAnnotation;
     * // Gets the markup bounds collection of the annotation.
     * let boundsCollection : Array<number[]> = annotation.boundsCollection;
     * // Destroy the document
     * document.destroy();
     * ```
     */
    get boundsCollection() {
        if (this._isLoaded) {
            const collection = [];
            if (this._dictionary.has('QuadPoints')) {
                const points = this._dictionary.getArray('QuadPoints');
                if (points && points.length > 0) {
                    const count = points.length / 8;
                    for (let i = 0; i < count; i++) {
                        let x = points[4 + (i * 8)] - points[i * 8];
                        let y = points[5 + (i * 8)] - points[1 + (i * 8)];
                        const height = Math.sqrt((x * x) + (y * y));
                        x = points[6 + (i * 8)] - points[4 + (i * 8)];
                        y = points[7 + (i * 8)] - points[5 + (i * 8)];
                        const width = Math.sqrt((x * x) + (y * y));
                        const rect = [points[i * 8], this._page.size[1] - points[1 + (i * 8)], width, height];
                        collection.push(rect);
                    }
                }
            }
            return collection;
        }
        return this._boundsCollection;
    }
    /**
     * Sets the markup bounds collection of the annotation.
     *
     * @param {Array<number[]>} value Markup bounds.
     * ```typescript
     * // Load an existing PDF document
     * let document: PdfDocument = new PdfDocument(data, password);
     * // Get the first page
     * let page: PdfPage = document.getPage(0) as PdfPage;
     * // Get the first annotation of the page
     * let annotation: PdfTextMarkupAnnotation = page.annotations.at(0) as PdfTextMarkupAnnotation;
     * // Sets the markup bounds collection of the  annotation.
     * annotation.boundsCollection = [[50, 50, 100, 100], [201, 101, 61, 31], [101, 401, 61, 31]];
     * // Save the document
     * document.save('output.pdf');
     * // Destroy the document
     * document.destroy();
     * ```
     */
    set boundsCollection(value) {
        if (!this._isLoaded && typeof value !== 'undefined') {
            if (this._boundsCollection.length > 0) {
                this._quadPoints = new Array(8 + (value.length * 8));
                for (let i = 0; i < value.length; i++) {
                    this._boundsCollection.push(value[Number.parseInt(i.toString(), 10)]);
                }
            }
            else {
                this._quadPoints = new Array(8);
                this._boundsCollection = value;
            }
        }
        if (this._isLoaded && typeof value !== 'undefined') {
            let isChanged = false;
            if (this.boundsCollection.length === value.length) {
                for (let i = 0; i < value.length; i++) {
                    const values = value[Number.parseInt(i.toString(), 10)];
                    for (let j = 0; j < values.length; j++) {
                        if (value[Number.parseInt(i.toString(), 10)][Number.parseInt(j.toString(), 10)] !==
                            this.boundsCollection[Number.parseInt(i.toString(), 10)][Number.parseInt(j.toString(), 10)]) {
                            isChanged = true;
                            break;
                        }
                    }
                }
            }
            else {
                isChanged = true;
            }
            if (isChanged) {
                this._quadPoints = new Array((value.length * 8));
                const pageHeight = this._page.size[1];
                for (let i = 0; i < value.length; i++) {
                    this._quadPoints[0 + (Number.parseInt(i.toString(), 10) * 8)] = value[Number.parseInt(i.toString(), 10)][0];
                    this._quadPoints[1 + (Number.parseInt(i.toString(), 10) * 8)] = pageHeight -
                        value[Number.parseInt(i.toString(), 10)][1];
                    this._quadPoints[2 + (Number.parseInt(i.toString(), 10) * 8)] = value[Number.parseInt(i.toString(), 10)][0] +
                        value[Number.parseInt(i.toString(), 10)][2];
                    this._quadPoints[3 + (Number.parseInt(i.toString(), 10) * 8)] = pageHeight -
                        value[Number.parseInt(i.toString(), 10)][1];
                    this._quadPoints[4 + (Number.parseInt(i.toString(), 10) * 8)] = value[Number.parseInt(i.toString(), 10)][0];
                    this._quadPoints[5 + (Number.parseInt(i.toString(), 10) * 8)] = this._quadPoints[1 + (i * 8)] -
                        value[Number.parseInt(i.toString(), 10)][3];
                    this._quadPoints[6 + (Number.parseInt(i.toString(), 10) * 8)] = value[Number.parseInt(i.toString(), 10)][0] +
                        value[Number.parseInt(i.toString(), 10)][2];
                    this._quadPoints[7 + (Number.parseInt(i.toString(), 10) * 8)] = this._quadPoints[5 +
                        (Number.parseInt(i.toString(), 10) * 8)];
                }
                this._dictionary.update('QuadPoints', this._quadPoints);
            }
        }
    }
    static _load(page, dictionary) {
        const annot = new PdfTextMarkupAnnotation();
        annot._isLoaded = true;
        annot._initialize(page, dictionary);
        return annot;
    }
    _initialize(page, dictionary) {
        super._initialize(page, dictionary);
    }
    _postProcess() {
        if (typeof this.bounds === 'undefined' || this.bounds === null) {
            throw new Error('Bounds cannot be null or undefined');
        }
        let borderWidth;
        if (this._dictionary.has('BS')) {
            borderWidth = this.border.width;
        }
        else {
            const dictionary = new _PdfDictionary(this._crossReference);
            dictionary.set('Type', _PdfName.get('Border'));
            dictionary.set('W', this.border.width);
            this._dictionary.set('BS', dictionary);
        }
        if (typeof borderWidth === 'undefined') {
            borderWidth = 1;
        }
        const size = this._page.size;
        this._setQuadPoints(size);
        const rect = [this.bounds.x,
            size[1] - (this.bounds.y + this.bounds.height),
            this.bounds.width,
            this.bounds.height];
        this._dictionary.update('Subtype', _PdfName.get(_reverseMarkupAnnotationType(this._textMarkupType)));
        this._dictionary.update('Rect', [rect[0], rect[1], rect[0] + rect[2], rect[1] + rect[3]]);
        if (this._setAppearance) {
            this._appearanceTemplate = this._createMarkupAppearance();
            if (!this._isLoaded && this._boundsCollection.length > 1) {
                const native = this._obtainNativeRectangle();
                this._dictionary.update('Rect', [native[0], native[1], native[0] + native[2], native[1] + native[3]]);
            }
            if (this._dictionary.has('AP')) {
                _removeDuplicateReference(this._dictionary.get('AP'), this._crossReference, 'N');
            }
            const dictionary = new _PdfDictionary();
            this._appearanceTemplate._content.dictionary._updated = true;
            const reference = this._crossReference._getNextReference();
            this._crossReference._cacheMap.set(reference, this._appearanceTemplate._content);
            this._appearanceTemplate._content.reference = reference;
            dictionary.set('N', reference);
            dictionary._updated = true;
            this._dictionary.set('AP', dictionary);
        }
        if (typeof this._text !== 'undefined' && this._text !== null) {
            this._dictionary.set('Contents', this._text);
        }
    }
    _doPostProcess(isFlatten = false) {
        if (this._isLoaded) {
            if (this._setAppearance || (isFlatten && !this._dictionary.has('AP'))) {
                this._appearanceTemplate = this._createMarkupAppearance();
                if (!isFlatten) {
                    if (this._dictionary.has('AP')) {
                        _removeDuplicateReference(this._dictionary.get('AP'), this._crossReference, 'N');
                    }
                    const dictionary = new _PdfDictionary();
                    this._appearanceTemplate._content.dictionary._updated = true;
                    const reference = this._crossReference._getNextReference();
                    this._crossReference._cacheMap.set(reference, this._appearanceTemplate._content);
                    this._appearanceTemplate._content.reference = reference;
                    dictionary.set('N', reference);
                    dictionary._updated = true;
                    this._dictionary.set('AP', dictionary);
                }
            }
            if (!this._appearanceTemplate && isFlatten && this._dictionary.has('AP')) {
                const dictionary = this._dictionary.get('AP');
                if (dictionary && dictionary.has('N')) {
                    const appearanceStream = dictionary.get('N');
                    if (appearanceStream) {
                        const reference = dictionary.getRaw('N');
                        if (reference) {
                            appearanceStream.reference = reference;
                        }
                        this._appearanceTemplate = new PdfTemplate(appearanceStream, this._crossReference);
                    }
                }
            }
        }
        else {
            this._postProcess();
            if (!this._appearanceTemplate) {
                if (isFlatten) {
                    if (!this._dictionary.has('AP')) {
                        this._appearanceTemplate = this._createMarkupAppearance();
                    }
                    else {
                        const dictionary = this._dictionary.get('AP');
                        if (dictionary && dictionary.has('N')) {
                            const appearanceStream = dictionary.get('N');
                            if (appearanceStream) {
                                const reference = dictionary.getRaw('N');
                                if (reference) {
                                    appearanceStream.reference = reference;
                                }
                                this._appearanceTemplate = new PdfTemplate(appearanceStream, this._crossReference);
                            }
                        }
                    }
                }
            }
        }
        if (typeof this.flattenPopups !== 'undefined' && this.flattenPopups) {
            if (this._isLoaded) {
                this._flattenLoadedPopUp();
            }
            else {
                this._flattenPopUp();
            }
        }
        if (isFlatten && this._appearanceTemplate) {
            const isNormalMatrix = this._validateTemplateMatrix(this._appearanceTemplate._content.dictionary);
            if (!this._appearanceTemplate._content.dictionary.has('Matrix') && !this._isLoaded) {
                const box = this._appearanceTemplate._content.dictionary.getArray('BBox');
                if (box) {
                    this._appearanceTemplate._content.dictionary.update('Matrix', [1, 0, 0, 1, -box[0], -box[1]]);
                }
            }
            if (isNormalMatrix && typeof this._page.rotation !== 'undefined' && this._page.rotation !== PdfRotationAngle.angle0) {
                this._flattenAnnotationTemplate(this._appearanceTemplate, isNormalMatrix);
            }
            else if (isNormalMatrix && this._validateTemplateMatrix(this._appearanceTemplate._content.dictionary, this._appearanceTemplate)) {
                this._flattenAnnotationTemplate(this._appearanceTemplate, isNormalMatrix);
            }
            else if (!this._dictionary.has('AP') && this._appearanceTemplate) {
                this._flattenAnnotationTemplate(this._appearanceTemplate, isNormalMatrix);
            }
        }
    }
    _createMarkupAppearance() {
        let width;
        let height = 0;
        let rectangle;
        if (this.boundsCollection.length > 1) {
            const pdfPath = new _PdfPath();
            for (let i = 0; i < this.boundsCollection.length; i++) {
                const bounds = [];
                bounds[0] = this.boundsCollection[Number.parseInt(i.toString(), 10)][0];
                bounds[1] = this.boundsCollection[Number.parseInt(i.toString(), 10)][1];
                bounds[2] = this.boundsCollection[Number.parseInt(i.toString(), 10)][2];
                bounds[3] = this.boundsCollection[Number.parseInt(i.toString(), 10)][3];
                pdfPath._addRectangle(bounds[0], bounds[1], bounds[2], bounds[3]);
            }
            const rect = pdfPath._getBounds();
            rectangle = { x: rect[0], y: rect[1], width: rect[2], height: rect[3] };
            this.bounds = rectangle;
            width = rectangle.width;
            height = rectangle.height;
        }
        else {
            if (this._dictionary.has('QuadPoints')) {
                const quadPoints = this._dictionary.get('QuadPoints');
                if (this._quadPoints !== null) {
                    for (let i = 0; i < (quadPoints.length / 8); i++) {
                        if (this._isLoaded) {
                            const point = new Array();
                            let j = 0;
                            for (let k = 0; k < quadPoints.length;) {
                                const x1 = quadPoints[Number.parseInt(k.toString(), 10)];
                                const y1 = quadPoints[k + 1];
                                point[Number.parseInt(j.toString(), 10)] = [x1, y1];
                                k = k + 2;
                                j++;
                            }
                            const path = new _PdfPath();
                            path._addLines(point);
                            const rect = path._getBounds();
                            rectangle = { x: rect[0], y: rect[1], width: rect[2], height: rect[3] };
                            width = rectangle.width;
                            height = rectangle.height;
                        }
                        else {
                            let x = Math.floor(quadPoints[4 + (i * 8)]) - Math.floor(quadPoints[0 + (i * 8)]);
                            let y = Math.floor(quadPoints[5 + (i * 8)]) - Math.floor(quadPoints[1 + (i * 8)]);
                            height = Math.sqrt((x * x) + (y * y));
                            x = Math.floor(quadPoints[6 + (i * 8)]) - Math.floor(quadPoints[4 + (i * 8)]);
                            y = Math.floor(quadPoints[7 + (i * 8)]) - Math.floor(quadPoints[5 + (i * 8)]);
                            width = Math.sqrt((x * x) + (y * y));
                            this.bounds = { x: this.bounds.x, y: this.bounds.y, width: width, height: height };
                        }
                    }
                }
            }
        }
        const nativeRectangle = [0, 0, width, height];
        const template = new PdfTemplate(nativeRectangle, this._crossReference);
        _setMatrix(template, this._getRotationAngle());
        const graphics = template.graphics;
        if (typeof this.opacity !== 'undefined') {
            graphics.setTransparency(this.opacity, this.opacity, PdfBlendMode.multiply);
        }
        if (this.textMarkUpColor) {
            const pdfPen = new PdfPen(this.textMarkUpColor, this.border.width);
            const brush = new PdfBrush(this.textMarkUpColor);
            let x1 = 0;
            let y1 = 0;
            let w1 = 0;
            let h1 = 0;
            if (this.boundsCollection.length > 1) {
                for (let i = 0; i < this.boundsCollection.length; i++) {
                    const bounds = [];
                    bounds[0] = this.boundsCollection[Number.parseInt(i.toString(), 10)][0];
                    bounds[1] = this.boundsCollection[Number.parseInt(i.toString(), 10)][1];
                    bounds[2] = this.boundsCollection[Number.parseInt(i.toString(), 10)][2];
                    bounds[3] = this.boundsCollection[Number.parseInt(i.toString(), 10)][3];
                    if (this.textMarkupType === PdfTextMarkupAnnotationType.highlight) {
                        graphics.drawRectangle(bounds[0] - rectangle.x, bounds[1] - rectangle.y, bounds[2], bounds[3], brush);
                    }
                    else if (this.textMarkupType === PdfTextMarkupAnnotationType.underline) {
                        x1 = bounds[0] - rectangle.x;
                        y1 = (bounds[1] - rectangle.y) + (bounds[3] - ((bounds[3] / 2) / 3));
                        w1 = bounds[2] + (bounds[0] - rectangle.x);
                        h1 = (bounds[1] - rectangle.y) + (bounds[3] - ((bounds[3] / 2) / 3));
                        graphics.drawLine(pdfPen, x1, y1, w1, h1);
                    }
                    else if (this.textMarkupType === PdfTextMarkupAnnotationType.strikeOut) {
                        x1 = bounds[0] - rectangle.x;
                        y1 = (bounds[1] - rectangle.y) + (bounds[3] - (bounds[3] / 2));
                        w1 = bounds[2] + (bounds[0] - rectangle.x);
                        h1 = (bounds[1] - rectangle.y) + (bounds[3] - (bounds[3] / 2));
                        graphics.drawLine(pdfPen, x1, y1, w1, h1);
                    }
                    else if (this.textMarkupType === PdfTextMarkupAnnotationType.squiggly) {
                        pdfPen._width = bounds[3] * 0.02;
                        graphics.save();
                        graphics.translateTransform(bounds[0] - rectangle.x, (bounds[1] - rectangle.y));
                        graphics.setClip([0, 0, bounds[2], bounds[3]]);
                        graphics._drawPath(this._drawSquiggly(bounds[2], bounds[3]), pdfPen);
                        graphics.restore();
                    }
                }
            }
            else {
                if (this.textMarkupType === PdfTextMarkupAnnotationType.highlight) {
                    graphics.drawRectangle(0, 0, width, height, brush);
                }
                else if (this.textMarkupType === PdfTextMarkupAnnotationType.underline) {
                    graphics.drawLine(pdfPen, 0, height - ((height / 2) / 3), width, height - ((height / 2) / 3));
                }
                else if (this.textMarkupType === PdfTextMarkupAnnotationType.strikeOut) {
                    graphics.drawLine(pdfPen, 0, height / 2, width, height / 2);
                }
                else if (this.textMarkupType === PdfTextMarkupAnnotationType.squiggly) {
                    pdfPen._width = height * 0.02;
                    graphics._drawPath(this._drawSquiggly(Math.round(width), Math.round(height)), pdfPen);
                }
                if (this._isLoaded) {
                    this._dictionary.update('Rect', [rectangle.x, rectangle.y, rectangle.x + rectangle.width, rectangle.y + rectangle.height]);
                }
            }
        }
        return template;
    }
    _drawSquiggly(width, height) {
        if (Math.floor(width) % 2 !== 0 || Math.round(width) > width) {
            width = Math.floor(width) + 1;
        }
        const path = new _PdfPath();
        const pathPoints = new Array();
        const pathPointsCount = Math.ceil((width / height) * 16);
        const length = width / (pathPointsCount / 2);
        const location = parseFloat(((length + length) * 0.6).toFixed(2));
        let zigZag = location;
        let x = 0;
        for (let i = 0; i < pathPointsCount; i++) {
            const y = ((height - location) + zigZag) - (height * 0.02);
            const temp = [x, parseFloat(y.toFixed(2))];
            pathPoints.push(temp);
            if (zigZag === 0) {
                zigZag = location;
            }
            else {
                zigZag = 0;
            }
            x = x + length;
        }
        path._addLines(pathPoints);
        return path;
    }
    _setQuadPoints(pageSize) {
        const textQuadLocation = [];
        const pageHeight = pageSize[1];
        this._boundsCollection[0] = [this.bounds.x, this.bounds.y, this.bounds.width, this.bounds.height];
        const noofRect = this._quadPoints.length / 8;
        for (let i = 0; i < noofRect; i++) {
            const locationX = this._boundsCollection[Number.parseInt(i.toString(), 10)][0];
            const locationY = this._boundsCollection[Number.parseInt(i.toString(), 10)][1];
            textQuadLocation[0 + (i * 8)] = locationX;
            textQuadLocation[1 + (i * 8)] = (pageHeight - locationY);
            textQuadLocation[2 + (i * 8)] = (locationX + this._boundsCollection[Number.parseInt(i.toString(), 10)][2]);
            textQuadLocation[3 + (i * 8)] = (pageHeight - locationY);
            textQuadLocation[4 + (i * 8)] = locationX;
            textQuadLocation[5 + (i * 8)] = (textQuadLocation[1 + (i * 8)] - this._boundsCollection[Number.parseInt(i.toString(), 10)][3]);
            textQuadLocation[6 + (i * 8)] = (locationX + this._boundsCollection[Number.parseInt(i.toString(), 10)][2]);
            textQuadLocation[7 + (i * 8)] = textQuadLocation[5 + (i * 8)];
        }
        this._points = textQuadLocation;
        this._dictionary.set('QuadPoints', this._points);
    }
}
/**
 * `PdfWatermarkAnnotation` class represents the watermark annotation objects.
 * ```typescript
 * // Load an existing PDF document
 * let document: PdfDocument = new PdfDocument(data, password);
 * // Get the first page
 * let page: PdfPage = document.getPage(0) as PdfPage;
 * // Create a new water mark annotation
 * const annotation: PdfWatermarkAnnotation = new PdfWatermarkAnnotation('Water Mark', 50, 100, 100, 50);
 * // Set the color of the annotation
 * annotation.color = [0, 0, 0];
 * // Add annotation to the page
 * page.annotations.add(annotation);
 * // Save the document
 * document.save('output.pdf');
 * // Destroy the document
 * document.destroy();
 * ```
 */
class PdfWatermarkAnnotation extends PdfAnnotation {
    constructor(text, x, y, width, height) {
        super();
        this._watermarkText = '';
        this._dictionary = new _PdfDictionary();
        this._dictionary.update('Type', _PdfName.get('Annot'));
        this._dictionary.update('Subtype', _PdfName.get('Watermark'));
        if (typeof text !== 'undefined') {
            this._watermarkText = text;
            this.text = text;
        }
        if (typeof x !== 'undefined' && typeof y !== 'undefined' && typeof width !== 'undefined' && typeof height !== 'undefined') {
            this.bounds = { x, y, width, height };
        }
        this._type = _PdfAnnotationType.watermarkAnnotation;
    }
    static _load(page, dictionary) {
        const annot = new PdfWatermarkAnnotation();
        annot._isLoaded = true;
        annot._initialize(page, dictionary);
        return annot;
    }
    _initialize(page, dictionary) {
        super._initialize(page, dictionary);
    }
    _postProcess() {
        if (typeof this.bounds === 'undefined' || this.bounds === null) {
            throw new Error('Bounds cannot be null or undefined');
        }
        let borderWidth;
        if (this._dictionary.has('BS')) {
            borderWidth = this.border.width;
        }
        else {
            const dictionary = new _PdfDictionary(this._crossReference);
            dictionary.set('Type', _PdfName.get('Border'));
            this._dictionary.set('BS', dictionary);
        }
        if (typeof borderWidth === 'undefined') {
            borderWidth = 1;
        }
        if (typeof this.color === 'undefined') {
            this.color = [0, 0, 0];
        }
        this._appearanceTemplate = this._createWatermarkAppearance();
        const size = this._page.size;
        const rect = [this.bounds.x,
            size[1] - (this.bounds.y + this.bounds.height),
            this.bounds.width,
            this.bounds.height];
        this._dictionary.update('Rect', [rect[0], rect[1], rect[0] + rect[2], rect[1] + rect[3]]);
        if (typeof this.opacity !== 'undefined' && this._opacity !== 1.0) {
            this._dictionary.set('CA', this._opacity);
        }
    }
    _createWatermarkAppearance() {
        let font = this._obtainFont();
        if ((typeof font === 'undefined' || font === null) || (!this._isLoaded && font.size === 1)) {
            font = this._lineCaptionFont;
            this._pdfFont = font;
        }
        this._rotateAngle = this._getRotationAngle();
        if (typeof this.rotationAngle !== 'undefined' && this._rotate !== PdfRotationAngle.angle0 || this._rotateAngle !== PdfRotationAngle.angle0) {
            if (this._rotateAngle === 0) {
                this._rotateAngle = this.rotationAngle * 90;
            }
            this.bounds = this._getRotatedBounds(this.bounds, this._rotateAngle);
        }
        const nativeRectangle = [0, 0, this.bounds.width, this.bounds.height];
        const appearance = new PdfAppearance(this, nativeRectangle);
        appearance.normal = new PdfTemplate(nativeRectangle, this._crossReference);
        const template = appearance.normal;
        _setMatrix(template, this._rotateAngle);
        const graphics = appearance.normal.graphics;
        const width = this.border.width / 2;
        const format = new PdfStringFormat(PdfTextAlignment.left, PdfVerticalAlignment.top);
        const borderPen = new PdfPen(this.color, width);
        let backBrush;
        if (this.innerColor) {
            backBrush = new PdfBrush(this._innerColor);
        }
        if (this._isLoaded) {
            if (this._dictionary.has('Contents')) {
                this._watermarkText = this._dictionary.get('Contents');
            }
            this._dictionary.update('Contents', this._watermarkText);
        }
        else {
            this._dictionary.update('Contents', this._watermarkText);
        }
        if (typeof this._watermarkText !== 'undefined') {
            graphics.drawString(this._watermarkText, font, [0, 0, 0, 0], borderPen, backBrush, format);
        }
        if (this._dictionary.has('AP')) {
            _removeDuplicateReference(this._dictionary.get('AP'), this._crossReference, 'N');
        }
        const dictionary = new _PdfDictionary();
        graphics._template._content.dictionary._updated = true;
        const reference = this._crossReference._getNextReference();
        this._crossReference._cacheMap.set(reference, graphics._template._content);
        graphics._template._content.reference = reference;
        dictionary.set('N', reference);
        dictionary._updated = true;
        this._dictionary.set('AP', dictionary);
        return template;
    }
    _doPostProcess(isFlatten = false) {
        if (this._isLoaded) {
            if (!isFlatten) {
                this._appearanceTemplate = this._createWatermarkAppearance();
            }
            if (!this._appearanceTemplate && isFlatten && this._dictionary.has('AP')) {
                const dictionary = this._dictionary.get('AP');
                if (dictionary && dictionary.has('N')) {
                    const appearanceStream = dictionary.get('N');
                    if (appearanceStream) {
                        const reference = dictionary.getRaw('N');
                        if (reference) {
                            appearanceStream.reference = reference;
                        }
                        this._appearanceTemplate = new PdfTemplate(appearanceStream, this._crossReference);
                    }
                }
            }
        }
        else {
            this._postProcess();
            if (!this._appearanceTemplate) {
                if (isFlatten) {
                    if (!this._dictionary.has('AP')) {
                        this._appearanceTemplate = this._createWatermarkAppearance();
                    }
                    else {
                        const dictionary = this._dictionary.get('AP');
                        if (dictionary && dictionary.has('N')) {
                            const appearanceStream = dictionary.get('N');
                            if (appearanceStream) {
                                const reference = dictionary.getRaw('N');
                                if (reference) {
                                    appearanceStream.reference = reference;
                                }
                                this._appearanceTemplate = new PdfTemplate(appearanceStream, this._crossReference);
                            }
                        }
                    }
                }
            }
        }
        if (isFlatten && this._appearanceTemplate) {
            const isNormalMatrix = this._validateTemplateMatrix(this._appearanceTemplate._content.dictionary);
            if (!this._appearanceTemplate._content.dictionary.has('Matrix')) {
                const box = this._appearanceTemplate._content.dictionary.getArray('BBox');
                if (box) {
                    this._appearanceTemplate._content.dictionary.update('Matrix', [1, 0, 0, 1, -box[0], -box[1]]);
                }
            }
            this._flattenAnnotationTemplate(this._appearanceTemplate, isNormalMatrix);
        }
    }
}
/**
 * `PdfRubberStampAnnotation` class represents the rubber stamp annotation objects.
 * ```typescript
 * // Load an existing PDF document
 * let document: PdfDocument = new PdfDocument(data, password);
 * // Get the first page
 * let page: PdfPage = document.getPage(0) as PdfPage;
 * // Create a new rubber stamp annotation
 * const annotation: PdfRubberStampAnnotation = new PdfRubberStampAnnotation (50, 100, 100, 50);
 * // Add annotation to the page
 * page.annotations.add(annotation);
 * // Save the document
 * document.save('output.pdf');
 * // Destroy the document
 * document.destroy();
 * ```
 */
class PdfRubberStampAnnotation extends PdfComment {
    constructor(x, y, width, height) {
        super();
        this._icon = PdfRubberStampAnnotationIcon.draft;
        this._stampWidth = 0;
        this._iconString = '';
        this.rotateAngle = 0;
        this._stampAppearanceFont = new PdfStandardFont(PdfFontFamily.helvetica, 20, PdfFontStyle.italic | PdfFontStyle.bold);
        this._dictionary = new _PdfDictionary();
        this._dictionary.update('Type', _PdfName.get('Annot'));
        this._dictionary.update('Subtype', _PdfName.get('Stamp'));
        if (typeof x !== 'undefined' && typeof y !== 'undefined' && typeof width !== 'undefined' && typeof height !== 'undefined') {
            this.bounds = { x, y, width, height };
        }
        this._type = _PdfAnnotationType.rubberStampAnnotation;
    }
    /**
     * Gets the icon type of the rubber stamp annotation.
     *
     * @returns {PdfRubberStampAnnotationIcon} Annotation icon.
     * ```typescript
     * // Load an existing PDF document
     * let document: PdfDocument = new PdfDocument(data, password);
     * // Get the first page
     * let page: PdfPage = document.getPage(0) as PdfPage;
     * // Get the first annotation of the page
     * let annotation: PdfRubberStampAnnotationIcon = page.annotations.at(0) as PdfRubberStampAnnotationIcon;
     * // Gets the icon type of the rubber stamp annotation.
     * let icon: PdfRubberStampAnnotationIcon = annotation.icon;
     * // Destroy the document
     * document.destroy();
     * ```
     */
    get icon() {
        if (this._dictionary.has('Name')) {
            this._icon = _mapRubberStampIcon(this._dictionary.get('Name').name);
        }
        return this._icon;
    }
    /**
     * Sets the icon type of the rubber stamp annotation.
     *
     * @param {PdfRubberStampAnnotationIcon} value Annotation icon.
     * ```typescript
     * // Load an existing PDF document
     * let document: PdfDocument = new PdfDocument(data, password);
     * // Get the first page
     * let page: PdfPage = document.getPage(0) as PdfPage;
     * // Get the first annotation of the page
     * let annotation: PdfRubberStampAnnotationIcon = page.annotations.at(0) as PdfRubberStampAnnotationIcon;
     * // Sets the icon type of the rubber stamp annotation.
     * annotation.icon = PdfRubberStampAnnotationIcon.completed;
     * // Save the document
     * document.save('output.pdf');
     * // Destroy the document
     * document.destroy();
     * ```
     */
    set icon(value) {
        if (typeof value !== 'undefined') {
            this._icon = value;
            this._dictionary.update('Name', _PdfName.get('#' + this._obtainIconName(this._icon)));
        }
    }
    /**
     * Get the appearance of the rubber stamp annotation. (Read only)
     *
     * @returns {PdfAppearance} Returns the appearance of the annotation.
     * ```typescript
     * // Load an existing PDF document
     * let document: PdfDocument = new PdfDocument(data, password);
     * // Get the first page
     * let page: PdfPage = document.getPage(0) as PdfPage;
     * // Create a new rubber stamp annotation
     * const annotation: PdfRubberStampAnnotation = new PdfRubberStampAnnotation(50, 100, 100, 50);
     * // Get the appearance of the annotation
     * let appearance: PdfAppearance = annotation.appearance;
     * // Access the normal template of the appearance
     * let template: PdfTemplate = appearance.normal;
     * // Create new image object by using JPEG image data as Base64 string format
     * let image: PdfImage = new PdfBitmap('/9j/4AAQSkZJRgABAQEAkACQAAD/4....QB//Z');
     * // Draw the image as the custom appearance for the annotation
     * template.graphics.drawImage(image, 0, 0, 100, 50);
     * // Add annotation to the page
     * page.annotations.add(annotation);
     * // Save the document
     * document.save('output.pdf');
     * // Destroy the document
     * document.destroy();
     * ```
     */
    get appearance() {
        if (this._isLoaded) {
            return null;
        }
        if (typeof this._appearance === 'undefined') {
            const nativeRectangle = [0, 0, this.bounds.width, this.bounds.height];
            this._appearance = new PdfAppearance(this, nativeRectangle);
            this._appearance.normal = new PdfTemplate(nativeRectangle, this._crossReference);
        }
        return this._appearance;
    }
    get _innerTemplateBounds() {
        let innerBounds;
        if (this._isLoaded) {
            innerBounds = this._obtainInnerBounds();
            innerBounds.x = this.bounds.x;
            innerBounds.y = this.bounds.y;
        }
        return innerBounds;
    }
    static _load(page, dictionary) {
        const annot = new PdfRubberStampAnnotation();
        annot._isLoaded = true;
        annot._initialize(page, dictionary);
        return annot;
    }
    _initialize(page, dictionary) {
        super._initialize(page, dictionary);
    }
    _postProcess() {
        let borderWidth;
        if (this._dictionary.has('BS')) {
            borderWidth = this.border.width;
        }
        else {
            const dictionary = new _PdfDictionary(this._crossReference);
            dictionary.set('Type', _PdfName.get('Border'));
            this._dictionary.set('BS', dictionary);
        }
        if (typeof borderWidth === 'undefined') {
            borderWidth = 1;
        }
        this._appearanceTemplate = this._createRubberStampAppearance();
    }
    _transformBBox(bBoxValue, matrix) {
        const xCoordinate = [];
        const yCoordinate = [];
        const point1 = this._transformPoint(bBoxValue.x, bBoxValue.height, matrix);
        xCoordinate[0] = point1[0];
        yCoordinate[0] = point1[1];
        const point2 = this._transformPoint(bBoxValue.width, bBoxValue.y, matrix);
        xCoordinate[1] = point2[0];
        yCoordinate[1] = point2[1];
        const point3 = this._transformPoint(bBoxValue.x, bBoxValue.y, matrix);
        xCoordinate[2] = point3[0];
        yCoordinate[2] = point3[1];
        const point4 = this._transformPoint(bBoxValue.width, bBoxValue.height, matrix);
        xCoordinate[3] = point4[0];
        yCoordinate[3] = point4[1];
        const rect = [this._minValue(xCoordinate), this._minValue(yCoordinate),
            this._maxValue(xCoordinate), this._maxValue(yCoordinate)];
        return rect;
    }
    _transformPoint(x, y, matrix) {
        const point = [];
        point[0] = x * matrix[0] + y * matrix[2] + matrix[4];
        point[1] = x * matrix[1] + y * matrix[3] + matrix[5];
        return point;
    }
    _minValue(values) {
        let minimum = values[0];
        for (let i = 1; i < values.length; i++) {
            if (values[Number.parseInt(i.toString(), 10)] < minimum) {
                minimum = values[Number.parseInt(i.toString(), 10)];
            }
        }
        return minimum;
    }
    _maxValue(values) {
        let maximum = values[0];
        for (let i = 1; i < values.length; i++) {
            if (values[Number.parseInt(i.toString(), 10)] > maximum) {
                maximum = values[Number.parseInt(i.toString(), 10)];
            }
        }
        return maximum;
    }
    _doPostProcess(isFlatten = false) {
        let isTransformBBox = false;
        if (this._isLoaded && (this._setAppearance || isFlatten || this._isExport)) {
            if ((!isFlatten && !this._isExport) || this._setAppearance) {
                this._appearanceTemplate = this._createRubberStampAppearance();
            }
            if (!this._appearanceTemplate && (this._isExport || isFlatten) && this._dictionary.has('AP')) {
                const dictionary = this._dictionary.get('AP');
                if (dictionary && dictionary.has('N')) {
                    const appearanceStream = dictionary.get('N');
                    if (appearanceStream) {
                        const reference = dictionary.getRaw('N');
                        if (reference) {
                            appearanceStream.reference = reference;
                        }
                        let isStamp = false;
                        if (this._type === _PdfAnnotationType.rubberStampAnnotation) {
                            let isRotated = false;
                            let size;
                            let rect;
                            if (appearanceStream) {
                                isRotated = (this._page.rotation === PdfRotationAngle.angle0 &&
                                    this.rotateAngle === PdfRotationAngle.angle0);
                                if (!isRotated) {
                                    isRotated = (this._page.rotation !== PdfRotationAngle.angle0 &&
                                        this.rotateAngle === PdfRotationAngle.angle0);
                                }
                            }
                            this._appearanceTemplate = new PdfTemplate(appearanceStream, this._crossReference);
                            isStamp = true;
                            isTransformBBox = isRotated ? true : false;
                            if (isTransformBBox) {
                                const matrix = appearanceStream.dictionary.getArray('Matrix');
                                if (matrix) {
                                    const mMatrix = [];
                                    for (let i = 0; i < matrix.length; i++) {
                                        const value = matrix[Number.parseInt(i.toString(), 10)];
                                        mMatrix[Number.parseInt(i.toString(), 10)] = value;
                                    }
                                    const bounds = appearanceStream.dictionary.getArray('BBox');
                                    if (bounds && bounds.length > 3) {
                                        rect = _toRectangle(bounds);
                                        const rectangle = this._transformBBox(rect, mMatrix);
                                        size = [rectangle[2], rectangle[3]];
                                        this._appearanceTemplate._size = size;
                                    }
                                    else {
                                        size = [rect.width, rect.height];
                                    }
                                }
                            }
                            else {
                                size = [rect.width, rect.height];
                            }
                        }
                        if (!isStamp) {
                            this._appearanceTemplate = new PdfTemplate(appearanceStream, this._crossReference);
                        }
                    }
                }
            }
        }
        else {
            if (!(this._isImported && this._dictionary.has('AP'))) {
                this._postProcess();
            }
            if ((!this._appearanceTemplate) && (isFlatten || this._isImported)) {
                if (!this._dictionary.has('AP')) {
                    this._appearanceTemplate = this._createRubberStampAppearance();
                }
                else {
                    const dictionary = this._dictionary.get('AP');
                    if (dictionary && dictionary.has('N')) {
                        const appearanceStream = dictionary.get('N');
                        if (appearanceStream) {
                            const reference = dictionary.getRaw('N');
                            if (reference) {
                                appearanceStream.reference = reference;
                            }
                            this._appearanceTemplate = new PdfTemplate(appearanceStream, this._crossReference);
                        }
                    }
                }
            }
        }
        if (typeof this.flattenPopups !== 'undefined' && this.flattenPopups) {
            if (this._isLoaded) {
                this._flattenLoadedPopUp();
            }
            else {
                this._flattenPopUp();
            }
        }
        if (isFlatten && this._appearanceTemplate) {
            const isNormalMatrix = this._validateTemplateMatrix(this._appearanceTemplate._content.dictionary);
            if (!this._appearanceTemplate._content.dictionary.has('Matrix')) {
                const box = this._appearanceTemplate._content.dictionary.getArray('BBox');
                if (box) {
                    this._appearanceTemplate._content.dictionary.update('Matrix', [1, 0, 0, 1, -box[0], -box[1]]);
                }
            }
            if (isTransformBBox) {
                this._flattenAnnotationTemplate(this._appearanceTemplate, isTransformBBox);
            }
            else {
                this._flattenAnnotationTemplate(this._appearanceTemplate, isNormalMatrix);
            }
        }
    }
    _createRubberStampAppearance() {
        const nativeRectangle = [0, 0, this.bounds.width, this.bounds.height];
        let appearance;
        if (this._appearance) {
            appearance = this._appearance;
            if (!this._dictionary.has('Name')) {
                this._dictionary.update('Name', _PdfName.get('#23CustomStamp'));
            }
        }
        else {
            this._iconString = this._obtainIconName(this._icon);
            this._dictionary.update('Name', _PdfName.get('#23' + this._iconString));
            appearance = new PdfAppearance(this, nativeRectangle);
            appearance.normal = new PdfTemplate(nativeRectangle, this._crossReference);
        }
        const template = appearance.normal;
        if (typeof this._rotate !== 'undefined' && (this._rotate !== PdfRotationAngle.angle0 || this._getRotationAngle() !== 0)) {
            this.rotateAngle = this._getRotationAngle();
            if (this.rotateAngle === 0) {
                this.rotateAngle = this.rotationAngle * 90;
            }
            this.bounds = this._getRotatedBounds(this.bounds, this.rotateAngle);
        }
        _setMatrix(template, this.rotateAngle);
        if (!this._appearance) {
            this._drawStampAppearance(template);
        }
        if (this._dictionary.has('AP')) {
            _removeDuplicateReference(this._dictionary.get('AP'), this._crossReference, 'N');
        }
        const dictionary = new _PdfDictionary();
        template._content.dictionary._updated = true;
        const reference = this._crossReference._getNextReference();
        this._crossReference._cacheMap.set(reference, template._content);
        template._content.reference = reference;
        dictionary.set('N', reference);
        dictionary._updated = true;
        this._dictionary.set('AP', dictionary);
        this._dictionary.set('Border', [this.border.hRadius, this.border.vRadius, this.border.width]);
        const size = this._page.size;
        const rectangle = [this.bounds.x, this.bounds.y + this.bounds.height, this.bounds.width, this.bounds.height];
        rectangle[1] = size[1] - (this.bounds.y + this.bounds.height);
        this._dictionary.set('Rect', [rectangle[0], rectangle[1], rectangle[0] + rectangle[2], rectangle[1] + rectangle[3]]);
        return template;
    }
    _drawStampAppearance(template) {
        const stringFormat = new PdfStringFormat();
        stringFormat.alignment = PdfTextAlignment.center;
        stringFormat.lineAlignment = PdfVerticalAlignment.middle;
        const backBrush = new PdfBrush(this._obtainBackGroundColor());
        const borderPen = new PdfPen(this._obtainBorderColor(), this.border.width);
        const graphics = template.graphics;
        graphics.save();
        graphics.scaleTransform(template._size[0] / (this._stampWidth + 4), (template._size[1] / 28));
        const rubberFont = this._stampAppearanceFont;
        this._drawRubberStamp(graphics, borderPen, backBrush, rubberFont, stringFormat);
        graphics.restore();
    }
    _obtainIconName(icon) {
        switch (icon) {
            case PdfRubberStampAnnotationIcon.approved:
                this._iconString = 'Approved';
                this._stampWidth = 126;
                break;
            case PdfRubberStampAnnotationIcon.asIs:
                this._iconString = 'AsIs';
                this._stampWidth = 75;
                break;
            case PdfRubberStampAnnotationIcon.confidential:
                this._iconString = 'Confidential';
                this._stampWidth = 166;
                break;
            case PdfRubberStampAnnotationIcon.departmental:
                this._iconString = 'Departmental';
                this._stampWidth = 186;
                break;
            case PdfRubberStampAnnotationIcon.draft:
                this._iconString = 'Draft';
                this._stampWidth = 90;
                break;
            case PdfRubberStampAnnotationIcon.experimental:
                this._iconString = 'Experimental';
                this._stampWidth = 176;
                break;
            case PdfRubberStampAnnotationIcon.expired:
                this._iconString = 'Expired';
                this._stampWidth = 116;
                break;
            case PdfRubberStampAnnotationIcon.final:
                this._iconString = 'Final';
                this._stampWidth = 90;
                break;
            case PdfRubberStampAnnotationIcon.forComment:
                this._iconString = 'ForComment';
                this._stampWidth = 166;
                break;
            case PdfRubberStampAnnotationIcon.forPublicRelease:
                this._iconString = 'ForPublicRelease';
                this._stampWidth = 240;
                break;
            case PdfRubberStampAnnotationIcon.notApproved:
                this._iconString = 'NotApproved';
                this._stampWidth = 186;
                break;
            case PdfRubberStampAnnotationIcon.notForPublicRelease:
                this._iconString = 'NotForPublicRelease';
                this._stampWidth = 290;
                break;
            case PdfRubberStampAnnotationIcon.sold:
                this._iconString = 'Sold';
                this._stampWidth = 75;
                break;
            case PdfRubberStampAnnotationIcon.topSecret:
                this._iconString = 'TopSecret';
                this._stampWidth = 146;
                break;
            case PdfRubberStampAnnotationIcon.completed:
                this._iconString = 'Completed';
                this._stampWidth = 136;
                break;
            case PdfRubberStampAnnotationIcon.void:
                this._iconString = 'Void';
                this._stampWidth = 75;
                break;
            case PdfRubberStampAnnotationIcon.informationOnly:
                this._iconString = 'InformationOnly';
                this._stampWidth = 230;
                break;
            case PdfRubberStampAnnotationIcon.preliminaryResults:
                this._iconString = 'PreliminaryResults';
                this._stampWidth = 260;
                break;
        }
        return this._iconString;
    }
    _obtainBackGroundColor() {
        let color = [];
        let red;
        let green;
        let blue;
        if (this._icon === PdfRubberStampAnnotationIcon.notApproved ||
            this._icon === PdfRubberStampAnnotationIcon.void) {
            red = 251;
            green = 222;
            blue = 221;
            color = [red, green, blue];
        }
        else if (this._icon === PdfRubberStampAnnotationIcon.approved ||
            this._icon === PdfRubberStampAnnotationIcon.final ||
            this._icon === PdfRubberStampAnnotationIcon.completed) {
            red = 229;
            green = 238;
            blue = 222;
            color = [red, green, blue];
        }
        else {
            red = 219;
            green = 227;
            blue = 240;
            color = [red, green, blue];
        }
        return color;
    }
    _obtainBorderColor() {
        let color = [];
        let red;
        let green;
        let blue;
        if (this._icon === PdfRubberStampAnnotationIcon.notApproved ||
            this._icon === PdfRubberStampAnnotationIcon.void) {
            red = 151;
            green = 23;
            blue = 15;
            color = [red, green, blue];
        }
        else if (this._icon === PdfRubberStampAnnotationIcon.approved ||
            this._icon === PdfRubberStampAnnotationIcon.final ||
            this._icon === PdfRubberStampAnnotationIcon.completed) {
            red = 73;
            green = 110;
            blue = 38;
            color = [red, green, blue];
        }
        else {
            red = 24;
            green = 37;
            blue = 100;
            color = [red, green, blue];
        }
        return color;
    }
    _drawRubberStamp(graphics, pen, brush, font, format) {
        graphics.drawRoundedRectangle(2, 1, this._stampWidth, 26, 3, pen, brush);
        const pdfBrush = new PdfBrush(this._obtainBorderColor());
        graphics.drawString(this._iconString.toUpperCase(), font, [(this._stampWidth / 2) + 1, 15, 0, 0], null, pdfBrush, format);
    }
    _obtainInnerBounds() {
        let bounds = { x: 0, y: 0, width: 0, height: 0 };
        if (this._dictionary && this._dictionary.has('AP')) {
            const appearanceDictionary = this._dictionary.get('AP');
            if (appearanceDictionary && appearanceDictionary.has('N')) {
                const normalAppearance = appearanceDictionary.get('N');
                if (normalAppearance && typeof normalAppearance.dictionary !== 'undefined') {
                    const normalAppearanceDictionary = normalAppearance.dictionary;
                    if (normalAppearanceDictionary.has('BBox')) {
                        const values = normalAppearanceDictionary.getArray('BBox');
                        if (values && values.length === 4) {
                            bounds = _toRectangle(values);
                        }
                    }
                }
            }
        }
        return bounds;
    }
}
/**
 * `PdfSoundAnnotation` class represents the sound annotation objects.
 * ```typescript
 * // Load an existing PDF document
 * let document: PdfDocument = new PdfDocument(data, password);
 * // Access first page
 * let page: PdfPage = document.getPage(0);
 * // Access the annotation at index 0
 * let annotation: PdfSoundAnnotation = page.annotations.at(0) as PdfSoundAnnotation;
 * // Save the document
 * document.save('output.pdf');
 * // Destroy the document
 * document.destroy();
 * ```
 */
class PdfSoundAnnotation extends PdfComment {
    /**
     * Initializes a new instance of the `PdfSoundAnnotation` class.
     *
     * @private
     */
    constructor() {
        super();
        this._type = _PdfAnnotationType.soundAnnotation;
    }
    static _load(page, dictionary) {
        const annot = new PdfSoundAnnotation();
        annot._isLoaded = true;
        annot._initialize(page, dictionary);
        return annot;
    }
    _initialize(page, dictionary) {
        super._initialize(page, dictionary);
    }
    _doPostProcess(isFlatten = false) {
        if (isFlatten) {
            let appearanceStream;
            if (this._dictionary.has('AP')) {
                const dictionary = this._dictionary.get('AP');
                if (dictionary && dictionary.has('N')) {
                    appearanceStream = dictionary.get('N');
                    const reference = dictionary.getRaw('N');
                    if (reference && appearanceStream) {
                        appearanceStream.reference = reference;
                    }
                }
            }
            if (appearanceStream) {
                const template = new PdfTemplate(appearanceStream, this._crossReference);
                const isNormalMatrix = this._validateTemplateMatrix(template._content.dictionary);
                this._flattenAnnotationTemplate(template, isNormalMatrix);
            }
            else {
                this._removeAnnotation(this._page, this);
            }
        }
    }
}
/**
 * `PdfFreeTextAnnotation` class represents the free text annotation objects.
 * ```typescript
 * // Load an existing PDF document
 * let document: PdfDocument = new PdfDocument(data, password);
 * // Get the first page
 * let page: PdfPage = document.getPage(0) as PdfPage;
 * // Create a new free text annotation
 * const annotation: PdfFreeTextAnnotation = new PdfFreeTextAnnotation(50, 100, 100, 50);
 * // Add annotation to the page
 * page.annotations.add(annotation);
 * // Destroy the document
 * document.destroy();
 * ```
 */
class PdfFreeTextAnnotation extends PdfComment {
    constructor(x, y, width, height) {
        super();
        this._intentString = '';
        this._markUpFont = new PdfStandardFont(PdfFontFamily.helvetica, 7, PdfFontStyle.regular);
        this._textAlignment = PdfTextAlignment.left;
        this._cropBoxValueX = 0;
        this._cropBoxValueY = 0;
        this._dictionary = new _PdfDictionary();
        this._dictionary.update('Type', _PdfName.get('Annot'));
        this._dictionary.update('Subtype', _PdfName.get('FreeText'));
        if (typeof x !== 'undefined' && typeof y !== 'undefined' && typeof width !== 'undefined' && typeof height !== 'undefined') {
            this.bounds = { x, y, width, height };
        }
        this._type = _PdfAnnotationType.freeTextAnnotation;
    }
    /**
     * Gets the callout lines of the free text annotation.
     *
     * @returns {Array<number[]>} Callout lines.
     * ```typescript
     * // Load an existing PDF document
     * let document: PdfDocument = new PdfDocument(data, password);
     * // Get the first page
     * let page: PdfPage = document.getPage(0) as PdfPage;
     * // Get the first annotation of the page
     * let annotation: PdfFreeTextAnnotation= page.annotations.at(0) as PdfFreeTextAnnotation;
     * // Gets the callout lines of the free text annotation.
     * let calloutLines: Array<number[]> = annotation.calloutLines;
     * // Destroy the document
     * document.destroy();
     * ```
     */
    get calloutLines() {
        if (typeof this._calloutLines === 'undefined') {
            this._calloutLines = this._getCalloutLinePoints();
        }
        return this._calloutLines;
    }
    /**
     * Sets the callout lines of the free text annotation.
     *
     * @param {Array<number[]>} value Callout lines.
     * ```typescript
     * // Load an existing PDF document
     * let document: PdfDocument = new PdfDocument(data, password);
     * // Get the first page
     * let page: PdfPage = document.getPage(0) as PdfPage;
     * // Get the first annotation of the page
     * let annotation: PdfFreeTextAnnotation = page.annotations.at(0) as PdfFreeTextAnnotation;
     * // Sets the callout lines of the free text annotation.
     * annotation.calloutLines = [[100, 450], [100, 200], [100, 150]];
     * // Save the document
     * document.save('output.pdf');
     * // Destroy the document
     * document.destroy();
     * ```
     */
    set calloutLines(value) {
        if (!this._isLoaded) {
            this._calloutLines = value;
        }
        let isChanged = false;
        if (this._isLoaded && value.length >= 2) {
            if (this._calloutLines.length === value.length) {
                for (let i = 0; i < value.length; i++) {
                    const values = value[Number.parseInt(i.toString(), 10)];
                    for (let j = 0; j < values.length; j++) {
                        if (value[Number.parseInt(i.toString(), 10)][Number.parseInt(j.toString(), 10)] !==
                            this._calloutLines[Number.parseInt(i.toString(), 10)][Number.parseInt(j.toString(), 10)]) {
                            isChanged = true;
                            break;
                        }
                    }
                }
            }
            else {
                isChanged = true;
            }
        }
        if (isChanged) {
            const pageHeight = this._page.size[1];
            const lines = [];
            for (let i = 0; i < value.length; i++) {
                if (i < value.length) {
                    lines.push(value[Number.parseInt(i.toString(), 10)][0] + this._cropBoxValueX);
                    lines.push((pageHeight + this._cropBoxValueY) - value[Number.parseInt(i.toString(), 10)][1]);
                }
                else {
                    break;
                }
            }
            this._calloutLines = value;
            this._dictionary.update('CL', lines);
        }
    }
    /**
     * Gets the line ending style of the annotation.
     *
     * @returns {PdfLineEndingStyle} Line ending style.
     * ```typescript
     * // Load an existing PDF document
     * let document: PdfDocument = new PdfDocument(data, password);
     * // Get the first page
     * let page: PdfPage = document.getPage(0) as PdfPage;
     * // Get the first annotation of the page
     * let annotation: PdfFreeTextAnnotation = page.annotations.at(0) as PdfFreeTextAnnotation;
     * // Gets the Line ending style of the annotation.
     * let lineEndingStyle: PdfLineEndingStyle = annotation.lineEndingStyle;
     * // Save the document
     * document.save('output.pdf');
     * // Destroy the document
     * document.destroy();
     * ```
     */
    get lineEndingStyle() {
        this._lineEndingStyle = this._obtainLineEndingStyle();
        return this._lineEndingStyle;
    }
    /**
     * Sets the line ending style of the line annotation.
     *
     * @param {PdfLineEndingStyle} value Line ending style.
     * ```typescript
     * // Load an existing PDF document
     * let document: PdfDocument = new PdfDocument(data, password);
     * // Get the first page
     * let page: PdfPage = document.getPage(0) as PdfPage;
     * // Get the first annotation of the page
     * let annotation: PdfFreeTextAnnotation = page.annotations.at(0) as PdfFreeTextAnnotation;
     * // Sets the line ending style of the line annotation.
     * annotation.lineEndingStyle = PdfLineEndingStyle.closedArrow;
     * // Save the document
     * document.save('output.pdf');
     * // Destroy the document
     * document.destroy();
     * ```
     */
    set lineEndingStyle(value) {
        if (typeof value !== 'undefined') {
            this._dictionary.update('LE', _PdfName.get(_reverseMapEndingStyle(value)));
        }
        this._lineEndingStyle = value;
    }
    /**
     * Gets the text markup color of the annotation.
     *
     * @returns {number[]} Text markup color as R, G, B color array in between 0 to 255.
     * ```typescript
     * // Load an existing PDF document
     * let document: PdfDocument = new PdfDocument(data, password);
     * // Get the first page
     * let page: PdfPage = document.getPage(0) as PdfPage;
     * // Get the first annotation of the page
     * let annotation: PdfFreeTextAnnotation = page.annotations.at(0) as PdfFreeTextAnnotation;
     * // Gets the text markup color of the annotation.
     * let textMarkUpColor: number[] = annotation.textMarkUpColor;
     * // Destroy the document
     * document.destroy();
     * ```
     */
    get textMarkUpColor() {
        if (typeof this._textMarkUpColor === 'undefined') {
            let color;
            if (this._dictionary.has('TextColor')) {
                this._textMarkUpColor = _parseColor(this._dictionary.getArray('TextColor'));
                return this._textMarkUpColor;
            }
            if (this._dictionary.has('DS')) {
                const collections = this._dictionary.get('DS').split(';');
                for (let i = 0; i < collections.length; i++) {
                    if (collections[Number.parseInt(i.toString(), 10)].indexOf('color') !== -1) {
                        color = collections[Number.parseInt(i.toString(), 10)].split(':')[1];
                        if (color.startsWith('#')) {
                            color = color.substring(1);
                        }
                        this._textMarkUpColor = _convertToColor(color);
                        return this._textMarkUpColor;
                    }
                }
            }
            if (!this._textMarkUpColor && this._dictionary.has('RC')) {
                //Need to code
            }
        }
        return this._textMarkUpColor;
    }
    /**
     * Sets the text markup color of the annotation.
     *
     * @param {number[]} value R, G, B color values in between 0 to 255.
     * ```typescript
     * // Load an existing PDF document
     * let document: PdfDocument = new PdfDocument(data, password);
     * // Get the first page
     * let page: PdfPage = document.getPage(0) as PdfPage;
     * // Get the first annotation of the page
     * let annotation: PdfFreeTextAnnotation = page.annotations.at(0) as PdfFreeTextAnnotation;
     * // Sets the text markup color of the annotation.
     * annotation.textMarkUpColor = [200, 200, 200];
     * // Save the document
     * document.save('output.pdf');
     * // Destroy the document
     * document.destroy();
     * ```
     */
    set textMarkUpColor(value) {
        if (typeof value !== 'undefined' && value.length === 3) {
            this._textMarkUpColor = value;
            const ds = 'font:' +
                this.font._metrics._postScriptName +
                ' ' +
                this.font._size +
                'pt;style:' + _reverseMapPdfFontStyle(this.font._style) +
                ';color:' +
                this._colorToHex(value);
            this._dictionary.update('DS', ds);
        }
    }
    /**
     * Gets the text alignment of the annotation.
     *
     * @returns {PdfTextAlignment} Text alignment.
     * ```typescript
     * // Load an existing PDF document
     * let document: PdfDocument = new PdfDocument(data, password);
     * // Get the first page
     * let page: PdfPage = document.getPage(0) as PdfPage;
     * // Get the first annotation of the page
     * let annotation: PdfFreeTextAnnotation = page.annotations.at(0) as PdfFreeTextAnnotation;
     * // Gets the text alignment of the annotation.
     * let textAlignment: PdfTextAlignment = annotation.textAlignment;
     * // Destroy the document
     * document.destroy();
     * ```
     */
    get textAlignment() {
        if (this._dictionary.has('Q')) {
            this._textAlignment = this._dictionary.get('Q');
        }
        return this._textAlignment;
    }
    /**
     * Sets the text alignment of the annotation.
     *
     * @param {PdfTextAlignment} value Text alignment.
     * ```typescript
     * // Load an existing PDF document
     * let document: PdfDocument = new PdfDocument(data, password);
     * // Get the first page
     * let page: PdfPage = document.getPage(0) as PdfPage;
     * // Get the first annotation of the page
     * let annotation: PdfFreeTextAnnotation = page.annotations.at(0) as PdfFreeTextAnnotation;
     * // Sets the text alignment of the annotation.
     * annotation.textAlignment = PdfTextAlignment.justify;
     * // Save the document
     * document.save('output.pdf');
     * // Destroy the document
     * document.destroy();
     * ```
     */
    set textAlignment(value) {
        if (this._textAlignment !== value) {
            this._dictionary.update('Q', value);
        }
        this._textAlignment = value;
    }
    /**
     * Gets the font of the annotation.
     *
     * @returns {PdfFont} font.
     * ```typescript
     * // Load an existing PDF document
     * let document: PdfDocument = new PdfDocument(data, password);
     * // Get the first page
     * let page: PdfPage = document.getPage(0) as PdfPage;
     * // Get the first annotation of the page
     * let annotation: PdfFreeTextAnnotation = page.annotations.at(0) as PdfFreeTextAnnotation;
     * // Gets the font of the annotation.
     * let font: PdfFont = annotation.font;
     * // Destroy the document
     * document.destroy();
     * ```
     */
    get font() {
        if (!this._font) {
            this._font = this._obtainFont();
            if ((this._font === null || typeof this._font === 'undefined') || (!this._isLoaded && this._font.size === 1)) {
                this._font = this._markUpFont;
            }
        }
        return this._font;
    }
    /**
     * Sets the font of the annotation.
     *
     * @param {PdfFont} value font.
     * ```typescript
     * // Load an existing PDF document
     * let document: PdfDocument = new PdfDocument(data, password);
     * // Get the first page
     * let page: PdfPage = document.getPage(0) as PdfPage;
     * // Get the first annotation of the page
     * let annotation: PdfFreeTextAnnotation = page.annotations.at(0) as PdfFreeTextAnnotation;
     * // Sets the font of the annotation.
     * annotation.font = new PdfStandardFont(PdfFontFamily.helvetica, 10, PdfFontStyle.regular);
     * // Save the document
     * document.save('output.pdf');
     * // Destroy the document
     * document.destroy();
     * ```
     */
    set font(value) {
        this._font = value;
    }
    /**
     * Gets the border color of the annotation.
     *
     * @returns {number[]} R, G, B color values in between 0 to 255.
     * ```typescript
     * // Load an existing PDF document
     * let document: PdfDocument = new PdfDocument(data, password);
     * // Get the first page
     * let page: PdfPage = document.getPage(0) as PdfPage;
     * // Get the first annotation of the page
     * let annotation: PdfFreeTextAnnotation = page.annotations.at(0) as PdfFreeTextAnnotation;
     * // Gets the border color of the annotation.
     * let borderColor: number[] = annotation.borderColor;
     * // Destroy the document
     * document.destroy();
     * ```
     */
    get borderColor() {
        if (typeof this._borderColor === 'undefined' && this._dictionary.has('DA')) {
            this._borderColor = this._obtainColor();
        }
        return this._borderColor;
    }
    /**
     * Sets the border color of the annotation.
     *
     * @param {number[]} value R, G, B color values in between 0 to 255.
     * ```typescript
     * // Load an existing PDF document
     * let document: PdfDocument = new PdfDocument(data, password);
     * // Get the first page
     * let page: PdfPage = document.getPage(0) as PdfPage;
     * // Get the first annotation of the page
     * let annotation: PdfFreeTextAnnotation = page.annotations.at(0) as PdfFreeTextAnnotation;
     * // Sets the border color of the annotation.
     * annotation.borderColor = [150, 150, 150];
     * // Save the document
     * document.save('output.pdf');
     * // Destroy the document
     * document.destroy();
     * ```
     */
    set borderColor(value) {
        if (typeof value !== 'undefined' && value.length === 3) {
            this._borderColor = value;
            this._dictionary.update('DA', this._getBorderColorString(this.borderColor));
        }
    }
    /**
     * Gets the intent of the annotation.
     *
     * @returns {PdfAnnotationIntent} Annotation intent.
     * ```typescript
     * // Load an existing PDF document
     * let document: PdfDocument = new PdfDocument(data, password);
     * // Get the first page
     * let page: PdfPage = document.getPage(0) as PdfPage;
     * // Get the first annotation of the page
     * let annotation: PdfFreeTextAnnotation = page.annotations.at(0) as PdfFreeTextAnnotation;
     * // Gets the intent of the annotation.
     * let annotationIntent: PdfAnnotationIntent = annotation.annotationIntent;
     * // Destroy the document
     * document.destroy();
     * ```
     */
    get annotationIntent() {
        if (this._dictionary.has('IT')) {
            this._annotationIntent = _mapAnnotationIntent(this._dictionary.get('IT').name);
        }
        else {
            this._annotationIntent = PdfAnnotationIntent.none;
        }
        return this._annotationIntent;
    }
    /**
     * Sets the intent of the annotation.
     *
     * @param {PdfAnnotationIntent} value Annotation intent.
     * ```typescript
     * // Load an existing PDF document
     * let document: PdfDocument = new PdfDocument(data, password);
     * // Get the first page
     * let page: PdfPage = document.getPage(0) as PdfPage;
     * // Get the first annotation of the page
     * let annotation: PdfFreeTextAnnotation = page.annotations.at(0) as PdfFreeTextAnnotation;
     * // Sets the intent of the annotation.
     * annotation.annotationIntent = PdfAnnotationIntent.freeTextTypeWriter;
     * // Save the document
     * document.save('output.pdf');
     * // Destroy the document
     * document.destroy();
     * ```
     */
    set annotationIntent(value) {
        if (typeof value !== 'undefined') {
            this._annotationIntent = value;
            if (value === PdfAnnotationIntent.none) {
                this._dictionary.update('Subj', 'Text Box');
            }
            else {
                this._dictionary.update('IT', _PdfName.get(this._obtainAnnotationIntent(this._annotationIntent)));
            }
        }
    }
    get _mkDictionary() {
        let value;
        if (this._dictionary.has('MK')) {
            value = this._dictionary.get('MK');
        }
        return value;
    }
    static _load(page, dictionary) {
        const annot = new PdfFreeTextAnnotation();
        annot._isLoaded = true;
        annot._initialize(page, dictionary);
        return annot;
    }
    _setPaddings(paddings) {
        this._paddings = paddings;
    }
    _initialize(page, dictionary) {
        super._initialize(page, dictionary);
    }
    _postProcess(isFlatten) {
        if (typeof this.bounds === 'undefined' || this.bounds === null) {
            throw new Error('Bounds cannot be null or undefined');
        }
        let borderWidth;
        if (this._dictionary.has('BS')) {
            borderWidth = this.border.width;
        }
        else {
            const dictionary = new _PdfDictionary(this._crossReference);
            dictionary.set('Type', _PdfName.get('Border'));
            this._dictionary.set('BS', dictionary);
        }
        if (typeof borderWidth === 'undefined') {
            borderWidth = 1;
        }
        this._updateCropBoxValues();
        if (isFlatten || this._setAppearance) {
            this._appearanceTemplate = this._createAppearance();
        }
        if (!isFlatten) {
            const size = this._page.size;
            const rect = [this.bounds.x,
                size[1] - (this.bounds.y + this.bounds.height),
                this.bounds.width,
                this.bounds.height];
            this._dictionary.update('Rect', [rect[0], rect[1], rect[0] + rect[2], rect[1] + rect[3]]);
            this._saveFreeTextDictionary();
        }
    }
    _updateCropBoxValues() {
        if (this._page) {
            let cropOrMediaBox;
            if (this._page._pageDictionary.has('CropBox')) {
                cropOrMediaBox = this._page._pageDictionary.getArray('CropBox');
            }
            else if (this._page._pageDictionary.has('MediaBox')) {
                cropOrMediaBox = this._page._pageDictionary.getArray('MediaBox');
            }
            if (cropOrMediaBox) {
                this._cropBoxValueX = cropOrMediaBox[0];
                this._cropBoxValueY = cropOrMediaBox[1];
            }
        }
    }
    _doPostProcess(isFlatten = false) {
        if (this._isLoaded) {
            if (this._setAppearance || (isFlatten && !this._dictionary.has('AP'))) {
                this._appearanceTemplate = this._createAppearance();
            }
            if (!this._appearanceTemplate && isFlatten && this._dictionary.has('AP')) {
                const dictionary = this._dictionary.get('AP');
                if (dictionary && dictionary.has('N')) {
                    const appearanceStream = dictionary.get('N');
                    if (appearanceStream) {
                        const reference = dictionary.getRaw('N');
                        if (reference) {
                            appearanceStream.reference = reference;
                        }
                        this._appearanceTemplate = new PdfTemplate(appearanceStream, this._crossReference);
                    }
                }
            }
        }
        else {
            this._postProcess(isFlatten);
            if (!this._appearanceTemplate && isFlatten) {
                if (!this._dictionary.has('AP')) {
                    this._appearanceTemplate = this._createAppearance();
                }
                else {
                    const dictionary = this._dictionary.get('AP');
                    if (dictionary && dictionary.has('N')) {
                        const appearanceStream = dictionary.get('N');
                        if (appearanceStream) {
                            const reference = dictionary.getRaw('N');
                            if (reference) {
                                appearanceStream.reference = reference;
                            }
                            this._appearanceTemplate = new PdfTemplate(appearanceStream, this._crossReference);
                        }
                    }
                }
            }
        }
        if (typeof this.flattenPopups !== 'undefined' && this.flattenPopups) {
            if (this._isLoaded) {
                this._flattenLoadedPopUp();
            }
            else {
                this._flattenPopUp();
            }
        }
        if (isFlatten && this._appearanceTemplate) {
            const isNormalMatrix = this._validateTemplateMatrix(this._appearanceTemplate._content.dictionary);
            if (!this._appearanceTemplate._content.dictionary.has('Matrix') && !this._isLoaded) {
                const box = this._appearanceTemplate._content.dictionary.getArray('BBox');
                if (box) {
                    this._appearanceTemplate._content.dictionary.update('Matrix', [1, 0, 0, 1, -box[0], -box[1]]);
                }
            }
            if (isNormalMatrix && typeof this._page.rotation !== 'undefined' && this._page.rotation !== PdfRotationAngle.angle0) {
                this._flattenAnnotationTemplate(this._appearanceTemplate, isNormalMatrix);
            }
            else if (this._appearanceTemplate && !this._dictionary.has('AP')) {
                this._flattenAnnotationTemplate(this._appearanceTemplate, isNormalMatrix);
            }
            else if (this._dictionary.has('AP')) {
                if (this._isValidTemplateMatrix(this._appearanceTemplate._content.dictionary, this.bounds, this._appearanceTemplate)) {
                    this._flattenAnnotationTemplate(this._appearanceTemplate, isNormalMatrix);
                }
            }
        }
        if (!isFlatten && this._setAppearance) {
            let appearance;
            if (this._dictionary.has('AP')) {
                appearance = this._dictionary.get('AP');
            }
            else {
                const reference = this._crossReference._getNextReference();
                appearance = new _PdfDictionary(this._crossReference);
                this._crossReference._cacheMap.set(reference, appearance);
                this._dictionary.update('AP', reference);
            }
            _removeDuplicateReference(appearance, this._crossReference, 'N');
            const reference = this._crossReference._getNextReference();
            this._crossReference._cacheMap.set(reference, this._appearanceTemplate._content);
            appearance.update('N', reference);
        }
    }
    _isValidTemplateMatrix(dictionary, bounds, appearanceTemplate) {
        let isValidMatrix = true;
        const pointF = bounds;
        if (dictionary && dictionary.has('Matrix')) {
            const box = dictionary.getArray('BBox');
            const matrix = dictionary.getArray('Matrix');
            if (matrix && box && matrix.length > 3 && box.length > 2) {
                if (typeof matrix[0] !== 'undefined' &&
                    typeof matrix[1] !== 'undefined' &&
                    typeof matrix[2] !== 'undefined' &&
                    typeof matrix[3] !== 'undefined') {
                    if (matrix[0] === 1 && matrix[1] === 0 && matrix[2] === 0 && matrix[3] === 1) {
                        if (typeof box[0] !== 'undefined' &&
                            typeof box[1] !== 'undefined' &&
                            typeof box[2] !== 'undefined' &&
                            typeof box[3] !== 'undefined') {
                            if (Math.round(box[0]) !== Math.round(-(matrix[4])) && Math.round(box[1]) !== Math.round(-(matrix[5])) ||
                                box[0] === 0 && Math.round(-(matrix[4])) === 0) {
                                const graphics = this._page.graphics;
                                const state = graphics.save();
                                if (typeof this.opacity !== 'undefined' && this._opacity < 1) {
                                    graphics.setTransparency(this._opacity);
                                }
                                pointF.x -= box[0];
                                pointF.y += box[1];
                                graphics._drawTemplate(appearanceTemplate, pointF);
                                graphics.restore(state);
                                this._removeAnnotationFromPage(this._page, this);
                                isValidMatrix = false;
                            }
                        }
                    }
                }
            }
        }
        return isValidMatrix;
    }
    _createAppearance() {
        let template;
        const borderWidth = this.border.width / 2;
        const nativeRectangle = this._obtainAppearanceBounds();
        const rotationAngle = this.rotate;
        if (rotationAngle === 0 || rotationAngle === 90 || rotationAngle === 180 || rotationAngle === 270) {
            this._isAllRotation = false;
        }
        if (rotationAngle > 0 && this._isAllRotation) {
            template = new PdfTemplate([0, 0, nativeRectangle[2], nativeRectangle[3]], this._crossReference);
        }
        else {
            template = new PdfTemplate(nativeRectangle, this._crossReference);
        }
        _setMatrix(template, this._getRotationAngle());
        const parameter = new _PaintParameter();
        const text = this._obtainText();
        template._writeTransformation = false;
        const graphics = template.graphics;
        const alignment = this._obtainTextAlignment();
        const borderColor = this._obtainColor();
        const borderPen = new PdfPen(borderColor, this.border.width);
        if (this.border.width > 0) {
            parameter.borderPen = borderPen;
        }
        let rectangle = this._obtainStyle(borderPen, nativeRectangle, borderWidth, parameter);
        if (this.color) {
            parameter.foreBrush = new PdfBrush(this._color);
        }
        if (this.textMarkUpColor) {
            parameter.backBrush = new PdfBrush(this._textMarkUpColor);
        }
        parameter.borderWidth = this.border.width;
        if (this.calloutLines && this._calloutLines.length >= 2) {
            this._drawCallOuts(graphics, borderPen);
            if (this._isLoaded && typeof this._lineEndingStyle === 'undefined') {
                this._lineEndingStyle = this.lineEndingStyle;
            }
            if (this._lineEndingStyle !== PdfLineEndingStyle.none) {
                const linePoints = this._obtainLinePoints();
                const angle = this._getAngle(linePoints);
                const endPoint = this._getAxisValue([linePoints[2], linePoints[3]], 90, 0);
                this._drawLineEndStyle(endPoint, graphics, angle, borderPen, parameter.foreBrush, this.lineEndingStyle, this.border.width, false);
            }
            if (!this._dictionary.has('RD')) {
                rectangle = [this.bounds.x,
                    -((this._page.size[1] - (this.bounds.y + this.bounds.height))),
                    this.bounds.width,
                    -this.bounds.height];
            }
            else {
                rectangle = [rectangle[0], -rectangle[1], rectangle[2], -rectangle[3]];
            }
            rectangle[0] = rectangle[0] + this._cropBoxValueX;
            rectangle[1] = rectangle[1] - this._cropBoxValueY;
            this._calculateRectangle(rectangle);
            parameter.bounds = rectangle;
        }
        else {
            rectangle = [rectangle[0], -rectangle[1], rectangle[2], -rectangle[3]];
            parameter.bounds = rectangle;
        }
        const outerRectangle = this._obtainAppearanceBounds();
        const value = [rectangle[0] - outerRectangle[0], (-(rectangle[1])) - outerRectangle[1], rectangle[2] - outerRectangle[2],
            (((-rectangle[1]) - outerRectangle[1]) + (-rectangle[3])) - outerRectangle[3]];
        for (let i = 0; i < value.length; i++) {
            if (value[Number.parseInt(i.toString(), 10)] < 0) {
                value[Number.parseInt(i.toString(), 10)] = -value[Number.parseInt(i.toString(), 10)];
            }
        }
        this._dictionary.update('RD', value);
        if (this.opacity && this._opacity < 1) {
            graphics.save();
            graphics.setTransparency(this._opacity);
        }
        if (this.rotationAngle && this._rotate !== PdfRotationAngle.angle0) {
            graphics.save();
        }
        this._drawFreeTextRectangle(graphics, parameter, rectangle, alignment);
        this._drawFreeMarkUpText(graphics, parameter, rectangle, text, alignment);
        if (this.opacity && this._opacity < 1) {
            graphics.restore();
        }
        if (this.rotationAngle && this._rotate !== PdfRotationAngle.angle0) {
            graphics.restore();
        }
        const bounds = this._obtainAppearanceBounds();
        this._dictionary.set('Rect', [bounds[0], bounds[1], bounds[0] + bounds[2], bounds[1] + bounds[3]]);
        return template;
    }
    _calculateRectangle(innerRectangle) {
        const outerRectangle = this._obtainAppearanceBounds();
        const value = [innerRectangle[0] - outerRectangle[0],
            (-(innerRectangle[1])) - outerRectangle[1], innerRectangle[2] - outerRectangle[2],
            (((-innerRectangle[1]) - outerRectangle[1]) + (-innerRectangle[3])) - outerRectangle[3]];
        for (let i = 0; i < 4; i++) {
            if (value[Number.parseInt(i.toString(), 10)] < 0) {
                value[Number.parseInt(i.toString(), 10)] = -value[Number.parseInt(i.toString(), 10)];
            }
        }
        this._dictionary.set('RD', value);
    }
    _obtainAnnotationIntent(_annotationIntent) {
        switch (_annotationIntent) {
            case PdfAnnotationIntent.freeTextCallout:
                this._intentString = 'FreeTextCallout';
                break;
            case PdfAnnotationIntent.freeTextTypeWriter:
                this._intentString = 'FreeTextTypeWriter';
                break;
        }
        return this._intentString;
    }
    _obtainFont() {
        const fontData = this._obtainFontDetails();
        if (!fontData.size && this._dictionary.has('RC')) {
            //Parse XML data
        }
        return _mapFont(fontData.name, fontData.size, fontData.style, this);
    }
    _drawFreeMarkUpText(graphics, parameter, rectangle, text, alignment) {
        let isRotation = false;
        const angle = this.rotate;
        if (this.rotationAngle === PdfRotationAngle.angle90 && !this._isAllRotation) {
            rectangle = [-rectangle[1], rectangle[0], -rectangle[3], rectangle[2]];
        }
        else if (this.rotationAngle === PdfRotationAngle.angle180 && !this._isAllRotation) {
            rectangle = [-(rectangle[0] + rectangle[2]), -rectangle[3], rectangle[2], -rectangle[3]];
        }
        else if (this.rotationAngle === PdfRotationAngle.angle270 && !this._isAllRotation) {
            rectangle = [(rectangle[1] + rectangle[3]), -(rectangle[0] + rectangle[2]), -rectangle[3], rectangle[2]];
        }
        else if (angle === 0 && !this._isAllRotation) {
            rectangle = [rectangle[0], (rectangle[1] + rectangle[3]), rectangle[2], rectangle[3]];
        }
        if ((typeof this._font === 'undefined' || this._font === null) || (!this._isLoaded && this._font.size === 1)) {
            this._font = this._markUpFont;
        }
        if (angle > 0 && this._isAllRotation) {
            isRotation = true;
            const bounds = this.bounds;
            const format = new PdfStringFormat(PdfTextAlignment.center, PdfVerticalAlignment.middle);
            const textSize = this._font.measureString(text, [0, 0], format, 0, 0);
            if (angle > 0 && angle <= 91) {
                graphics.translateTransform(textSize[1], -bounds.height);
            }
            else if (angle > 91 && angle <= 181) {
                graphics.translateTransform(bounds.width - textSize[1], -(bounds.height - textSize[1]));
            }
            else if (angle > 181 && angle <= 271) {
                graphics.translateTransform(bounds.width - textSize[1], -textSize[1]);
            }
            else if (angle > 271 && angle < 360) {
                graphics.translateTransform(textSize[1], -textSize[1]);
            }
            graphics.rotateTransform(angle);
            parameter.bounds = [0, 0, parameter.bounds[2], parameter.bounds[3]];
        }
        const bounds = [rectangle[0], rectangle[1], rectangle[2], rectangle[3]];
        if (this._paddings && !this._isLoaded) {
            const left = this._paddings._left;
            const top = this._paddings._top;
            const right = this._paddings._right + this._paddings._left;
            const bottom = this._paddings._top + this._paddings._bottom;
            if (parameter.borderWidth > 0) {
                const first = rectangle[0] + (parameter.borderWidth + left);
                const second = rectangle[1] + (parameter.borderWidth + top);
                const third = rectangle[2] - ((parameter.borderWidth * 2) + right);
                let forth;
                if (rectangle[3] > 0) {
                    forth = rectangle[3] - ((parameter.borderWidth * 2) + bottom);
                }
                else {
                    forth = -rectangle[3] - ((parameter.borderWidth * 2) + bottom);
                }
                rectangle = [first, second, third, forth];
            }
            else {
                const first = rectangle[0] + left;
                const second = rectangle[1] + top;
                const third = rectangle[2] - right;
                let forth;
                if (rectangle[3] > 0) {
                    forth = rectangle[3] - bottom;
                }
                else {
                    forth = -rectangle[3] - bottom;
                }
                rectangle = [first, second, third, forth];
            }
        }
        else if (parameter.borderWidth > 0) {
            rectangle = [rectangle[0] + (parameter.borderWidth * 1.5),
                rectangle[1] + (parameter.borderWidth * 1.5),
                rectangle[2] - (parameter.borderWidth * 3),
                (rectangle[3] > 0) ? (rectangle[3] - (parameter.borderWidth * 3)) : (-rectangle[3] - (parameter.borderWidth * 3))];
        }
        const first = this._font._metrics._getHeight() > ((rectangle[3] > 0) ? rectangle[3] : -rectangle[3]);
        const second = this._font._metrics._getHeight() <= ((bounds[3] > 0) ? bounds[3] : -bounds[3]);
        const checkPaddingWithFontHeight = first && second;
        this._drawFreeTextAnnotation(graphics, parameter, text, this._font, checkPaddingWithFontHeight ? bounds : rectangle, true, alignment, isRotation);
    }
    _drawFreeTextRectangle(graphics, parameter, rectangle, alignment) {
        const isRotation = false;
        if (this._dictionary.has('BE')) {
            for (let i = 0; i < rectangle.length; i++) {
                if (rectangle[Number.parseInt(i.toString(), 10)] < 0) {
                    rectangle[Number.parseInt(i.toString(), 10)] = -rectangle[Number.parseInt(i.toString(), 10)];
                }
            }
            this._drawAppearance(graphics, parameter, rectangle);
            if (this.rotationAngle === PdfRotationAngle.angle90 && !this._isAllRotation) {
                graphics.rotateTransform(-90);
            }
            else if (this.rotationAngle === PdfRotationAngle.angle180 && !this._isAllRotation) {
                graphics.rotateTransform(-180);
            }
            else if (this.rotationAngle === PdfRotationAngle.angle270 && !this._isAllRotation) {
                graphics.rotateTransform(-270);
            }
        }
        else {
            if (this.rotationAngle === PdfRotationAngle.angle90 && !this._isAllRotation) {
                graphics.rotateTransform(-90);
                parameter.bounds = [-rectangle[1], rectangle[2] + rectangle[0] - rectangle[3], -rectangle[2]];
            }
            else if (this.rotationAngle === PdfRotationAngle.angle180 && !this._isAllRotation) {
                graphics.rotateTransform(-180);
                parameter.bounds = [-(rectangle[2] + rectangle[0]), -(rectangle[3] + rectangle[1]), rectangle[2], rectangle[3]];
            }
            else if (this.rotationAngle === PdfRotationAngle.angle270 && !this._isAllRotation) {
                graphics.rotateTransform(-270);
                parameter.bounds = [rectangle[1] + rectangle[3], -rectangle[0], -rectangle[3], -rectangle[2]];
            }
            this._drawFreeTextAnnotation(graphics, parameter, '', this._font, parameter.bounds, false, alignment, isRotation);
        }
    }
    _drawAppearance(graphics, parameter, rectangle) {
        const graphicsPath = new _PdfPath();
        graphicsPath._addRectangle(rectangle[0], rectangle[1], rectangle[2], rectangle[3]);
        if (this._dictionary.has('BE')) {
            const dictionary = this._dictionary.get('BE');
            if (dictionary && dictionary.has('I')) {
                const value = dictionary.get('I');
                const radius = value === 1 ? 4 : 9;
                this._drawCloudStyle(graphics, parameter.foreBrush, parameter.borderPen, radius, 0.833, graphicsPath._points, true);
            }
        }
    }
    _drawFreeTextAnnotation(g, parameter, text, font, rectangle, isSkipDrawRectangle, alignment, isRotation) {
        if (!isSkipDrawRectangle) {
            g.drawRectangle(rectangle[0], rectangle[1], rectangle[2], rectangle[3], parameter.borderPen, parameter.foreBrush);
        }
        else {
            const format = new PdfStringFormat();
            format.lineAlignment = PdfVerticalAlignment.top;
            format.alignment = alignment;
            format.lineSpacing = 0;
            if (isRotation) {
                g.drawString(text, font, parameter.bounds, null, parameter.backBrush, format);
            }
            else {
                g.drawString(text, font, rectangle, null, parameter.backBrush, format);
            }
        }
    }
    _getCalloutLinePoints() {
        if (this._dictionary.has('CL')) {
            const calloutLinepoints = this._dictionary.getArray('CL');
            if (calloutLinepoints) {
                this._calloutLines = [];
                for (let i = 0; i < calloutLinepoints.length; i = i + 2) {
                    const points = [calloutLinepoints[Number.parseInt(i.toString(), 10)],
                        this._page.size[1] - calloutLinepoints[i + 1]];
                    this._calloutLines.push(points);
                }
            }
        }
        return this._calloutLines;
    }
    _obtainAppearanceBounds() {
        let bounds = [0, 0, 0, 0];
        if (this.calloutLines && this._calloutLines.length > 0) {
            const path = new _PdfPath();
            const pointArray = [];
            const length = this._calloutLines.length === 2 ? 2 : 3;
            for (let i = 0; i < length; i++) {
                pointArray.push([0, 0]);
            }
            if (this._calloutLines.length >= 2) {
                this._obtainCallOutsNative();
                for (let i = 0; i < this._calloutLines.length; i++) {
                    if (i < 3) {
                        pointArray[Number.parseInt(i.toString(), 10)] = [this._calloutsClone[Number.parseInt(i.toString(), 10)][0],
                            this._calloutsClone[Number.parseInt(i.toString(), 10)][1]];
                    }
                    else {
                        break;
                    }
                }
            }
            if (pointArray.length > 0) {
                if (this.lineEndingStyle !== PdfLineEndingStyle.none) {
                    this._expandAppearance(pointArray);
                }
                path._addLines(pointArray);
            }
            path._addRectangle(this.bounds.x - 2, (this._page.size[1] - (this.bounds.y + this.bounds.height)) - 2, this.bounds.width + (2 * 2), this.bounds.height + (2 * 2));
            bounds = path._getBounds();
        }
        else {
            bounds = [this.bounds.x, (this._page.size[1] - (this.bounds.y + this.bounds.height)), this.bounds.width, this.bounds.height];
        }
        return bounds;
    }
    _obtainCallOutsNative() {
        if (this.calloutLines && this._calloutLines.length > 0) {
            const size = this._page.size;
            this._calloutsClone = [];
            for (let i = 0; i < this._calloutLines.length; i++) {
                this._calloutsClone.push([this._calloutLines[Number.parseInt(i.toString(), 10)][0],
                    size[1] - this._calloutLines[Number.parseInt(i.toString(), 10)][1]]);
            }
        }
    }
    _obtainLinePoints() {
        const pageHeight = this._page.size[1];
        return [this.calloutLines[1][0],
            pageHeight - this.calloutLines[1][1],
            this.calloutLines[0][0],
            pageHeight - this.calloutLines[0][1]];
    }
    _obtainLineEndingStyle() {
        let lineEndingStyle = PdfLineEndingStyle.square;
        if (this._dictionary.has('LE')) {
            lineEndingStyle = _mapLineEndingStyle(this._dictionary.get('LE').name, lineEndingStyle);
        }
        return lineEndingStyle;
    }
    _obtainText() {
        let text = '';
        if (this._dictionary.has('Contents')) {
            const markUpText = this._dictionary.get('Contents');
            if (markUpText) {
                text = markUpText;
            }
            if (text && text !== '') {
                this._text = text;
            }
            return text;
        }
        else if (this._dictionary.has('RC')) {
            //this._parseXMLData();
            text = this._rcText;
            return text;
        }
        return text;
    }
    _obtainTextAlignment() {
        let textAlignment = PdfTextAlignment.left;
        let hasAlignment;
        if (this._dictionary.has('Q')) {
            const value = this._dictionary.get('Q');
            if (typeof value !== 'undefined') {
                textAlignment = value;
                hasAlignment = true;
            }
        }
        else if (this._dictionary.has('RC')) {
            //Need to add
        }
        if (!hasAlignment && this._dictionary.has('DS')) {
            const value = this._dictionary.get('DS');
            const collections = value.split(';');
            for (let i = 0; i < collections.length; i++) {
                if (collections[Number.parseInt(i.toString(), 10)].indexOf('text-align') !== -1) {
                    switch (collections[Number.parseInt(i.toString(), 10)]) {
                        case 'left':
                            textAlignment = PdfTextAlignment.left;
                            break;
                        case 'right':
                            textAlignment = PdfTextAlignment.right;
                            break;
                        case 'center':
                            textAlignment = PdfTextAlignment.center;
                            break;
                        case 'justify':
                            textAlignment = PdfTextAlignment.justify;
                            break;
                    }
                }
            }
        }
        return textAlignment;
    }
    _obtainColor() {
        let color;
        if (this._isLoaded) {
            if (this._dictionary.has('DA')) {
                const entry = this._dictionary.get('DA');
                if (Array.isArray(entry) && entry.length > 0) {
                    color = [entry[0], entry[1], entry[2]];
                }
                else if (typeof entry === 'string') {
                    this._da = new _PdfDefaultAppearance(entry);
                    color = this._da.color;
                }
            }
            else if (this._dictionary.has('MK')) {
                const mkDict = this._mkDictionary;
                if (mkDict && mkDict.has('BC')) {
                    color = _parseColor(mkDict.getArray('BC'));
                }
            }
            else {
                color = [0, 0, 0];
            }
        }
        else {
            color = this._borderColor ? this._borderColor : [0, 0, 0];
        }
        return color;
    }
    _expandAppearance(pointArray) {
        const pointY = pointArray[0][1];
        const pointX = pointArray[0][0];
        if (pointY > this.bounds.y) {
            if (this.lineEndingStyle !== PdfLineEndingStyle.openArrow) {
                pointArray[0][1] -= (this.border.width * 11);
            }
        }
        else {
            pointArray[0][1] += (this.border.width * 11);
        }
        if (pointX <= this.bounds.x) {
            pointArray[0][0] -= (this.border.width * 11);
        }
        else {
            pointArray[0][0] += (this.border.width * 11);
        }
    }
    _drawCallOuts(graphics, borderPen) {
        const path = new _PdfPath();
        const pointArray = [];
        const length = this._calloutLines.length === 2 ? 2 : 3;
        for (let i = 0; i < length; i++) {
            pointArray.push([0, 0]);
        }
        if (this._calloutLines.length >= 2) {
            this._obtainCallOutsNative();
            for (let i = 0; i < this._calloutLines.length && i < 3; i++) {
                pointArray[Number.parseInt(i.toString(), 10)] = [this._calloutsClone[Number.parseInt(i.toString(), 10)][0],
                    -this._calloutsClone[Number.parseInt(i.toString(), 10)][1]];
            }
        }
        if (pointArray.length > 0) {
            path._addLines(pointArray);
        }
        graphics._drawPath(path, borderPen);
    }
    _saveFreeTextDictionary() {
        if ((typeof this.font === 'undefined' || this.font === null) || (!this._isLoaded && this.font.size === 1)) {
            this.font = this._markUpFont;
        }
        this._dictionary.update('Contents', this.text);
        if (this._isLoaded) {
            this._textAlignment = this.textAlignment;
        }
        this._dictionary.update('Q', this._textAlignment);
        if (this.annotationIntent === PdfAnnotationIntent.none) {
            this._dictionary.update('Subj', 'Text Box');
        }
        else {
            this._dictionary.update('IT', _PdfName.get(this._obtainAnnotationIntent(this._annotationIntent)));
        }
        const ds = 'font:' +
            this.font._metrics._postScriptName +
            ' ' +
            this.font._size +
            'pt;style:' + _reverseMapPdfFontStyle(this.font._style) +
            ';color:' +
            this._colorToHex(this.textMarkUpColor);
        this._dictionary.update('DS', ds);
        this._dictionary.update('DA', this._getBorderColorString(this.borderColor ? this._borderColor : [0, 0, 0]));
        const body = '<?xml version="1.0"?><body xmlns="http://www.w3.org/1999/xhtml"><p dir="ltr">';
        this._dictionary.update('RC', body + (this.text ? this._getXmlFormattedString(this.text) : '') + '</p></body>');
        if (this._calloutLines && this._calloutLines.length >= 2) {
            const pageHeight = this._page.size[1];
            const lines = [];
            for (let i = 0; i < this._calloutLines.length && i < 3; i++) {
                lines.push(this._calloutLines[Number.parseInt(i.toString(), 10)][0] + this._cropBoxValueX);
                lines.push((pageHeight + this._cropBoxValueY) - this._calloutLines[Number.parseInt(i.toString(), 10)][1]);
            }
            this._dictionary.update('CL', lines);
        }
        if (this._setAppearance) {
            const rect = this._obtainAppearanceBounds();
            this._dictionary.update('Rect', [rect[0], rect[1], rect[0] + rect[2], rect[1] + rect[3]]);
        }
    }
    _getXmlFormattedString(markupText) {
        markupText = markupText.replace('&', '&amp;');
        markupText = markupText.replace('<', '&lt;');
        markupText = markupText.replace('>', '&gt;');
        return markupText;
    }
}
/**
 * `PdfRedactionAnnotation` class represents the redaction annotation objects.
 * ```typescript
 * // Load an existing PDF document
 * let document: PdfDocument = new PdfDocument(data, password);
 * // Get the first page
 * let page: PdfPage = document.getPage(0) as PdfPage;
 * // Create a new redaction annotation
 * const annotation: PdfRedactionAnnotation = new PdfRedactionAnnotation (50, 100, 100, 50);
 * // Add annotation to the page
 * page.annotations.add(annotation);
 * // Destroy the document
 * document.destroy();
 * ```
 */
class PdfRedactionAnnotation extends PdfAnnotation {
    constructor(x, y, width, height) {
        super();
        this._textAlignment = PdfTextAlignment.left;
        this._dictionary = new _PdfDictionary();
        this._dictionary.update('Type', _PdfName.get('Annot'));
        this._dictionary.update('Subtype', _PdfName.get('Redact'));
        if (typeof x !== 'undefined' && typeof y !== 'undefined' && typeof width !== 'undefined' && typeof height !== 'undefined') {
            this.bounds = { x, y, width, height };
        }
        this._type = _PdfAnnotationType.redactionAnnotation;
    }
    /**
     * Gets the boolean flag indicating whether annotation has repeat text or not.
     *
     * @returns {boolean} repeat text.
     * ```typescript
     * // Load an existing PDF document
     * let document: PdfDocument = new PdfDocument(data, password);
     * // Get the first page
     * let page: PdfPage = document.getPage(0) as PdfPage;
     * // Get the first annotation of the page
     * let annotation: PdfRedactionAnnotation = page.annotations.at(0) as PdfRedactionAnnotation;
     * // Gets the boolean flag indicating whether annotation has repeat text or not.
     * let repeatText: boolean = annotation. repeatText;
     * // Destroy the document
     * document.destroy();
     * ```
     */
    get repeatText() {
        if (typeof this._repeat === 'undefined' && this._dictionary.has('Repeat')) {
            this._repeat = this._dictionary.get('Repeat');
        }
        return this._repeat;
    }
    /**
     * Sets the boolean flag indicating whether annotation has repeat text or not.
     *
     * @param {boolean} value repeat text.
     * ```typescript
     * // Load an existing PDF document
     * let document: PdfDocument = new PdfDocument(data, password);
     * // Get the first page
     * let page: PdfPage = document.getPage(0) as PdfPage;
     * // Get the first annotation of the page
     * let annotation: PdfRedactionAnnotation = page.annotations.at(0) as PdfRedactionAnnotation;
     * // Sets the boolean flag indicating whether annotation has repeat text or not.
     * annotation.repeatText = false;
     * // Save the document
     * document.save('output.pdf');
     * // Destroy the document
     * document.destroy();
     * ```
     */
    set repeatText(value) {
        if (value !== this._repeat) {
            this._repeat = value;
            if (this._dictionary) {
                this._dictionary.update('Repeat', value);
            }
        }
    }
    /**
     * Gets the text alignment of the annotation.
     *
     * @returns {PdfTextAlignment} Text alignment.
     * ```typescript
     * // Load an existing PDF document
     * let document: PdfDocument = new PdfDocument(data, password);
     * // Get the first page
     * let page: PdfPage = document.getPage(0) as PdfPage;
     * // Get the first annotation of the page
     * let annotation: PdfRedactionAnnotation = page.annotations.at(0) as PdfRedactionAnnotation;
     * // Gets the text alignment of the annotation.
     * let textAlignment: PdfTextAlignment = annotation.textAlignment;
     * // Destroy the document
     * document.destroy();
     * ```
     */
    get textAlignment() {
        if (this._dictionary.has('Q')) {
            this._textAlignment = this._dictionary.get('Q');
        }
        return this._textAlignment;
    }
    /**
     * Sets the text alignment of the annotation.
     *
     * @param {PdfTextAlignment} value Text alignment.
     * ```typescript
     * // Load an existing PDF document
     * let document: PdfDocument = new PdfDocument(data, password);
     * // Get the first page
     * let page: PdfPage = document.getPage(0) as PdfPage;
     * // Get the first annotation of the page
     * let annotation: PdfRedactionAnnotation = page.annotations.at(0) as PdfRedactionAnnotation;
     * // Sets the text alignment of the annotation.
     * annotation.textAlignment = PdfTextAlignment.justify;
     * // Save the document
     * document.save('output.pdf');
     * // Destroy the document
     * document.destroy();
     * ```
     */
    set textAlignment(value) {
        if (this._textAlignment !== value) {
            this._dictionary.update('Q', value);
        }
        this._textAlignment = value;
    }
    /**
     * Gets the text color of the annotation.
     *
     * @returns {number[]} R, G, B color values in between 0 to 255.
     * ```typescript
     * // Load an existing PDF document
     * let document: PdfDocument = new PdfDocument(data, password);
     * // Get the first page
     * let page: PdfPage = document.getPage(0) as PdfPage;
     * // Get the first annotation of the page
     * let annotation: PdfRedactionAnnotation = page.annotations.at(0) as PdfRedactionAnnotation;
     * // Gets the text color of the annotation.
     * let textColor : number[] = annotation.textColor;
     * // Destroy the document
     * document.destroy();
     * ```
     */
    get textColor() {
        if (typeof this._textColor === 'undefined' && this._dictionary.has('C')) {
            this._textColor = _parseColor(this._dictionary.getArray('C'));
        }
        return this._textColor;
    }
    /**
     * Sets the text color of the annotation.
     *
     * @param {number[]} value R, G, B color values in between 0 to 255.
     * ```typescript
     * // Load an existing PDF document
     * let document: PdfDocument = new PdfDocument(data, password);
     * // Get the first page
     * let page: PdfPage = document.getPage(0) as PdfPage;
     * // Get the first annotation of the page
     * let annotation: PdfRedactionAnnotation = page.annotations.at(0) as PdfRedactionAnnotation;
     * // Sets the text color of the annotation.
     * annotation.textColor = [255, 255, 255];
     * // Save the document
     * document.save('output.pdf');
     * // Destroy the document
     * document.destroy();
     * ```
     */
    set textColor(value) {
        if (typeof value !== 'undefined' && value.length === 3) {
            const extColor = this.textColor;
            if (!this._isLoaded || typeof extColor === 'undefined' || (extColor[0] !== value[0] || extColor[1] !== value[1] || extColor[2] !== value[2])) {
                this._textColor = value;
                this._dictionary.update('C', [Number.parseFloat((value[0] / 255).toFixed(3)),
                    Number.parseFloat((value[1] / 255).toFixed(3)),
                    Number.parseFloat((value[2] / 255).toFixed(3))]);
            }
        }
    }
    /**
     * Gets the border color of the annotation.
     *
     * @returns {number[]} R, G, B color values in between 0 to 255.
     * ```typescript
     * // Load an existing PDF document
     * let document: PdfDocument = new PdfDocument(data, password);
     * // Get the first page
     * let page: PdfPage = document.getPage(0) as PdfPage;
     * // Get the first annotation of the page
     * let annotation: PdfRedactionAnnotation = page.annotations.at(0) as PdfRedactionAnnotation;
     * // Gets the border color of the annotation.
     * let borderColor: number[] = annotation.borderColor;
     * // Destroy the document
     * document.destroy();
     * ```
     */
    get borderColor() {
        if (typeof this._borderColor === 'undefined' && this._dictionary.has('OC')) {
            this._borderColor = _parseColor(this._dictionary.getArray('OC'));
        }
        return this._borderColor;
    }
    /**
     * Sets the border color of the annotation.
     *
     * @param {number[]} value R, G, B color values in between 0 to 255.
     * ```typescript
     * // Load an existing PDF document
     * let document: PdfDocument = new PdfDocument(data, password);
     * // Get the first page
     * let page: PdfPage = document.getPage(0) as PdfPage;
     * // Get the first annotation of the page
     * let annotation: PdfRedactionAnnotation = page.annotations.at(0) as PdfRedactionAnnotation;
     * // Sets the border color of the annotation.
     * annotation.borderColor = [255, 255, 255];
     * // Save the document
     * document.save('output.pdf');
     * // Destroy the document
     * document.destroy();
     * ```
     */
    set borderColor(value) {
        if (typeof value !== 'undefined' && value.length === 3) {
            const extColor = this.borderColor;
            if (!this._isLoaded || typeof extColor === 'undefined' || (extColor[0] !== value[0] || extColor[1] !== value[1] || extColor[2] !== value[2])) {
                this._borderColor = value;
                this._dictionary.update('OC', [Number.parseFloat((value[0] / 255).toFixed(3)),
                    Number.parseFloat((value[1] / 255).toFixed(3)),
                    Number.parseFloat((value[2] / 255).toFixed(3))]);
            }
        }
    }
    /**
     * Gets the overlay text of the annotation.
     *
     * @returns {string} overlay text.
     * ```typescript
     * // Load an existing PDF document
     * let document: PdfDocument = new PdfDocument(data, password);
     * // Get the first page
     * let page: PdfPage = document.getPage(0) as PdfPage;
     * // Get the first annotation of the page
     * let annotation: PdfRedactionAnnotation = page.annotations.at(0) as PdfRedactionAnnotation;
     * // Gets the overlay text of the annotation.
     * let overlayText: string =annotation.overlayText;
     * // Destroy the document
     * document.destroy();
     * ```
     */
    get overlayText() {
        if (typeof this._overlayText === 'undefined' && this._dictionary.has('OverlayText')) {
            this._overlayText = this._dictionary.get('OverlayText');
        }
        return this._overlayText;
    }
    /**
     * Sets the overlay text of the annotation.
     *
     * @param {string} value overlay text.
     * ```typescript
     * // Load an existing PDF document
     * let document: PdfDocument = new PdfDocument(data, password);
     * // Get the first page
     * let page: PdfPage = document.getPage(0) as PdfPage;
     * // Get the first annotation of the page
     * let annotation: PdfRedactionAnnotation = page.annotations.at(0) as PdfRedactionAnnotation;
     * // Sets the overlay text of the annotation.
     * annotation.overlayText = ‘syncfusion’;
     * // Save the document
     * document.save('output.pdf');
     * // Destroy the document
     * document.destroy();
     * ```
     */
    set overlayText(value) {
        if (typeof value === 'string') {
            this._dictionary.update('OverlayText', value);
            this._overlayText = value;
        }
    }
    /**
     * Gets the font of the annotation.
     *
     * @returns {PdfFont} font.
     * ```typescript
     * // Load an existing PDF document
     * let document: PdfDocument = new PdfDocument(data, password);
     * // Get the first page
     * let page: PdfPage = document.getPage(0) as PdfPage;
     * // Get the first annotation of the page
     * let annotation: PdfRedactionAnnotation = page.annotations.at(0) as PdfRedactionAnnotation;
     * // Gets the font of the annotation.
     * let font: PdfFont = annotation.font;
     * // Destroy the document
     * document.destroy();
     * ```
     */
    get font() {
        return this._font;
    }
    /**
     * Sets the font of the annotation.
     *
     * @param {PdfFont} value font.
     * ```typescript
     * // Load an existing PDF document
     * let document: PdfDocument = new PdfDocument(data, password);
     * // Get the first page
     * let page: PdfPage = document.getPage(0) as PdfPage;
     * // Get the first annotation of the page
     * let annotation: PdfRedactionAnnotation = page.annotations.at(0) as PdfRedactionAnnotation;
     * // Sets the font of the annotation.
     * annotation.font = new PdfStandardFont(PdfFontFamily.helvetica, 10, PdfFontStyle.regular);
     * // Save the document
     * document.save('output.pdf');
     * // Destroy the document
     * document.destroy();
     * ```
     */
    set font(value) {
        this._font = value;
    }
    static _load(page, dictionary) {
        const annot = new PdfRedactionAnnotation();
        annot._isLoaded = true;
        annot._initialize(page, dictionary);
        return annot;
    }
    _initialize(page, dictionary) {
        super._initialize(page, dictionary);
    }
    _postProcess(isFlatten) {
        if (typeof this.bounds === 'undefined' || this.bounds === null) {
            throw new Error('Bounds cannot be null or undefined');
        }
        let borderWidth;
        if (this._dictionary.has('BS')) {
            borderWidth = this.border.width;
        }
        else {
            const dictionary = new _PdfDictionary(this._crossReference);
            dictionary.set('Type', _PdfName.get('Border'));
            this._dictionary.set('BS', dictionary);
        }
        if (typeof borderWidth === 'undefined') {
            borderWidth = 1;
        }
        if (this._setAppearance) {
            this._appearanceTemplate = this._createRedactionAppearance(isFlatten);
        }
        const size = this._page.size;
        const rect = [this.bounds.x,
            size[1] - (this.bounds.y + this.bounds.height),
            this.bounds.width,
            this.bounds.height];
        this._dictionary.update('Rect', [rect[0], rect[1], rect[0] + rect[2], rect[1] + rect[3]]);
    }
    _doPostProcess(isFlatten = false) {
        if (!this._isImported) {
            if (this._isLoaded) {
                this._appearanceTemplate = this._createRedactionAppearance(isFlatten);
            }
            else {
                this._postProcess(isFlatten);
                if (!this._appearanceTemplate) {
                    if (isFlatten) {
                        if (!this._dictionary.has('AP')) {
                            this._appearanceTemplate = this._createRedactionAppearance(isFlatten);
                        }
                        else {
                            const dictionary = this._dictionary.get('AP');
                            if (dictionary && dictionary.has('N')) {
                                const appearanceStream = dictionary.get('N');
                                if (appearanceStream) {
                                    const reference = dictionary.getRaw('N');
                                    if (reference) {
                                        appearanceStream.reference = reference;
                                    }
                                    this._appearanceTemplate = new PdfTemplate(appearanceStream, this._crossReference);
                                }
                            }
                        }
                    }
                }
            }
            if (isFlatten && this._appearanceTemplate) {
                const isNormalMatrix = this._validateTemplateMatrix(this._appearanceTemplate._content.dictionary);
                if (!this._appearanceTemplate._content.dictionary.has('Matrix')) {
                    const box = this._appearanceTemplate._content.dictionary.getArray('BBox');
                    if (box) {
                        this._appearanceTemplate._content.dictionary.update('Matrix', [1, 0, 0, 1, -box[0], -box[1]]);
                    }
                }
                this._flattenAnnotationTemplate(this._appearanceTemplate, isNormalMatrix);
            }
        }
    }
    _createRedactionAppearance(isFlatten) {
        const normalTemplate = this._createNormalAppearance();
        if (isFlatten) {
            if (this._isLoaded && this._page !== null) {
                this._removeAnnotationFromPage(this._page, this);
            }
        }
        else {
            const borderTemplate = this._createBorderAppearance();
            if (this._dictionary.has('AP')) {
                const appearance = this._dictionary.get('AP');
                _removeDuplicateReference(appearance, this._crossReference, 'N');
                _removeDuplicateReference(appearance, this._crossReference, 'R');
            }
            const dictionary = new _PdfDictionary(this._crossReference);
            borderTemplate._content.dictionary._updated = true;
            const reference1 = this._crossReference._getNextReference();
            this._crossReference._cacheMap.set(reference1, borderTemplate._content);
            borderTemplate._content.reference = reference1;
            dictionary.set('N', reference1);
            normalTemplate._content.dictionary._updated = true;
            const reference = this._crossReference._getNextReference();
            this._crossReference._cacheMap.set(reference, normalTemplate._content);
            normalTemplate._content.reference = reference;
            dictionary.set('R', reference);
            dictionary._updated = true;
            this._dictionary.set('AP', dictionary);
        }
        return normalTemplate;
    }
    _createBorderAppearance() {
        const nativeRectangle = [0, 0, this.bounds.width, this.bounds.height];
        const template = new PdfTemplate(nativeRectangle, this._crossReference);
        const width = this.border.width / 2;
        const graphics = template.graphics;
        const actualWidth = this.border.width;
        let pen;
        if (this.border.width > 0 && this.borderColor) {
            pen = new PdfPen(this.borderColor, actualWidth);
        }
        const rect = [nativeRectangle[0], nativeRectangle[1], nativeRectangle[2], nativeRectangle[3]];
        if (this.opacity < 1) {
            const state = graphics.save();
            graphics.setTransparency(this.opacity);
            graphics.drawRectangle(rect[0] + width, rect[1] + width, rect[2] - actualWidth, rect[3] - actualWidth, pen, null);
            graphics.restore(state);
        }
        else {
            graphics.drawRectangle(rect[0] + width, rect[1] + width, rect[2] - actualWidth, rect[3] - actualWidth, pen, null);
        }
        return template;
    }
    _createNormalAppearance() {
        const nativeRectangle = [0, 0, this.bounds.width, this.bounds.height];
        const template = new PdfTemplate(nativeRectangle, this._crossReference);
        _setMatrix(template, this._getRotationAngle());
        const width = this.border.width / 2;
        const graphics = template.graphics;
        const parameter = new _PaintParameter();
        let borderPen;
        if (this.textColor && this.border.width > 0) {
            borderPen = new PdfPen(this.textColor, this.border.width);
        }
        let backBrush;
        let textcolor;
        if (this.innerColor) {
            backBrush = new PdfBrush(this.innerColor);
        }
        if (this.textColor) {
            textcolor = new PdfBrush(this.textColor);
        }
        else {
            textcolor = new PdfBrush([128, 128, 128]);
        }
        parameter.backBrush = backBrush;
        parameter.borderWidth = width;
        const widths = this.border.width;
        const rect = [nativeRectangle[0], nativeRectangle[1], nativeRectangle[2], nativeRectangle[3]];
        if (this.opacity < 1) {
            const state = graphics.save();
            graphics.setTransparency(this.opacity);
            graphics.drawRectangle(rect[0] + width, rect[1] + width, rect[2] - widths, rect[3] - widths, borderPen, backBrush);
            graphics.restore(state);
        }
        else {
            graphics.drawRectangle(rect[0] + width, rect[1] + width, rect[2] - widths, rect[3] - widths, borderPen, backBrush);
        }
        graphics.restore();
        if (this.overlayText && this._overlayText !== '') {
            let col = 0;
            let row = 0;
            if (typeof this.font === 'undefined' || this.font === null) {
                this.font = this._lineCaptionFont;
            }
            let y = 0;
            let x = 0;
            let diff = 0;
            let rectangle;
            if (this._isLoaded) {
                this._textAlignment = this.textAlignment;
            }
            const format = new PdfStringFormat(this._textAlignment, PdfVerticalAlignment.middle);
            const textsize = this.font.measureString(this.overlayText, [0, 0], format, 0, 0);
            if (this._isLoaded && typeof this._repeat === 'undefined') {
                this._repeat = this.repeatText;
            }
            if (this._repeat) {
                if (textsize[0] <= 0) {
                    textsize[0] = 1;
                }
                col = this.bounds.width / textsize[0];
                row = Math.floor(this.bounds.height / this.font._size);
                diff = Math.abs(this.bounds.width - (Math.floor(col) * textsize[0]));
                if (this._textAlignment === PdfTextAlignment.center) {
                    x = diff / 2;
                }
                if (this._textAlignment === PdfTextAlignment.right) {
                    x = diff;
                }
                for (let i = 1; i < col; i++) {
                    for (let j = 0; j < row; j++) {
                        rectangle = [x, y, 0, 0];
                        graphics.drawString(this.overlayText, this.font, rectangle, null, textcolor, null);
                        y = y + this.font._size;
                    }
                    x = x + textsize[0];
                    y = 0;
                }
            }
            else {
                diff = Math.abs(this.bounds.width - textsize[0]);
                if (this._textAlignment === PdfTextAlignment.center) {
                    x = diff / 2;
                }
                if (this._textAlignment === PdfTextAlignment.right) {
                    x = diff;
                }
                rectangle = [x, 0, 0, 0];
                graphics.drawString(this.overlayText, this.font, rectangle, null, textcolor, null);
            }
        }
        return template;
    }
}
/**
 * `PdfRichMediaAnnotation` class represents the rich media annotation objects.
 * ```typescript
 * // Load an existing PDF document
 * let document: PdfDocument = new PdfDocument(data, password);
 * // Access first page
 * let page: PdfPage = document.getPage(0);
 * // Access the annotation at index 0
 * let annotation: PdfRichMediaAnnotation = page.annotations.at(0) as PdfRichMediaAnnotation;
 * // Save the document
 * document.save('output.pdf');
 * // Destroy the document
 * document.destroy();
 * ```
 */
class PdfRichMediaAnnotation extends PdfAnnotation {
    /**
     * Initializes a new instance of the `PdfRichMediaAnnotation` class.
     *
     * @private
     */
    constructor() {
        super();
        this._type = _PdfAnnotationType.richMediaAnnotation;
    }
    static _load(page, dictionary) {
        const annot = new PdfRichMediaAnnotation();
        annot._isLoaded = true;
        annot._initialize(page, dictionary);
        return annot;
    }
    _initialize(page, dictionary) {
        super._initialize(page, dictionary);
    }
    _doPostProcess(isFlatten = false) {
        if (typeof this.flattenPopups !== 'undefined' && this.flattenPopups) {
            this._flattenPopUp();
        }
        if (isFlatten) {
            let appearanceStream;
            if (this._dictionary.has('AP')) {
                const dictionary = this._dictionary.get('AP');
                if (dictionary && dictionary.has('N')) {
                    appearanceStream = dictionary.get('N');
                    const reference = dictionary.getRaw('N');
                    if (reference && appearanceStream) {
                        appearanceStream.reference = reference;
                    }
                }
            }
            if (appearanceStream) {
                const template = new PdfTemplate(appearanceStream, this._crossReference);
                const isNormalMatrix = this._validateTemplateMatrix(template._content.dictionary);
                this._flattenAnnotationTemplate(template, isNormalMatrix);
            }
            else {
                this._removeAnnotation(this._page, this);
            }
        }
    }
}
/**
 * `PdfWidgetAnnotation` class represents the widget annotation objects.
 * ```typescript
 * // Load an existing PDF document
 * let document: PdfDocument = new PdfDocument(data, password);
 * // Access first page
 * let page: PdfPage = document.getPage(0);
 * // Access the annotation at index 0
 * let annotation: PdfWidgetAnnotation = page.annotations.at(0) as PdfWidgetAnnotation;
 * // Save the document
 * document.save('output.pdf');
 * // Destroy the document
 * document.destroy();
 * ```
 */
class PdfWidgetAnnotation extends PdfAnnotation {
    /**
     * Initializes a new instance of the `PdfWidgetAnnotation` class.
     *
     * @private
     */
    constructor() {
        super();
        this._isAutoResize = false;
        this._visibility = PdfFormFieldVisibility.visible;
        this._isFont = false;
        this._isTransparentBackColor = false;
        this._isWidget = true;
        this._type = _PdfAnnotationType.widgetAnnotation;
    }
    /**
     * Parse an existing widget annotation.
     *
     * @private
     * @param {_PdfDictionary} dictionary Widget dictionary.
     * @param {_PdfCrossReference} crossReference PDF cross reference.
     * @returns {PdfWidgetAnnotation} Widget.
     */
    static _load(dictionary, crossReference) {
        const widget = new PdfWidgetAnnotation();
        widget._isLoaded = true;
        widget._dictionary = dictionary;
        widget._crossReference = crossReference;
        return widget;
    }
    /**
     * Gets the page object (Read only).
     *
     * @returns {PdfPage} page object.
     *
     * ```typescript
     * // Load an existing PDF document
     * let document: PdfDocument = new PdfDocument(data, password);
     * // Access check box field
     * let field: PdfCheckBoxField = document.form.fieldAt(0) as PdfCheckBoxField;
     * // Access first item of check box field
     * let item: PdfWidgetAnnotation = field.itemAt(0);
     * // Gets the page object.
     * let page: PdfPage = item.page;
     * // Save the document
     * document.save('output.pdf');
     * // Destroy the document
     * document.destroy();
     * ```
     */
    get page() {
        return this._getPage();
    }
    /**
     * Gets the fore color of the annotation.
     *
     * @returns {number[]} Color as R, G, B color array in between 0 to 255.
     * ```typescript
     * // Load an existing PDF document
     * let document: PdfDocument = new PdfDocument(data, password);
     * // Get the first page
     * let page: PdfPage = document.getPage(0) as PdfPage;
     * // Get the first annotation of the page
     * let annotation: PdfWidgetAnnotation = page.annotations.at(0) as PdfWidgetAnnotation;
     * // Gets the fore color of the annotation.
     * let color: number[] = annotation.color;
     * // Destroy the document
     * document.destroy();
     * ```
     */
    get color() {
        if (typeof this._color === 'undefined' && this._defaultAppearance) {
            this._color = this._da.color;
        }
        return this._color;
    }
    /**
     * Sets the fore color of the annotation.
     *
     * @param {number[]} value Color as R, G, B color array in between 0 to 255.
     * ```typescript
     * // Load an existing PDF document
     * let document: PdfDocument = new PdfDocument(data, password);
     * // Get the first page
     * let page: PdfPage = document.getPage(0) as PdfPage;
     * // Get the first annotation of the page
     * let annotation: PdfWidgetAnnotation = page.annotations.at(0) as PdfWidgetAnnotation;
     * // Sets the fore color of the annotation.
     * annotation.color = [255,255,255];
     * // Save the document
     * document.save('output.pdf');
     * // Destroy the document
     * document.destroy();
     * ```
     */
    set color(value) {
        if (typeof this.color === 'undefined' || this._color !== value) {
            this._color = value;
        }
        let isNew = false;
        if (!this._defaultAppearance) {
            this._da = new _PdfDefaultAppearance('');
            isNew = true;
        }
        if (isNew || this._da.color !== value) {
            this._da.color = value;
            this._dictionary.update('DA', this._da.toString());
        }
    }
    /**
     * Gets the back color of the annotation.
     *
     * @returns {number[]} Color as R, G, B color array in between 0 to 255.
     * ```typescript
     * // Load an existing PDF document
     * let document: PdfDocument = new PdfDocument(data, password);
     * // Access the text box field at index 0
     * let field: PdfField = document.form.fieldAt(0);
     * // Gets the back color of the annotation
     * let backColor: number[] = field.itemAt(0).backColor;
     * // Destroy the document
     * document.destroy();
     * ```
     */
    get backColor() {
        return this._parseBackColor();
    }
    /**
     * Sets the back color of the annotation.
     *
     * @param {number[]} value Array with R, G, B, A color values in between 0 to 255. For optional A (0-254), it signifies transparency.
     * ```typescript
     * // Load an existing PDF document
     * let document: PdfDocument = new PdfDocument(data, password);
     * // Access the text box field at index 0
     * let field: PdfField = document.form.fieldAt(0);
     * // Sets the background color of the field item
     * field.itemAt(0).backColor = [255, 0, 0];
     * // Sets the background color of the field item to transparent
     * field.itemAt(1).backColor = [0, 0, 0, 0];
     * // Save the document
     * document.save('output.pdf');
     * // Destroy the document
     * document.destroy();
     * ```
     */
    set backColor(value) {
        this._updateBackColor(value);
    }
    get _hasBackColor() {
        if (this._isLoaded) {
            const mkDictionary = this._mkDictionary;
            return (mkDictionary && mkDictionary.has('BG'));
        }
        else {
            return !this._isTransparentBackColor;
        }
    }
    /**
     * Gets the border color of the annotation.
     *
     * @returns {number[]} Color as R, G, B color array in between 0 to 255.
     * ```typescript
     * // Load an existing PDF document
     * let document: PdfDocument = new PdfDocument(data, password);
     * // Get the first page
     * let page: PdfPage = document.getPage(0) as PdfPage;
     * // Get the first annotation of the page
     * let annotation: PdfWidgetAnnotation = page.annotations.at(0) as PdfWidgetAnnotation;
     * // Gets the border color of the annotation.
     * let borderColor: number[] = annotation.borderColor;
     * // Destroy the document
     * document.destroy();
     * ```
     */
    get borderColor() {
        if (typeof this._borderColor === 'undefined') {
            const mkDict = this._mkDictionary;
            if (mkDict && mkDict.has('BC')) {
                const bcArray = mkDict.getArray('BC');
                if (bcArray) {
                    this._borderColor = _parseColor(bcArray);
                }
            }
        }
        if (typeof this._borderColor === 'undefined' || this._borderColor === null) {
            this._borderColor = [0, 0, 0];
        }
        return this._borderColor;
    }
    /**
     * Sets the border color of the annotation.
     *
     * @param {number[]} value Color as R, G, B color array in between 0 to 255.
     * ```typescript
     * // Load an existing PDF document
     * let document: PdfDocument = new PdfDocument(data, password);
     * // Get the first page
     * let page: PdfPage = document.getPage(0) as PdfPage;
     * // Get the first annotation of the page
     * let annotation: PdfWidgetAnnotation = page.annotations.at(0) as PdfWidgetAnnotation;
     * // Sets the border color of the annotation.
     * annotation.borderColor = [255,255,255];
     * // Save the document
     * document.save('output.pdf');
     * // Destroy the document
     * document.destroy();
     * ```
     */
    set borderColor(value) {
        if (typeof this.borderColor === 'undefined' || this.borderColor !== value) {
            if (typeof this._mkDictionary === 'undefined') {
                this._dictionary.update('MK', new _PdfDictionary(this._crossReference));
            }
            this._mkDictionary.update('BC', [Number.parseFloat((value[0] / 255).toFixed(3)),
                Number.parseFloat((value[1] / 255).toFixed(3)),
                Number.parseFloat((value[2] / 255).toFixed(3))]);
            this._borderColor = value;
        }
    }
    /**
     * Gets the rotation angle of the annotation.
     *
     * @returns {number} Rotation angle as number.
     * ```typescript
     * // Load an existing PDF document
     * let document: PdfDocument = new PdfDocument(data, password);
     * // Get the first page
     * let page: PdfPage = document.getPage(0) as PdfPage;
     * // Get the first annotation of the page
     * let annotation: PdfWidgetAnnotation = page.annotations.at(0) as PdfWidgetAnnotation;
     * // Gets the rotation angle of the annotation.
     * let rotate: number = annotation.rotate;
     * // Destroy the document
     * document.destroy();
     * ```
     */
    get rotate() {
        if (typeof this._rotationAngle === 'undefined') {
            if (this._mkDictionary && this._mkDictionary.has('R')) {
                this._rotationAngle = this._mkDictionary.get('R');
            }
            else if (this._dictionary.has('R')) {
                this._rotationAngle = this._dictionary.get('R');
            }
        }
        return this._rotationAngle;
    }
    /**
     * Sets the rotation angle of the annotation.
     *
     * @param {number} value Rotation angle as number.
     * ```typescript
     * // Load an existing PDF document
     * let document: PdfDocument = new PdfDocument(data, password);
     * // Get the first page
     * let page: PdfPage = document.getPage(0) as PdfPage;
     * // Get the first annotation of the page
     * let annotation: PdfWidgetAnnotation = page.annotations.at(0) as PdfWidgetAnnotation;
     * // Sets the rotation angle of the annotation.
     * annotation.rotate = 90;
     * // Save the document
     * document.save('output.pdf');
     * // Destroy the document
     * document.destroy();
     * ```
     */
    set rotate(value) {
        if (typeof this.rotate === 'undefined' || this._rotationAngle !== value) {
            if (typeof this._mkDictionary === 'undefined') {
                this._dictionary.update('MK', new _PdfDictionary(this._crossReference));
            }
            this._mkDictionary.update('R', value);
            this._rotationAngle = value;
            this._dictionary._updated = true;
        }
    }
    /**
     * Gets the highlight mode of the annotation.
     *
     * @returns {PdfHighlightMode} Highlight mode.
     * ```typescript
     * // Load an existing PDF document
     * let document: PdfDocument = new PdfDocument(data, password);
     * // Get the first page
     * let page: PdfPage = document.getPage(0) as PdfPage;
     * // Get the first annotation of the page
     * let annotation: PdfWidgetAnnotation = page.annotations.at(0) as PdfWidgetAnnotation;
     * // Gets the highlight mode of the annotation.
     * let highlightMode: PdfHighlightMode = annotation.highlightMode;
     * // Destroy the document
     * document.destroy();
     * ```
     */
    get highlightMode() {
        if (typeof this._highlightMode === 'undefined' && this._dictionary.has('H')) {
            const mode = this._dictionary.get('H');
            this._highlightMode = _mapHighlightMode(mode.name);
        }
        return this._highlightMode;
    }
    /**
     * Sets the highlight mode of the annotation.
     *
     * @param {PdfHighlightMode} value Highlight mode.
     * ```typescript
     * // Load an existing PDF document
     * let document: PdfDocument = new PdfDocument(data, password);
     * // Get the first page
     * let page: PdfPage = document.getPage(0) as PdfPage;
     * // Get the first annotation of the page
     * let annotation: PdfWidgetAnnotation = page.annotations.at(0) as PdfWidgetAnnotation;
     * // Sets the highlight mode of the annotation.
     * annotation.highlightMode = PdfHighlightMode.noHighlighting;
     * // Save the document
     * document.save('output.pdf');
     * // Destroy the document
     * document.destroy();
     * ```
     */
    set highlightMode(value) {
        if (this._highlightMode !== value) {
            this._dictionary.update('H', _reverseMapHighlightMode(value));
        }
    }
    /**
     * Gets the bounds of the annotation.
     *
     * @returns {{x: number, y: number, width: number, height: number}} Bounds.
     * ```typescript
     * // Load an existing PDF document
     * let document: PdfDocument = new PdfDocument(data, password);
     * // Get the first page
     * let page: PdfPage = document.getPage(0) as PdfPage;
     * // Get the first annotation of the page
     * let annotation: PdfWidgetAnnotation = page.annotations.at(0) as PdfWidgetAnnotation;
     * // Gets the bounds of the annotation.
     * let bounds : {x: number, y: number, width: number, height: number} = annotation.bounds;
     * // Destroy the document
     * document.destroy();
     * ```
     */
    get bounds() {
        if (this._isLoaded && typeof this._bounds === 'undefined') {
            this._bounds = _calculateBounds(this._dictionary, this._getPage());
        }
        if (typeof this._bounds === 'undefined' || this._bounds === null) {
            this._bounds = { x: 0, y: 0, width: 0, height: 0 };
        }
        return this._bounds;
    }
    /**
     * Sets the bounds of the annotation.
     *
     * @param {{x: number, y: number, width: number, height: number}} value Bounds
     * ```typescript
     * // Load an existing PDF document
     * let document: PdfDocument = new PdfDocument(data, password);
     * // Get the first page
     * let page: PdfPage = document.getPage(0) as PdfPage;
     * // Get the first annotation of the page
     * let annotation: PdfWidgetAnnotation = page.annotations.at(0) as PdfWidgetAnnotation;
     * // Sets the bounds of the annotation.
     * annotation.bounds = {0, 0, 50, 50};
     * // Save the document
     * document.save('output.pdf');
     * // Destroy the document
     * document.destroy();
     * ```
     */
    set bounds(value) {
        if (value.x === 0 && value.y === 0 && value.width === 0 && value.height === 0) {
            throw new Error('Cannot set empty bounds');
        }
        this._bounds = value;
        this._dictionary.update('Rect', _getUpdatedBounds([value.x, value.y, value.width, value.height], this._getPage()));
    }
    /**
     * Gets the text alignment of the annotation.
     *
     * @returns {PdfTextAlignment} Text alignment.
     * ```typescript
     * // Load an existing PDF document
     * let document: PdfDocument = new PdfDocument(data, password);
     * // Get the first page
     * let page: PdfPage = document.getPage(0) as PdfPage;
     * // Get the first annotation of the page
     * let annotation: PdfWidgetAnnotation = page.annotations.at(0) as PdfWidgetAnnotation;
     * // Gets the text alignment of the annotation.
     * let textAlignment: PdfTextAlignment = annotation.textAlignment;
     * // Destroy the document
     * document.destroy();
     * ```
     */
    get textAlignment() {
        if (typeof this._textAlignment === 'undefined' && this._dictionary.has('Q')) {
            this._textAlignment = this._dictionary.get('Q');
        }
        return this._textAlignment;
    }
    /**
     * Sets the text alignment of the annotation.
     *
     * @param {PdfTextAlignment} value Text alignment.
     * ```typescript
     * // Load an existing PDF document
     * let document: PdfDocument = new PdfDocument(data, password);
     * // Get the first page
     * let page: PdfPage = document.getPage(0) as PdfPage;
     * // Get the first annotation of the page
     * let annotation: PdfWidgetAnnotation = page.annotations.at(0) as PdfWidgetAnnotation;
     * // Sets the text alignment of the annotation.
     * annotation.textAlignment = PdfTextAlignment.left;
     * // Save the document
     * document.save('output.pdf');
     * // Destroy the document
     * document.destroy();
     * ```
     */
    set textAlignment(value) {
        if (typeof this._textAlignment === 'undefined' || this._textAlignment !== value) {
            this._dictionary.update('Q', value);
        }
    }
    /**
     * Gets the visibility.
     *
     * @returns {PdfFormFieldVisibility} Field visibility option.
     * ```typescript
     * // Load an existing PDF document
     * let document: PdfDocument = new PdfDocument(data, password);
     * // Access the form field at index 0
     * let field: PdfField = document.form.fieldAt(0);
     * // Gets the visibility.
     * let visibility: PdfFormFieldVisibility = field.itemAt(0).visibility;
     * // Save the document
     * document.save('output.pdf');
     * // Destroy the document
     * document.destroy();
     * ```
     */
    get visibility() {
        let value;
        if (this._isLoaded) {
            value = PdfFormFieldVisibility.visible;
            let flag = PdfAnnotationFlag.default;
            if (this._hasFlags) {
                flag = this.flags;
                let flagValue = 3;
                if ((flag & PdfAnnotationFlag.hidden) === PdfAnnotationFlag.hidden) {
                    flagValue = 0;
                }
                if ((flag & PdfAnnotationFlag.noView) === PdfAnnotationFlag.noView) {
                    flagValue = 1;
                }
                if ((flag & PdfAnnotationFlag.print) !== PdfAnnotationFlag.print) {
                    flagValue &= 2;
                }
                switch (flagValue) {
                    case 0:
                        value = PdfFormFieldVisibility.hidden;
                        break;
                    case 1:
                        value = PdfFormFieldVisibility.hiddenPrintable;
                        break;
                    case 2:
                        value = PdfFormFieldVisibility.visibleNotPrintable;
                        break;
                    case 3:
                        value = PdfFormFieldVisibility.visible;
                        break;
                }
            }
            else {
                value = PdfFormFieldVisibility.visibleNotPrintable;
            }
        }
        else {
            return this._visibility;
        }
        return value;
    }
    /**
     * Sets the visibility.
     *
     * @param {PdfFormFieldVisibility} value Visibility option.
     * ```typescript
     * // Load an existing PDF document
     * let document: PdfDocument = new PdfDocument(data, password);
     * // Access the form field at index 0
     * let field: PdfField = document.form.fieldAt(0);
     * // Sets the visibility.
     * let field.itemAt(0).visibility = PdfFormFieldVisibility.hiddenPrintable;
     * // Save the document
     * document.save('output.pdf');
     * // Destroy the document
     * document.destroy();
     * ```
     */
    set visibility(value) {
        if (this._isLoaded) {
            _updateVisibility(this._dictionary, value);
            this._dictionary._updated = true;
        }
        else {
            switch (value) {
                case PdfFormFieldVisibility.hidden:
                    this.flags = PdfAnnotationFlag.hidden;
                    break;
                case PdfFormFieldVisibility.hiddenPrintable:
                    this.flags = PdfAnnotationFlag.noView | PdfAnnotationFlag.print;
                    break;
                case PdfFormFieldVisibility.visible:
                    this.flags = PdfAnnotationFlag.print;
                    break;
                case PdfFormFieldVisibility.visibleNotPrintable:
                    this.flags = PdfAnnotationFlag.default;
                    break;
            }
            this._visibility = value;
        }
    }
    /**
     * Gets the font of the item.
     *
     * @returns {PdfFont} font.
     *
     * ```typescript
     * // Load an existing PDF document
     * let document: PdfDocument = new PdfDocument(data, password);
     * // Get the first page
     * let page: PdfPage = document.getPage(0) as PdfPage;
     * // Access the form field at index 0
     * let field: PdfTextBoxField = document.form.fieldAt(0) as PdfTextBoxField;
     * // Get the first item of the field
     * let item: PdfWidgetAnnotation = field.itemAt(0);
     * // Gets the font of the item.
     * let font: PdfFont = item.font;
     * // Destroy the document
     * document.destroy();
     * ```
     */
    get font() {
        if (!this._pdfFont) {
            let fontName;
            if (this._crossReference) {
                const form = this._crossReference._document.form;
                const fontData = this._obtainFontDetails();
                if (form && form._dictionary.has('DR')) {
                    const resources = form._dictionary.get('DR');
                    if (resources.has('Font')) {
                        const fonts = resources.get('Font');
                        if (fonts.has(fontData.name)) {
                            const fontDictionary = fonts.get(fontData.name);
                            if (fontDictionary && fontData.name && fontDictionary.has('BaseFont')) {
                                const baseFont = fontDictionary.get('BaseFont');
                                let textFontStyle = PdfFontStyle.regular;
                                if (baseFont) {
                                    fontName = baseFont.name;
                                    textFontStyle = _getFontStyle(baseFont.name);
                                    if (fontName.includes('-')) {
                                        fontName = fontName.substring(0, fontName.indexOf('-'));
                                    }
                                    this._pdfFont = _mapFont(fontName, fontData.size, textFontStyle, this);
                                }
                            }
                        }
                    }
                }
            }
        }
        if ((this._pdfFont === null || typeof this._pdfFont === 'undefined') || (!this._isLoaded && this._pdfFont.size === 1)) {
            this._pdfFont = this._circleCaptionFont;
        }
        return this._pdfFont;
    }
    /**
     * Sets the font of the item.
     *
     * @param {PdfFont} value font.
     *
     * ```typescript
     * // Load an existing PDF document
     * let document: PdfDocument = new PdfDocument(data, password);
     * // Get the first page
     * let page: PdfPage = document.getPage(0) as PdfPage;
     * // Access the form field at index 0
     * let field: PdfTextBoxField = document.form.fieldAt(0) as PdfTextBoxField;
     * // Get the first item of the field
     * let item: PdfWidgetAnnotation = field.itemAt(0);
     * // Set the font of the item.
     * item.font = new PdfStandardFont(PdfFontFamily.helvetica, 12, PdfFontStyle.bold);
     * // Save the document
     * document.save('output.pdf');
     * // Destroy the document
     * document.destroy();
     * ```
     */
    set font(value) {
        if (value && value instanceof PdfFont) {
            this._pdfFont = value;
            this._initializeFont(value);
        }
    }
    get _defaultAppearance() {
        if (typeof this._da === 'undefined' && this._dictionary.has('DA')) {
            const da = this._dictionary.get('DA');
            if (da && da !== '') {
                this._da = new _PdfDefaultAppearance(da);
            }
        }
        return this._da;
    }
    get _mkDictionary() {
        let value;
        if (this._dictionary.has('MK')) {
            value = this._dictionary.get('MK');
        }
        return value;
    }
    _create(page, bounds, field) {
        this._page = page;
        this._crossReference = page._crossReference;
        this._ref = this._crossReference._getNextReference();
        this._dictionary = new _PdfDictionary(this._crossReference);
        this._crossReference._cacheMap.set(this._ref, this._dictionary);
        this._dictionary._currentObj = this;
        this._dictionary.objId = this._ref.toString();
        this._dictionary.update('Type', _PdfName.get('Annot'));
        this._dictionary.update('Subtype', _PdfName.get('Widget'));
        this.flags |= PdfAnnotationFlag.print;
        this._dictionary.update('P', page._ref);
        page._addWidget(this._ref);
        this.border = new PdfAnnotationBorder();
        this.bounds = bounds;
        if (field) {
            this._field = field;
            this._dictionary.update('Parent', this._field._ref);
        }
        return this._dictionary;
    }
    _doPostProcess(isFlatten = false, recreateAppearance = false) {
        if (isFlatten || recreateAppearance) {
            let appearanceStream;
            if (recreateAppearance || (isFlatten && !this._dictionary.has('AP'))) {
                //appearanceStream = this._createAppearance();
            }
            if (!appearanceStream && this._dictionary.has('AP')) {
                const dictionary = this._dictionary.get('AP');
                if (dictionary && dictionary.has('N')) {
                    appearanceStream = dictionary.get('N');
                    const reference = dictionary.getRaw('N');
                    if (reference && appearanceStream) {
                        appearanceStream.reference = reference;
                    }
                }
            }
            if (appearanceStream) {
                let bounds;
                if (isFlatten) {
                    const template = new PdfTemplate(appearanceStream, this._crossReference);
                    const page = this._getPage();
                    if (page) {
                        const graphics = page.graphics;
                        graphics.save();
                        if (page.rotation === PdfRotationAngle.angle90) {
                            graphics.translateTransform(graphics._size[0], graphics._size[1]);
                            graphics.rotateTransform(90);
                        }
                        else if (page.rotation === PdfRotationAngle.angle180) {
                            graphics.translateTransform(graphics._size[0], graphics._size[1]);
                            graphics.rotateTransform(-180);
                        }
                        else if (page.rotation === PdfRotationAngle.angle270) {
                            graphics.translateTransform(graphics._size[0], graphics._size[1]);
                            graphics.rotateTransform(270);
                        }
                        bounds = { x: this.bounds.x, y: this.bounds.y, width: template._size[0], height: template._size[1] };
                        graphics._drawTemplate(template, bounds);
                        graphics.restore();
                    }
                }
                else {
                    let appearance;
                    if (this._dictionary.has('AP')) {
                        appearance = this._dictionary.get('AP');
                    }
                    else {
                        const reference = this._crossReference._getNextReference();
                        appearance = new _PdfDictionary(this._crossReference);
                        this._crossReference._cacheMap.set(reference, appearance);
                        this._dictionary.update('AP', reference);
                    }
                    _removeDuplicateReference(appearance, this._crossReference, 'N');
                    const reference = this._crossReference._getNextReference();
                    this._crossReference._cacheMap.set(reference, appearanceStream);
                    appearance.update('N', reference);
                }
            }
            this._dictionary._updated = false;
        }
    }
    _initializeFont(font) {
        this._pdfFont = font;
        let document;
        if (this._crossReference) {
            document = this._crossReference._document;
            let resource;
            if (document) {
                if (document.form._dictionary.has('DR')) {
                    resource = document.form._dictionary.get('DR');
                }
                else {
                    resource = new _PdfDictionary(this._crossReference);
                }
            }
            let fontDict;
            let isReference = false;
            if (resource.has('Font')) {
                const obj = resource.getRaw('Font'); // eslint-disable-line
                if (obj && obj instanceof _PdfReference) {
                    isReference = true;
                    fontDict = this._crossReference._fetch(obj);
                }
                else if (obj instanceof _PdfDictionary) {
                    fontDict = obj;
                }
            }
            if (!fontDict) {
                fontDict = new _PdfDictionary(this._crossReference);
                resource.update('Font', fontDict);
            }
            const keyName = _PdfName.get(_getNewGuidString());
            const reference = this._crossReference._getNextReference();
            this._crossReference._cacheMap.set(reference, this._pdfFont._dictionary);
            if (font instanceof PdfTrueTypeFont) {
                if (this._pdfFont._pdfFontInternals) {
                    this._crossReference._cacheMap.set(reference, this._pdfFont._pdfFontInternals);
                }
            }
            else if (this._pdfFont._dictionary) {
                this._crossReference._cacheMap.set(reference, this._pdfFont._dictionary);
            }
            fontDict.update(keyName.name, reference);
            resource._updated = true;
            document.form._dictionary.update('DR', resource);
            document.form._dictionary._updated = true;
            this._fontName = keyName.name;
            const defaultAppearance = new _PdfDefaultAppearance();
            defaultAppearance.fontName = this._fontName;
            defaultAppearance.fontSize = this._pdfFont._size;
            defaultAppearance.color = this.color ? this.color : [0, 0, 0];
            this._dictionary.update('DA', defaultAppearance.toString());
            if (isReference) {
                resource._updated = true;
            }
            this._isFont = true;
        }
    }
    _getPage() {
        if (!this._page) {
            let document;
            if (this._crossReference) {
                document = this._crossReference._document;
            }
            let page;
            if (this._dictionary.has('P')) {
                const ref = this._dictionary.getRaw('P');
                if (ref && document) {
                    for (let i = 0; i < document.pageCount; i++) {
                        const entry = document.getPage(i);
                        if (entry && entry._ref === ref) {
                            page = entry;
                            break;
                        }
                    }
                }
            }
            if (!page && document && this._ref) {
                page = _findPage(document, this._ref);
            }
            this._page = page;
        }
        return this._page;
    }
    _beginSave() {
        if (!this._isLoaded) {
            const value = this._bounds;
            this._dictionary.update('Rect', _getUpdatedBounds([value.x, value.y, value.width, value.height], this._page));
        }
    }
    _parseBackColor() {
        let value;
        if ((this._isLoaded && this._hasBackColor) || (!this._isLoaded && !this._isTransparentBackColor)) {
            if (typeof this._backColor === 'undefined') {
                const dictionary = this._mkDictionary;
                if (dictionary && dictionary.has('BG')) {
                    const colorArray = dictionary.getArray('BG');
                    if (colorArray) {
                        this._backColor = _parseColor(colorArray);
                    }
                }
            }
            if (typeof this._backColor === 'undefined' || this._backColor === null) {
                this._backColor = [255, 255, 255];
            }
            value = this._backColor;
        }
        return value;
    }
    _updateBackColor(value, setAppearance = false) {
        let isChanged = false;
        if (value.length === 4 && value[3] !== 255) {
            this._isTransparentBackColor = true;
            if (this._dictionary.has('BG')) {
                delete this._dictionary._map.BG;
                isChanged = true;
            }
            const mkDictionary = this._mkDictionary;
            if (mkDictionary && mkDictionary.has('BG')) {
                delete mkDictionary._map.BG;
                this._dictionary._updated = true;
                isChanged = true;
            }
        }
        else {
            this._isTransparentBackColor = false;
            if (typeof this.backColor === 'undefined' || this._backColor !== value) {
                if (typeof this._mkDictionary === 'undefined') {
                    this._dictionary.update('MK', new _PdfDictionary(this._crossReference));
                }
                this._mkDictionary.update('BG', [Number.parseFloat((value[0] / 255).toFixed(3)),
                    Number.parseFloat((value[1] / 255).toFixed(3)),
                    Number.parseFloat((value[2] / 255).toFixed(3))]);
                this._backColor = [value[0], value[1], value[2]];
                this._dictionary._updated = true;
                isChanged = true;
            }
        }
        if (setAppearance && isChanged && this._field) {
            this._field._setAppearance = true;
        }
    }
}
/**
 * `PdfStateItem` class represents the check box field item objects.
 * ```typescript
 * // Load an existing PDF document
 * let document: PdfDocument = new PdfDocument(data, password);
 * // Access check box field
 * let field: PdfCheckBoxField = document.form.fieldAt(0) as PdfCheckBoxField;
 * // Access first item of check box field
 * let item: PdfStateItem = field.itemAt(0) as PdfStateItem;
 * // Sets the check box style as check
 * item.style = PdfCheckBoxStyle.check;
 * // Save the document
 * document.save('output.pdf');
 * // Destroy the document
 * document.destroy();
 * ```
 */
class PdfStateItem extends PdfWidgetAnnotation {
    /**
     * Initializes a new instance of the `PdfStateItem` class.
     *
     * @private
     */
    constructor() {
        super();
    }
    /**
     * Parse an existing item of the field.
     *
     * @private
     * @param {_PdfDictionary} dictionary Widget dictionary.
     * @param {_PdfCrossReference} crossReference PDF cross reference.
     * @param {PdfField} field Field object.
     * @returns {PdfStateItem} Widget.
     */
    static _load(dictionary, crossReference, field) {
        const widget = new PdfStateItem();
        widget._isLoaded = true;
        widget._dictionary = dictionary;
        widget._crossReference = crossReference;
        widget._field = field;
        return widget;
    }
    /**
     * Gets the flag to indicate whether the field item is checked or not.
     *
     * @returns {boolean} Checked or not.
     * ```typescript
     * // Load an existing PDF document
     * let document: PdfDocument = new PdfDocument(data, password);
     * // Access check box field
     * let field: PdfCheckBoxField = document.form.fieldAt(0) as PdfCheckBoxField;
     * // Access first item of check box field
     * let item: PdfStateItem = field.itemAt(0) as PdfStateItem;
     * // Gets the flag to indicate whether the field item is checked or not.
     * let checked: boolean = item.checked;
     * // Save the document
     * document.save('output.pdf');
     * // Destroy the document
     * document.destroy();
     * ```
     */
    get checked() {
        return _checkField(this._dictionary);
    }
    /**
     * Sets the flag to indicate whether the field item is checked or not.
     *
     * @param {boolean} value Checked or not.
     * ```typescript
     * // Load an existing PDF document
     * let document: PdfDocument = new PdfDocument(data, password);
     * // Access check box field
     * let field: PdfCheckBoxField = document.form.fieldAt(0) as PdfCheckBoxField;
     * // Access first item of check box field
     * let item: PdfStateItem = field.itemAt(0) as PdfStateItem;
     * // Sets the style of the annotation
     * item.checked = true;
     * // Save the document
     * document.save('output.pdf');
     * // Destroy the document
     * document.destroy();
     * ```
     */
    set checked(value) {
        if (this.checked !== value) {
            this._dictionary.update('AS', _PdfName.get(value ? 'Yes' : 'Off'));
        }
    }
    /**
     * Gets the style of annotation.
     *
     * @returns {PdfCheckBoxStyle} Style of annotation.
     * ```typescript
     * // Load an existing PDF document
     * let document: PdfDocument = new PdfDocument(data, password);
     * // Access check box field
     * let field: PdfCheckBoxField = document.form.fieldAt(0) as PdfCheckBoxField;
     * // Access first item of check box field
     * let item: PdfStateItem = field.itemAt(0) as PdfStateItem;
     * // Gets the style of the annotation
     * let style: PdfCheckBoxStyle = item.style;
     * // Save the document
     * document.save('output.pdf');
     * // Destroy the document
     * document.destroy();
     * ```
     */
    get style() {
        if (this._isLoaded) {
            const dictionary = this._mkDictionary;
            if (dictionary && dictionary.has('CA')) {
                this._style = _stringToStyle(dictionary.get('CA'));
            }
            else {
                this._style = PdfCheckBoxStyle.check;
            }
        }
        return this._style;
    }
    /**
     * Sets the style of annotation.
     *
     * @param {PdfCheckBoxStyle} value Style of annotation.
     * ```typescript
     * // Load an existing PDF document
     * let document: PdfDocument = new PdfDocument(data, password);
     * // Access check box field
     * let field: PdfCheckBoxField = document.form.fieldAt(0) as PdfCheckBoxField;
     * // Access first item of check box field
     * let item: PdfStateItem = field.itemAt(0) as PdfStateItem;
     * // Sets the style of the annotation
     * item.style = PdfCheckBoxStyle.check;
     * // Save the document
     * document.save('output.pdf');
     * // Destroy the document
     * document.destroy();
     * ```
     */
    set style(value) {
        if (this.style !== value) {
            this._style = value;
            let dictionary = this._mkDictionary;
            if (!dictionary) {
                dictionary = new _PdfDictionary(this._crossReference);
                this._dictionary.update('MK', dictionary);
            }
            dictionary.update('CA', _styleToString(value));
        }
    }
    _doPostProcess() {
        const style = this.checked ? _PdfCheckFieldState.checked : _PdfCheckFieldState.unchecked;
        const template = _getStateTemplate(style, this);
        if (template) {
            const page = this._getPage();
            if (page) {
                const graphics = page.graphics;
                graphics.save();
                if (page.rotation === PdfRotationAngle.angle90) {
                    graphics.translateTransform(graphics._size[0], graphics._size[1]);
                    graphics.rotateTransform(90);
                }
                else if (page.rotation === PdfRotationAngle.angle180) {
                    graphics.translateTransform(graphics._size[0], graphics._size[1]);
                    graphics.rotateTransform(-180);
                }
                else if (page.rotation === PdfRotationAngle.angle270) {
                    graphics.translateTransform(graphics._size[0], graphics._size[1]);
                    graphics.rotateTransform(270);
                }
                graphics._sw._setTextRenderingMode(_TextRenderingMode.fill);
                graphics._drawTemplate(template, this.bounds);
                graphics.restore();
            }
        }
        this._dictionary._updated = false;
    }
    _postProcess(value) {
        const field = this._field;
        if (!value) {
            value = (field && field.checked) ? 'Yes' : 'Off';
        }
        this._dictionary.update('AS', _PdfName.get(value));
    }
    _setField(field) {
        this._field = field;
        this._field._stringFormat = new PdfStringFormat(this.textAlignment, PdfVerticalAlignment.middle);
        this._field._addToKid(this);
    }
}
/**
 * `PdfRadioButtonListItem` class represents the radio button field item objects.
 * ```typescript
 * // Load an existing PDF document
 * let document: PdfDocument = new PdfDocument(data);
 * // Gets the first page of the document
 * let page: PdfPage = document.getPage(0) as PdfPage;
 * // Access the PDF form
 * let form: PdfForm = document.form;
 * // Create a new radio button list field
 * let field: PdfRadioButtonListField = new PdfRadioButtonListField(page, 'Age');
 * // Create and add first item
 * let first: PdfRadioButtonListItem = field.add('1-9', {x: 100, y: 140, width: 20, height: 20});
 * // Create and add second item
 * let second: PdfRadioButtonListItem = new PdfRadioButtonListItem('10-49', {x: 100, y: 170, width: 20, height: 20}, page);
 * field.add(second);
 * // Create and add third item
 * let third: PdfRadioButtonListItem = new PdfRadioButtonListItem('50-59', {x: 100, y: 200, width: 20, height: 20}, field);
 * field.add(third);
 * // Sets selected index of the radio button list field
 * field.selectedIndex = 0;
 * // Add the field into PDF form
 * form.add(field);
 * // Save the document
 * document.save('output.pdf');
 * // Destroy the document
 * document.destroy();
 * ```
 */
class PdfRadioButtonListItem extends PdfStateItem {
    constructor(value, bounds, item) {
        super();
        if (item && value && bounds) {
            if (item instanceof PdfField) {
                this._initializeItem(value, bounds, item.page, item);
            }
            else {
                this._initializeItem(value, bounds, item);
            }
        }
    }
    /**
     * Parse an existing item of the field.
     *
     * @private
     * @param {_PdfDictionary} dictionary Widget dictionary.
     * @param {_PdfCrossReference} crossReference PDF cross reference.
     * @param {PdfField} field Field object.
     * @returns {PdfRadioButtonListItem} Widget.
     */
    static _load(dictionary, crossReference, field) {
        const widget = new PdfRadioButtonListItem();
        widget._isLoaded = true;
        widget._dictionary = dictionary;
        widget._crossReference = crossReference;
        widget._field = field;
        return widget;
    }
    /**
     * Gets the flag to indicate whether the field item is selected or not.
     *
     * @returns {boolean} Selected or not.
     * ```typescript
     * // Load an existing PDF document
     * let document: PdfDocument = new PdfDocument(data);
     * // Gets the first page of the document
     * let page: PdfPage = document.getPage(0) as PdfPage;
     * // Access the PDF form
     * let form: PdfForm = document.form;
     * // Create a new radio button list field
     * let field: PdfRadioButtonListField = new PdfRadioButtonListField(page, 'Age');
     * // Access first list field item
     * let item: PdfRadioButtonListItem = field.itemAt(0);
     * // Gets the flag to indicate whether the field item is selected or not.
     * let selected: boolean = item.selected;
     * // Save the document
     * document.save('output.pdf');
     * // Destroy the document
     * document.destroy();
     * ```
     */
    get selected() {
        return this._index === this._field.selectedIndex;
    }
    /**
     * Gets the value of the radio button list field item
     *
     * @returns {string} Value of the radio button list field item.
     * ```typescript
     * // Load an existing PDF document
     * let document: PdfDocument = new PdfDocument(data);
     * // Gets the first page of the document
     * let page: PdfPage = document.getPage(0) as PdfPage;
     * // Access the PDF form
     * let form: PdfForm = document.form;
     * // Create a new radio button list field
     * let field: PdfRadioButtonListField = new PdfRadioButtonListField(page, 'Age');
     * // Access first list field item
     * let item: PdfRadioButtonListItem = field.itemAt(0);
     * // Gets the value of the radio button list field item
     * let value: string = item.value;
     * // Save the document
     * document.save('output.pdf');
     * // Destroy the document
     * document.destroy();
     * ```
     */
    get value() {
        if (this._isLoaded && !this._optionValue) {
            this._optionValue = _getItemValue(this._dictionary);
        }
        return this._optionValue;
    }
    /**
     * Sets the value of the radio button list field item
     *
     * @param {string} option Value of the radio button list field item.
     * ```typescript
     * // Load an existing PDF document
     * let document: PdfDocument = new PdfDocument(data);
     * // Gets the first page of the document
     * let page: PdfPage = document.getPage(0) as PdfPage;
     * // Access the PDF form
     * let form: PdfForm = document.form;
     * // Create a new radio button list field
     * let field: PdfRadioButtonListField = new PdfRadioButtonListField(page, 'Age');
     * // Access first list field item
     * let item: PdfRadioButtonListItem = field.itemAt(0);
     * // Sets the value of the radio button list field item
     * item.value = '1-9';
     * // Save the document
     * document.save('output.pdf');
     * // Destroy the document
     * document.destroy();
     * ```
     */
    set value(option) {
        this._optionValue = option;
    }
    /**
     * Gets the back color of the annotation.
     *
     * @returns {number[]} Color as R, G, B color array in between 0 to 255.
     * ```typescript
     * // Load an existing PDF document
     * let document: PdfDocument = new PdfDocument(data, password);
     * // Get the first page
     * let page: PdfPage = document.getPage(0) as PdfPage;
     * // Get the first annotation of the page
     * let annotation: PdfWidgetAnnotation = page.annotations.at(0) as PdfWidgetAnnotation;
     * // Gets the back color of the annotation
     * let backColor: number[] = annotation.backColor;
     * // Destroy the document
     * document.destroy();
     * ```
     */
    get backColor() {
        return this._parseBackColor();
    }
    /**
     * Sets the back color of the annotation.
     *
     * @param {number[]} value Array with R, G, B, A color values in between 0 to 255. For optional A (0-254), it signifies transparency.
     * ```typescript
     * // Load an existing PDF document
     * let document: PdfDocument = new PdfDocument(data);
     * // Gets the first page of the document
     * let page: PdfPage = document.getPage(0);
     * // Access the PDF form
     * let form: PdfForm = document.form;
     * // Access the radio button list field
     * let field: PdfRadioButtonListField = form.fieldAt(0) as PdfRadioButtonListField;
     * // Sets the back color of the radio button list item
     * field.itemAt(0).backColor = [255, 255, 255];
     * // Sets the background color of the field item to transparent
     * field.itemAt(1).backColor = [0, 0, 0, 0];
     * // Save the document
     * document.save('output.pdf');
     * // Destroy the document
     * document.destroy();
     * ```
     */
    set backColor(value) {
        this._updateBackColor(value, true);
    }
    _initializeItem(value, bounds, page, field) {
        this._optionValue = value;
        this._page = page;
        this._create(this._page, bounds, this._field);
        this.textAlignment = PdfTextAlignment.left;
        this._dictionary.update('MK', new _PdfDictionary(this._crossReference));
        this._mkDictionary.update('BC', [0, 0, 0]);
        this._mkDictionary.update('BG', [1, 1, 1]);
        this.style = PdfCheckBoxStyle.circle;
        this._dictionary.update('DA', '/TiRo 0 Tf 0 0 0 rg');
        if (field) {
            this._setField(field);
            this._dictionary.update('Parent', field._ref);
        }
    }
    _postProcess(value) {
        const field = this._field;
        if (!value && field && field.selectedIndex !== -1) {
            value = field.itemAt(field.selectedIndex).value;
        }
        if (this.value === value) {
            this._dictionary.update('AS', _PdfName.get(this.value));
        }
        else {
            this._dictionary.update('AS', _PdfName.get('Off'));
        }
    }
}
/**
 * `PdfListBoxItem` class represents the list and combo box field item objects.
 * ```typescript
 * // Load an existing PDF document
 * let document: PdfDocument = new PdfDocument(data);
 * // Gets the first page of the document
 * let page: PdfPage = document.getPage(0) as PdfPage;
 * // Access the PDF form
 * let form: PdfForm = document.form;
 * // Create a new list box field
 * let field: PdfListBoxField = new PdfListBoxField(page, 'list1', {x: 100, y: 60, width: 100, height: 50});
 * // Add list items to the field.
 * field.addItem(new PdfListFieldItem('English', 'English'));
 * field.addItem(new PdfListFieldItem('French', 'French'));
 * field.addItem(new PdfListFieldItem('German', 'German'));
 * // Sets the selected index
 * field.selectedIndex = 2;
 * // Sets the flag indicates whether the list box allows multiple selections.
 * field.multiSelect = true;
 * // Add the field into PDF form
 * form.add(field);
 * // Save the document
 * document.save('output.pdf');
 * // Destroy the document
 * document.destroy();
 * ```
 */
class PdfListFieldItem extends PdfStateItem {
    constructor(text, value, field) {
        super();
        if (text && value) {
            this._initializeItem(text, value, field);
        }
    }
    /**
     * Parse an existing item of the field.
     *
     * @private
     * @param {_PdfDictionary} dictionary Widget dictionary.
     * @param {_PdfCrossReference} crossReference PDF cross reference.
     * @param {PdfField} field Field object.
     * @returns {PdfListFieldItem} Widget.
     */
    static _load(dictionary, crossReference, field) {
        const widget = new PdfListFieldItem();
        widget._isLoaded = true;
        widget._dictionary = dictionary;
        widget._crossReference = crossReference;
        widget._field = field;
        return widget;
    }
    /**
     * Gets the text of the annotation.
     *
     * @returns {string} Text.
     * ```typescript
     * // Load an existing PDF document
     * let document: PdfDocument = new PdfDocument(data);
     * // Gets the first page of the document
     * let page: PdfPage = document.getPage(0) as PdfPage;
     * // Access the PDF form
     * let form: PdfForm = document.form;
     * // Create a new radio button list field
     * let field: PdfListBoxField = form.fieldAt(0) as PdfListBoxField;
     * // Access first list field item
     * let item: PdfListFieldItem = field.itemAt(0);
     * // Gets the text of the list field item
     * let text: string = item.text;
     * // Save the document
     * document.save('output.pdf');
     * // Destroy the document
     * document.destroy();
     * ```
     */
    get text() {
        if (typeof this._text === 'undefined' &&
            typeof this._field !== 'undefined' &&
            (this._field instanceof PdfListBoxField || this._field instanceof PdfComboBoxField)) {
            this._text = this._field._options[Number.parseInt(this._index.toString(), 10)][1];
        }
        return this._text;
    }
    /**
     * Sets the text of the annotation.
     *
     * @param {string} value Text.
     * ```typescript
     * // Load an existing PDF document
     * let document: PdfDocument = new PdfDocument(data);
     * // Gets the first page of the document
     * let page: PdfPage = document.getPage(0) as PdfPage;
     * // Access the PDF form
     * let form: PdfForm = document.form;
     * // Create a new radio button list field
     * let field: PdfListBoxField = form.fieldAt(0) as PdfListBoxField;
     * // Access first list field item
     * let item: PdfListFieldItem = field.itemAt(0);
     * // Sets the text of the list field item
     * item.text = '1-9';
     * // Save the document
     * document.save('output.pdf');
     * // Destroy the document
     * document.destroy();
     * ```
     */
    set text(value) {
        if (typeof value === 'string' &&
            typeof this._field !== 'undefined' &&
            (this._field instanceof PdfListBoxField || this._field instanceof PdfComboBoxField)) {
            if (value !== this._field._options[Number.parseInt(this._index.toString(), 10)][1]) {
                this._field._options[Number.parseInt(this._index.toString(), 10)][1] = value;
                this._text = value;
                this._field._dictionary._updated = true;
            }
        }
    }
    /**
     * Gets the flag to indicate whether the field item is selected or not (Read only).
     *
     * @returns {boolean} Selected or not.
     * ```typescript
     * // Load an existing PDF document
     * let document: PdfDocument = new PdfDocument(data);
     * // Gets the first page of the document
     * let page: PdfPage = document.getPage(0) as PdfPage;
     * // Access the PDF form
     * let form: PdfForm = document.form;
     * // Create a new radio button list field
     * let field: PdfListBoxField = form.fieldAt(0) as PdfListBoxField;
     * // Access first list field item
     * let item: PdfListFieldItem = field.itemAt(0);
     * // Gets the flag to indicate whether the field item is selected or not.
     * let selected: boolean = item.selected;
     * // Save the document
     * document.save('output.pdf');
     * // Destroy the document
     * document.destroy();
     * ```
     */
    get selected() {
        return this._index === this._field.selectedIndex;
    }
    _initializeItem(text, value, field) {
        this._text = text;
        this._value = value;
        if (field && field instanceof PdfListBoxField) {
            field._addToOptions(this, field);
        }
    }
}
/**
 * `PdfAnnotationCaption` class represents the caption text and properties of annotations.
 * ```typescript
 * // Load an existing PDF document
 * let document: PdfDocument = new PdfDocument(data, password);
 * // Get the first page
 * let page: PdfPage = document.getPage(0) as PdfPage;
 * // Get the first annotation of the page
 * let annotation: PdfLineAnnotation = page.annotations.at(0) as PdfLineAnnotation;
 * // Create and set annotation caption values
 * annotation.caption = new PdfAnnotationCaption(true, PdfLineCaptionType.inline, [10, 10]);
 * // Destroy the document
 * document.destroy();
 * ```
 */
class PdfAnnotationCaption {
    constructor(cap, type, offset) {
        this._cap = typeof cap !== 'undefined' ? cap : false;
        this._type = typeof type !== 'undefined' ? type : PdfLineCaptionType.inline;
        this._offset = typeof offset !== 'undefined' ? offset : [0, 0];
    }
    /**
     * Gets the boolean flag indicating whether annotation has caption or not.
     *
     * @returns {boolean} Caption.
     * ```typescript
     * // Load an existing PDF document
     * let document: PdfDocument = new PdfDocument(data, password);
     * // Get the first page
     * let page: PdfPage = document.getPage(0) as PdfPage;
     * // Get the first annotation of the page
     * let annotation: PdfLineAnnotation = page.annotations.at(0) as PdfLineAnnotation;
     * // Gets the boolean flag indicating whether annotation has caption or not.
     * let cap: boolean = annotation.caption.cap;
     * // Destroy the document
     * document.destroy();
     * ```
     */
    get cap() {
        return this._cap;
    }
    /**
     * Sets the boolean flag indicating whether annotation has caption or not.
     *
     * @param {boolean} value Caption.
     * ```typescript
     * // Load an existing PDF document
     * let document: PdfDocument = new PdfDocument(data, password);
     * // Get the first page
     * let page: PdfPage = document.getPage(0) as PdfPage;
     * // Get the first annotation of the page
     * let annotation: PdfLineAnnotation = page.annotations.at(0) as PdfLineAnnotation;
     * // Sets the boolean flag indicating whether annotation has caption or not.
     * annotation.caption.cap = true;
     * // Destroy the document
     * document.destroy();
     * ```
     */
    set cap(value) {
        if (value !== this._cap) {
            this._cap = value;
            if (this._dictionary) {
                this._dictionary.update('Cap', value);
            }
        }
    }
    /**
     * Gets the caption type of the annotation.
     *
     * @returns {PdfLineCaptionType} Caption type.
     * ```typescript
     * // Load an existing PDF document
     * let document: PdfDocument = new PdfDocument(data, password);
     * // Get the first page
     * let page: PdfPage = document.getPage(0) as PdfPage;
     * // Get the first annotation of the page
     * let annotation: PdfLineAnnotation = page.annotations.at(0) as PdfLineAnnotation;
     * // Gets the caption type of the annotation.
     * let type: PdfLineCaptionType = annotation.caption.type;
     * // Destroy the document
     * document.destroy();
     * ```
     */
    get type() {
        return this._type;
    }
    /**
     * Sets the caption type of the annotation.
     *
     * @param {PdfLineCaptionType} value Caption type.
     * ```typescript
     * // Load an existing PDF document
     * let document: PdfDocument = new PdfDocument(data, password);
     * // Get the first page
     * let page: PdfPage = document.getPage(0) as PdfPage;
     * // Get the first annotation of the page
     * let annotation: PdfLineAnnotation = page.annotations.at(0) as PdfLineAnnotation;
     * // Sets the caption type of the annotation.
     * annotation.caption.type = PdfLineCaptionType.inline;
     * // Destroy the document
     * document.destroy();
     * ```
     */
    set type(value) {
        if (value !== this._type) {
            this._type = value;
            if (this._dictionary) {
                this._dictionary.update('CP', _PdfName.get(value === PdfLineCaptionType.top ? 'Top' : 'Inline'));
            }
        }
    }
    /**
     * Gets the offset position of the annotation.
     *
     * @returns {Array<number>} Caption offset.
     * ```typescript
     * // Load an existing PDF document
     * let document: PdfDocument = new PdfDocument(data, password);
     * // Get the first page
     * let page: PdfPage = document.getPage(0) as PdfPage;
     * // Get the first annotation of the page
     * let annotation: PdfLineAnnotation = page.annotations.at(0) as PdfLineAnnotation;
     * // Gets the offset position of the annotation.
     * let offset: Array<number> = annotation.caption.offset;
     * // Destroy the document
     * document.destroy();
     * ```
     */
    get offset() {
        return this._offset;
    }
    /**
     * Sets the offset position of the annotation.
     *
     * @param {Array<number>} value Caption offset.
     * ```typescript
     * // Load an existing PDF document
     * let document: PdfDocument = new PdfDocument(data, password);
     * // Get the first page
     * let page: PdfPage = document.getPage(0) as PdfPage;
     * // Get the first annotation of the page
     * let annotation: PdfLineAnnotation = page.annotations.at(0) as PdfLineAnnotation;
     * // Sets the offset position of the annotation.
     * annotation.caption.offset = [10, 10];
     * // Destroy the document
     * document.destroy();
     * ```
     */
    set offset(value) {
        if (_areNotEqual(value, this._offset)) {
            this._offset = value;
            if (this._dictionary) {
                this._dictionary.update('CO', value);
            }
        }
    }
}
/**
 * `PdfAnnotationLineEndingStyle` class represents the line ending styles of annotations.
 * ```typescript
 * // Load an existing PDF document
 * let document: PdfDocument = new PdfDocument(data, password);
 * // Get the first page
 * let page: PdfPage = document.getPage(0) as PdfPage;
 * // Get the first annotation of the page
 * let annotation: PdfLineAnnotation = page.annotations.at(0) as PdfLineAnnotation;
 * // Initializes a new instance of the `PdfAnnotationLineEndingStyle` class.
 * annotation.lineEndingStyle = new PdfAnnotationLineEndingStyle(PdfLineEndingStyle.openArrow, PdfLineEndingStyle.closeArrow);
 * // Destroy the document
 * document.destroy();
 * ```
 */
class PdfAnnotationLineEndingStyle {
    constructor(begin, end) {
        this._begin = typeof begin !== 'undefined' ? begin : PdfLineEndingStyle.none;
        this._end = typeof end !== 'undefined' ? end : PdfLineEndingStyle.none;
    }
    /**
     * Gets the begin line ending style of the annotation.
     *
     * @returns {PdfLineEndingStyle} Begin line ending style.
     * `PdfAnnotationLineEndingStyle` class represents the line ending styles of annotations.
     * ```typescript
     * // Load an existing PDF document
     * let document: PdfDocument = new PdfDocument(data, password);
     * // Get the first page
     * let page: PdfPage = document.getPage(0) as PdfPage;
     * // Get the first annotation of the page
     * let annotation: PdfLineAnnotation = page.annotations.at(0) as PdfLineAnnotation;
     * // Gets the begin line ending style of the annotation.
     * let begin: PdfLineEndingStyle = annotation.lineEndingStyle.begin;
     * // Destroy the document
     * document.destroy();
     * ```
     */
    get begin() {
        return this._begin;
    }
    /**
     * Sets the begin line ending style of the annotation.
     *
     * @param {PdfLineEndingStyle} value Begin line ending style.
     * ```typescript
     * // Load an existing PDF document
     * let document: PdfDocument = new PdfDocument(data, password);
     * // Get the first page
     * let page: PdfPage = document.getPage(0) as PdfPage;
     * // Get the first annotation of the page
     * let annotation: PdfLineAnnotation = page.annotations.at(0) as PdfLineAnnotation;
     * // Initializes a new instance of the `PdfAnnotationLineEndingStyle` class.
     * let lineEndingStyle = new PdfAnnotationLineEndingStyle();
     * // Sets the begin line ending style of the annotation.
     * lineEndingStyle.begin = PdfLineEndingStyle.openArrow;
     * // Sets the end line ending style of the annotation.
     * lineEndingStyle.end = PdfLineEndingStyle.closeArrow;
     * // Sets the line ending style to the annotation
     * annotation.lineEndingStyle = lineEndingStyle;
     * // Destroy the document
     * document.destroy();
     * ```
     */
    set begin(value) {
        if (value !== this._begin) {
            this._begin = value;
            if (this._dictionary) {
                this._dictionary.update('LE', [_PdfName.get(_reverseMapEndingStyle(value)), _PdfName.get(_reverseMapEndingStyle(this._end))]);
            }
        }
    }
    /**
     * Gets the begin line ending style of the annotation.
     *
     * @returns {PdfLineEndingStyle} End line ending style.
     * `PdfAnnotationLineEndingStyle` class represents the line ending styles of annotations.
     * ```typescript
     * // Load an existing PDF document
     * let document: PdfDocument = new PdfDocument(data, password);
     * // Get the first page
     * let page: PdfPage = document.getPage(0) as PdfPage;
     * // Get the first annotation of the page
     * let annotation: PdfLineAnnotation = page.annotations.at(0) as PdfLineAnnotation;
     * // Gets the end line ending style of the annotation.
     * let end: PdfLineEndingStyle = annotation.lineEndingStyle.end;
     * // Destroy the document
     * document.destroy();
     * ```
     */
    get end() {
        return this._end;
    }
    /**
     * Sets the begin line ending style of the annotation.
     *
     * @param {PdfLineEndingStyle} value End line ending style.
     * ```typescript
     * // Load an existing PDF document
     * let document: PdfDocument = new PdfDocument(data, password);
     * // Get the first page
     * let page: PdfPage = document.getPage(0) as PdfPage;
     * // Get the first annotation of the page
     * let annotation: PdfLineAnnotation = page.annotations.at(0) as PdfLineAnnotation;
     * // Initializes a new instance of the `PdfAnnotationLineEndingStyle` class.
     * let lineEndingStyle = new PdfAnnotationLineEndingStyle();
     * // Sets the begin line ending style of the annotation.
     * lineEndingStyle.begin = PdfLineEndingStyle.openArrow;
     * // Sets the end line ending style of the annotation.
     * lineEndingStyle.end = PdfLineEndingStyle.closeArrow;
     * // Sets the line ending style to the annotation
     * annotation.lineEndingStyle = lineEndingStyle;
     * // Destroy the document
     * document.destroy();
     * ```
     */
    set end(value) {
        if (value !== this._end) {
            this._end = value;
            if (this._dictionary) {
                this._dictionary.update('LE', [_PdfName.get(_reverseMapEndingStyle(this._begin)), _PdfName.get(_reverseMapEndingStyle(value))]);
            }
        }
    }
}
/**
 * `PdfInteractiveBorder` class represents the border of the field.
 * ```typescript
 * // Load an existing PDF document
 * let document: PdfDocument = new PdfDocument(data, password);
 * // Get the PDF form field
 * let field: PdfField = document.form.fieldAt(0);
 * // Gets the width of the field border.
 * let width: number = field.border.width;
 * // Destroy the document
 * document.destroy();
 * ```
 */
class PdfInteractiveBorder {
    constructor(width, style, dash) {
        this._width = typeof width !== 'undefined' ? width : 1;
        this._style = typeof style !== 'undefined' ? style : PdfBorderStyle.solid;
        if (typeof dash !== 'undefined' && Array.isArray(dash)) {
            this._dash = dash;
        }
    }
    /**
     * Gets the width of the field border.
     *
     * @returns {number} border width.
     * ```typescript
     * // Load an existing PDF document
     * let document: PdfDocument = new PdfDocument(data, password);
     * // Get the PDF form field
     * let field: PdfField = document.form.fieldAt(0);
     * // Gets the width of the annotation border.
     * let width: number = field.border.width;
     * // Destroy the document
     * document.destroy();
     * ```
     */
    get width() {
        return this._width;
    }
    /**
     * Sets the width of the field border.
     *
     * @param {number} value width.
     * ```typescript
     * // Load an existing PDF document
     * let document: PdfDocument = new PdfDocument(data, password);
     * // Get the PDF form field
     * let field: PdfField = document.form.fieldAt(0);
     * // Initializes a new instance of the `PdfInteractiveBorder` class.
     * let border: PdfInteractiveBorder = new PdfInteractiveBorder();
     * //Sets the width of the annotation border.
     * border.width = 10;
     * //Sets the style of the annotation border.
     * border.style = PdfBorderStyle.dashed;
     * //Sets the dash pattern of the annotation border.
     * border.dash = [1, 2, 1];
     * // Sets the border to the PDF form field
     * field.border = border;
     * // Destroy the document
     * document.destroy();
     * ```
     */
    set width(value) {
        if (value !== this._width) {
            this._width = value;
            if (this._dictionary) {
                const bs = this._dictionary.has('BS') ? this._dictionary.get('BS') : new _PdfDictionary(this._crossReference);
                bs.update('Type', _PdfName.get('Border'));
                bs.update('W', this._width);
                bs.update('S', _mapBorderStyle(this._style));
                if (this._dash) {
                    bs.update('D', this._dash);
                }
                this._dictionary.update('BS', bs);
                this._dictionary._updated = true;
            }
        }
    }
    /**
     * Gets the border line style of the field border.
     *
     * @returns {PdfBorderStyle} Border style.
     * ```typescript
     * // Load an existing PDF document
     * let document: PdfDocument = new PdfDocument(data, password);
     * // Get the PDF form field
     * let field: PdfField = document.form.fieldAt(0);
     * // Gets the border line style of the annotation border.
     * let style: PdfBorderStyle = field.border.style;
     * // Destroy the document
     * document.destroy();
     * ```
     */
    get style() {
        return this._style;
    }
    /**
     * Sets the border line style of the field border.
     *
     * @param {PdfBorderStyle} value Border style.
     * ```typescript
     * // Load an existing PDF document
     * let document: PdfDocument = new PdfDocument(data, password);
     * // Get the PDF form field
     * let field: PdfField = document.form.fieldAt(0);
     * // Initializes a new instance of the `PdfInteractiveBorder` class.
     * let border: PdfInteractiveBorder = new PdfInteractiveBorder();
     * //Sets the width of the annotation border.
     * border.width = 10;
     * //Sets the style of the annotation border.
     * border.style = PdfBorderStyle.dashed;
     * //Sets the dash pattern of the annotation border.
     * border.dash = [1, 2, 1];
     * // Sets the border to the PDF form field
     * field.border = border;
     * // Destroy the document
     * document.destroy();
     * ```
     */
    set style(value) {
        if (value !== this._style) {
            this._style = value;
            if (this._dictionary) {
                const bs = this._dictionary.has('BS') ? this._dictionary.get('BS') : new _PdfDictionary(this._crossReference);
                bs.update('Type', _PdfName.get('Border'));
                bs.update('W', this._width);
                bs.update('S', _mapBorderStyle(this._style));
                if (this._dash) {
                    bs.update('D', this._dash);
                }
                this._dictionary.update('BS', bs);
                this._dictionary._updated = true;
            }
        }
    }
    /**
     * Gets the dash pattern of the field border.
     *
     * @returns {Array<number>} Dash pattern.
     * ```typescript
     * // Load an existing PDF document
     * let document: PdfDocument = new PdfDocument(data, password);
     * // Get the PDF form field
     * let field: PdfField = document.form.fieldAt(0);
     * // Gets the dash pattern of the field border.
     * let dash: Array<number> = field.border.dash;
     * // Destroy the document
     * document.destroy();
     * ```
     */
    get dash() {
        return this._dash;
    }
    /**
     * Sets the dash pattern of the field border.
     *
     * @param {Array<number>} value Dash pattern.
     * ```typescript
     * // Load an existing PDF document
     * let document: PdfDocument = new PdfDocument(data, password);
     * // Get the PDF form field
     * let field: PdfField = document.form.fieldAt(0);
     * // Initializes a new instance of the `PdfInteractiveBorder` class.
     * let border: PdfInteractiveBorder = new PdfInteractiveBorder();
     * //Sets the width of the annotation border.
     * border.width = 10;
     * //Sets the style of the annotation border.
     * border.style = PdfBorderStyle.dashed;
     * //Sets the dash pattern of the annotation border.
     * border.dash = [1, 2, 1];
     * // Sets the border to the PDF form field
     * field.border = border;
     * // Destroy the document
     * document.destroy();
     * ```
     */
    set dash(value) {
        if (typeof this._dash === 'undefined' || _areNotEqual(value, this._dash)) {
            this._dash = value;
            if (this._dictionary) {
                const bs = this._dictionary.has('BS') ? this._dictionary.get('BS') : new _PdfDictionary(this._crossReference);
                bs.update('Type', _PdfName.get('Border'));
                bs.update('W', this._width);
                bs.update('S', _mapBorderStyle(this._style));
                bs.update('D', this._dash);
                this._dictionary.update('BS', bs);
                this._dictionary._updated = true;
            }
        }
    }
}
/**
 * `PdfAnnotationBorder` class represents the border properties of annotations.
 * ```typescript
 * // Load an existing PDF document
 * let document: PdfDocument = new PdfDocument(data, password);
 * // Get the first page
 * let page: PdfPage = document.getPage(0) as PdfPage;
 * // Get the first annotation of the page
 * let annotation: PdfLineAnnotation = page.annotations.at(0) as PdfLineAnnotation;
 * // Initializes a new instance of the ` PdfAnnotationBorder ` class.
 * let border: PdfAnnotationBorder = new PdfAnnotationBorder ();
 * //Sets the width of the annotation border.
 * border.width = 10;
 * //Sets the style of the annotation border.
 * border.style = PdfBorderStyle.dashed;
 * //Sets the dash pattern of the annotation border.
 * border.dash = [1, 2, 1];
 * // Sets the border to the PDF form field
 * annotation.border = border;
 * // Destroy the document
 * document.destroy();
 * ```
 */
class PdfAnnotationBorder extends PdfInteractiveBorder {
    constructor(width, hRadius, vRadius, style, dash) {
        super(width, style, dash);
        this._hRadius = typeof hRadius !== 'undefined' ? hRadius : 0;
        this._vRadius = typeof vRadius !== 'undefined' ? vRadius : 0;
    }
    /**
     * Gets the width of the annotation border.
     *
     * @returns {number} border width.
     * ```typescript
     * // Load an existing PDF document
     * let document: PdfDocument = new PdfDocument(data, password);
     * // Get the first page
     * let page: PdfPage = document.getPage(0) as PdfPage;
     * // Get the first annotation of the page
     * let annotation: PdfLineAnnotation = page.annotations.at(0) as PdfLineAnnotation;
     * // Gets the width of the annotation border.
     * let width: number = annotation.border.width;
     * // Destroy the document
     * document.destroy();
     * ```
     */
    get width() {
        return this._width;
    }
    /**
     * Sets the width of the annotation border.
     *
     * @param {number} value width.
     * ```typescript
     * // Load an existing PDF document
     * let document: PdfDocument = new PdfDocument(data, password);
     * // Get the first page
     * let page: PdfPage = document.getPage(0) as PdfPage;
     * // Get the first annotation of the page
     * let annotation: PdfLineAnnotation = page.annotations.at(0) as PdfLineAnnotation;
     * // Initializes a new instance of the ` PdfAnnotationBorder ` class.
     * let border: PdfAnnotationBorder = new PdfAnnotationBorder ();
     * //Sets the width of the annotation border.
     * border.width = 10;
     * //Sets the style of the annotation border.
     * border.style = PdfBorderStyle.dashed;
     * //Sets the dash pattern of the annotation border.
     * border.dash = [1, 2, 1];
     * // Sets the border to the PDF form field
     * annotation.border = border;
     * // Destroy the document
     * document.destroy();
     * ```
     */
    set width(value) {
        if (value !== this._width) {
            this._width = value;
            if (this._dictionary) {
                this._dictionary.update('Border', [this._hRadius, this._vRadius, this._width]);
                const bs = this._dictionary.has('BS') ? this._dictionary.get('BS') : new _PdfDictionary(this._crossReference);
                bs.update('Type', _PdfName.get('Border'));
                bs.update('W', this._width);
                bs.update('S', _mapBorderStyle(this._style));
                if (this._dash) {
                    bs.update('D', this._dash);
                }
                this._dictionary.update('BS', bs);
                this._dictionary._updated = true;
            }
        }
    }
    /**
     * Gets the horizontal radius of the annotation border.
     *
     * @returns {number} horizontal radius.
     * ```typescript
     * // Load an existing PDF document
     * let document: PdfDocument = new PdfDocument(data, password);
     * // Get the first page
     * let page: PdfPage = document.getPage(0) as PdfPage;
     * // Get the first annotation of the page
     * let annotation: PdfLineAnnotation = page.annotations.at(0) as PdfLineAnnotation;
     * // Gets the horizontal radius of the annotation border.
     * let hRadius: number = annotation.border.hRadius;
     * // Destroy the document
     * document.destroy();
     * ```
     */
    get hRadius() {
        return this._hRadius;
    }
    /**
     * Sets the horizontal radius of the annotation border.
     *
     * @param {number} value horizontal radius.
     * ```typescript
     * // Load an existing PDF document
     * let document: PdfDocument = new PdfDocument(data, password);
     * // Get the first page
     * let page: PdfPage = document.getPage(0) as PdfPage;
     * // Get the first annotation of the page
     * let annotation: PdfLineAnnotation = page.annotations.at(0) as PdfLineAnnotation;
     * // Initializes a new instance of the ` PdfAnnotationBorder ` class.
     * let border: PdfAnnotationBorder = new PdfAnnotationBorder ();
     * //Sets the width of the annotation border.
     * border.width = 10;
     * // Sets the horizontal radius of the annotation border.
     * border.hRadius = 2;
     * //Sets the style of the annotation border.
     * border.style = PdfBorderStyle.dashed;
     * //Sets the dash pattern of the annotation border.
     * border.dash = [1, 2, 1];
     * // Sets the border to the PDF form field
     * annotation.border = border;
     * // Destroy the document
     * document.destroy();
     * ```
     */
    set hRadius(value) {
        if (value !== this._hRadius) {
            this._hRadius = value;
            if (this._dictionary) {
                this._dictionary.update('Border', [this._hRadius, this._vRadius, this._width]);
            }
        }
    }
    /**
     * Gets the vertical radius of the annotation border.
     *
     * @returns {number} vertical radius.
     * ```typescript
     * // Load an existing PDF document
     * let document: PdfDocument = new PdfDocument(data, password);
     * // Get the first page
     * let page: PdfPage = document.getPage(0) as PdfPage;
     * // Get the first annotation of the page
     * let annotation: PdfLineAnnotation = page.annotations.at(0) as PdfLineAnnotation;
     * // Gets the vertical radius of the annotation border.
     * let vRadius: number = annotation.border.vRadius;
     * // Destroy the document
     * document.destroy();
     * ```
     */
    get vRadius() {
        return this._vRadius;
    }
    /**
     * Sets the vertical radius of the annotation border.
     *
     * @param {number} value vertical radius.
     * ```typescript
     * // Load an existing PDF document
     * let document: PdfDocument = new PdfDocument(data, password);
     * // Get the first page
     * let page: PdfPage = document.getPage(0) as PdfPage;
     * // Get the first annotation of the page
     * let annotation: PdfLineAnnotation = page.annotations.at(0) as PdfLineAnnotation;
     * // Initializes a new instance of the ` PdfAnnotationBorder ` class.
     * let border: PdfAnnotationBorder = new PdfAnnotationBorder ();
     * //Sets the width of the annotation border.
     * border.width = 10;
     * // Sets the vertical radius of the annotation border.
     * border.vRadius = 2;
     * //Sets the style of the annotation border.
     * border.style = PdfBorderStyle.dashed;
     * //Sets the dash pattern of the annotation border.
     * border.dash = [1, 2, 1];
     * // Sets the border to the PDF form field
     * annotation.border = border;
     * // Destroy the document
     * document.destroy();
     * ```
     */
    set vRadius(value) {
        if (value !== this._vRadius) {
            this._vRadius = value;
            if (this._dictionary) {
                this._dictionary.update('Border', [this._hRadius, this._vRadius, this._width]);
            }
        }
    }
}
/**
 * `PdfBorderEffect` class represents the border effects of annotations.
 * ```typescript
 * // Load an existing PDF document
 * let document: PdfDocument = new PdfDocument(data, password);
 * // Get the first page
 * let page: PdfPage = document.getPage(0) as PdfPage;
 * // Get the first annotation of the page
 * let annotation: PdfSquareAnnotation = page.annotations.at(0) as PdfSquareAnnotation;
 * // Initializes a new instance of the `PdfBorderEffect` class.
 * let borderEffect: PdfBorderEffect = new PdfBorderEffect();
 * // Sets the intensity of the annotation border.
 * borderEffect.intensity = 2;
 * // Sets the effect style of the annotation border.
 * borderEffect.style = PdfBorderEffectStyle.cloudy;
 * // Sets border effect to the annotation.
 * annotation.borderEffect = borderEffect;
 * // Destroy the document
 * document.destroy();
 * ```
 */
class PdfBorderEffect {
    constructor(dictionary) {
        this._intensity = 0;
        if (typeof dictionary !== 'undefined' && dictionary !== null) {
            if (dictionary.has('BE')) {
                const borderEffect = this._dictionary.get('BE');
                if (borderEffect) {
                    if (borderEffect.has('I')) {
                        this._intensity = borderEffect.get('I');
                    }
                    if (borderEffect.has('S')) {
                        this._style = this._getBorderEffect(borderEffect.get('S'));
                    }
                }
            }
        }
        else {
            this._dictionary = new _PdfDictionary();
            this._dictionary.set('I', this._intensity);
            this._dictionary.set('S', this._styleToEffect(this._style));
        }
    }
    /**
     * Gets the intensity of the annotation border.
     *
     * @returns {number} intensity.
     * ```typescript
     * // Load an existing PDF document
     * let document: PdfDocument = new PdfDocument(data, password);
     * // Get the first page
     * let page: PdfPage = document.getPage(0) as PdfPage;
     * // Get the first annotation of the page
     * let annotation: PdfSquareAnnotation = page.annotations.at(0) as PdfSquareAnnotation;
     * // Gets the intensity of the annotation border.
     * let intensity: number = annotation.borderEffect.intensity;
     * // Gets the effect style of the annotation border.
     * let style: PdfBorderEffectStyle = annotation.borderEffect.style;
     * // Destroy the document
     * document.destroy();
     * ```
     */
    get intensity() {
        return this._intensity;
    }
    /**
     * Sets the intensity of the annotation border.
     *
     * @param {number} value intensity.
     * ```typescript
     * // Load an existing PDF document
     * let document: PdfDocument = new PdfDocument(data, password);
     * // Get the first page
     * let page: PdfPage = document.getPage(0) as PdfPage;
     * // Get the first annotation of the page
     * let annotation: PdfSquareAnnotation = page.annotations.at(0) as PdfSquareAnnotation;
     * // Initializes a new instance of the `PdfBorderEffect` class.
     * let borderEffect: PdfBorderEffect = new PdfBorderEffect();
     * // Sets the intensity of the annotation border.
     * borderEffect.intensity = 2;
     * // Sets the effect style of the annotation border.
     * borderEffect.style = PdfBorderEffectStyle.cloudy;
     * // Sets border effect to the annotation.
     * annotation.borderEffect = borderEffect;
     * // Destroy the document
     * document.destroy();
     * ```
     */
    set intensity(value) {
        if (value !== this._intensity) {
            this._intensity = value;
            if (this._dictionary) {
                const bs = this._dictionary.has('BE') ? this._dictionary.get('BE') : new _PdfDictionary(this._crossReference);
                bs.update('I', this._intensity);
                bs.update('S', this._styleToEffect(this._style));
                this._dictionary.update('BE', bs);
                this._dictionary._updated = true;
            }
            this._dictionary._updated = true;
        }
    }
    /**
     * Gets the effect style of the annotation border.
     *
     * @returns {PdfBorderEffectStyle} effect style.
     * ```typescript
     * // Load an existing PDF document
     * let document: PdfDocument = new PdfDocument(data, password);
     * // Get the first page
     * let page: PdfPage = document.getPage(0) as PdfPage;
     * // Get the first annotation of the page
     * let annotation: PdfSquareAnnotation = page.annotations.at(0) as PdfSquareAnnotation;
     * // Gets the intensity of the annotation border.
     * let intensity: number = annotation.borderEffect.intensity;
     * // Gets the effect style of the annotation border.
     * let style: PdfBorderEffectStyle = annotation.borderEffect.style;
     * // Destroy the document
     * document.destroy();
     * ```
     */
    get style() {
        return this._style;
    }
    /**
     * Sets the effect style of the annotation border.
     *
     * @param {PdfBorderEffectStyle} value effect style.
     * ```typescript
     * // Load an existing PDF document
     * let document: PdfDocument = new PdfDocument(data, password);
     * // Get the first page
     * let page: PdfPage = document.getPage(0) as PdfPage;
     * // Get the first annotation of the page
     * let annotation: PdfSquareAnnotation = page.annotations.at(0) as PdfSquareAnnotation;
     * // Initializes a new instance of the `PdfBorderEffect` class.
     * let borderEffect: PdfBorderEffect = new PdfBorderEffect();
     * // Sets the intensity of the annotation border.
     * borderEffect.intensity = 2;
     * // Sets the effect style of the annotation border.
     * borderEffect.style = PdfBorderEffectStyle.cloudy;
     * // Sets border effect to the annotation.
     * annotation.borderEffect = borderEffect;
     * // Destroy the document
     * document.destroy();
     * ```
     */
    set style(value) {
        if (value !== this._style) {
            this._style = value;
            if (this._dictionary) {
                const bs = this._dictionary.has('BE') ?
                    this._dictionary.get('BE') :
                    new _PdfDictionary(this._crossReference);
                bs.update('I', this._intensity);
                bs.update('S', this._styleToEffect(this._style));
                this._dictionary.update('BE', bs);
                this._dictionary._updated = true;
            }
        }
    }
    _getBorderEffect(value) {
        if (value === '/C') {
            return PdfBorderEffectStyle.cloudy;
        }
        else {
            return PdfBorderEffectStyle.solid;
        }
    }
    _styleToEffect(value) {
        if (value === PdfBorderEffectStyle.cloudy) {
            return 'C';
        }
        else {
            return 'S';
        }
    }
}
class _PaintParameter {
    constructor() {
        this.borderWidth = 1;
    }
}
class _CloudStyleArc {
    constructor() {
        this.startAngle = 0;
        this.endAngle = 0;
    }
}

/**
 * The class provides methods and properties to handle the collection of `PdfAnnotation`.
 * ```typescript
 * // Load an existing PDF document
 * let document: PdfDocument = new PdfDocument(data);
 * // Access annotation coolection from first page
 * let annotations: PdfAnnotationCollection = document.getPage(0).annotations;
 * // Save the document
 * document.save('output.pdf');
 * // Destroy the document
 * document.destroy();
 * ```
 */
class PdfAnnotationCollection {
    /**
     * Represents a annotation collection.
     *
     * @private
     * @param {Array<_PdfReference>} array Annotation references.
     * @param {_PdfCrossReference} xref Cross reference object.
     * @param {PdfPage} page PDF page object.
     */
    constructor(array, xref, page) {
        this._isExport = false;
        this._annotations = array;
        this._page = page;
        this._crossReference = xref;
        this._parsedAnnotations = new Map();
        this._comments = [];
    }
    /**
     * Gets the annotation count (Read only).
     *
     * @returns {number} Number of annotations.
     *
     * ```typescript
     * // Load an existing PDF document
     * let document: PdfDocument = new PdfDocument(data, password);
     * // Access first page
     * let page: PdfPage = document.getPage(0);
     * // Gets the annotation count
     * let count: number = page.annotations.count;
     * // Destroy the document
     * document.destroy();
     * ```
     */
    get count() {
        return this._annotations.length;
    }
    /**
     * Gets the `PdfAnnotation` at the specified index.
     *
     * @param {number} index Field index.
     * @returns {PdfAnnotation} Annotation at the specified index.
     *
     * ```typescript
     * // Load an existing PDF document
     * let document: PdfDocument = new PdfDocument(data, password);
     * // Access first page
     * let page: PdfPage = document.getPage(0);
     * // Access the annotation at index 0
     * let annotation: PdfAnnotation = page.annotations.at(0);
     * // Save the document
     * document.save('output.pdf');
     * // Destroy the document
     * document.destroy();
     * ```
     */
    at(index) {
        if (index < 0 || index >= this._annotations.length) {
            throw Error('Index out of range.');
        }
        if (!this._parsedAnnotations.has(index)) {
            let dictionary = this._annotations[Number.parseInt(index.toString(), 10)];
            if (typeof dictionary !== 'undefined' && dictionary instanceof _PdfReference) {
                dictionary = this._crossReference._fetch(dictionary);
            }
            if (typeof dictionary !== 'undefined' && dictionary instanceof _PdfDictionary) {
                const annotation = this._parseAnnotation(dictionary);
                if (annotation) {
                    annotation._ref = this._annotations[Number.parseInt(index.toString(), 10)];
                    this._parsedAnnotations.set(index, annotation);
                }
            }
        }
        return this._parsedAnnotations.get(index);
    }
    /**
     * Add a new `PdfAnnotation` into the collection.
     *
     * @param {PdfAnnotation} annotation Annotation to add.
     * @returns {number} Annotation index.
     *
     * ```typescript
     * // Load an existing PDF document
     * let document: PdfDocument = new PdfDocument(data, password);
     * // Access first page
     * let page: PdfPage = document.getPage(0);
     * // Add a new annotation into the collection
     * page.annotations.add(annotation);
     * // Save the document
     * document.save('output.pdf');
     * // Destroy the document
     * document.destroy();
     * ```
     */
    add(annotation) {
        if (typeof annotation === 'undefined' || annotation === null) {
            throw Error('annotation cannot be null or undefined');
        }
        if (annotation._isLoaded) {
            throw Error('cannot add an existing annotation');
        }
        annotation._initialize(this._page);
        let reference;
        if (typeof annotation._ref !== 'undefined' && annotation._ref._isNew) {
            reference = annotation._ref;
        }
        else {
            reference = this._crossReference._getNextReference();
            this._crossReference._cacheMap.set(reference, annotation._dictionary);
            annotation._ref = reference;
        }
        const index = this._annotations.length;
        this._annotations.push(reference);
        this._parsedAnnotations.set(index, annotation);
        let isAdded = false;
        if (this._page._pageDictionary.has('Annots')) {
            const collection = this._page._pageDictionary.get('Annots');
            if (collection !== null && typeof collection !== 'undefined' && collection.indexOf(reference) === -1) {
                collection.push(reference);
                this._page._pageDictionary.set('Annots', collection);
                isAdded = true;
            }
        }
        if (!isAdded) {
            this._page._pageDictionary.set('Annots', this._annotations);
        }
        this._page._pageDictionary._updated = true;
        if (annotation instanceof PdfComment) {
            this._addCommentsAndReview(annotation, annotation._dictionary.get('F'));
        }
        this._updateCustomAppearanceResource(annotation);
        return index;
    }
    /**
     * Remove an annotation from the collection.
     *
     * @param {PdfAnnotation} annotation Annotation to remove.
     * @returns {void} Nothing.
     *
     * ```typescript
     * // Load an existing PDF document
     * let document: PdfDocument = new PdfDocument(data);
     * // Access first page
     * let page: PdfPage = document.getPage(0);
     * // Access first annotation from the PDF page
     * let annotation: PdfAnnotation = page.annotations.at(0);
     * // Remove an annotation from the collection
     * page.annotations.remove(annotation);
     * // Save the document
     * document.save('output.pdf');
     * // Destroy the document
     * document.destroy();
     * ```
     */
    remove(annotation) {
        if (annotation._ref) {
            const index = this._annotations.indexOf(annotation._ref);
            if (index > -1) {
                this.removeAt(index);
            }
        }
    }
    /**
     * Remove an annotation from the collection at the specified index.
     *
     * @param {number} index Annotation index.
     * @returns {void} Nothing.
     *
     * ```typescript
     * // Load an existing PDF document
     * let document: PdfDocument = new PdfDocument(data);
     * // Access first page
     * let page: PdfPage = document.getPage(0);
     * // Remove an annotation from the collection
     * page.annotations.removeAt(0);
     * // Save the document
     * document.save('output.pdf');
     * // Destroy the document
     * document.destroy();
     * ```
     */
    removeAt(index) {
        if (index < 0 || index >= this._annotations.length) {
            throw Error('Index out of range.');
        }
        const reference = this._annotations[Number.parseInt(index.toString(), 10)];
        if (reference && this._page) {
            const array = this._page._getProperty('Annots');
            const actualIndex = array.indexOf(reference);
            if (actualIndex > -1) {
                array.splice(actualIndex, 1);
            }
            this._page._pageDictionary.set('Annots', array);
            this._page._pageDictionary._updated = true;
            if (this._annotations.indexOf(reference) > -1) {
                this._annotations.splice(index, 1);
            }
            if (this._parsedAnnotations.has(index)) {
                this._parsedAnnotations.delete(index);
                this._reorderParsedAnnotations(index);
            }
            const crossReference = this._page._crossReference;
            if (crossReference && crossReference._cacheMap.has(reference)) {
                crossReference._cacheMap.delete(reference);
            }
        }
    }
    _reorderParsedAnnotations(index) {
        const result = new Map();
        this._parsedAnnotations.forEach((value, key) => {
            if (key > index) {
                result.set(key - 1, value);
            }
            else {
                result.set(key, value);
            }
        });
        this._parsedAnnotations = result;
    }
    _updateCustomAppearanceResource(annotation) {
        if (annotation instanceof PdfRubberStampAnnotation && typeof annotation._appearance !== 'undefined') {
            annotation._appearance.normal.graphics._processResources(annotation._crossReference);
        }
    }
    _addCommentsAndReview(annotation, flag) {
        this._updateChildReference(annotation, annotation.comments, flag);
        this._updateChildReference(annotation, annotation.reviewHistory, flag);
    }
    _updateChildReference(annotation, collection, flag) {
        if (collection && collection.count > 0) {
            if (flag !== 30) {
                for (let i = 0; i < collection.count; i++) {
                    const childAnnotation = collection._collection[Number.parseInt(i.toString(), 10)];
                    if (childAnnotation && !childAnnotation._dictionary.has('IRT')) {
                        if (i === 0 || !collection._isReview) {
                            childAnnotation._dictionary.update('IRT', annotation._ref);
                        }
                        else {
                            childAnnotation._dictionary.update('IRT', collection._collection[i - 1]._ref);
                        }
                        if (collection._isReview) {
                            childAnnotation._isReview = true;
                        }
                        else {
                            childAnnotation._isComment = true;
                        }
                        this.add(childAnnotation);
                    }
                }
            }
            else {
                throw new Error('Could not add comments/reviews to the review');
            }
        }
    }
    _parseAnnotation(dictionary) {
        let annot;
        if (dictionary.has('Subtype')) {
            const key = dictionary.get('Subtype');
            const size = dictionary.get('Rect');
            if (key) {
                let link;
                switch (key.name) {
                    case 'Line':
                        annot = PdfLineAnnotation._load(this._page, dictionary);
                        break;
                    case 'Circle':
                        if (dictionary.has('Measure')) {
                            annot = PdfCircleAnnotation._load(this._page, dictionary);
                        }
                        else {
                            const width = size[2] - size[0];
                            const height = size[3] - size[1];
                            if (width === height) {
                                annot = PdfCircleAnnotation._load(this._page, dictionary);
                            }
                            else {
                                annot = PdfEllipseAnnotation._load(this._page, dictionary);
                            }
                        }
                        break;
                    case 'Square':
                        if (size[2] === size[3]) {
                            annot = PdfSquareAnnotation._load(this._page, dictionary);
                        }
                        else {
                            annot = PdfRectangleAnnotation._load(this._page, dictionary);
                        }
                        break;
                    case 'Polygon':
                        annot = PdfPolygonAnnotation._load(this._page, dictionary);
                        break;
                    case 'PolyLine':
                        if (dictionary.has('Measure') && dictionary.has('IT')) {
                            const type = dictionary.get('IT');
                            if (type && type.name === 'PolyLineAngle') {
                                annot = PdfAngleMeasurementAnnotation._load(this._page, dictionary);
                            }
                        }
                        if (!annot) {
                            annot = PdfPolyLineAnnotation._load(this._page, dictionary);
                        }
                        break;
                    case 'Ink':
                        annot = PdfInkAnnotation._load(this._page, dictionary);
                        break;
                    case 'Popup':
                        annot = PdfPopupAnnotation._load(this._page, dictionary);
                        break;
                    case 'Text':
                        annot = PdfPopupAnnotation._load(this._page, dictionary);
                        break;
                    case 'Link':
                        if (dictionary.has('A')) {
                            link = dictionary.get('A');
                        }
                        if (link && link.has('S')) {
                            const type = link.get('S').name;
                            if (type) {
                                const isTextWebLink = this._hasValidBorder(dictionary.getArray('Border'));
                                if (type === 'URI') {
                                    annot = isTextWebLink ?
                                        PdfTextWebLinkAnnotation._load(this._page, dictionary) :
                                        this._getLinkAnnotation(dictionary);
                                }
                                else if (type === 'Launch') {
                                    annot = PdfFileLinkAnnotation._load(this._page, dictionary);
                                }
                                else if (type === 'GoToR') {
                                    annot = this._getLinkAnnotation(dictionary);
                                }
                                else if (type === 'GoTo') {
                                    annot = PdfDocumentLinkAnnotation._load(this._page, dictionary);
                                }
                            }
                        }
                        else if (key.name === 'Link') {
                            annot = PdfDocumentLinkAnnotation._load(this._page, dictionary);
                        }
                        break;
                    case 'FileAttachment':
                        annot = PdfAttachmentAnnotation._load(this._page, dictionary);
                        break;
                    case '3D':
                        annot = Pdf3DAnnotation._load(this._page, dictionary);
                        break;
                    case 'FreeText':
                        annot = PdfFreeTextAnnotation._load(this._page, dictionary);
                        break;
                    case 'Redact':
                        annot = PdfRedactionAnnotation._load(this._page, dictionary);
                        break;
                    case 'RichMedia':
                        annot = PdfRichMediaAnnotation._load(this._page, dictionary);
                        break;
                    case 'Watermark':
                        annot = PdfWatermarkAnnotation._load(this._page, dictionary);
                        break;
                    case 'Stamp':
                        annot = PdfRubberStampAnnotation._load(this._page, dictionary);
                        break;
                    case 'Sound':
                        annot = PdfSoundAnnotation._load(this._page, dictionary);
                        break;
                    case 'Highlight':
                    case 'Squiggly':
                    case 'StrikeOut':
                    case 'Underline':
                        annot = PdfTextMarkupAnnotation._load(this._page, dictionary);
                        break;
                }
            }
        }
        return annot;
    }
    _getLinkAnnotation(dictionary) {
        let annot;
        if (dictionary.has('A')) {
            const remote = dictionary.get('A');
            if (remote && remote.has('S')) {
                const link = remote.get('S');
                if (link && link.name === 'GoToR' && remote.has('F')) {
                    annot = PdfFileLinkAnnotation._load(this._page, dictionary);
                }
                else if (link && link.name === 'URI') {
                    annot = PdfUriAnnotation._load(this._page, dictionary);
                }
            }
        }
        else {
            annot = PdfUriAnnotation._load(this._page, dictionary);
        }
        return annot;
    }
    _hasValidBorder(border) {
        if (typeof border === 'undefined' || border === null) {
            return false;
        }
        for (let i = 0; i < border.length; i++) {
            let val = 0;
            const value = border[Number.parseInt(i.toString(), 10)];
            if (value !== null && typeof value !== 'undefined') {
                val = value;
            }
            if (val > 0) {
                return false;
            }
        }
        return true;
    }
    _doPostProcess(isFlatten) {
        for (let i = this.count - 1; i >= 0; i--) {
            const annotation = this.at(i);
            if (annotation) {
                annotation._isExport = this._isExport;
                annotation._doPostProcess(annotation.flatten || isFlatten);
            }
        }
    }
    _reArrange(ref, tabIndex, index) {
        if (this._annotations) {
            if (tabIndex > this._annotations.length) {
                tabIndex = 0;
            }
            if (index >= this._annotations.length) {
                index = this._annotations.indexOf(ref);
            }
            const annotationDictionary = this._crossReference.
                _fetch(this._annotations[Number.parseInt(index.toString(), 10)]);
            if (annotationDictionary.has('Parent')) {
                const parentReference = annotationDictionary.getRaw('Parent');
                if ((parentReference && parentReference === ref) || ref ===
                    this._annotations[Number.parseInt(index.toString(), 10)]) {
                    const temp = this._annotations[Number.parseInt(index.toString(), 10)];
                    this._annotations[Number.parseInt(index.toString(), 10)] = this._annotations[Number.parseInt(tabIndex.toString(), 10)];
                    this._annotations[Number.parseInt(tabIndex.toString(), 10)] = temp;
                }
            }
        }
        return this._annotations;
    }
    _clear() {
        this._annotations = [];
        this._parsedAnnotations = new Map();
        this._comments = [];
    }
}
/**
 * Represents the collection of `PdfPopupAnnotation`
 * ```typescript
 * // Load an existing PDF document
 * let document: PdfDocument = new PdfDocument(data);
 * // Access annotation collection from first page
 * let annotations: PdfRectangleAnnotation = document.getPage(0).annotations;
 * // Gets the comments of annotation
 * let comments: PdfPopupAnnotationCollection = annotation.comments;
 * // Save the document
 * document.save('output.pdf');
 * // Destroy the document
 * document.destroy();
 * ```
 */
class PdfPopupAnnotationCollection {
    /**
     * Initializes a new instance of the `PdfPopupAnnotationCollection` class
     *
     * @private
     * @param {PdfAnnotation} annotation Annotation reference
     * @param {boolean} isReview Boolean flag to set review
     */
    constructor(annotation, isReview) {
        this._collection = [];
        this._annotation = annotation;
        this._isReview = isReview;
        if (this._annotation._isLoaded || typeof annotation._page !== 'undefined') {
            this._page = annotation._page;
            this._parentDictionary = annotation._dictionary;
            if (this._annotation._isLoaded) {
                this._parseCommentsOrReview();
            }
        }
    }
    /**
     * Gets the annotation count (Read only).
     *
     * @private
     * @returns {number} Number of annotations
     *
     * ```typescript
     * // Load an existing PDF document
     * let document: PdfDocument = new PdfDocument(data);
     * // Access annotation collection from first page
     * let annotations: PdfRectangleAnnotation = document.getPage(0).annotations;
     * // Gets the comments of annotation
     * let comments: PdfPopupAnnotationCollection = annotation.comments;
     * // Gets the count of comments
     * let count: number = comments.count;
     * // Save the document
     * document.save('output.pdf');
     * // Destroy the document
     * document.destroy();
     * ```
     */
    get count() {
        return this._collection.length;
    }
    /**
     * Gets the popup annotation at the specified index.
     *
     * @private
     * @param {number} index Index of the annotation
     * @returns {number} Annotation at the specified index
     *
     * ```typescript
     * // Load an existing PDF document
     * let document: PdfDocument = new PdfDocument(data);
     * // Access annotation collection from first page
     * let annotations: PdfRectangleAnnotation = document.getPage(0).annotations;
     * // Gets the comments of annotation
     * let comments: PdfPopupAnnotationCollection = annotation.comments;
     * // Gets the first comment
     * let comment: PdfPopupAnnotation = comments.at(0);
     * // Save the document
     * document.save('output.pdf');
     * // Destroy the document
     * document.destroy();
     * ```
     */
    at(index) {
        if (index < 0 || index >= this._collection.length) {
            throw Error('Index out of range.');
        }
        return this._collection[Number.parseInt(index.toString(), 10)];
    }
    /**
     * Add a new popup annotation into the collection
     *
     * @param {PdfPopupAnnotation} annotation Annotation to add
     * @returns {void} Nothing
     *
     * ```typescript
     * // Load an existing PDF document
     * let document: PdfDocument = new PdfDocument(data, password);
     * // Access first page
     * let page: PdfPage = document.getPage(0);
     * // Create a new popup annotation
     * const popupAnnotation: PdfPopupAnnotation = new PdfPopupAnnotation('Test popup annotation', 10, 40, 30, 30);
     * popupAnnotation.author = 'Syncfusion';
     * // Add a new popup annotation into the collection
     * annotation.comments.add(popupAnnotation);
     * // Save the document
     * document.save('output.pdf');
     * // Destroy the document
     * document.destroy();
     * ```
     */
    add(annotation) {
        if (this._annotation._dictionary.get('F') === 30) {
            throw new Error('Could not add comments/reviews to the review');
        }
        annotation._dictionary.update('F', ((this._annotation.flags === PdfAnnotationFlag.locked) ? 128 : (this._isReview ? 30 : 28)));
        if (this._annotation && (this._annotation._isLoaded || (this._page && this._annotation._ref))) {
            this._page.annotations.add(annotation);
            const length = this._collection.length;
            if (length === 0 || !this._isReview) {
                annotation._dictionary.update('IRT', this._annotation._ref);
            }
            else {
                annotation._dictionary.update('IRT', this._collection[Number.parseInt((length - 1).toString(), 10)]._ref);
            }
            if (this._isReview) {
                annotation._isReview = true;
            }
            else {
                annotation._isComment = true;
            }
        }
        this._collection.push(annotation);
    }
    /**
     * Remove an annotation from the collection
     *
     * @param {PdfPopupAnnotation} annotation Annotation to remove
     * @returns {void} Nothing
     *
     * ```typescript
     * // Load an existing PDF document
     * let document: PdfDocument = new PdfDocument(data);
     * // Access annotation collection from first page
     * let annotations: PdfRectangleAnnotation = document.getPage(0).annotations;
     * // Gets the comments of annotation
     * let comments: PdfPopupAnnotationCollection = annotation.comments;
     * // Gets the first comment
     * let comment: PdfPopupAnnotation = comments.at(0);
     * // Remove the comment
     * comments.remove(comment);
     * // Save the document
     * document.save('output.pdf');
     * // Destroy the document
     * document.destroy();
     * ```
     */
    remove(annotation) {
        const index = this._collection.indexOf(annotation);
        if (index > -1) {
            this.removeAt(index);
        }
    }
    /**
     * Remove an annotation from the collection at the specified index
     *
     * @param {number} index Annotation index to remove
     * @returns {void} Nothing
     *
     * ```typescript
     * // Load an existing PDF document
     * let document: PdfDocument = new PdfDocument(data);
     * // Access annotation collection from first page
     * let annotations: PdfRectangleAnnotation = document.getPage(0).annotations;
     * // Gets the comments of annotation
     * let comments: PdfPopupAnnotationCollection = annotation.comments;
     * // Remove the first comment
     * comments.removeAt(0);
     * // Save the document
     * document.save('output.pdf');
     * // Destroy the document
     * document.destroy();
     * ```
     */
    removeAt(index) {
        if (index > -1 && index < this._collection.length) {
            const annotation = this._collection[Number.parseInt(index.toString(), 10)];
            if (this._isReview && index < this._collection.length - 1) {
                const nextAnnotation = this._collection[Number.parseInt((index + 1).toString(), 10)];
                const previous = annotation._dictionary._get('IRT');
                nextAnnotation._dictionary.set('IRT', previous);
                nextAnnotation._dictionary._updated = true;
            }
            this._collection.splice(index, 1);
            this._page.annotations.remove(annotation);
        }
        else {
            throw new Error('Index out of range.');
        }
    }
    _parseCommentsOrReview() {
        if (this._isReview) {
            this._parseReview();
        }
        else {
            this._parseComments();
        }
    }
    _parseReview() {
        const collection = this._page.annotations;
        const map = new Map();
        map.set(this._annotation._ref, this._annotation);
        if (collection._comments && collection._comments.length > 0) {
            const remaining = [];
            for (let i = 0; i < collection._comments.length; i++) {
                const annotation = collection._comments[Number.parseInt(i.toString(), 10)];
                const reference = annotation._dictionary._get('IRT');
                if (annotation._isReview && reference && map.has(reference)) {
                    this._collection.push(annotation);
                    map.set(annotation._ref, annotation);
                }
                else {
                    remaining.push(annotation);
                }
            }
            if (remaining.length > 0) {
                collection._comments = remaining;
            }
            else {
                collection._comments = [];
            }
        }
        else {
            const count = collection.count;
            for (let i = 0; i < count; i++) {
                const annotation = collection.at(i);
                if (annotation && annotation instanceof PdfPopupAnnotation) {
                    const dictionary = annotation._dictionary;
                    if (annotation._dictionary.has('IRT')) {
                        const reference = dictionary._get('IRT');
                        if (annotation._isReview && reference && map.has(reference)) {
                            this._collection.push(annotation);
                            map.set(annotation._ref, annotation);
                        }
                        else {
                            collection._comments.push(annotation);
                        }
                    }
                }
            }
        }
        map.clear();
    }
    _parseComments() {
        const collection = this._page.annotations;
        if (collection._comments && collection._comments.length > 0) {
            const remaining = [];
            for (let i = 0; i < collection._comments.length; i++) {
                const annotation = collection._comments[Number.parseInt(i.toString(), 10)];
                const dictionary = annotation._dictionary;
                const isReview = _checkReview(dictionary);
                const reference = dictionary._get('IRT');
                if (reference && reference === this._annotation._ref && !isReview) {
                    this._collection.push(annotation);
                }
                else {
                    remaining.push(annotation);
                }
            }
            if (remaining.length > 0) {
                collection._comments = remaining;
            }
            else {
                collection._comments = [];
            }
        }
        else {
            const count = collection.count;
            for (let i = 0; i < count; i++) {
                const annotation = collection.at(i);
                if (annotation && annotation instanceof PdfPopupAnnotation) {
                    const dictionary = annotation._dictionary;
                    if (annotation._dictionary.has('IRT')) {
                        const isReview = _checkReview(dictionary);
                        const reference = dictionary._get('IRT');
                        if (reference && reference === this._annotation._ref && !isReview) {
                            this._collection.push(annotation);
                        }
                        else {
                            collection._comments.push(annotation);
                        }
                    }
                }
            }
        }
    }
}

/**
 * Represents a page loaded from the PDF document.
 * ```typescript
 * // Load an existing PDF document
 * let document: PdfDocument = new PdfDocument(data);
 * // Access first page
 * let page: PdfPage = document.getPage(0);
 * // Save the document
 * document.save('output.pdf');
 * // Destroy the document
 * document.destroy();
 * ```
 */
class PdfPage {
    /**
     * Represents a loaded page of the PDF document.
     *
     * @private
     * @param {_PdfCrossReference} crossReference Cross reference object.
     * @param {number} pageIndex page index.
     * @param {_PdfDictionary} dictionary page Dictionary.
     * @param {_PdfReference} reference page reference.
     */
    constructor(crossReference, pageIndex, dictionary, reference) {
        this._isAnnotationParsed = false;
        this._pageIndex = pageIndex;
        this._pageDictionary = dictionary;
        this._crossReference = crossReference;
        this._ref = reference;
    }
    /**
     * Gets the collection of the page's annotations (Read only).
     *
     * @returns {PdfAnnotationCollection} Annotation collection.
     *
     * ```typescript
     * // Load an existing PDF document
     * let document: PdfDocument = new PdfDocument(data);
     * // Access first page
     * let page: PdfPage = document.getPage(0);
     * // Gets the annotation collection
     * let annotations: PdfAnnotationCollection = page.annotations;
     * // Save the document
     * document.save('output.pdf');
     * // Destroy the document
     * document.destroy();
     * ```
     */
    get annotations() {
        if (typeof this._annotations === 'undefined') {
            if (this._pageDictionary.has('Annots')) {
                const annots = this._getProperty('Annots');
                if (annots && Array.isArray(annots)) {
                    const widgets = this._crossReference._document.form._parseWidgetReferences();
                    if (widgets && widgets.length > 0) {
                        const validAnnotations = [];
                        annots.forEach((entry) => {
                            if (widgets.indexOf(entry) === -1) {
                                validAnnotations.push(entry);
                            }
                        });
                        this._annotations = new PdfAnnotationCollection(validAnnotations, this._crossReference, this);
                    }
                    else {
                        this._annotations = new PdfAnnotationCollection(annots, this._crossReference, this);
                    }
                }
            }
            if (typeof this._annotations === 'undefined') {
                this._annotations = new PdfAnnotationCollection([], this._crossReference, this);
            }
        }
        return this._annotations;
    }
    /**
     * Gets the size of the page (Read only).
     *
     * @returns {number[]} Page width and height as number array.
     *
     * ```typescript
     * // Load an existing PDF document
     * let document: PdfDocument = new PdfDocument(data);
     * // Access first page
     * let page: PdfPage = document.getPage(0);
     * // Gets the width and height of the PDF page as number array
     * let size: number[] = page.size;
     * // Save the document
     * document.save('output.pdf');
     * // Destroy the document
     * document.destroy();
     * ```
     */
    get size() {
        if (typeof this._size === 'undefined') {
            const mBox = this.mediaBox;
            let width = 0;
            let height = 0;
            if (mBox) {
                width = mBox[2] - mBox[0];
                height = mBox[3] !== 0 ? mBox[3] - mBox[1] : mBox[1];
            }
            if (height < 0) {
                height = -height;
            }
            if (width < 0) {
                width = -width;
            }
            this._size = [width, height];
        }
        return this._size;
    }
    /**
     * Gets the rotation angle of the page (Read only).
     *
     * @returns {PdfRotationAngle} Page rotation angle.
     *
     * ```typescript
     * // Load an existing PDF document
     * let document: PdfDocument = new PdfDocument(data);
     * // Access first page
     * let page: PdfPage = document.getPage(0);
     * // Gets the rotation angle of the page
     * let rotation: PdfRotationAngle = page.rotation;
     * // Save the document
     * document.save('output.pdf');
     * // Destroy the document
     * document.destroy();
     * ```
     */
    get rotation() {
        let angle = 0;
        if (typeof this._rotation === 'undefined') {
            angle = _getInheritableProperty(this._pageDictionary, 'Rotate', false, true, 'Parent');
        }
        if (angle < 0) {
            angle += 360;
        }
        return (typeof angle !== 'undefined') ? ((angle / 90) % 4) : PdfRotationAngle.angle0;
    }
    /**
     * Gets the tab order of a PDF form field.
     *
     * @returns {PdfFormFieldsTabOrder} tab order.
     * ```typescript
     * // Load an existing PDF document
     * let document: PdfDocument = new PdfDocument(data);
     * // Access first page
     * let page: PdfPage = document.getPage(0);
     * // Gets the tab order of a PDF form field.
     * let tabOrder: PdfFormFieldsTabOrder = page.tabOrder;
     * // Save the document
     * document.save('output.pdf');
     * // Destroy the document
     * document.destroy();
     * ```
     */
    get tabOrder() {
        return this._obtainTabOrder();
    }
    /**
     * Sets the tab order of a PDF form field.
     *
     * @param {PdfFormFieldsTabOrder} value tab order.
     * ```typescript
     * // Load an existing PDF document
     * let document: PdfDocument = new PdfDocument(data);
     * // Access first page
     * let page: PdfPage = document.getPage(0);
     * // Sets the tab order of a PDF form field.
     * page.tabOrder = PdfFormFieldsTabOrder.row;
     * // Save the document
     * document.save('output.pdf');
     * // Destroy the document
     * document.destroy();
     * ```
     */
    set tabOrder(value) {
        this._tabOrder = value;
        let tabs = '';
        if (this._tabOrder !== PdfFormFieldsTabOrder.none) {
            if (this._tabOrder === PdfFormFieldsTabOrder.row) {
                tabs = 'R';
            }
            else if (this._tabOrder === PdfFormFieldsTabOrder.column) {
                tabs = 'C';
            }
            else if (this._tabOrder === PdfFormFieldsTabOrder.structure) {
                tabs = 'S';
            }
        }
        this._pageDictionary.update('Tabs', _PdfName.get(tabs));
    }
    /**
     * Gets the bounds that define the area intended for display or printing in the PDF viewer application (Read only).
     *
     * @returns {number[]} Page size as number array.
     *
     * ```typescript
     * // Load an existing PDF document
     * let document: PdfDocument = new PdfDocument(data);
     * // Access first page
     * let page: PdfPage = document.getPage(0);
     * // Gets the cropBox of the PDF page as number array
     * let cropBox: number[] = page.cropBox;
     * // Save the document
     * document.save('output.pdf');
     * // Destroy the document
     * document.destroy();
     * ```
     */
    get cropBox() {
        if (typeof this._cBox === 'undefined') {
            this._cBox = _getInheritableProperty(this._pageDictionary, 'CropBox', false, true, 'Parent', 'P');
        }
        if (typeof this._cBox === 'undefined') {
            this._cBox = [0, 0, 0, 0];
        }
        return this._cBox;
    }
    /**
     * Gets the size that specify the width and height of the page (Read only).
     *
     * @returns {number[]} Page size as number array.
     *
     * ```typescript
     * // Load an existing PDF document
     * let document: PdfDocument = new PdfDocument(data);
     * // Access first page
     * let page: PdfPage = document.getPage(0);
     * // Gets the mediaBox of the PDF page as number array
     * let mediaBox: number[] = page.mediaBox;
     * // Save the document
     * document.save('output.pdf');
     * // Destroy the document
     * document.destroy();
     * ```
     */
    get mediaBox() {
        if (typeof this._mBox === 'undefined') {
            this._mBox = _getInheritableProperty(this._pageDictionary, 'MediaBox', false, true, 'Parent', 'P');
        }
        if (typeof this._mBox === 'undefined') {
            this._mBox = [0, 0, 0, 0];
        }
        return this._mBox;
    }
    /**
     * Gets the orientation of the page (Read only).
     *
     * @returns {PdfPageOrientation} Page orientation.
     *
     * ```typescript
     * // Load an existing PDF document
     * let document: PdfDocument = new PdfDocument(data);
     * // Access first page
     * let page: PdfPage = document.getPage(0);
     * // Gets the orientation of the PDF page
     * let orientation: number[] = page.orientation;
     * // Save the document
     * document.save('output.pdf');
     * // Destroy the document
     * document.destroy();
     * ```
     */
    get orientation() {
        if (typeof this._orientation === 'undefined') {
            if (typeof this.size !== 'undefined') {
                const size = this.size;
                if (size[0] > size[1]) {
                    this._orientation = PdfPageOrientation.landscape;
                }
                else {
                    this._orientation = PdfPageOrientation.portrait;
                }
            }
        }
        return this._orientation;
    }
    get _origin() {
        if (typeof this._o === 'undefined' || (this._o[0] === 0 && this._o[1] === 0)) {
            this._o = [this.mediaBox[0], this._mBox[1]];
        }
        return this._o;
    }
    /**
     * Gets the graphics of the page (Read only).
     *
     * @returns {PdfGraphics} Page graphics.
     *
     * ```typescript
     * // Load an existing PDF document
     * let document: PdfDocument = new PdfDocument(data, password);
     * // Access first page
     * let page: PdfPage = document.getPage(0);
     * // Gets the graphics of the PDF page
     * let graphics: PdfGraphics = page.graphics;
     * //Create a new pen.
     * let pen: PdfPen = new PdfPen([0, 0, 0], 1);
     * //Draw line on the page graphics.
     * graphics.drawLine(pen, 10, 10, 100, 100);
     * // Save the document
     * document.save('output.pdf');
     * // Destroy the document
     * document.destroy();
     * ```
     */
    get graphics() {
        if (typeof this._g === 'undefined' || this._needInitializeGraphics) {
            this._parseGraphics();
        }
        return this._g;
    }
    _addWidget(reference) {
        let annots;
        if (this._pageDictionary.has('Annots')) {
            annots = this._getProperty('Annots');
        }
        if (annots && Array.isArray(annots)) {
            annots.push(reference);
        }
        else {
            this._pageDictionary.update('Annots', [reference]);
        }
        this._pageDictionary._updated = true;
    }
    _getProperty(key, getArray = false) {
        const value = _getInheritableProperty(this._pageDictionary, key, getArray, false); // eslint-disable-line
        if (!Array.isArray(value)) {
            return value;
        }
        if (value.length === 1 || !(value[0] instanceof _PdfDictionary)) {
            return value[0];
        }
        return _PdfDictionary.merge(this._crossReference, value);
    }
    _parseGraphics() {
        this._loadContents();
        const saveStream = new _PdfContentStream([32, 113, 32, 10]);
        const saveReference = this._crossReference._getNextReference();
        this._crossReference._cacheMap.set(saveReference, saveStream);
        this._contents.splice(0, 0, saveReference);
        const restoreStream = new _PdfContentStream([32, 81, 32, 10]);
        const restoreReference = this._crossReference._getNextReference();
        this._crossReference._cacheMap.set(restoreReference, restoreStream);
        this._contents.push(restoreReference);
        const contentStream = new _PdfContentStream([]);
        const contentReference = this._crossReference._getNextReference();
        this._crossReference._cacheMap.set(contentReference, contentStream);
        this._contents.push(contentReference);
        this._pageDictionary.set('Contents', this._contents);
        this._pageDictionary._updated = true;
        this._initializeGraphics(contentStream);
    }
    _loadContents() {
        let contents = this._pageDictionary.getRaw('Contents'); // eslint-disable-line
        let ref;
        if (contents !== null && typeof contents !== 'undefined' && contents instanceof _PdfReference) {
            ref = contents;
            contents = this._crossReference._fetch(ref);
        }
        if (contents && contents instanceof _PdfBaseStream) {
            this._contents = [ref];
        }
        else if (contents && Array.isArray(contents)) {
            this._contents = contents;
        }
        else {
            this._contents = [];
        }
    }
    _initializeGraphics(stream) {
        let isInvalidCase = false;
        let llx = 0;
        let lly = 0;
        let urx = 0;
        let ury = 0;
        const size = this.size;
        const mbox = this.mediaBox;
        if (mbox && mbox.length >= 4) {
            llx = mbox[0];
            lly = mbox[1];
            urx = mbox[2];
            ury = mbox[3];
        }
        let cbox;
        if (this._pageDictionary.has('CropBox')) {
            cbox = this.cropBox;
            if (cbox && cbox.length >= 4) {
                const cx = cbox[0];
                const cy = cbox[1];
                const crx = cbox[2];
                const cry = cbox[3];
                const isValid = (cx < 0 || cy < 0 || crx < 0 || cry < 0) &&
                    (Math.floor(Math.abs(cy)) === Math.floor(Math.abs(size[1]))) &&
                    (Math.floor(Math.abs(cx)) === Math.floor(Math.abs(size[0])));
                if (isValid) {
                    this._g = new PdfGraphics([Math.max(cx, crx), Math.max(cy, cry)], stream, this._crossReference, this);
                }
                else {
                    this._g = new PdfGraphics(size, stream, this._crossReference, this);
                    this._g._cropBox = cbox;
                }
            }
            else {
                this._g = new PdfGraphics(size, stream, this._crossReference, this);
            }
        }
        else if ((llx < 0 || lly < 0 || urx < 0 || ury < 0) &&
            (Math.floor(Math.abs(lly)) === Math.floor(Math.abs(size[1]))) &&
            (Math.floor(Math.abs(urx)) === Math.floor(Math.abs(size[0])))) {
            let width = Math.max(llx, urx);
            let height = Math.max(lly, ury);
            if (width <= 0 || height <= 0) {
                isInvalidCase = true;
                if (llx < 0) {
                    llx = -llx;
                }
                if (lly < 0) {
                    lly = -lly;
                }
                if (urx < 0) {
                    urx = -urx;
                }
                if (ury < 0) {
                    ury = -ury;
                }
                width = Math.max(llx, urx);
                height = Math.max(lly, ury);
            }
            this._g = new PdfGraphics([width, height], stream, this._crossReference, this);
        }
        else {
            this._g = new PdfGraphics(size, stream, this._crossReference, this);
        }
        if (this._pageDictionary.has('MediaBox')) {
            this._g._mediaBoxUpperRightBound = isInvalidCase ? -lly : ury;
        }
        this._graphicsState = this._g.save();
        const origin = this._origin;
        if ((origin[0] >= 0 && origin[1] >= 0) || Math.sign(origin[0]) !== Math.sign(origin[1])) {
            this._g._initializeCoordinates();
        }
        else {
            this._g._initializeCoordinates(this);
        }
        //Need to code - set transparency group
        const rotation = this.rotation;
        if (!Number.isNaN(rotation) && (rotation !== PdfRotationAngle.angle0 || this._pageDictionary.has('Rotate'))) {
            let rotate;
            if (this._pageDictionary.has('Rotate')) {
                rotate = this._pageDictionary.get('Rotate');
            }
            else {
                rotate = rotation * 90;
            }
            const clip = this._g._clipBounds;
            if (rotate === 90) {
                this._g.translateTransform(0, size[1]);
                this._g.rotateTransform(-90);
                this._g._clipBounds = [clip[0], clip[1], size[0], size[1]];
            }
            else if (rotate === 180) {
                this._g.translateTransform(size[0], size[1]);
                this._g.rotateTransform(-180);
            }
            else if (rotate === 270) {
                this._g.translateTransform(size[0], 0);
                this._g.rotateTransform(-270);
                this._g._clipBounds = [clip[0], clip[1], size[1], size[0]];
            }
        }
        this._needInitializeGraphics = false;
    }
    _fetchResources() {
        if (typeof this._resourceObject === 'undefined') {
            if (this._pageDictionary && this._pageDictionary.has('Resources')) {
                const obj = this._pageDictionary.getRaw('Resources'); // eslint-disable-line
                if (obj !== null && typeof obj !== 'undefined' && obj instanceof _PdfReference) {
                    this._hasResourceReference = true;
                    this._resourceObject = this._crossReference._fetch(obj);
                }
                else if (obj instanceof _PdfDictionary) {
                    this._resourceObject = obj;
                }
            }
            else {
                this._resourceObject = new _PdfDictionary(this._crossReference);
                this._pageDictionary.update('Resources', this._resourceObject);
            }
        }
        return this._resourceObject;
    }
    _getCropOrMediaBox() {
        let box;
        if (this._pageDictionary.has('CropBox')) {
            box = this._pageDictionary.getArray('CropBox');
        }
        else if (this._pageDictionary.has('MediaBox')) {
            box = this._pageDictionary.getArray('MediaBox');
        }
        return box;
    }
    _beginSave() {
        if (typeof this._graphicsState !== 'undefined') {
            this.graphics.restore(this._graphicsState);
            this._graphicsState = null;
            this._needInitializeGraphics = true;
        }
    }
    _destroy() {
        this._pageDictionary = undefined;
        this._size = undefined;
        this._mBox = undefined;
        this._cBox = undefined;
        this._o = undefined;
        this._g = undefined;
        this._graphicsState = undefined;
        this._contents = undefined;
    }
    _obtainTabOrder() {
        if (this._pageDictionary.has('Tabs')) {
            const tabOrder = this._pageDictionary.get('Tabs');
            if (tabOrder === _PdfName.get('R')) {
                this._tabOrder = PdfFormFieldsTabOrder.row;
            }
            else if (tabOrder === _PdfName.get('C')) {
                this._tabOrder = PdfFormFieldsTabOrder.column;
            }
            else if (tabOrder === _PdfName.get('S')) {
                this._tabOrder = PdfFormFieldsTabOrder.structure;
            }
            else if (tabOrder === _PdfName.get('W')) {
                this._tabOrder = PdfFormFieldsTabOrder.widget;
            }
        }
        if (this._tabOrder === null || typeof this._tabOrder === 'undefined') {
            this._tabOrder = PdfFormFieldsTabOrder.none;
        }
        return this._tabOrder;
    }
    _removeAnnotation(reference) {
        if (this._pageDictionary.has('Annots')) {
            const annots = this._getProperty('Annots');
            if (annots && Array.isArray(annots)) {
                const index = annots.indexOf(reference);
                if (index >= 0) {
                    annots.splice(index, 1);
                }
                this._pageDictionary.set('Annots', annots);
                this._pageDictionary._updated = true;
            }
        }
    }
}
/**
 * `PdfDestination` class represents the PDF destination.
 * ```typescript
 * // Load an existing PDF document
 * let document: PdfDocument = new PdfDocument(data, password);
 * // Access the annotation at index 0
 * let annotation: PdfDocumentLinkAnnotation = document.getPage(0).annotations.at(0) as PdfDocumentLinkAnnotation;
 * // Initializes a new instance of the `PdfDestination` class.
 * let destination: PdfDestination = new PdfDestination();
 * // Sets the zoom factor.
 * destination.zoom = 20;
 * // Sets the page where the destination is situated.
 * destination.page = page;
 * // Sets the mode of the destination.
 * destination.mode = PdfDestinationMode.fitToPage;
 * // Sets the location of the destination.
 * destination.location = [20, 20];
 * // Sets the bounds of the destination.
 * destination.destinationBounds = [20, 20, 100, 50];
 * // Sets destination to  document link annotation.
 * annotation.destination = destination;
 * // Save the document
 * document.save('output.pdf');
 * // Destroy the document
 * document.destroy();
 * ```
 */
class PdfDestination {
    constructor(page, location) {
        this._location = [0, 0];
        this._destinationMode = PdfDestinationMode.location;
        this._zoom = 0;
        this._isValid = true;
        this._index = 0;
        this._destinationBounds = [0, 0, 0, 0];
        this._array = Array(); // eslint-disable-line
        if (typeof page !== 'undefined' && page !== null) {
            if (page.rotation === PdfRotationAngle.angle180) {
                this._location = [page.graphics._size[0], this._location[1]];
            }
            else if (page.rotation === PdfRotationAngle.angle90) {
                this._location = [0, 0];
            }
            else if (page.rotation === PdfRotationAngle.angle270) {
                this._location = [page.graphics._size[0], 0];
            }
            else {
                this._location = [0, this._location[1]];
            }
            this._page = page;
            this._index = page._pageIndex;
        }
        if (typeof location !== 'undefined' && location.length === 2) {
            this._location = location;
        }
        if (typeof location !== 'undefined' && location.length === 4) {
            this._location = [location[0], location[1]];
            this._destinationBounds = location;
        }
    }
    /**
     * Gets the zoom factor.
     *
     * @returns {number} zoom.
     * ```typescript
     * // Load an existing PDF document
     * let document: PdfDocument = new PdfDocument(data, password);
     * //Access the annotation at index 0
     * let annot: PdfDocumentLinkAnnotation = page.annotations.at(0) as PdfDocumentLinkAnnotation;
     * // Gets the zoom factor of the destination.
     * let zoom: number = annot.destination.zoom;
     * // Save the document
     * document.save('output.pdf');
     * // Destroy the document
     * document.destroy();
     * ```
     */
    get zoom() {
        return this._zoom;
    }
    /**
     * Sets the zoom factor.
     *
     * @param {number} value zoom.
     * ```typescript
     * // Load an existing PDF document
     * let document: PdfDocument = new PdfDocument(data, password);
     * // Access the annotation at index 0
     * let annotation: PdfDocumentLinkAnnotation = document.getPage(0).annotations.at(0) as PdfDocumentLinkAnnotation;
     * // Initializes a new instance of the `PdfDestination` class.
     * let destination: PdfDestination = new PdfDestination();
     * // Sets the zoom factor.
     * destination.zoom = 20;
     * // Sets the page where the destination is situated.
     * destination.page = page;
     * // Sets the mode of the destination.
     * destination.mode = PdfDestinationMode.fitToPage;
     * // Sets the location of the destination.
     * destination.location = [20, 20];
     * // Sets the bounds of the destination.
     * destination.destinationBounds = [20, 20, 100, 50];
     * // Sets destination to  document link annotation.
     * annotation.destination = destination;
     * // Save the document
     * document.save('output.pdf');
     * // Destroy the document
     * document.destroy();
     * ```
     */
    set zoom(value) {
        if (value !== this._zoom) {
            this._zoom = value;
            this._initializePrimitive();
        }
    }
    /**
     * Gets the page where the destination is situated.
     *
     * @returns {PdfPage} page.
     * ```typescript
     * // Load an existing PDF document
     * let document: PdfDocument = new PdfDocument(data, password);
     * //Access the annotation at index 0
     * let annot: PdfDocumentLinkAnnotation = document.getPage(0).annotations.at(0) as PdfDocumentLinkAnnotation;
     * // Gets the page of the destination.
     * let page: PdfPage = annot.destination.page;
     * // Save the document
     * document.save('output.pdf');
     * // Destroy the document
     * document.destroy();
     * ```
     */
    get page() {
        return this._page;
    }
    /**
     * Sets the page where the destination is situated.
     *
     * @param {PdfPage} value page.
     * ```typescript
     * // Load an existing PDF document
     * let document: PdfDocument = new PdfDocument(data, password);
     * // Access the annotation at index 0
     * let annotation: PdfDocumentLinkAnnotation = document.getPage(0).annotations.at(0) as PdfDocumentLinkAnnotation;
     * // Initializes a new instance of the `PdfDestination` class.
     * let destination: PdfDestination = new PdfDestination();
     * // Sets the zoom factor.
     * destination.zoom = 20;
     * // Sets the page where the destination is situated.
     * destination.page = page;
     * // Sets the mode of the destination.
     * destination.mode = PdfDestinationMode.fitToPage;
     * // Sets the location of the destination.
     * destination.location = [20, 20];
     * // Sets the bounds of the destination.
     * destination.destinationBounds = [20, 20, 100, 50];
     * // Sets destination to  document link annotation.
     * annotation.destination = destination;
     * // Save the document
     * document.save('output.pdf');
     * // Destroy the document
     * document.destroy();
     * ```
     */
    set page(value) {
        if (value !== this._page) {
            this._page = value;
            this._initializePrimitive();
            this._index = value._pageIndex;
        }
    }
    /**
     * Gets the page index of bookmark destination (Read only).
     *
     * @returns {number} index.
     * ```typescript
     * // Load an existing PDF document
     * let document: PdfDocument = new PdfDocument(data, password);
     * //Access the annotation at index 0
     * let annot: PdfDocumentLinkAnnotation = document.getPage(0).annotations.at(0) as PdfDocumentLinkAnnotation;
     * // Gets the page index of the destination.
     * let pageIndex: number = annot.destination.pageIndex;
     * // Save the document
     * document.save('output.pdf');
     * // Destroy the document
     * document.destroy();
     * ```
     */
    get pageIndex() {
        return this._index;
    }
    /**
     * Gets the mode of the destination.
     *
     * @returns {PdfDestinationMode} page.
     * ```typescript
     * // Load an existing PDF document
     * let document: PdfDocument = new PdfDocument(data, password);
     * //Access the annotation at index 0
     * let annot: PdfDocumentLinkAnnotation = document.getPage(0).annotations.at(0) as PdfDocumentLinkAnnotation;
     * // Gets the mode of the destination.
     * let mode: PdfDestinationMode = annot.destination.mode;
     * // Save the document
     * document.save('output.pdf');
     * // Destroy the document
     * document.destroy();
     * ```
     */
    get mode() {
        return this._destinationMode;
    }
    /**
     * Sets the mode of the destination.
     *
     * @param {PdfDestinationMode} value page.
     * ```typescript
     * // Load an existing PDF document
     * let document: PdfDocument = new PdfDocument(data, password);
     * // Access the annotation at index 0
     * let annotation: PdfDocumentLinkAnnotation = document.getPage(0).annotations.at(0) as PdfDocumentLinkAnnotation;
     * // Initializes a new instance of the `PdfDestination` class.
     * let destination: PdfDestination = new PdfDestination();
     * // Sets the zoom factor.
     * destination.zoom = 20;
     * // Sets the page where the destination is situated.
     * destination.page = page;
     * // Sets the mode of the destination.
     * destination.mode = PdfDestinationMode.fitToPage;
     * // Sets the location of the destination.
     * destination.location = [20, 20];
     * // Sets the bounds of the destination.
     * destination.destinationBounds = [20, 20, 100, 50];
     * // Sets destination to document link annotation.
     * annotation.destination = destination;
     * // Save the document
     * document.save('output.pdf');
     * // Destroy the document
     * document.destroy();
     * ```
     */
    set mode(value) {
        if (value !== this._destinationMode) {
            this._destinationMode = value;
            this._initializePrimitive();
        }
    }
    /**
     * Gets the location of the destination.
     *
     * @returns {number[]} page.
     * ```typescript
     * // Load an existing PDF document
     * let document: PdfDocument = new PdfDocument(data, password);
     * // Access the annotation at index 0
     * let annot: PdfDocumentLinkAnnotation = document.getPage(0).annotations.at(0) as PdfDocumentLinkAnnotation;
     * // Gets the location of the destination.
     * let location: number[] = annot.destination.location;
     * // Save the document
     * document.save('output.pdf');
     * // Destroy the document
     * document.destroy();
     * ```
     */
    get location() {
        return this._location;
    }
    /**
     * Sets the location of the destination.
     *
     * @param {number[]} value page.
     * ```typescript
     * // Load an existing PDF document
     * let document: PdfDocument = new PdfDocument(data, password);
     * // Access the annotation at index 0
     * let annotation: PdfDocumentLinkAnnotation = document.getPage(0).annotations.at(0) as PdfDocumentLinkAnnotation;
     * // Initializes a new instance of the `PdfDestination` class.
     * let destination: PdfDestination = new PdfDestination();
     * // Sets the zoom factor.
     * destination.zoom = 20;
     * // Sets the page where the destination is situated.
     * destination.page = page;
     * // Sets the mode of the destination.
     * destination.mode = PdfDestinationMode.fitToPage;
     * // Sets the location of the destination.
     * destination.location = [20, 20];
     * // Sets the bounds of the destination.
     * destination.destinationBounds = [20, 20, 100, 50];
     * // Sets destination to  document link annotation.
     * annotation.destination = destination;
     * // Save the document
     * document.save('output.pdf');
     * // Destroy the document
     * document.destroy();
     * ```
     */
    set location(value) {
        if (value !== this._location) {
            this._location = value;
            this._initializePrimitive();
        }
    }
    /**
     * Gets the bounds of the destination.
     *
     * @returns {number[]} bounds.
     * ```typescript
     * // Load an existing PDF document
     * let document: PdfDocument = new PdfDocument(data, password);
     * // Access the annotation at index 0
     * let annot: PdfDocumentLinkAnnotation = document.getPage(0).annotations.at(0) as PdfDocumentLinkAnnotation;
     * // Gets the bounds of the destination.
     * let destinationBounds: number[] = annot.destination.destinationBounds;
     * // Save the document
     * document.save('output.pdf');
     * // Destroy the document
     * document.destroy();
     * ```
     */
    get destinationBounds() {
        return this._destinationBounds;
    }
    /**
     * Sets the bounds of the destination.
     *
     * @param {number[]} value bounds.
     * ```typescript
     * // Load an existing PDF document
     * let document: PdfDocument = new PdfDocument(data, password);
     * // Access the annotation at index 0
     * let annotation: PdfDocumentLinkAnnotation = document.getPage(0).annotations.at(0) as PdfDocumentLinkAnnotation;
     * // Initializes a new instance of the `PdfDestination` class.
     * let destination: PdfDestination = new PdfDestination();
     * // Sets the zoom factor.
     * destination.zoom = 20;
     * // Sets the page where the destination is situated.
     * destination.page = page;
     * // Sets the mode of the destination.
     * destination.mode = PdfDestinationMode.fitToPage;
     * // Sets the location of the destination.
     * destination.location = [20, 20];
     * // Sets the bounds of the destination.
     * destination.destinationBounds = [20, 20, 100, 50];
     * // Sets destination to  document link annotation.
     * annotation.destination = destination;
     * // Save the document
     * document.save('output.pdf');
     * // Destroy the document
     * document.destroy();
     * ```
     */
    set destinationBounds(value) {
        if (value !== this._destinationBounds) {
            this._destinationBounds = value;
            this._initializePrimitive();
        }
    }
    /**
     * Gets a value indicating whether this instance is valid (Read only).
     *
     * @returns {boolean} value indicating whether this instance is valid.
     * ```typescript
     * // Load an existing PDF document
     * let document: PdfDocument = new PdfDocument(data, password);
     * // Access the annotation at index 0
     * let annot: PdfDocumentLinkAnnotation = document.getPage(0).annotations.at(0) as PdfDocumentLinkAnnotation;
     * // Gets a value indicating whether this instance is valid.
     * let isValid: boolean = annot.destination.isValid;
     * // Save the document
     * document.save('output.pdf');
     * // Destroy the document
     * document.destroy();
     * ```
     */
    get isValid() {
        return this._isValid;
    }
    _setValidation(value) {
        this._isValid = value;
    }
    _initializePrimitive() {
        this._array = [];
        const page = this._page;
        const element = this._page._pageDictionary;
        if (typeof element !== 'undefined' && element !== null) {
            this._array.push(this._page._ref);
        }
        switch (this._destinationMode) {
            case PdfDestinationMode.location:
                this._array.push(_PdfName.get('XYZ'));
                if (typeof page !== 'undefined' && page !== null) {
                    this._array.push(this._location[0]);
                    this._array.push(this._page.graphics._size[1] - this._location[1]);
                }
                else {
                    this._array.push(0);
                    this._array.push(0);
                }
                this._array.push(this._zoom);
                break;
            case PdfDestinationMode.fitToPage:
                this._array.push(_PdfName.get('Fit'));
                break;
            case PdfDestinationMode.fitR:
                this._array.push(_PdfName.get('FitR'));
                this._array.push(this._destinationBounds[0]);
                this._array.push(this._destinationBounds[1]);
                this._array.push(this._destinationBounds[2]);
                this._array.push(this._destinationBounds[3]);
                break;
            case PdfDestinationMode.fitH:
                this._array.push(_PdfName.get('FitH'));
                this._array.push((typeof page !== 'undefined' && page !== null) ? page._size[1] - this._location[1] : 0);
                break;
        }
        if (this._parent) {
            this._parent._dictionary.set('D', this._array);
            this._parent._dictionary._updated = true;
        }
    }
}

class _PdfStreamWriter {
    constructor(stream) {
        this._newLine = '\r\n';
        this._whiteSpace = ' ';
        this._stream = stream;
    }
    _writeOperator(value) {
        this._stream.write(value);
        this._stream.write(this._newLine);
    }
    _saveGraphicsState() {
        this._writeOperator('q');
    }
    _restoreGraphicsState() {
        this._writeOperator('Q');
    }
    _writeComment(comment) {
        if (comment && comment.length > 0) {
            this._writeOperator('% ' + comment);
        }
    }
    _setGraphicsState(value) {
        this._stream.write(`/${_escapePdfName(value.name)} `);
        this._writeOperator('gs');
    }
    _modifyCtm(matrix) {
        this._stream.write(`${matrix._toString()} `);
        this._writeOperator('cm');
    }
    _modifyTM(matrix) {
        this._stream.write(`${matrix._toString()} `);
        this._writeOperator('Tm');
    }
    _setColorSpace(value, forStroking) {
        this._stream.write(`/${value} `);
        this._writeOperator(forStroking ? 'CS' : 'cs');
    }
    _setColor(color, forStroking) {
        this._stream.write(`${(color[0] / 255).toFixed(3)} ${(color[1] / 255).toFixed(3)} ${(color[2] / 255).toFixed(3)} `);
        this._writeOperator(forStroking ? 'RG' : 'rg');
    }
    _appendRectangle(x, y, width, height) {
        this._writePoint(x, y);
        this._writePoint(width, height);
        this._writeOperator('re');
    }
    _writePoint(x, y) {
        this._stream.write(`${x.toFixed(3)} ${(-y).toFixed(3)} `);
    }
    _clipPath(isEvenOdd) {
        this._stream.write(`${isEvenOdd ? 'W*' : 'W'} n${this._newLine}`);
    }
    _fillPath(isEvenOdd) {
        this._writeOperator(isEvenOdd ? 'f*' : 'f');
    }
    _closeFillPath(isEvenOdd) {
        this._writeOperator('h');
        this._fillPath(isEvenOdd);
    }
    _strokePath() {
        this._writeOperator('S');
    }
    _closeStrokePath() {
        this._writeOperator('s');
    }
    _fillStrokePath(isEvenOdd) {
        this._writeOperator(isEvenOdd ? 'B*' : 'B');
    }
    _closeFillStrokePath(isEvenOdd) {
        this._writeOperator(isEvenOdd ? 'b*' : 'b');
    }
    _endPath() {
        this._writeOperator('n');
    }
    _setFont(name, size) {
        this._stream.write(`/${name} ${size.toFixed(3)} `);
        this._writeOperator('Tf');
    }
    _setTextScaling(textScaling) {
        this._stream.write(`${textScaling.toFixed(3)} `);
        this._writeOperator('Tz');
    }
    _closePath() {
        this._writeOperator('h');
    }
    _startNextLine(x, y) {
        if (typeof x === 'undefined') {
            this._writeOperator('T*');
        }
        else {
            this._writePoint(x, y);
            this._writeOperator('Td');
        }
    }
    _showText(text) {
        this._writeText(text);
        this._writeOperator('Tj');
    }
    _write(string) {
        let builder = '';
        builder += string;
        builder += '\r\n';
        this._writeOperator(builder);
    }
    _writeText(text) {
        let result = '';
        const data = this._escapeSymbols(text);
        for (let i = 0; i < data.length; i++) {
            result += String.fromCharCode(data[i]); // eslint-disable-line
        }
        result = '(' + result + ')';
        this._stream.write(result);
    }
    _beginText() {
        this._writeOperator('BT');
    }
    _endText() {
        this._writeOperator('ET');
    }
    _beginPath(x, y) {
        this._writePoint(x, y);
        this._writeOperator('m');
    }
    _appendLineSegment(x, y) {
        this._writePoint(x, y);
        this._writeOperator('l');
    }
    _appendBezierSegment(x1, y1, x2, y2, x3, y3) {
        this._writePoint(x1, y1);
        this._writePoint(x2, y2);
        this._writePoint(x3, y3);
        this._writeOperator('c');
    }
    _setTextRenderingMode(renderingMode) {
        this._stream.write(`${renderingMode.toString()} `);
        this._writeOperator('Tr');
    }
    _setCharacterSpacing(charSpacing) {
        this._stream.write(`${charSpacing.toFixed(3)} `);
        this._writeOperator('Tc');
    }
    _setWordSpacing(wordSpacing) {
        this._stream.write(`${wordSpacing.toFixed(3)} `);
        this._writeOperator('Tw');
    }
    _showNextLineText(text, unicode) {
        if (unicode !== null && typeof unicode !== 'undefined' && unicode) {
            this._writeText(text);
            this._writeOperator('\'');
        }
        else {
            this._stream.write(text);
            this._writeOperator('\'');
        }
    }
    _setLineDashPattern(pattern, patternOffset) {
        let tempPattern = '[';
        if (pattern.length > 1) {
            for (let index = 0; index < pattern.length; index++) {
                if (index === pattern.length - 1) {
                    tempPattern += pattern[index].toString(); // eslint-disable-line
                }
                else {
                    tempPattern += pattern[index].toString() + ' '; // eslint-disable-line
                }
            }
        }
        tempPattern += '] ';
        tempPattern += patternOffset.toString();
        tempPattern += ' d';
        this._writeOperator(tempPattern);
    }
    _setMiterLimit(miterLimit) {
        this._stream.write(`${miterLimit.toFixed(3)} `);
        this._writeOperator('M');
    }
    _setLineWidth(width) {
        this._stream.write(`${width.toFixed(3)} `);
        this._writeOperator('w');
    }
    _setLineCap(lineCapStyle) {
        this._stream.write(`${lineCapStyle} `);
        this._writeOperator('J');
    }
    _setLineJoin(lineJoinStyle) {
        this._stream.write(`${lineJoinStyle} `);
        this._writeOperator('j');
    }
    _executeObject(name) {
        this._stream.write(`/${name.name} `);
        this._writeOperator('Do');
    }
    _beginMarkupSequence(name) {
        this._stream.write(`/${name} `);
        this._writeOperator('BMC');
    }
    _endMarkupSequence() {
        this._writeOperator('EMC');
    }
    _clear() {
        this._stream._bytes = [];
    }
    _escapeSymbols(value) {
        const data = [];
        for (let i = 0; i < value.length; i++) {
            const currentData = value.charCodeAt(i);
            switch (currentData) {
                case 40:
                case 41:
                    data.push(92);
                    data.push(currentData);
                    break;
                case 13:
                    data.push(92);
                    data.push(114);
                    break;
                case 92:
                    data.push(92);
                    data.push(currentData);
                    break;
                default:
                    data.push(currentData);
                    break;
            }
        }
        return data;
    }
}

/**
 * The 'PdfImage' contains methods and properties to handle the images.
 * ```typescript
 * // Load an existing PDF document
 * let document: PdfDocument = new PdfDocument(data, password);
 * // Access first page
 * let page: PdfPage = document.getPage(0);
 * // Gets the graphics of the PDF page
 * let graphics: PdfGraphics = page.graphics;
 * // Create new image object by using JPEG image data as Base64 string format
 * let image: PdfImage = new PdfBitmap('/9j/4AAQSkZJRgABAQEAkACQAAD/4....QB//Z');
 * //Draw the image.
 * graphics.drawImage(image, 10, 20, 400, 400);
 * // Save the document
 * document.save('output.pdf');
 * // Destroy the document
 * document.destroy();
 * ```
 */
class PdfImage {
    /**
     * Gets the width of the PDF image.
     *
     * @returns {number} image width.
     * ```typescript
     * // Load an existing PDF document
     * let document: PdfDocument = new PdfDocument(data, password);
     * // Access first page
     * let page: PdfPage = document.getPage(0);
     * // Gets the graphics of the PDF page
     * let graphics: PdfGraphics = page.graphics;
     * // Create new image object by using JPEG image data as Base64 string format
     * let image: PdfImage = new PdfBitmap('/9j/4AAQSkZJRgABAQEAkACQAAD/4....QB//Z');
     * // Gets the width of the image.
     * let width: number = image.width;
     * //Draw the image.
     * image.draw(graphics);
     * // Save the document
     * document.save('output.pdf');
     * // Destroy the document
     * document.destroy();
     * ```
     */
    get width() {
        return this._imageWidth;
    }
    /**
     * Sets the width of the PDF image.
     *
     * @param {number} value value.
     * ```typescript
     * // Load an existing PDF document
     * let document: PdfDocument = new PdfDocument(data, password);
     * // Access first page
     * let page: PdfPage = document.getPage(0);
     * // Gets the graphics of the PDF page
     * let graphics: PdfGraphics = page.graphics;
     * // Create new image object by using JPEG image data as Base64 string format
     * let image: PdfImage = new PdfBitmap('/9j/4AAQSkZJRgABAQEAkACQAAD/4....QB//Z');
     * // Sets the width of the image.
     * image.width = 100;
     * //Draw the image.
     * image.draw(graphics);
     * // Save the document
     * document.save('output.pdf');
     * // Destroy the document
     * document.destroy();
     * ```
     */
    set width(value) {
        this._imageWidth = value;
    }
    /**
     * Gets the height of the PDF image.
     *
     * @returns {number} image height.
     * ```typescript
     * // Load an existing PDF document
     * let document: PdfDocument = new PdfDocument(data, password);
     * // Access first page
     * let page: PdfPage = document.getPage(0);
     * // Gets the graphics of the PDF page
     * let graphics: PdfGraphics = page.graphics;
     * // Create new image object by using JPEG image data as Base64 string format
     * let image: PdfImage = new PdfBitmap('/9j/4AAQSkZJRgABAQEAkACQAAD/4....QB//Z');
     * // Gets the height of the image.
     * let height: number = image.height;
     * //Draw the image.
     * image.draw(graphics);
     * // Save the document
     * document.save('output.pdf');
     * // Destroy the document
     * document.destroy();
     * ```
     */
    get height() {
        return this._imageHeight;
    }
    /**
     * Sets the height of the PDF image.
     *
     * @param {number} value value.
     * ```typescript
     * // Load an existing PDF document
     * let document: PdfDocument = new PdfDocument(data, password);
     * // Access first page
     * let page: PdfPage = document.getPage(0);
     * // Gets the graphics of the PDF page
     * let graphics: PdfGraphics = page.graphics;
     * // Create new image object by using JPEG image data as Base64 string format
     * let image: PdfImage = new PdfBitmap('/9j/4AAQSkZJRgABAQEAkACQAAD/4....QB//Z');
     * // Sets the height of the image.
     * image.height = 100;
     * //Draw the image.
     * image.draw(graphics);
     * // Save the document
     * document.save('output.pdf');
     * // Destroy the document
     * document.destroy();
     * ```
     */
    set height(value) {
        this._imageHeight = value;
    }
    /**
     * Gets the physical dimension of the PDF image (Read only).
     *
     * @returns {number[]} image physical dimension.
     * ```typescript
     * // Load an existing PDF document
     * let document: PdfDocument = new PdfDocument(data, password);
     * // Access first page
     * let page: PdfPage = document.getPage(0);
     * // Gets the graphics of the PDF page
     * let graphics: PdfGraphics = page.graphics;
     * // Create new image object by using JPEG image data as Base64 string format
     * let image: PdfImage = new PdfBitmap('/9j/4AAQSkZJRgABAQEAkACQAAD/4....QB//Z');
     * // Gets the physical dimension of the image.
     * let dimension: number[] = image.physicalDimension;
     * //Draw the image.
     * image.draw(graphics);
     * // Save the document
     * document.save('output.pdf');
     * // Destroy the document
     * document.destroy();
     * ```
     */
    get physicalDimension() {
        this._imagePhysicalDimension = this._getPointSize(this.width, this.height, this._horizontalResolution);
        return [this.width, this.height];
    }
    draw(graphics, x, y) {
        if ((x === null || typeof x === 'undefined') && (y === null || typeof y === 'undefined')) {
            x = 0;
            y = 0;
        }
        const needSave = (x !== 0 || y !== 0);
        let state = null;
        if (needSave) {
            state = graphics.save();
            graphics.translateTransform(x, y);
        }
        graphics.drawImage(this, 0, 0);
        if (needSave) {
            graphics.restore(state);
        }
    }
    _getPointSize(width, height, horizontalResolution) {
        if ((horizontalResolution === null || typeof horizontalResolution === 'undefined')) {
            const dpiX = 96;
            const size = this._getPointSize(width, height, dpiX);
            return size;
        }
        else {
            const ucX = new _PdfUnitConvertor();
            const ucY = new _PdfUnitConvertor();
            const ptWidth = ucX._convertUnits(width, _PdfGraphicsUnit.pixel, _PdfGraphicsUnit.point);
            const ptHeight = ucY._convertUnits(height, _PdfGraphicsUnit.pixel, _PdfGraphicsUnit.point);
            const size = [ptWidth, ptHeight];
            return size;
        }
    }
}

/**
 * Represents a graphics from a PDF page.
 * ```typescript
 * // Load an existing PDF document
 * let document: PdfDocument = new PdfDocument(data, password);
 * // Access first page
 * let page: PdfPage = document.getPage(0);
 * // Gets the graphics of the PDF page
 * let graphics: PdfGraphics = page.graphics;
 * //Create a new pen.
 * let pen: PdfPen = new PdfPen([0, 0, 0], 1);
 * //Draw line on the page graphics.
 * graphics.drawLine(pen, 10, 10, 100, 100);
 * // Save the document
 * document.save('output.pdf');
 * // Destroy the document
 * document.destroy();
 * ```
 */
class PdfGraphics {
    constructor(size, content, xref, source) {
        this._pendingResource = []; // eslint-disable-line
        this._hasResourceReference = false;
        if (source instanceof PdfPage) {
            this._source = source._pageDictionary;
            this._page = source;
        }
        else if (source instanceof PdfTemplate) {
            this._source = source._content.dictionary;
            this._template = source;
        }
        if (this._source && this._source.has('Resources')) {
            const obj = this._source.getRaw('Resources'); // eslint-disable-line
            if (obj instanceof _PdfReference) {
                this._hasResourceReference = true;
                this._resourceObject = xref._fetch(obj);
            }
            else if (obj instanceof _PdfDictionary) {
                this._resourceObject = obj;
            }
        }
        else {
            this._resourceObject = new _PdfDictionary();
            this._source.update('Resources', this._resourceObject);
        }
        this._crossReference = xref;
        this._sw = new _PdfStreamWriter(content);
        this._size = size;
        _addProcSet('PDF', this._resourceObject);
        this._initialize();
    }
    get _matrix() {
        if (typeof this._m === 'undefined') {
            this._m = new _PdfTransformationMatrix();
        }
        return this._m;
    }
    get _resources() {
        if (typeof this._resourceMap === 'undefined') {
            this._resourceMap = new Map();
            if (this._resourceObject.has('Font')) {
                const fonts = this._resourceObject.get('Font');
                if (fonts && fonts.size > 0) {
                    fonts.forEach((key, value) => {
                        if (value !== null && typeof value !== 'undefined' && value instanceof _PdfReference) {
                            this._resourceMap.set(value, _PdfName.get(key));
                        }
                    });
                }
            }
            if (this._resourceObject.has('XObject')) {
                const other = this._resourceObject.get('XObject');
                if (other && other.size > 0) {
                    other.forEach((key, value) => {
                        if (value !== null && typeof value !== 'undefined' && value instanceof _PdfReference) {
                            this._resourceMap.set(value, _PdfName.get(key));
                        }
                    });
                }
            }
            if (this._resourceObject.has('ExtGState')) {
                const state = this._resourceObject.get('ExtGState');
                if (state && state.size > 0) {
                    if (!this._transparencies) {
                        this._transparencies = new Map();
                    }
                    state.forEach((key, value) => {
                        if (value !== null && typeof value !== 'undefined' && value instanceof _PdfReference) {
                            this._setTransparencyData(value, _PdfName.get(key));
                        }
                    });
                }
            }
        }
        return this._resourceMap;
    }
    /**
     * Save the current graphics state.
     *
     * @returns {PdfGraphicsState} graphics state.
     * ```typescript
     * // Load an existing PDF document
     * let document: PdfDocument = new PdfDocument(data, password);
     * // Access first page
     * let page: PdfPage = document.getPage(0);
     * // Gets the graphics of the PDF page
     * let graphics: PdfGraphics = page.graphics;
     * // Create a new font
     * let font: PdfFont = new PdfStandardFont(PdfFontFamily.Helvetica, 20);
     * // Save the graphics
     * let state: PdfGraphicsState = graphics.save();
     * //Set graphics translate transform.
     * graphics.translateTransform(100, 100);
     * //Draws the String.
     * graphics.drawString("Hello world!", font, [10, 20, 100, 200], undefined, new PdfBrush([0, 0, 255]));
     * //Restore the graphics.
     * graphics.restore(state);
     * // Save the document
     * document.save('output.pdf');
     * // Destroy the document
     * document.destroy();
     * ```
     */
    save() {
        const state = new PdfGraphicsState(this, this._matrix);
        state._textRenderingMode = this._textRenderingMode;
        state._charSpacing = this._characterSpacing;
        state._textScaling = this._textScaling;
        state._wordSpacing = this._wordSpacing;
        state._currentBrush = this._currentBrush;
        state._currentPen = this._currentPen;
        state._currentFont = this._currentFont;
        this._graphicsState.push(state);
        this._sw._saveGraphicsState();
        return state;
    }
    /**
     * Restore the graphics state.
     *
     * @param {PdfGraphicsState} state graphics state.
     * @returns {void} restore of the graphics state.
     * ```typescript
     * // Load an existing PDF document
     * let document: PdfDocument = new PdfDocument(data, password);
     * // Access first page
     * let page: PdfPage = document.getPage(0);
     * // Gets the graphics of the PDF page
     * let graphics: PdfGraphics = page.graphics;
     * // Create a new font
     * let font: PdfFont = new PdfStandardFont(PdfFontFamily.Helvetica, 20);
     * // Save the graphics
     * let state: PdfGraphicsState = graphics.save();
     * //Set graphics translate transform.
     * graphics.translateTransform(100, 100);
     * //Draws the String.
     * graphics.drawString("Hello world!", font, [10, 20, 100, 200], undefined, new PdfBrush([0, 0, 255]));
     * //Restore the graphics.
     * graphics.restore(state);
     * // Save the document
     * document.save('output.pdf');
     * // Destroy the document
     * document.destroy();
     * ```
     */
    restore(state) {
        if (this._graphicsState.length > 0) {
            if (typeof state === 'undefined') {
                this._doRestore();
            }
            else {
                if (this._graphicsState.length > 0 && this._graphicsState.indexOf(state) !== -1) {
                    while (this._graphicsState.length > 0) {
                        if (this._doRestore() === state) {
                            break;
                        }
                    }
                }
            }
        }
    }
    _doRestore() {
        const state = this._graphicsState.pop();
        this._m = state._transformationMatrix;
        this._currentBrush = state._currentBrush;
        this._currentPen = state._currentPen;
        this._currentFont = state._currentFont;
        this._characterSpacing = state._charSpacing;
        this._wordSpacing = state._wordSpacing;
        this._textScaling = state._textScaling;
        this._textRenderingMode = state._textRenderingMode;
        this._sw._restoreGraphicsState();
        return state;
    }
    drawRectangle(x, y, width, height, first, second) {
        let pen;
        let brush;
        if (first instanceof PdfPen) {
            pen = first;
            if (second) {
                brush = second;
            }
        }
        else {
            brush = first;
        }
        this._stateControl(pen, brush);
        this._sw._appendRectangle(x, y, width, height);
        this._drawGraphicsPath(pen, brush);
    }
    drawPolygon(points, first, second) {
        if (points.length > 0) {
            let pen;
            let brush;
            if (first instanceof PdfPen) {
                pen = first;
                if (second) {
                    brush = second;
                }
            }
            else {
                brush = first;
            }
            this._stateControl(pen, brush);
            this._sw._beginPath(points[0][0], points[0][1]);
            for (let i = 1; i < points.length; i++) {
                this._sw._appendLineSegment(points[Number.parseInt(i.toString(), 10)][0], points[Number.parseInt(i.toString(), 10)][1]);
            }
            this._drawGraphicsPath(pen, brush, PdfFillMode.winding, true);
        }
    }
    drawEllipse(x, y, width, height, first, second) {
        let pen;
        let brush;
        if (first instanceof PdfPen) {
            pen = first;
            if (second) {
                brush = second;
            }
        }
        else {
            brush = first;
        }
        this._stateControl(pen, brush);
        this._constructArcPath(x, y, x + width, y + height, 0, 360);
        this._drawGraphicsPath(pen, brush, PdfFillMode.winding, true);
    }
    /**
     * Draw arc on the page graphics.
     *
     * @param {number} x value.
     * @param {number} y value.
     * @param {number} width value.
     * @param {number} height value.
     * @param {number} startAngle value.
     * @param {number} sweepAngle value.
     * @param {PdfPen} pen value.
     * @returns {void} draw a arc.
     * ```typescript
     * // Load an existing PDF document
     * let document: PdfDocument = new PdfDocument(data, password);
     * // Access first page
     * let page: PdfPage = document.getPage(0);
     * // Gets the graphics of the PDF page
     * let graphics: PdfGraphics = page.graphics;
     * //Create a new pen.
     * let pen: PdfPen = new PdfPen([0, 0, 0], 1);
     * //Draw arc on the page graphics.
     * graphics.drawArc(10, 20, 100, 200, 20, 30, pen);
     * // Save the document
     * document.save('output.pdf');
     * // Destroy the document
     * document.destroy();
     * ```
     */
    drawArc(x, y, width, height, startAngle, sweepAngle, pen) {
        if (sweepAngle !== 0) {
            this._stateControl(pen);
            this._constructArcPath(x, y, x + width, y + height, startAngle, sweepAngle);
            this._drawGraphicsPath(pen, null, PdfFillMode.winding, false);
        }
    }
    drawImage(arg1, arg2, arg3, arg4, arg5) {
        if (typeof arg2 === 'number' && typeof arg3 === 'number' && typeof arg4 === 'undefined') {
            const size = arg1.physicalDimension;
            this.drawImage(arg1, arg2, arg3, size[0], size[1]);
        }
        else {
            arg1._save();
            const matrix = new _PdfTransformationMatrix();
            this._getTranslateTransform(arg2, (arg3 + arg5), matrix);
            this._getScaleTransform(arg4, arg5, matrix);
            this._sw._write('q');
            this._sw._modifyCtm(matrix);
            let sourceDictionary;
            let keyName;
            let isNew = true;
            if (this._resourceObject.has('XObject')) {
                const obj = this._resourceObject.getRaw('XObject'); // eslint-disable-line
                if (obj instanceof _PdfDictionary) {
                    sourceDictionary = obj;
                }
                if (sourceDictionary) {
                    isNew = false;
                }
            }
            if (isNew) {
                sourceDictionary = new _PdfDictionary(this._crossReference);
                this._resourceObject.update('XObject', sourceDictionary);
            }
            if (typeof keyName === 'undefined') {
                keyName = _PdfName.get(_getNewGuidString());
            }
            if (this._crossReference) {
                this._updateImageResource(arg1, keyName, sourceDictionary, this._crossReference);
                this._source.update('Resources', this._resourceObject);
                this._source._updated = true;
            }
            else {
                this._pendingResource.push({ 'resource': arg1, 'key': keyName, 'source': sourceDictionary });
            }
            this._sw._executeObject(keyName);
            this._sw._write('Q');
            this._sw._write('\r\n');
            _addProcSet('ImageB', this._resourceObject);
            _addProcSet('ImageC', this._resourceObject);
            _addProcSet('ImageI', this._resourceObject);
            _addProcSet('Text', this._resourceObject);
        }
    }
    _processResources(crossReference) {
        if (this._pendingResource.length > 0) {
            for (let i = 0; i < this._pendingResource.length; i++) {
                const entry = this._pendingResource[Number.parseInt(i.toString(), 10)]; // eslint-disable-line
                if (entry.resource instanceof PdfImage) {
                    this._updateImageResource(entry.resource, entry.key, entry.source, crossReference);
                }
                this._source.update('Resources', this._resourceObject);
                this._source._updated = true;
            }
            this._pendingResource = [];
        }
    }
    _updateImageResource(image, keyName, source, crossReference) {
        let ref;
        if (image._reference) {
            ref = image._reference;
        }
        else {
            ref = crossReference._getNextReference();
            image._reference = ref;
        }
        if (!crossReference._cacheMap.has(ref)) {
            if (image && image._imageStream && image._imageStream.dictionary) {
                crossReference._cacheMap.set(ref, image._imageStream);
                image._imageStream.dictionary._updated = true;
            }
        }
        source.update(keyName.name, ref);
        this._resources.set(ref, keyName);
        this._resourceObject._updated = true;
    }
    _drawTemplate(template, bounds) {
        const scaleX = (template && template._size[0] > 0) ? bounds.width / template._size[0] : 1;
        const scaleY = (template && template._size[1] > 0) ? bounds.height / template._size[1] : 1;
        const needScale = !(scaleX === 1 && scaleY === 1);
        let cropBox;
        let mediaBox;
        if (this._page) {
            cropBox = this._page.cropBox;
            mediaBox = this._page.mediaBox;
            if (this._page._pageDictionary.has('CropBox') && this._page._pageDictionary.has('MediaBox')) {
                if (cropBox[0] > 0 && cropBox[1] > 0 && mediaBox[0] < 0 && mediaBox[1] < 0) {
                    this.translateTransform(cropBox[0], -cropBox[1]);
                    bounds.x = -cropBox[0];
                    bounds.y = cropBox[1];
                }
            }
        }
        const state = this.save();
        let matrix = new _PdfTransformationMatrix();
        if (this._page) {
            const needTransform = (this._page._pageDictionary.has('CropBox') &&
                this._page._pageDictionary.has('MediaBox') && cropBox && mediaBox &&
                cropBox[0] === mediaBox[0] && cropBox[1] === mediaBox[1] && cropBox[2] === mediaBox[2] && cropBox[3] === mediaBox[3]) ||
                (this._page._pageDictionary.has('MediaBox') && mediaBox && mediaBox[3] === 0);
            matrix._translate(bounds.x, -(bounds.y + ((this._page._origin[0] >= 0 || needTransform) ? bounds.height : 0)));
        }
        else {
            matrix._translate(bounds.x, -(bounds.y + bounds.height));
        }
        if (needScale) {
            if (template._isAnnotationTemplate && template._needScale) {
                let scaleApplied = false;
                if (template._content && template._content.dictionary) {
                    const dictionary = template._content.dictionary;
                    if (dictionary.has('Matrix') && dictionary.has('BBox')) {
                        const templateMatrix = dictionary.getArray('Matrix');
                        const templateBox = dictionary.getArray('BBox');
                        if (templateMatrix && templateBox && templateMatrix.length > 5 && templateBox.length > 3) {
                            const templateScaleX = Number.parseFloat(_numberToString(-templateMatrix[1]));
                            const templateScaleY = Number.parseFloat(_numberToString(templateMatrix[2]));
                            const roundScaleX = Number.parseFloat(_numberToString(scaleX));
                            const roundScaleY = Number.parseFloat(_numberToString(scaleY));
                            if (roundScaleX === templateScaleX &&
                                roundScaleY === templateScaleY &&
                                templateBox[2] === template._size[0] &&
                                templateBox[3] === template._size[1]) {
                                matrix = new _PdfTransformationMatrix();
                                matrix._translate(bounds.x - templateMatrix[4], bounds.y + templateMatrix[5]);
                                matrix._scale(1, 1);
                                scaleApplied = true;
                            }
                        }
                    }
                }
                if (!scaleApplied) {
                    matrix._scale(scaleX, scaleY);
                }
            }
            else {
                matrix._scale(scaleX, scaleY);
            }
        }
        this._sw._modifyCtm(matrix);
        let sourceDictionary;
        let isReference = false;
        let keyName;
        let isNew = true;
        let ref;
        if (this._resourceObject.has('XObject')) {
            const obj = this._resourceObject.getRaw('XObject'); // eslint-disable-line
            if (obj instanceof _PdfReference) {
                isReference = true;
                sourceDictionary = this._crossReference._fetch(obj);
            }
            else if (obj instanceof _PdfDictionary) {
                sourceDictionary = obj;
            }
            if (sourceDictionary) {
                isNew = false;
                this._resources.forEach((value, key) => {
                    if (key && key instanceof _PdfReference) {
                        const base = this._crossReference._fetch(key);
                        if (base && template && base === template._content) {
                            keyName = value;
                            ref = key;
                        }
                    }
                });
            }
        }
        if (isNew) {
            sourceDictionary = new _PdfDictionary(this._crossReference);
            this._resourceObject.update('XObject', sourceDictionary);
        }
        if (typeof keyName === 'undefined') {
            keyName = _PdfName.get(_getNewGuidString());
            if (template && template._content.reference) {
                ref = template._content.reference;
            }
            else {
                ref = this._crossReference._getNextReference();
            }
            if (!this._crossReference._cacheMap.has(ref)) {
                if (template && template._content) {
                    this._crossReference._cacheMap.set(ref, template._content);
                }
            }
            sourceDictionary.update(keyName.name, ref);
            this._resources.set(ref, keyName);
            this._resourceObject._updated = true;
        }
        if (isReference) {
            this._resourceObject._updated = true;
        }
        if (this._hasResourceReference) {
            this._source._updated = true;
        }
        this._sw._executeObject(keyName);
        this.restore(state);
        _addProcSet('ImageB', this._resourceObject);
        _addProcSet('ImageC', this._resourceObject);
        _addProcSet('ImageI', this._resourceObject);
        _addProcSet('Text', this._resourceObject);
    }
    _drawPath(path, pen, brush) {
        if (pen || brush) {
            this._stateControl(pen, brush, null);
            this._buildUpPath(path._points, path._pathTypes);
            this._drawGraphicsPath(pen, brush, path._fillMode, false);
        }
    }
    /**
     * Draw rounded rectangle on the page graphics.
     *
     * @param {number} x value.
     * @param {number} y value.
     * @param {number} width value.
     * @param {number} height value.
     * @param {number} radius value.
     * @param {PdfPen} pen value.
     * @param {PdfBrush} brush value.
     * @returns {void} draw a rounded rectangle.
     * ```typescript
     * // Load an existing PDF document
     * let document: PdfDocument = new PdfDocument(data, password);
     * // Access first page
     * let page: PdfPage = document.getPage(0);
     * // Gets the graphics of the PDF page
     * let graphics: PdfGraphics = page.graphics;
     * //Create a new pen.
     * let pen: PdfPen = new PdfPen([0, 0, 0], 1);
     * //Create a new brush.
     * let brush: PdfBrush = new PdfBrush([0, 0, 255]);
     * //Draw rounded rectangle on the page graphics.
     * graphics.drawRoundedRectangle(10, 20, 100, 200, 5, pen, brush);
     * // Save the document
     * document.save('output.pdf');
     * // Destroy the document
     * document.destroy();
     * ```
     */
    drawRoundedRectangle(x, y, width, height, radius, pen, brush) {
        if (pen === null) {
            throw new Error('pen');
        }
        if (brush === null) {
            throw new Error('brush');
        }
        const bounds = [x, y, width, height];
        const diameter = radius * 2;
        const size = [diameter, diameter];
        const arc = [bounds[0], bounds[1], size[0], size[1]];
        const path = new _PdfPath();
        if (radius === 0) {
            path._addRectangle(bounds[0], bounds[1], bounds[2], bounds[3]);
            this._drawPath(path, pen, brush);
        }
        else {
            path._isRoundedRectangle = true;
            path._addArc(arc[0], arc[1], arc[2], arc[3], 180, 90);
            arc[0] = (bounds[0] + bounds[2]) - diameter;
            path._addArc(arc[0], arc[1], arc[2], arc[3], 270, 90);
            arc[1] = (bounds[1] + bounds[3]) - diameter;
            path._addArc(arc[0], arc[1], arc[2], arc[3], 0, 90);
            arc[0] = bounds[0];
            path._addArc(arc[0], arc[1], arc[2], arc[3], 90, 90);
            path._closeFigure();
            this._drawPath(path, pen, brush);
        }
    }
    _constructArcPath(x1, y1, x2, y2, start, sweep) {
        const points = _getBezierArc(x1, y1, x2, y2, start, sweep);
        if (points.length === 8) {
            return;
        }
        let point = [points[0], points[1], points[2], points[3], points[4], points[5], points[6], points[7]];
        this._sw._beginPath(point[0], point[1]);
        for (let i = 0; i < points.length; i = i + 8) {
            point = [points[Number.parseInt(i.toString(), 10)],
                points[i + 1],
                points[i + 2],
                points[i + 3],
                points[i + 4],
                points[i + 5],
                points[i + 6],
                points[i + 7]];
            this._sw._appendBezierSegment(point[2], point[3], point[4], point[5], point[6], point[7]);
        }
    }
    _writePen(pen) {
        const lineWidth = pen._width;
        const pattern = pen._dashPattern;
        for (let i = 0; i < pattern.length; ++i) {
            pattern[i] *= pen._width; // eslint-disable-line
        }
        this._sw._setLineDashPattern(pattern, pen._dashOffset * lineWidth);
        this._sw._setLineWidth(pen._width);
        this._sw._setLineJoin(pen._lineJoin);
        this._sw._setLineCap(pen._lineCap);
        if (pen._miterLimit > 0) {
            this._sw._setMiterLimit(pen._miterLimit);
        }
        this._sw._setColor(pen._color, true);
    }
    /**
     * Draw text on the page graphics.
     *
     * @param {string} value draw string.
     * @param {PdfFont} font value.
     * @param {number[]} bounds value.
     * @param {PdfPen} pen value.
     * @param {PdfBrush} brush value.
     * @param {PdfStringFormat} format value.
     * @returns {void} draw a string.
     * ```typescript
     * // Load an existing PDF document
     * let document: PdfDocument = new PdfDocument(data, password);
     * // Access first page
     * let page: PdfPage = document.getPage(0);
     * // Gets the graphics of the PDF page
     * let graphics: PdfGraphics = page.graphics;
     * // Create a new pen.
     * let pen: PdfPen = new PdfPen([0, 0, 0], 1);
     * // Create a new font.
     * let font: PdfStandardFont = new PdfStandardFont(PdfFontFamily.symbol, 10);
     * // Create a new string format
     * let format: PdfStringFormat = new PdfStringFormat();
     * format.alignment = PdfTextAlignment.center;
     * // Draw text on the page graphics.
     * graphics.drawString('Hello World', font, [10, 20, 100, 200], pen, new PdfBrush([0, 0, 255]), format);
     * // Save the document
     * document.save('output.pdf');
     * // Destroy the document
     * document.destroy();
     * ```
     */
    drawString(value, font, bounds, pen, brush, format) {
        const layouter = new _PdfStringLayouter();
        const result = layouter._layout(value, font, format, [bounds[2], bounds[3]]);
        if (!result._empty) {
            const rect = this._checkCorrectLayoutRectangle(result._actualSize, bounds[0], bounds[1], format);
            if (bounds[2] <= 0) {
                bounds[0] = rect[0];
                bounds[2] = rect[2];
            }
            if (bounds[3] <= 0) {
                bounds[1] = rect[1];
                bounds[3] = rect[3];
            }
            this._drawStringLayoutResult(result, font, pen, brush, bounds, format);
        }
        _addProcSet('Text', this._resourceObject);
    }
    _buildUpPath(points, types) {
        for (let i = 0; i < points.length; i++) {
            const point = points[Number.parseInt(i.toString(), 10)];
            let type = types[Number.parseInt(i.toString(), 10)];
            switch (type & 0xf) {
                case _PathPointType.start:
                    this._sw._beginPath(point[0], point[1]);
                    break;
                case _PathPointType.bezier:
                    let result = this._getBezierPoint(points, types, i); // eslint-disable-line
                    i = result.index;
                    const first = result.point; // eslint-disable-line
                    result = this._getBezierPoint(points, types, i);
                    i = result.index;
                    const second = result.point; // eslint-disable-line
                    this._sw._appendBezierSegment(point[0], point[1], first[0], first[1], second[0], second[1]);
                    break;
                case _PathPointType.line:
                    this._sw._appendLineSegment(point[0], point[1]);
                    break;
                default:
                    throw new Error('Incorrect path formation.');
            }
            type = types[Number.parseInt(i.toString(), 10)];
            if ((type & _PathPointType.closePath) === _PathPointType.closePath) {
                this._sw._closePath();
            }
        }
    }
    _getBezierPoint(points, types, index) {
        if (types[Number.parseInt(index.toString(), 10)] !== _PathPointType.bezier) {
            throw new Error('Malforming path.');
        }
        index++;
        return { 'index': index, 'point': points[Number.parseInt(index.toString(), 10)] };
    }
    _initialize() {
        this._mediaBoxUpperRightBound = 0;
        this._characterSpacing = -1;
        this._wordSpacing = -1;
        this._textScaling = -100;
        this._textRenderingMode = -1;
        this._graphicsState = [];
        this._clipBounds = [0, 0, this._size[0], this._size[1]];
        this._colorSpaceInitialized = false;
        this._startCutIndex = -1;
    }
    _initializeCurrentColorSpace() {
        if (!this._colorSpaceInitialized) {
            this._sw._setColorSpace('DeviceRGB', true);
            this._sw._setColorSpace('DeviceRGB', false);
            this._colorSpaceInitialized = true;
        }
    }
    _brushControl(brush) {
        this._sw._setColor(brush._color, false);
        this._currentBrush = brush;
    }
    _penControl(pen) {
        this._currentPen = pen;
        this._writePen(pen);
        this._currentPen = pen;
    }
    _fontControl(font, format) {
        const size = font._metrics._getSize(format);
        this._currentFont = font;
        let fontDict;
        let isReference = false;
        let keyName;
        let isNew = true;
        let ref;
        if (this._resourceObject.has('Font')) {
            const obj = this._resourceObject.getRaw('Font'); // eslint-disable-line
            if (obj !== null && typeof obj !== 'undefined') {
                if (obj instanceof _PdfReference) {
                    isReference = true;
                    fontDict = this._crossReference._fetch(obj);
                }
                else if (obj instanceof _PdfDictionary) {
                    fontDict = obj;
                }
            }
            if (typeof fontDict !== 'undefined' && fontDict !== null) {
                isNew = false;
                this._resources.forEach((value, key) => {
                    if (key !== null && typeof key !== 'undefined') {
                        const dictionary = this._crossReference._fetch(key);
                        if (dictionary && dictionary === font._dictionary) {
                            keyName = value;
                            ref = key;
                        }
                    }
                });
            }
        }
        if (isNew) {
            fontDict = new _PdfDictionary(this._crossReference);
            this._resourceObject.update('Font', fontDict);
        }
        if (typeof keyName === 'undefined') {
            keyName = _PdfName.get(_getNewGuidString());
            if (!ref) {
                ref = this._crossReference._getNextReference();
            }
            if (font._dictionary) {
                this._crossReference._cacheMap.set(ref, font._dictionary);
                fontDict.update(keyName.name, ref);
                this._resources.set(ref, keyName);
            }
            else if (font instanceof PdfTrueTypeFont) {
                const internal = font._fontInternal;
                if (internal && internal._fontDictionary) {
                    this._crossReference._cacheMap.set(ref, internal._fontDictionary);
                }
                fontDict.update(keyName.name, ref);
                this._resources.set(ref, keyName);
            }
        }
        if (isReference) {
            this._resourceObject._updated = true;
        }
        if (this._hasResourceReference) {
            this._source._updated = true;
        }
        this._sw._setFont(keyName.name, size);
    }
    _stateControl(pen, brush, font, format) {
        if (pen || brush) {
            this._initializeCurrentColorSpace();
        }
        if (pen) {
            this._penControl(pen);
        }
        if (brush) {
            this._brushControl(brush);
        }
        if (font) {
            this._fontControl(font, format);
        }
    }
    _drawStringLayoutResult(result, font, pen, brush, layoutRectangle, format) {
        if (!result._empty) {
            const allowPartialLines = (format && typeof format.lineLimit !== 'undefined' && !format.lineLimit);
            const shouldClip = (typeof format === 'undefined' || (format && typeof format.noClip !== 'undefined'
                && !format.noClip));
            const clipRegion = allowPartialLines && shouldClip;
            let state;
            if (clipRegion) {
                state = this.save();
                const clipBounds = [layoutRectangle[0], layoutRectangle[1], result._actualSize[0], result._actualSize[1]];
                if (layoutRectangle[2] > 0) {
                    clipBounds[2] = layoutRectangle[2];
                }
                if (format.lineAlignment === PdfVerticalAlignment.middle) {
                    clipBounds[1] += (layoutRectangle[3] - clipBounds[3]) / 2;
                }
                else if (format.lineAlignment === PdfVerticalAlignment.bottom) {
                    clipBounds[1] += (layoutRectangle[3] - clipBounds[3]);
                }
                this.setClip(clipBounds);
            }
            this._applyStringSettings(font, pen, brush, format);
            const textScaling = (typeof format !== 'undefined' && format !== null) ? format.horizontalScalingFactor : 100.0;
            if (textScaling !== this._textScaling) {
                this._sw._setTextScaling(textScaling);
                this._textScaling = textScaling;
            }
            let verticalAlignShift = this._getTextVerticalAlignShift(result._actualSize[1], layoutRectangle[3], format);
            const height = (typeof format === 'undefined' || format === null || format.lineSpacing === 0) ?
                font._metrics._getHeight(format) :
                format.lineSpacing + font._metrics._getHeight(format);
            const script = (format !== null && typeof format !== 'undefined' &&
                format.subSuperScript === PdfSubSuperScript.subScript);
            let shift = 0;
            shift = (script) ? height - (font.height + font._metrics._getDescent(format)) : (height - font._metrics._getAscent(format));
            if (format && format.lineAlignment === PdfVerticalAlignment.bottom) {
                if (layoutRectangle[3] - result._actualSize[1] !== 0 &&
                    (layoutRectangle[3] - result._actualSize[1]) < (font._metrics._size / 2) - 1) {
                    if (Number.parseFloat(_numberToString(layoutRectangle[3])) <=
                        Number.parseFloat(_numberToString(font._metrics._getHeight(format)))) {
                        shift = -(height / font._metrics._size);
                    }
                }
            }
            const matrix = new _PdfTransformationMatrix();
            matrix._translate(layoutRectangle[0], (-(layoutRectangle[1] + font._metrics._getHeight(format)) -
                (font._metrics._getDescent(format) > 0 ? -font._metrics._getDescent(format) : font._metrics._getDescent(format))) -
                verticalAlignShift);
            this._sw._modifyTM(matrix);
            if (layoutRectangle[3] < font._metrics._size) {
                if ((result._actualSize[1] - layoutRectangle[3]) < (font._metrics._size / 2) - 1) {
                    verticalAlignShift = 0;
                }
            }
            if (verticalAlignShift !== 0) {
                if (format !== null && format.lineAlignment === PdfVerticalAlignment.bottom) {
                    if (layoutRectangle[3] - result._actualSize[1] !== 0 &&
                        (layoutRectangle[3] - result._actualSize[1]) > (font._metrics._size / 2) - 1) {
                        verticalAlignShift -= (shift - (height - font._metrics._size)) / 2;
                    }
                }
            }
            this._drawLayoutResult(result, font, format, layoutRectangle);
            if (verticalAlignShift !== 0) {
                this._sw._startNextLine(0, -(verticalAlignShift - result._lineHeight));
            }
            _addProcSet('Text', this._resourceObject);
            this._sw._endText();
            this._underlineStrikeoutText(brush, result, font, layoutRectangle, format);
            if (clipRegion) {
                this.restore(state);
            }
        }
    }
    _getNextPage() {
        let page;
        const pageCount = this._crossReference._document.pageCount;
        if (this._page._pageIndex < pageCount - 2) {
            page = this._crossReference._document.getPage(this._page._pageIndex + 1);
        }
        return page;
    }
    _applyStringSettings(font, pen, brush, format) {
        let tm = _TextRenderingMode.fill;
        if (pen != null && brush != null) {
            tm = _TextRenderingMode.fillStroke;
        }
        else if (pen) {
            tm = _TextRenderingMode.stroke;
        }
        else if (brush) {
            tm = _TextRenderingMode.fill;
        }
        if (format && format.clipPath) {
            tm |= _TextRenderingMode.clipFlag;
        }
        this._sw._beginText();
        this._stateControl(pen, brush, font, format);
        if (tm !== this._textRenderingMode) {
            this._sw._setTextRenderingMode(tm);
            this._textRenderingMode = tm;
        }
        const cs = (typeof format !== 'undefined' && format !== null) ? format.characterSpacing : 0;
        if (cs !== this._characterSpacing) {
            this._sw._setCharacterSpacing(cs);
            this._characterSpacing = cs;
        }
        const ws = (typeof format !== 'undefined' && format !== null) ? format.wordSpacing : 0;
        if (ws !== this._wordSpacing) {
            this._sw._setWordSpacing(ws);
            this._wordSpacing = ws;
        }
    }
    _drawLayoutResult(result, font, format, layoutRectangle) {
        const height = (typeof format === 'undefined' || format === null || format.lineSpacing === 0) ?
            font._metrics._getHeight(format) :
            format.lineSpacing + font._metrics._getHeight(format);
        const lines = result._lines;
        const ttfFont = font;
        const unicode = (ttfFont !== null && ttfFont.isUnicode);
        for (let i = 0, len = lines.length; (i < len && i !== this._startCutIndex); i++) {
            const lineInfo = lines[Number.parseInt(i.toString(), 10)];
            const lineWidth = lineInfo._width;
            const hAlignShift = this._getHorizontalAlignShift(lineWidth, layoutRectangle[2], format) +
                this._getLineIndent(lineInfo, format, layoutRectangle[2], (i === 0));
            if (hAlignShift !== 0) {
                this._sw._startNextLine(hAlignShift, 0);
            }
            if (unicode) {
                this._drawUnicodeLine(lineInfo, layoutRectangle[2], font, format);
            }
            else {
                this._drawAsciiLine(lineInfo, layoutRectangle[2], format, font);
            }
            if ((i + 1 !== len)) {
                const vAlignShift = this._getTextVerticalAlignShift(result._actualSize[1], layoutRectangle[3], format);
                const matrix = new _PdfTransformationMatrix();
                const baseline = ((-(layoutRectangle[1] + font._metrics._getHeight(format)) -
                    font._metrics._getDescent(format)) -
                    vAlignShift) -
                    (height * (i + 1));
                matrix._translate(layoutRectangle[0], baseline);
                this._sw._modifyTM(matrix);
            }
        }
    }
    _drawUnicodeLine(lineInfo, width, font, format) {
        const line = lineInfo._text;
        const rtl = (format !== null && typeof format !== 'undefined' && format.rightToLeft);
        const useWordSpace = (format !== null && typeof format !== 'undefined' && (format.wordSpacing !== 0 ||
            format.alignment === PdfTextAlignment.justify));
        const ttfFont = font;
        const wordSpacing = this._justifyLine(lineInfo, width, format, ttfFont);
        const rtlRender = new _RtlRenderer();
        if (rtl || (format !== null && typeof format !== 'undefined' && format.textDirection !== PdfTextDirection.none)) {
            let blocks = [];
            const rightAlign = (format !== null && typeof format !== 'undefined' && format.alignment === PdfTextAlignment.right);
            if (format !== null && typeof format !== 'undefined' && format.textDirection !== PdfTextDirection.none) {
                blocks = rtlRender._layout(line, ttfFont, (format.textDirection === PdfTextDirection.rightToLeft) ? true : false, useWordSpace, format);
            }
            else {
                blocks = rtlRender._layout(line, ttfFont, rightAlign, useWordSpace, format);
            }
            let words = [];
            if (blocks.length > 1) {
                if (format !== null && typeof format !== 'undefined' && format.textDirection !== PdfTextDirection.none) {
                    words = rtlRender._splitLayout(line, ttfFont, (format.textDirection === PdfTextDirection.rightToLeft) ? true : false, useWordSpace, format);
                }
            }
            else {
                words = [line];
            }
            this._drawUnicodeBlocks(blocks, words, ttfFont, format, wordSpacing);
        }
        else {
            if (useWordSpace) {
                const result = this._breakUnicodeLine(line, ttfFont, null);
                const blocks = result.tokens;
                const words = result.words;
                this._drawUnicodeBlocks(blocks, words, ttfFont, format, wordSpacing);
            }
            else {
                const token = this._convertToUnicode(line, ttfFont);
                this._sw._showNextLineText(token, true);
            }
        }
    }
    _drawUnicodeBlocks(blocks, words, font, format, wordSpacing) {
        if (blocks !== null && typeof blocks !== 'undefined' && blocks.length > 0 && words !== null && typeof words !== 'undefined' &&
            words.length > 0 && font !== null && typeof font !== 'undefined') {
            this._sw._startNextLine();
            let x = 0;
            let xShift = 0;
            let firstLineIndent = 0;
            let paragraphIndent = 0;
            try {
                if (format !== null && typeof format !== 'undefined') {
                    firstLineIndent = format.firstLineIndent;
                    paragraphIndent = format.paragraphIndent;
                    format.firstLineIndent = 0;
                    format.paragraphIndent = 0;
                }
                let spaceWidth = font._getCharacterWidth(_StringTokenizer._whiteSpace, format) + wordSpacing;
                const characterSpacing = (format != null) ? format.characterSpacing : 0;
                const wordSpace = (format !== null && typeof format !== 'undefined' && wordSpacing === 0) ? format.wordSpacing : 0;
                spaceWidth += characterSpacing + wordSpace;
                for (let i = 0; i < blocks.length; i++) {
                    const token = blocks[i]; //eslint-disable-line
                    const word = words[i]; //eslint-disable-line
                    let tokenWidth = 0;
                    if (x !== 0) {
                        this._sw._startNextLine(x, 0);
                    }
                    if (word.length > 0) {
                        tokenWidth += font.measureString(word, format)[0];
                        tokenWidth += characterSpacing;
                        this._sw._showText(token);
                    }
                    if (i !== blocks.length - 1) {
                        x = tokenWidth + spaceWidth;
                        xShift += x;
                    }
                }
                if (xShift > 0) {
                    this._sw._startNextLine(-xShift, 0);
                }
            }
            finally {
                if (format !== null && typeof format !== 'undefined') {
                    format.firstLineIndent = firstLineIndent;
                    format.paragraphIndent = paragraphIndent;
                }
            }
        }
    }
    _breakUnicodeLine(line, ttfFont, words) {
        const tokens = [];
        if (line !== null && typeof line !== 'undefined' && line.length > 0) {
            words = line.split(null);
            for (let i = 0; i < words.length; i++) {
                const word = words[i]; //eslint-disable-line
                const token = this._convertToUnicode(word, ttfFont);
                tokens[Number.parseInt(i.toString(), 10)] = token;
            }
        }
        return { tokens: tokens, words: words };
    }
    _convertToUnicode(text, ttfFont) {
        let token = null;
        if (text !== null && typeof text !== 'undefined' && ttfFont !== null && typeof ttfFont !== 'undefined' &&
            ttfFont._fontInternal instanceof _UnicodeTrueTypeFont) {
            const ttfReader = ttfFont._fontInternal._ttfReader;
            ttfFont._setSymbols(text);
            token = ttfReader._convertString(text);
            const bytes = _stringToUnicodeArray(token);
            token = _bytesToString(bytes);
        }
        return token;
    }
    _getTextVerticalAlignShift(textHeight, boundsHeight, format) {
        let shift = 0;
        if (boundsHeight >= 0 && (typeof format !== 'undefined' && format !== null) && format.lineAlignment !== PdfVerticalAlignment.top) {
            switch (format.lineAlignment) {
                case PdfVerticalAlignment.middle:
                    shift = (boundsHeight - textHeight) / 2;
                    break;
                case PdfVerticalAlignment.bottom:
                    shift = boundsHeight - textHeight;
                    break;
            }
        }
        return shift;
    }
    _getHorizontalAlignShift(lineWidth, boundsWidth, format) {
        let shift = 0;
        if (boundsWidth >= 0 && (typeof format !== 'undefined' && format !== null) && format.alignment !== PdfTextAlignment.left) {
            switch (format.alignment) {
                case PdfTextAlignment.center:
                    shift = (boundsWidth - lineWidth) / 2;
                    break;
                case PdfTextAlignment.right:
                    shift = boundsWidth - lineWidth;
                    break;
            }
        }
        return shift;
    }
    _getLineIndent(lineInfo, format, width, firstLine) {
        let lineIndent = 0;
        const firstParagraphLine = ((lineInfo._lineType & _LineType.firstParagraphLine) > 0);
        if (format && firstParagraphLine) {
            lineIndent = (firstLine) ? format.firstLineIndent : format.paragraphIndent;
            lineIndent = (width > 0) ? Math.min(width, lineIndent) : lineIndent;
        }
        return lineIndent;
    }
    _drawAsciiLine(lineInfo, width, format, font) {
        this._justifyLine(lineInfo, width, format, font);
        let value = '';
        if (lineInfo._text.indexOf('(') !== -1 || lineInfo._text.indexOf(')') !== -1) {
            for (let i = 0; i < lineInfo._text.length; i++) {
                if (lineInfo._text[Number.parseInt(i.toString(), 10)] === '(') {
                    value += '\\\('; // eslint-disable-line
                }
                else if (lineInfo._text[Number.parseInt(i.toString(), 10)] === ')') {
                    value += '\\\)'; // eslint-disable-line
                }
                else {
                    value += lineInfo._text[Number.parseInt(i.toString(), 10)];
                }
            }
        }
        if (value === '') {
            value = lineInfo._text;
        }
        this._sw._showNextLineText('(' + value + ')');
    }
    _justifyLine(lineInfo, boundsWidth, format, font) {
        const line = lineInfo._text;
        let lineWidth = lineInfo._width;
        const shouldJustify = this._shouldJustify(lineInfo, boundsWidth, format, font);
        const hasWordSpacing = (format && format.wordSpacing !== 0);
        const whitespacesCount = font._getCharacterCount(line, [' ', '\t']);
        let wordSpace = 0;
        if (shouldJustify) {
            if (hasWordSpacing) {
                lineWidth -= (whitespacesCount * format.wordSpacing);
            }
            wordSpace = (boundsWidth - lineWidth) / whitespacesCount;
            this._sw._setWordSpacing(wordSpace);
        }
        else if (format && format.alignment === PdfTextAlignment.justify) {
            this._sw._setWordSpacing(0);
        }
        return wordSpace;
    }
    _shouldJustify(lineInfo, boundsWidth, format, font) {
        const line = lineInfo._text;
        const lineWidth = lineInfo._width;
        const justifyStyle = (format && format.alignment === PdfTextAlignment.justify);
        const goodWidth = (boundsWidth >= 0 && lineWidth < boundsWidth);
        const whitespacesCount = font._getCharacterCount(line, [' ', '\t']);
        const hasSpaces = (whitespacesCount > 0 && line[0] !== ' ');
        const goodLineBreakStyle = ((lineInfo._lineType & _LineType.layoutBreak) > 0);
        return (justifyStyle && goodWidth && hasSpaces && (goodLineBreakStyle || format.alignment === PdfTextAlignment.justify));
    }
    _underlineStrikeoutText(brush, result, font, layoutRectangle, format) {
        if (font.isUnderline || font.isStrikeout) {
            const linePen = this._createUnderlineStrikeoutPen(brush, font);
            if (typeof linePen !== 'undefined' && linePen !== null) {
                const shift = this._getTextVerticalAlignShift(result._actualSize[1], layoutRectangle[3], format);
                let underlineYOffset = layoutRectangle[1] + shift + font._metrics._getAscent(format) + 1.5 * linePen._width;
                let strikeoutYOffset = layoutRectangle[1] + shift + font._metrics._getHeight(format) / 2 + 1.5 * linePen._width;
                const lines = result._lines;
                for (let i = 0; i < result._lineCount; i++) {
                    const lineInfo = lines[Number.parseInt(i.toString(), 10)];
                    const lineWidth = lineInfo._width;
                    const hShift = this._getHorizontalAlignShift(lineWidth, layoutRectangle[2], format);
                    const lineIndent = this._getLineIndent(lineInfo, format, layoutRectangle[2], (i === 0));
                    const x1 = layoutRectangle[0] + hShift;
                    const x2 = (!this._shouldJustify(lineInfo, layoutRectangle[2], format, font)) ?
                        x1 + lineWidth - lineIndent :
                        x1 + layoutRectangle[2] - lineIndent;
                    if (font.isUnderline) {
                        this.drawLine(linePen, x1, underlineYOffset, x2, underlineYOffset);
                        underlineYOffset += result._lineHeight;
                    }
                    if (font.isStrikeout) {
                        this.drawLine(linePen, x1, strikeoutYOffset, x2, strikeoutYOffset);
                        strikeoutYOffset += result._lineHeight;
                    }
                }
            }
        }
    }
    /**
     * Draw line on the page graphics.
     *
     * @param {PdfPen} pen pen value.
     * @param {number} x1 value.
     * @param {number} y1 value.
     * @param {number} x2 value.
     * @param {number} y2 value.
     * @returns {void} draw a line.
     * ```typescript
     * // Load an existing PDF document
     * let document: PdfDocument = new PdfDocument(data, password);
     * // Access first page
     * let page: PdfPage = document.getPage(0);
     * // Gets the graphics of the PDF page
     * let graphics: PdfGraphics = page.graphics;
     * //Create a new pen.
     * let pen: PdfPen = new PdfPen([0, 0, 0], 1);
     * //Draw line on the page graphics.
     * graphics.drawLine(pen, 10, 10, 100, 100);
     * // Save the document
     * document.save('output.pdf');
     * // Destroy the document
     * document.destroy();
     * ```
     */
    drawLine(pen, x1, y1, x2, y2) {
        this._stateControl(pen);
        this._sw._beginPath(x1, y1);
        this._sw._appendLineSegment(x2, y2);
        this._sw._strokePath();
        _addProcSet('PDF', this._resourceObject);
    }
    _createUnderlineStrikeoutPen(brush, font) {
        return new PdfPen(brush._color, font._metrics._size / 20);
    }
    _checkCorrectLayoutRectangle(textSize, x, y, format) {
        const layoutedRectangle = [x, y, textSize[0], textSize[0]];
        if (format) {
            switch (format.alignment) {
                case PdfTextAlignment.center:
                    layoutedRectangle[0] = layoutedRectangle[0] - layoutedRectangle[2] / 2;
                    break;
                case PdfTextAlignment.right:
                    layoutedRectangle[0] = layoutedRectangle[0] - layoutedRectangle[2];
                    break;
            }
            switch (format.lineAlignment) {
                case PdfVerticalAlignment.middle:
                    layoutedRectangle[1] = layoutedRectangle[1] - layoutedRectangle[3] / 2;
                    break;
                case PdfVerticalAlignment.bottom:
                    layoutedRectangle[1] = layoutedRectangle[1] - layoutedRectangle[3];
                    break;
            }
        }
        return layoutedRectangle;
    }
    _drawGraphicsPath(pen, brush, fillMode, needClosing) {
        if (typeof fillMode === 'undefined') {
            fillMode = PdfFillMode.winding;
        }
        const isBrush = (typeof brush !== 'undefined' && brush !== null);
        const isPen = (typeof pen !== 'undefined' && pen !== null);
        const isEvenOdd = fillMode === PdfFillMode.alternate;
        if (isPen && isBrush) {
            if (needClosing) {
                this._sw._closeFillStrokePath(isEvenOdd);
            }
            else {
                this._sw._fillStrokePath(isEvenOdd);
            }
        }
        else if (!isPen && !isBrush) {
            this._sw._endPath();
        }
        else if (isPen) {
            if (needClosing) {
                this._sw._closeStrokePath();
            }
            else {
                this._sw._strokePath();
            }
        }
        else {
            if (needClosing) {
                this._sw._closeFillPath(isEvenOdd);
            }
            else {
                this._sw._fillPath(isEvenOdd);
            }
        }
    }
    _initializeCoordinates(page) {
        let cbox;
        if (page) {
            const location = [0, 0];
            let needTransformation = false;
            if (page._pageDictionary.has('CropBox') && page._pageDictionary.has('MediaBox')) {
                cbox = page._pageDictionary.getArray('CropBox');
                const mbox = page._pageDictionary.getArray('MediaBox');
                if (cbox[0] === mbox[0] && cbox[1] === mbox[1] && cbox[2] === mbox[2] && cbox[3] === mbox[3]) {
                    needTransformation = true;
                }
                if (cbox[0] > 0 && cbox[3] > 0 && mbox[0] < 0 && mbox[1] < 0) {
                    this.translateTransform(cbox[0], -cbox[3]);
                    location[0] = -cbox[0];
                    location[1] = cbox[3];
                }
                else if (!page._pageDictionary.has('CropBox')) {
                    needTransformation = true;
                }
                if (needTransformation) {
                    this._sw._writeComment('Change co-ordinate system to left/top.');
                    if (this._cropBox) {
                        this.translateTransform(this._cropBox[0], -this._cropBox[3]);
                    }
                    else {
                        if (-(page._origin[1]) < this._mediaBoxUpperRightBound || this._mediaBoxUpperRightBound === 0) {
                            this.translateTransform(0, -this._size[1]);
                        }
                        else {
                            this.translateTransform(0, -this._mediaBoxUpperRightBound);
                        }
                    }
                }
            }
        }
        else {
            this._sw._writeComment('Change co-ordinate system to left/top.');
            if (this._mediaBoxUpperRightBound !== (-this._size[1])) {
                if (this._cropBox) {
                    cbox = this._cropBox;
                    if (cbox[0] > 0 || cbox[1] > 0 || this._size[0] === cbox[2] || this._size[1] === cbox[3]) {
                        this.translateTransform(cbox[0], -cbox[3]);
                    }
                    else {
                        if (this._mediaBoxUpperRightBound === this._size[1] || this._mediaBoxUpperRightBound === 0) {
                            this.translateTransform(0, -this._size[1]);
                        }
                        else {
                            this.translateTransform(0, -this._mediaBoxUpperRightBound);
                        }
                    }
                }
                else {
                    if (this._mediaBoxUpperRightBound === this._size[1] || this._mediaBoxUpperRightBound === 0) {
                        this.translateTransform(0, -this._size[1]);
                    }
                    else {
                        this.translateTransform(0, -this._mediaBoxUpperRightBound);
                    }
                }
            }
        }
    }
    /**
     * Represents a scale transform of the graphics.
     *
     * @param {number} scaleX Scale factor in the x direction.
     * @param {number} scaleY Scale factor in the y direction.
     * @returns {void} scale transform.
     * ```typescript
     * // Load an existing PDF document
     * let document: PdfDocument = new PdfDocument(data, password);
     * // Access first page
     * let page: PdfPage = document.getPage(0);
     * // Gets the graphics of the PDF page
     * let graphics: PdfGraphics = page.graphics;
     * // Create a new font
     * let font: PdfFont = new PdfStandardFont(PdfFontFamily.Helvetica, 20);
     * // Save the graphics
     * let state: PdfGraphicsState = graphics.save();
     * //Set graphics scale transform.
     * graphics.scaleTransform(0.5, 0.5);
     * //Draws the String.
     * graphics.drawString("Hello world!", font, [10, 20, 100, 200], undefined, new PdfBrush([0, 0, 255]));
     * //Restore the graphics.
     * graphics.restore(state);
     * // Save the document
     * document.save('output.pdf');
     * // Destroy the document
     * document.destroy();
     * ```
     */
    scaleTransform(scaleX, scaleY) {
        const matrix = new _PdfTransformationMatrix();
        matrix._scale(scaleX, scaleY);
        this._sw._modifyCtm(matrix);
        this._matrix._multiply(matrix);
    }
    /**
     * Represents a translate transform of the graphics.
     *
     * @param {number} x x-coordinate of the translation.
     * @param {number} y y-coordinate of the translation.
     * @returns {void} translate transform.
     * ```typescript
     * // Load an existing PDF document
     * let document: PdfDocument = new PdfDocument(data, password);
     * // Access first page
     * let page: PdfPage = document.getPage(0);
     * // Gets the graphics of the PDF page
     * let graphics: PdfGraphics = page.graphics;
     * // Create a new font
     * let font: PdfFont = new PdfStandardFont(PdfFontFamily.Helvetica, 20);
     * // Save the graphics
     * let state: PdfGraphicsState = graphics.save();
     * //Set graphics translate transform.
     * graphics.translateTransform(100, 100);
     * //Draws the String.
     * graphics.drawString("Hello world!", font, [10, 20, 100, 200], undefined, new PdfBrush([0, 0, 255]));
     * //Restore the graphics.
     * graphics.restore(state);
     * // Save the document
     * document.save('output.pdf');
     * // Destroy the document
     * document.destroy();
     * ```
     */
    translateTransform(x, y) {
        const matrix = new _PdfTransformationMatrix();
        matrix._translate(x, -y);
        this._sw._modifyCtm(matrix);
        this._matrix._multiply(matrix);
    }
    /**
     * Represents a rotate transform of the graphics.
     *
     * @param {number} angle Angle of rotation in degrees
     * @returns {void} rotate transform.
     * ```typescript
     * // Load an existing PDF document
     * let document: PdfDocument = new PdfDocument(data, password);
     * // Access first page
     * let page: PdfPage = document.getPage(0);
     * // Gets the graphics of the PDF page
     * let graphics: PdfGraphics = page.graphics;
     * // Create a new font
     * let font: PdfFont = new PdfStandardFont(PdfFontFamily.Helvetica, 20);
     * // Save the graphics
     * let state: PdfGraphicsState = graphics.save();
     * //Set graphics rotate transform.
     * graphics.rotateTransform(-90);
     * //Draws the String.
     * graphics.drawString("Hello world!", font, [10, 20, 100, 200], undefined, new PdfBrush([0, 0, 255]));
     * //Restore the graphics.
     * graphics.restore(state);
     * // Save the document
     * document.save('output.pdf');
     * // Destroy the document
     * document.destroy();
     * ```
     */
    rotateTransform(angle) {
        const matrix = new _PdfTransformationMatrix();
        matrix._rotate(-angle);
        this._sw._modifyCtm(matrix);
        this._matrix._multiply(matrix);
    }
    /**
     * Represents a clipping region of this graphics.
     *
     * @param {number[]} bounds Rectangle structure that represents the new clip region.
     * @param {PdfFillMode} mode Member of the PdfFillMode enumeration that specifies the filling operation to use.
     * @returns {void} clipping region.
     * ```typescript
     * // Load an existing PDF document
     * let document: PdfDocument = new PdfDocument(data, password);
     * // Access first page
     * let page: PdfPage = document.getPage(0);
     * // Gets the graphics of the PDF page
     * let graphics: PdfGraphics = page.graphics;
     * // Create a new font
     * let font: PdfFont = new PdfStandardFont(PdfFontFamily.Helvetica, 20);
     * //Set clip.
     * graphics.setClip([0, 0, 50, 12], PdfFillMode.alternate);
     * //Draws the String.
     * graphics.drawString("Hello world!", font, [0, 0, 100, 200], undefined, new PdfBrush([0, 0, 255]));
     * // Save the document
     * document.save('output.pdf');
     * // Destroy the document
     * document.destroy();
     * ```
     */
    setClip(bounds, mode) {
        if (typeof mode === 'undefined') {
            mode = PdfFillMode.winding;
        }
        this._sw._appendRectangle(bounds[0], bounds[1], bounds[2], bounds[3]);
        this._sw._clipPath(mode === PdfFillMode.alternate);
    }
    /**
     * Represents a transparency of this graphics.
     *
     * @param {number} stroke transparency value.
     * @param {number} fill transparency value.
     * @param {PdfBlendMode} mode blend mode.
     * @returns {void} transparency of this graphics.
     * ```typescript
     * // Load an existing PDF document
     * let document: PdfDocument = new PdfDocument(data, password);
     * // Access first page
     * let page: PdfPage = document.getPage(0);
     * // Gets the graphics of the PDF page
     * let graphics: PdfGraphics = page.graphics;
     * // Create a new font
     * let font: PdfFont = new PdfStandardFont(PdfFontFamily.Helvetica, 20);
     * //Set transparency.
     * graphics.setTransparency(0.5, 0.5, PdfBlendMode.multiply);
     * //Draws the String.
     * graphics.drawString("Hello world!", font, [0, 0, 100, 200], undefined, new PdfBrush([0, 0, 255]));
     * // Save the document
     * document.save('output.pdf');
     * // Destroy the document
     * document.destroy();
     * ```
     */
    setTransparency(stroke, fill, mode) {
        if (typeof fill === 'undefined') {
            fill = stroke;
        }
        if (typeof mode === 'undefined') {
            mode = PdfBlendMode.normal;
        }
        if (typeof this._transparencies === 'undefined') {
            this._transparencies = new Map();
        }
        const transparencyKey = 'CA:' + stroke.toString() + '_ca:' + fill.toString() + '_BM:' + mode.toString();
        let transparencyData;
        if (this._transparencies.size > 0) {
            this._transparencies.forEach((value, key) => {
                if (value === transparencyKey) {
                    transparencyData = key;
                }
            });
        }
        if (!transparencyData) {
            transparencyData = new _TransparencyData();
            const transparencyDict = new _PdfDictionary();
            transparencyDict.update('CA', stroke);
            transparencyDict.update('ca', fill);
            transparencyDict.update('BM', _reverseMapBlendMode(mode));
            const ref = this._crossReference._getNextReference();
            this._crossReference._cacheMap.set(ref, transparencyDict);
            transparencyData._dictionary = transparencyDict;
            transparencyData._key = transparencyKey;
            transparencyData._name = _PdfName.get(_getNewGuidString());
            transparencyData._reference = ref;
            let dictionary;
            let isReference = false;
            if (this._resourceObject.has('ExtGState')) {
                const obj = this._resourceObject.getRaw('ExtGState'); // eslint-disable-line
                if (obj !== null && typeof obj !== 'undefined') {
                    if (obj instanceof _PdfReference) {
                        isReference = true;
                        dictionary = this._crossReference._fetch(obj);
                    }
                    else if (obj instanceof _PdfDictionary) {
                        dictionary = obj;
                    }
                }
            }
            else {
                dictionary = new _PdfDictionary(this._crossReference);
                this._resourceObject.update('ExtGState', dictionary);
            }
            dictionary.update(transparencyData._name.name, ref);
            if (isReference) {
                this._resourceObject._updated = true;
            }
            if (this._hasResourceReference) {
                this._source._updated = true;
            }
        }
        this._sw._setGraphicsState(transparencyData._name);
    }
    _setTransparencyData(ref, name) {
        this._resourceMap.set(ref, name);
        const dictionary = this._crossReference._fetch(ref);
        let stroke = 0;
        let fill = 0;
        let mode = 0;
        if (dictionary.has('CA')) {
            stroke = dictionary.get('CA');
        }
        if (dictionary.has('ca')) {
            fill = dictionary.get('ca');
        }
        if (dictionary.has('ca')) {
            fill = dictionary.get('ca');
        }
        if (dictionary.has('BM')) {
            mode = _mapBlendMode(dictionary.get('BM'));
        }
        const tkey = 'CA:' + stroke.toString() + '_ca:' + fill.toString() + '_BM:' + mode.toString();
        const tdata = new _TransparencyData();
        tdata._dictionary = dictionary;
        tdata._key = tkey;
        tdata._name = name;
        tdata._reference = ref;
        this._transparencies.set(tdata, tkey);
    }
    _getTranslateTransform(x, y, input) {
        input._translate(x, -y);
        return input;
    }
    _getScaleTransform(x, y, input) {
        if (input === null || typeof input === 'undefined') {
            input = new _PdfTransformationMatrix();
        }
        input._scale(x, y);
        return input;
    }
}
class _PdfTransformationMatrix {
    constructor() {
        this._matrix = new _Matrix(1, 0, 0, 1, 0, 0);
    }
    _translate(x, y) {
        this._matrix._translate(x, y);
    }
    _scale(x, y) {
        this._matrix._elements[0] = x;
        this._matrix._elements[3] = y;
    }
    _rotate(angle) {
        angle = (angle * Math.PI) / 180;
        this._matrix._elements[0] = Math.cos(angle);
        this._matrix._elements[1] = Math.sin(angle);
        this._matrix._elements[2] = -Math.sin(angle);
        this._matrix._elements[3] = Math.cos(angle);
    }
    _multiply(matrix) {
        this._matrix._multiply(matrix._matrix);
    }
    _toString() {
        let builder = '';
        for (let i = 0, len = this._matrix._elements.length; i < len; i++) {
            builder += _floatToString(this._matrix._elements[Number.parseInt(i.toString(), 10)]) + ' ';
        }
        return builder;
    }
}
class _Matrix {
    constructor(arg1, arg2, arg3, arg4, arg5, arg6) {
        if (typeof arg1 === 'undefined') {
            this._elements = [];
        }
        else if (typeof arg1 === 'number') {
            this._elements = [arg1, arg2, arg3, arg4, arg5, arg6];
        }
        else {
            this._elements = arg1;
        }
    }
    get _offsetX() {
        return this._elements[4];
    }
    get _offsetY() {
        return this._elements[5];
    }
    _clone() {
        return new _Matrix(this._elements.slice());
    }
    _translate(x, y) {
        this._elements[4] = x;
        this._elements[5] = y;
    }
    _transform(points) {
        const x = points[0];
        const y = points[1];
        const x2 = x * this._elements[0] + y * this._elements[2] + this._offsetX;
        const y2 = x * this._elements[1] + y * this._elements[3] + this._offsetY;
        return [x2, y2];
    }
    _multiply(matrix) {
        this._elements = [(this._elements[0] * matrix._elements[0] + this._elements[1] * matrix._elements[2]),
            (this._elements[0] * matrix._elements[1] + this._elements[1] * matrix._elements[3]),
            (this._elements[2] * matrix._elements[0] + this._elements[3] * matrix._elements[2]),
            (this._elements[2] * matrix._elements[1] + this._elements[3] * matrix._elements[3]),
            (this._offsetX * matrix._elements[0] + this._offsetY * matrix._elements[2] + matrix._offsetX),
            (this._offsetX * matrix._elements[1] + this._offsetY * matrix._elements[3] + matrix._offsetY)];
    }
}
/**
 * Represents a state of the graphics from a PDF page.
 * ```typescript
 * // Load an existing PDF document
 * let document: PdfDocument = new PdfDocument(data, password);
 * // Access first page
 * let page: PdfPage = document.getPage(0);
 * // Gets the graphics of the PDF page
 * let graphics: PdfGraphics = page.graphics;
 * // Create a new font
 * let font: PdfFont = new PdfStandardFont(PdfFontFamily.Helvetica, 20);
 * // Save the graphics
 * let state: PdfGraphicsState = graphics.save();
 * //Set graphics translate transform.
 * graphics.translateTransform(100, 100);
 * //Draws the String.
 * graphics.drawString("Hello world!", font, [10, 20, 100, 200], undefined, new PdfBrush([0, 0, 255]));
 * //Restore the graphics.
 * graphics.restore(state);
 * // Save the document
 * document.save('output.pdf');
 * // Destroy the document
 * document.destroy();
 * ```
 */
class PdfGraphicsState {
    /**
     * Initializes a new instance of the `PdfGraphicsState` class.
     *
     * @private
     * @param {PdfGraphics} graphics Graphics.
     * @param {_PdfTransformationMatrix} matrix Matrix.
     *
     */
    constructor(graphics, matrix) {
        if (graphics) {
            this._g = graphics;
            this._transformationMatrix = matrix;
        }
        this._charSpacing = 0;
        this._wordSpacing = 0;
        this._textScaling = 100;
        this._textRenderingMode = _TextRenderingMode.fill;
    }
}
class _TransparencyData {
}
var _TextRenderingMode;
(function (_TextRenderingMode) {
    _TextRenderingMode[_TextRenderingMode["fill"] = 0] = "fill";
    _TextRenderingMode[_TextRenderingMode["stroke"] = 1] = "stroke";
    _TextRenderingMode[_TextRenderingMode["fillStroke"] = 2] = "fillStroke";
    _TextRenderingMode[_TextRenderingMode["none"] = 3] = "none";
    _TextRenderingMode[_TextRenderingMode["clipFlag"] = 4] = "clipFlag";
    _TextRenderingMode[_TextRenderingMode["clipFill"] = 4] = "clipFill";
    _TextRenderingMode[_TextRenderingMode["clipStroke"] = 5] = "clipStroke";
    _TextRenderingMode[_TextRenderingMode["clipFillStroke"] = 6] = "clipFillStroke";
    _TextRenderingMode[_TextRenderingMode["clip"] = 7] = "clip";
})(_TextRenderingMode || (_TextRenderingMode = {}));
/**
 * Represents a brush for the PDF page.
 * ```typescript
 * // Load an existing PDF document
 * let document: PdfDocument = new PdfDocument(data, password);
 * // Access first page
 * let page: PdfPage = document.getPage(0);
 * // Gets the graphics of the PDF page
 * let graphics: PdfGraphics = page.graphics;
 * // Create a new brush
 * let brush: PdfBrush = new PdfBrush([0, 255, 255]);
 * // Draw a rectangle using brush
 * graphics.drawRectangle(10, 10, 100, 100, brush);
 * // Save the document
 * document.save('output.pdf');
 * // Destroy the document
 * document.destroy();
 * ```
 */
class PdfBrush {
    /**
     * Initializes a new instance of the `PdfBrush` class.
     *
     * @param {number[]} color Color.
     * ```typescript
     * // Load an existing PDF document
     * let document: PdfDocument = new PdfDocument(data, password);
     * // Access first page
     * let page: PdfPage = document.getPage(0);
     * // Gets the graphics of the PDF page
     * let graphics: PdfGraphics = page.graphics;
     * // Create a new brush
     * let brush: PdfBrush = new PdfBrush([0, 255, 255]);
     * // Draw a rectangle using brush
     * graphics.drawRectangle(10, 10, 100, 100, brush);
     * // Save the document
     * document.save('output.pdf');
     * // Destroy the document
     * document.destroy();
     * ```
     */
    constructor(color) {
        this._color = typeof color !== 'undefined' ? color : [0, 0, 0];
    }
}
/**
 * Represents a pen for the PDF page.
 * ```typescript
 * // Load an existing PDF document
 * let document: PdfDocument = new PdfDocument(data, password);
 * // Access first page
 * let page: PdfPage = document.getPage(0);
 * // Gets the graphics of the PDF page
 * let graphics: PdfGraphics = page.graphics;
 * // Create a new pen
 * let pen: PdfPen = new PdfPen([0, 0, 0], 1);
 * // Draw a rectangle using pen
 * graphics.drawRectangle(150, 50, 50, 50, pen);
 * // Save the document
 * document.save('output.pdf');
 * // Destroy the document
 * document.destroy();
 * ```
 */
class PdfPen {
    /**
     * Initializes a new instance of the `PdfPen` class.
     *
     * @param {number[]} color Color.
     * @param {number} width Width.
     * ```typescript
     * // Load an existing PDF document
     * let document: PdfDocument = new PdfDocument(data, password);
     * // Access first page
     * let page: PdfPage = document.getPage(0);
     * // Gets the graphics of the PDF page
     * let graphics: PdfGraphics = page.graphics;
     * // Create a new pen
     * let pen: PdfPen = new PdfPen([0, 0, 0], 1);
     * // Draw a rectangle using pen
     * graphics.drawRectangle(150, 50, 50, 50, pen);
     * // Save the document
     * document.save('output.pdf');
     * // Destroy the document
     * document.destroy();
     * ```
     */
    constructor(color, width) {
        this._color = color;
        this._width = width;
        this._dashOffset = 0;
        this._dashPattern = [];
        this._dashStyle = PdfDashStyle.solid;
        this._miterLimit = 0;
        this._lineCap = PdfLineCap.flat;
        this._lineJoin = PdfLineJoin.miter;
    }
}
class _PdfUnitConvertor {
    constructor() {
        this._horizontalResolution = 96;
        this._proportions = this._updateProportions(this._horizontalResolution);
    }
    _updateProportions(pixel) {
        return [pixel / 2.54, pixel / 6.0, 1, pixel / 72.0, pixel, pixel / 300.0, pixel / 25.4];
    }
    _convertUnits(value, from, to) {
        return this._convertFromPixels(this._convertToPixels(value, from), to);
    }
    _convertFromPixels(value, to) {
        const index = to;
        return (value / this._proportions[Number.parseInt(index.toString(), 10)]);
    }
    _convertToPixels(value, from) {
        const index = from;
        return (value * this._proportions[Number.parseInt(index.toString(), 10)]);
    }
}

/**
 * Gets the page rotation.
 *
 * @param {PdfPage} page Page.
 * @param {number} height Height.
 * @param {number} left Left.
 * @returns {number} Page rotation.
 */
function _checkRotation(page, height, left) {
    let topValue = 0;
    left = (typeof left === 'undefined' || left === null) ? 0 : left;
    if (page.rotation === PdfRotationAngle.angle90) {
        topValue = (typeof height === 'undefined' || height === null) ? 0 : left;
    }
    else if (page.rotation === PdfRotationAngle.angle180) {
        topValue = (typeof height === 'undefined' || height === null) ? 0 : height;
    }
    else if (page.rotation === PdfRotationAngle.angle270) {
        const size = page.size;
        topValue = (typeof height === 'undefined' || height === null) ? 0 : size[0] - left;
    }
    return topValue;
}
/**
 * Gets the page index.
 *
 * @param {PdfDocument} loadedDocument Loaded document.
 * @param {_PdfDictionary} pageDictionary Page dictionary.
 * @returns {number} Page index.
 */
function _getPageIndex(loadedDocument, pageDictionary) {
    let index = -1;
    for (let i = 0; i < loadedDocument.pageCount; i++) {
        const page = loadedDocument.getPage(i);
        if (page._pageDictionary === pageDictionary) {
            index = i;
            break;
        }
    }
    return index;
}
/**
 * Convert string value from annotation flag
 *
 * @private
 * @param {PdfAnnotationFlag} flag Annotation flag.
 * @returns {string} Valid string to write into XML.
 */
function _annotationFlagsToString(flag) {
    const values = [];
    if ((flag & PdfAnnotationFlag.hidden) !== 0) {
        values.push('hidden');
    }
    if ((flag & PdfAnnotationFlag.invisible) !== 0) {
        values.push('invisible');
    }
    if ((flag & PdfAnnotationFlag.locked) !== 0) {
        values.push('locked');
    }
    if ((flag & PdfAnnotationFlag.noRotate) !== 0) {
        values.push('norotate');
    }
    if ((flag & PdfAnnotationFlag.noView) !== 0) {
        values.push('noview');
    }
    if ((flag & PdfAnnotationFlag.noZoom) !== 0) {
        values.push('nozoom');
    }
    if ((flag & PdfAnnotationFlag.print) !== 0) {
        values.push('print');
    }
    if ((flag & PdfAnnotationFlag.readOnly) !== 0) {
        values.push('readonly');
    }
    if ((flag & PdfAnnotationFlag.toggleNoView) !== 0) {
        values.push('togglenoview');
    }
    if ((flag & PdfAnnotationFlag.default) !== 0) {
        values.push('default');
    }
    return values.join(',');
}
/**
 * Convert string value to annotation flag
 *
 * @private
 * @param {string} flag String value to map
 * @returns {PdfAnnotationFlag} Annotation flag
 */
function _stringToAnnotationFlags(flag) {
    switch (flag) {
        case 'hidden':
            return PdfAnnotationFlag.hidden;
        case 'invisible':
            return PdfAnnotationFlag.invisible;
        case 'locked':
            return PdfAnnotationFlag.locked;
        case 'norotate':
            return PdfAnnotationFlag.noRotate;
        case 'noview':
            return PdfAnnotationFlag.noView;
        case 'nozoom':
            return PdfAnnotationFlag.noZoom;
        case 'print':
            return PdfAnnotationFlag.print;
        case 'readonly':
            return PdfAnnotationFlag.readOnly;
        case 'togglenoview':
            return PdfAnnotationFlag.toggleNoView;
        default:
            return PdfAnnotationFlag.default;
    }
}
/**
 * Convert string value to byte array
 *
 * @private
 * @param {string} value string value.
 * @returns {string} Valid string to write into PDF.
 */
function _stringToPdfString(value) {
    if (value.charCodeAt(0) >= '\xEF'.charCodeAt(0)) {
        let encoding;
        if (value[0] === '\xEF' && value[1] === '\xBB' && value[2] === '\xBF') {
            encoding = 'utf-8';
        }
        else if (value[0] === '\xFF' && value[1] === '\xFE') {
            encoding = 'utf-16le';
        }
        else if (value[0] === '\xFE' && value[1] === '\xFF') {
            encoding = 'utf-16be';
        }
        if (encoding) {
            try {
                return (new TextDecoder(encoding, { fatal: true })).decode(_stringToBytes(value));
            }
            catch (e) { } // eslint-disable-line
        }
    }
    const buffer = [];
    const translateTable = [
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0x2d8,
        0x2c7, 0x2c6, 0x2d9, 0x2dd, 0x2db, 0x2da, 0x2dc, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0x2022, 0x2020, 0x2021, 0x2026, 0x2014, 0x2013, 0x192,
        0x2044, 0x2039, 0x203a, 0x2212, 0x2030, 0x201e, 0x201c, 0x201d, 0x2018,
        0x2019, 0x201a, 0x2122, 0xfb01, 0xfb02, 0x141, 0x152, 0x160, 0x178, 0x17d,
        0x131, 0x142, 0x153, 0x161, 0x17e, 0, 0x20ac
    ];
    for (let i = 0; i < value.length; i++) {
        const code = translateTable[value.charCodeAt(i)];
        buffer.push(code ? String.fromCharCode(code) : value.charAt(i));
    }
    return buffer.join('');
}
/**
 * Convert string value to byte array
 *
 * @private
 * @param {string} value string value.
 * @param {boolean} isDirect Whether to return object or number[]. Default is false.
 * @returns {Uint8Array | number[]} Byte array
 */
function _stringToBytes(value, isDirect = false) {
    const bytes = [];
    for (let i = 0; i < value.length; ++i) {
        bytes.push(value.charCodeAt(i) & 0xff);
    }
    return isDirect ? bytes : new Uint8Array(bytes);
}
/**
 * Convert string value to byte array
 *
 * @private
 * @param {string} value string value.
 * @param {number[]} destination byte array.
 * @returns {number[]} Byte array
 */
function _convertStringToBytes(value, destination) {
    for (let i = 0; i < value.length; ++i) {
        destination.push(value.charCodeAt(i) & 0xff);
    }
    return destination;
}
/**
 * Check equal or not.
 *
 * @private
 * @param {number[]} first byte array.
 * @param {number[]} second byte array.
 * @returns {boolean} Equal or not
 */
function _areArrayEqual(first, second) {
    if (first.length !== second.length) {
        return false;
    }
    for (let i = 0; i < first.length; i++) {
        if (first[Number.parseInt(i.toString(), 10)] !== second[Number.parseInt(i.toString(), 10)]) {
            return false;
        }
    }
    return true;
}
/**
 * Convert number to string as round value with fixed decimal points 2.
 *
 * @private
 * @param {number[]} value number value.
 * @returns {boolean} Equal string.
 */
function _numberToString(value) {
    if (Number.isInteger(value)) {
        return value.toString();
    }
    return value.toFixed(7);
}
/**
 * Check whether entries in two array are equal or not.
 *
 * @private
 * @param {number[]} value first array.
 * @param {number[]} current second array.
 * @returns {boolean} Return true if for each elements are equal in both array.
 */
function _areNotEqual(value, current) {
    let result = false;
    if (value.length !== current.length) {
        return true;
    }
    for (let i = 0; i < value.length; i++) {
        if (value[i] !== current[i]) { // eslint-disable-line
            result = true;
            break;
        }
    }
    return result;
}
/**
 * Process bytes and convert as string.
 *
 * @private
 * @param {Uint8Array} bytes Input data.
 * @returns {string} String value processed from input bytes.
 */
function _bytesToString(bytes) {
    const length = bytes.length;
    const max = 8192;
    if (length < max) {
        return String.fromCharCode.apply(null, bytes);
    }
    const stringBuffer = [];
    for (let i = 0; i < length; i += max) {
        const chunkEnd = Math.min(i + max, length);
        const chunk = bytes.subarray(i, chunkEnd);
        stringBuffer.push(String.fromCharCode.apply(null, chunk));
    }
    return stringBuffer.join('');
}
/**
 * Convert string to unicode array.
 *
 * @private
 * @param {string} value string value.
 * @returns {Uint8Array} unicode array
 */
function _stringToUnicodeArray(value) {
    const output = [];
    if (value !== null && typeof value !== 'undefined') {
        for (let i = 0; i < value.length; i++) {
            const code = value.charCodeAt(i);
            output.push(code / 256 >>> 0);
            output.push(code & 0xff);
        }
    }
    const unicodeArray = new Uint8Array(output);
    return unicodeArray;
}
/**
 * Convert byte array to hex string.
 *
 * @private
 * @param {Uint8Array} byteArray Byte array.
 * @returns {string} Hex string.
 */
function _byteArrayToHexString(byteArray) {
    let nextHexByte;
    const stringBuffer = [];
    for (let i = 0; i < byteArray.length; i++) {
        nextHexByte = byteArray[Number.parseInt(i.toString(), 10)].toString(16).toUpperCase();
        if (nextHexByte.length < 2) {
            nextHexByte = '0' + nextHexByte;
        }
        stringBuffer.push(nextHexByte);
    }
    return stringBuffer.join('');
}
/**
 * Convert hex string to byte array.
 *
 * @private
 * @param {string} hexString Hex string.
 * @param {boolean} isDirect Whether to return object or number[]. Default is false.
 * @returns {Uint8Array | number[]} Byte array.
 */
function _hexStringToByteArray(hexString, isDirect = false) {
    const array = [];
    if (hexString) {
        for (let i = 0; i < hexString.length; i += 2) {
            array.push(Number.parseInt(hexString.substring(i, i + 2), 16));
        }
    }
    return isDirect ? array : new Uint8Array(array);
}
/**
 * Convert hex string to normal string.
 *
 * @private
 * @param {string} hexString Hex string.
 * @returns {string} Normal string.
 */
function _hexStringToString(hexString) {
    let result = '';
    if (hexString && hexString[0] === '#') {
        hexString = hexString.substring(1);
        for (let i = 0; i < hexString.length; i += 2) {
            result += String.fromCharCode(Number.parseInt(hexString.substring(i, i + 2), 16));
        }
        return result;
    }
    return hexString;
}
/**
 * Check whether the character code is white space.
 *
 * @private
 * @param {number} ch The character code to check.
 * @returns {boolean} True if the character is space, otherwise false.
 */
function _isWhiteSpace(ch) {
    return ch === 0x20 || ch === 0x09 || ch === 0x0d || ch === 0x0a;
}
/**
 * Decode bytes from base64 string.
 *
 * @private
 * @param {string} input The base64 string to decode.
 * @param {boolean} isDirect Whether to return object or number[]. Default is false.
 * @returns {Uint8Array | number[]} Decoded bytes.
 */
function _decode(input, isDirect = false) {
    const key = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=';
    let chr1;
    let chr2;
    let chr3;
    let enc1;
    let enc2;
    let enc3;
    let enc4;
    let i = 0;
    let resultIndex = 0;
    input = input.replace(/[^A-Za-z0-9\+\/\=]/g, ''); // eslint-disable-line
    let totalLength = input.length * 3 / 4;
    if (input.charAt(input.length - 1) === key.charAt(64)) {
        totalLength--;
    }
    const output = new Array(totalLength | 0);
    while (i < input.length) {
        enc1 = key.indexOf(input.charAt(i++));
        enc2 = key.indexOf(input.charAt(i++));
        enc3 = key.indexOf(input.charAt(i++));
        enc4 = key.indexOf(input.charAt(i++));
        chr1 = (enc1 << 2) | (enc2 >> 4);
        chr2 = ((enc2 & 15) << 4) | (enc3 >> 2);
        chr3 = ((enc3 & 3) << 6) | enc4;
        if (resultIndex < totalLength) {
            output[resultIndex++] = chr1;
        }
        if (resultIndex < totalLength) {
            output[resultIndex++] = chr2;
        }
        if (resultIndex < totalLength) {
            output[resultIndex++] = chr3;
        }
    }
    return isDirect ? output : new Uint8Array(output);
}
/**
 * Encode bytes to base64 string.
 *
 * @private
 * @param {Uint8Array} bytes Bytes to encode.
 * @returns {string} Decoded string.
 */
function _encode(bytes) {
    const key = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=';
    let output = '';
    let currentChar = 0;
    for (let i = 0; i < bytes.length; i++) {
        if (i % 3 === 0) {
            currentChar = (bytes[Number.parseInt(i.toString(), 10)] >> 2);
            output += key[Number.parseInt(currentChar.toString(), 10)];
            currentChar = (bytes[Number.parseInt(i.toString(), 10)] << 4) & 63;
        }
        else if (i % 3 === 1) {
            currentChar += (bytes[Number.parseInt(i.toString(), 10)] >> 4);
            output += key[Number.parseInt(currentChar.toString(), 10)];
            currentChar = (bytes[Number.parseInt(i.toString(), 10)] << 2) & 63;
        }
        else if (i % 3 === 2) {
            currentChar += (bytes[Number.parseInt(i.toString(), 10)] >> 6);
            output += key[Number.parseInt(currentChar.toString(), 10)];
            currentChar = bytes[Number.parseInt(i.toString(), 10)] & 63;
            output += key[Number.parseInt(currentChar.toString(), 10)];
        }
    }
    if (bytes.length % 3 === 1) {
        output += `${key[Number.parseInt(currentChar.toString(), 10)]}==`;
    }
    if (bytes.length % 3 === 2) {
        output += `${key[Number.parseInt(currentChar.toString(), 10)]}=`;
    }
    return output;
}
/**
 * Get property value in inheritable mode.
 *
 * @private
 * @param {_PdfDictionary} dictionary Input dictionary.
 * @param {string} key Input dictionary.
 * @param {boolean} isArray Search array.
 * @param {boolean} stopWhenFound Stop when found.
 * @param {string[]} parentKey Key string for parent node.
 * @returns {any} Property value.
 */
function _getInheritableProperty(dictionary, key, isArray = false, stopWhenFound = true, ...parentKey) {
    let values; // eslint-disable-line
    const refSet = new Set(); // eslint-disable-line
    while (dictionary instanceof _PdfDictionary && dictionary.objId && !refSet.has(dictionary.objId)) {
        if (dictionary.objId) {
            refSet.add(dictionary.objId);
        }
        const value = isArray ? dictionary.getArray(key) : dictionary.get(key); // eslint-disable-line
        if (value !== undefined) {
            if (stopWhenFound) {
                return value;
            }
            if (!values) {
                values = [];
            }
            values.push(value);
        }
        let index = 0;
        let hasParent = false;
        while (index < parentKey.length) {
            const element = parentKey[index]; // eslint-disable-line
            if (dictionary.has(element)) {
                dictionary = dictionary.get(element);
                hasParent = true;
                break;
            }
            index++;
        }
        if (!hasParent) {
            break;
        }
    }
    return values;
}
/**
 * Calculate bounds of annotation or field.
 *
 * @private
 * @param {_PdfDictionary} dictionary Input dictionary.
 * @param {boolean} isWidget Input page.
 * @returns {any} Bounds value.
 */
function _parseRectangle(dictionary, isWidget) {
    const rectangle = { x: 0, y: 0, width: 0, height: 0 };
    const elements = dictionary.getArray('Rect');
    if (elements && Array.isArray(elements)) {
        const x1 = elements[0];
        const y1 = elements[1];
        const x2 = elements[2];
        const y2 = elements[3];
        if (typeof x1 !== 'undefined' && typeof y1 !== 'undefined' && typeof x2 !== 'undefined' && typeof y2 !== 'undefined') {
            rectangle.x = Math.min(x1, x2);
            rectangle.y = Math.min(y1, y2);
            rectangle.width = Math.max(x1, x2) - rectangle.x;
            rectangle.height = Math.max(y1, y2) - rectangle.y;
            if (isWidget) {
                rectangle.height = parseFloat(rectangle.height.toFixed(3));
                if (elements[1] < 0) {
                    rectangle.y = elements[1];
                    if (elements[1] > elements[3]) {
                        rectangle.y -= rectangle.height;
                    }
                }
            }
        }
    }
    return rectangle;
}
/**
 * Calculate bounds of annotation or field.
 *
 * @private
 * @param {_PdfDictionary} dictionary Input dictionary.
 * @param {string} page Input page.
 * @returns {any} Bounds value.
 */
function _calculateBounds(dictionary, page) {
    let rect;
    if (dictionary.has('Rect')) {
        rect = _parseRectangle(dictionary);
        if (page) {
            const size = page.size;
            const mBox = page.mediaBox;
            const cropBox = page.cropBox;
            if (cropBox && Array.isArray(cropBox) && cropBox.length === 4 && page._pageDictionary.has('CropBox')) {
                if ((cropBox[0] !== 0 || cropBox[1] !== 0 || size[0] === cropBox[2] ||
                    size[1] === cropBox[3]) && (rect.x !== cropBox[0])) {
                    rect.x -= cropBox[0];
                    rect.y = cropBox[3] - (rect.y + rect.height);
                }
                else {
                    rect.y = size[1] - (rect.y + rect.height);
                }
            }
            else if (mBox && Array.isArray(mBox) && mBox.length === 4 && page._pageDictionary.has('MediaBox')) {
                if (mBox[0] > 0 || mBox[1] > 0 || size[0] === mBox[2] || size[1] === mBox[3]) {
                    rect.x -= mBox[0];
                    rect.y = mBox[3] - (rect.y + rect.height);
                }
                else {
                    rect.y = size[1] - (rect.y + rect.height);
                }
            }
            else {
                rect.y = size[1] - (rect.y + rect.height);
            }
        }
        else {
            rect.y = rect.y + rect.height;
        }
    }
    return rect;
}
/**
 * Calculate bounds of annotation or field.
 *
 * @private
 * @param {number[]} value array value.
 * @returns {any} Rectangle value.
 */
function _toRectangle(value) {
    return {
        x: Math.min(value[0], value[2]),
        y: Math.min(value[1], value[3]),
        width: Math.abs(value[0] - value[2]),
        height: Math.abs(value[1] - value[3])
    };
}
/**
 * Calculate bounds of annotation or field.
 *
 * @private
 * @param {any} value Rectangle value.
 * @param {any} value.x X value.
 * @param {any} value.y Y value.
 * @param {any} value.width Width value.
 * @param {any} value.height Height value.
 * @returns {number[]} Bounds value.
 */
function _fromRectangle(value) {
    return [value.x, value.y, value.x + value.width, value.y + value.height];
}
/**
 * Calculate bounds of annotation or field.
 *
 * @private
 * @param {number[]} value Input dictionary.
 * @param {string} page Input page.
 * @returns {number[]} Bounds value.
 */
function _getUpdatedBounds(value, page) {
    let x = value[0];
    let y = value[1];
    const width = value[2];
    const height = value[3];
    if (page) {
        const size = page.size;
        const pageWidth = size[0];
        const pageHeight = size[1];
        const mBox = page.mediaBox;
        const cropBox = page.cropBox;
        if (cropBox && Array.isArray(cropBox) && cropBox.length === 4) {
            if (cropBox[0] !== 0 || cropBox[1] !== 0 || pageWidth === cropBox[2] || pageHeight === cropBox[3]) {
                x += cropBox[0];
                y = cropBox[3] - (y + height);
            }
            else {
                y = pageHeight - (y + height);
            }
        }
        else if (mBox && Array.isArray(mBox) && mBox.length === 4) {
            if (mBox[0] > 0 || mBox[1] > 0 || pageWidth === mBox[2] || pageHeight === mBox[3]) {
                x -= mBox[0];
                y = mBox[3] - (y + height);
            }
            else {
                y = pageHeight - (y + height);
            }
        }
        else {
            y = pageHeight - (y + height);
        }
    }
    return [x, y, x + width, y + height];
}
/**
 * Parse RGB color.
 *
 * @private
 * @param {string} colorString Color value in string format.
 * @returns {number[]} RGB color value.
 */
function _convertToColor(colorString) {
    let color = _getColorValue(colorString);
    if (!color) {
        const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(colorString);
        if (result) {
            color = [Number.parseInt(result[1], 16), parseInt(result[2], 16), parseInt(result[3], 16)];
        }
    }
    return color;
}
/**
 * Parse RGB color.
 *
 * @private
 * @param {number[]} array Color array in dictionary.
 * @returns {number[]} RGB color value.
 */
function _parseColor(array) {
    let color;
    if (array) {
        if (array.length === 1) {
            const entry = array[0];
            if (typeof entry !== 'undefined') {
                const round = Math.round(entry * 255);
                color = [round, round, round];
            }
        }
        else if (array.length === 3) {
            const r = array[0];
            const g = array[1];
            const b = array[2];
            if (typeof r !== 'undefined' && typeof g !== 'undefined' && typeof b !== 'undefined') {
                color = [Math.round(r * 255), Math.round(g * 255), Math.round(b * 255)];
            }
        }
        else if (array.length === 4) {
            const c = array[0];
            const m = array[1];
            const y = array[2];
            const k = array[3];
            if (typeof c !== 'undefined' && typeof m !== 'undefined' && typeof y !== 'undefined' && typeof k !== 'undefined') {
                const fBlack = k * 255;
                color = [Math.round(255 - Math.min(255, ((c * (255 - fBlack)) + fBlack))),
                    Math.round(255 - Math.min(255, ((m * (255 - fBlack)) + fBlack))),
                    Math.round(255 - Math.min(255, ((y * (255 - fBlack)) + fBlack)))];
            }
        }
    }
    return color;
}
/**
 * Get the border style in _PdfName.
 *
 * @private
 * @param {PdfBorderStyle} style border style in enum.
 * @returns {_PdfName} border style in _PdfName.
 */
function _mapBorderStyle(style) {
    let token = 'S';
    switch (style) {
        case PdfBorderStyle.dot:
        case PdfBorderStyle.dashed:
            token = 'D';
            break;
        case PdfBorderStyle.beveled:
            token = 'B';
            break;
        case PdfBorderStyle.inset:
            token = 'I';
            break;
        case PdfBorderStyle.underline:
            token = 'U';
            break;
    }
    return _PdfName.get(token);
}
/**
 * Get the border effect style in _PdfName.
 *
 * @private
 * @param {string} style border effect style as string.
 * @returns {PdfBorderEffectStyle} border effect style.
 */
function _mapBorderEffectStyle(style) {
    let value = PdfBorderEffectStyle.solid;
    switch (style) {
        case 'C':
            value = PdfBorderEffectStyle.cloudy;
            break;
    }
    return value;
}
/**
 * Get the string value for line ending style.
 *
 * @private
 * @param {PdfLineEndingStyle} style style in enum.
 * @returns {string} value default None.
 */
function _reverseMapEndingStyle(style) {
    let value = 'None';
    if (typeof style !== 'undefined') {
        switch (style) {
            case PdfLineEndingStyle.openArrow:
                value = 'OpenArrow';
                break;
            case PdfLineEndingStyle.closedArrow:
                value = 'ClosedArrow';
                break;
            case PdfLineEndingStyle.rOpenArrow:
                value = 'ROpenArrow';
                break;
            case PdfLineEndingStyle.rClosedArrow:
                value = 'RClosedArrow';
                break;
            case PdfLineEndingStyle.butt:
                value = 'Butt';
                break;
            case PdfLineEndingStyle.diamond:
                value = 'Diamond';
                break;
            case PdfLineEndingStyle.circle:
                value = 'Circle';
                break;
            case PdfLineEndingStyle.square:
                value = 'Square';
                break;
            case PdfLineEndingStyle.slash:
                value = 'Slash';
                break;
        }
    }
    return value;
}
/**
 * Get the enum value for line ending style.
 *
 * @private
 * @param {string} style Style value in string.
 * @param {PdfLineEndingStyle} defaultValue Default style value to return.
 * @returns {PdfLineEndingStyle} enum value default 0.
 */
function _mapLineEndingStyle(style, defaultValue) {
    let value = typeof defaultValue !== 'undefined' ? defaultValue : PdfLineEndingStyle.none;
    switch (style.toLowerCase()) {
        case 'openarrow':
            value = PdfLineEndingStyle.openArrow;
            break;
        case 'closedarrow':
            value = PdfLineEndingStyle.closedArrow;
            break;
        case 'ropenarrow':
            value = PdfLineEndingStyle.rOpenArrow;
            break;
        case 'rclosedarrow':
            value = PdfLineEndingStyle.rClosedArrow;
            break;
        case 'butt':
            value = PdfLineEndingStyle.butt;
            break;
        case 'diamond':
            value = PdfLineEndingStyle.diamond;
            break;
        case 'circle':
            value = PdfLineEndingStyle.circle;
            break;
        case 'square':
            value = PdfLineEndingStyle.square;
            break;
        case 'slash':
            value = PdfLineEndingStyle.slash;
            break;
    }
    return value;
}
/**
 * Get highlight mode.
 *
 * @private
 * @param {string} mode Mode entry in dictionary.
 * @returns {PdfHighlightMode} Highlight mode.
 */
function _mapHighlightMode(mode) {
    switch (mode) {
        case 'P':
            return PdfHighlightMode.push;
        case 'N':
            return PdfHighlightMode.noHighlighting;
        case 'O':
            return PdfHighlightMode.outline;
        default:
            return PdfHighlightMode.invert;
    }
}
/**
 * Get highlight mode as string.
 *
 * @private
 * @param {PdfHighlightMode} mode Mode entry.
 * @returns {_PdfName} Highlight mode as PDF name.
 */
function _reverseMapHighlightMode(mode) {
    switch (mode) {
        case PdfHighlightMode.push:
            return _PdfName.get('P');
        case PdfHighlightMode.noHighlighting:
            return _PdfName.get('N');
        case PdfHighlightMode.outline:
            return _PdfName.get('O');
        default:
            return _PdfName.get('I');
    }
}
/**
 * Reverse map blend mode.
 *
 * @private
 * @param {PdfBlendMode} mode Mode entry.
 * @returns {_PdfName} Blend mode as name.
 */
function _reverseMapBlendMode(mode) {
    let token = 'Normal';
    switch (mode) {
        case PdfBlendMode.multiply:
            token = 'Multiply';
            break;
        case PdfBlendMode.screen:
            token = 'Screen';
            break;
        case PdfBlendMode.overlay:
            token = 'Overlay';
            break;
        case PdfBlendMode.darken:
            token = 'Darken';
            break;
        case PdfBlendMode.lighten:
            token = 'Lighten';
            break;
        case PdfBlendMode.colorDodge:
            token = 'ColorDodge';
            break;
        case PdfBlendMode.colorBurn:
            token = 'ColorBurn';
            break;
        case PdfBlendMode.hardLight:
            token = 'HardLight';
            break;
        case PdfBlendMode.softLight:
            token = 'SoftLight';
            break;
        case PdfBlendMode.difference:
            token = 'Difference';
            break;
        case PdfBlendMode.exclusion:
            token = 'Exclusion';
            break;
        case PdfBlendMode.hue:
            token = 'Hue';
            break;
        case PdfBlendMode.saturation:
            token = 'Saturation';
            break;
        case PdfBlendMode.color:
            token = 'Color';
            break;
        case PdfBlendMode.luminosity:
            token = 'Luminosity';
            break;
        default:
            token = 'Normal';
            break;
    }
    return _PdfName.get(token);
}
/**
 * Map blend mode.
 *
 * @private
 * @param {_PdfName} token Blend mode as name.
 * @returns {PdfBlendMode} Mode value;
 */
function _mapBlendMode(token) {
    let style = PdfBlendMode.normal;
    switch (token.name) {
        case 'Multiply':
            style = PdfBlendMode.multiply;
            break;
        case 'Screen':
            style = PdfBlendMode.screen;
            break;
        case 'Overlay':
            style = PdfBlendMode.overlay;
            break;
        case 'Darken':
            style = PdfBlendMode.darken;
            break;
        case 'Lighten':
            style = PdfBlendMode.lighten;
            break;
        case 'ColorDodge':
            style = PdfBlendMode.colorDodge;
            break;
        case 'ColorBurn':
            style = PdfBlendMode.colorBurn;
            break;
        case 'HardLight':
            style = PdfBlendMode.hardLight;
            break;
        case 'SoftLight':
            style = PdfBlendMode.softLight;
            break;
        case 'Difference':
            style = PdfBlendMode.difference;
            break;
        case 'Exclusion':
            style = PdfBlendMode.exclusion;
            break;
        case 'Hue':
            style = PdfBlendMode.hue;
            break;
        case 'Saturation':
            style = PdfBlendMode.saturation;
            break;
        case 'Color':
            style = PdfBlendMode.color;
            break;
        case 'Luminosity':
            style = PdfBlendMode.luminosity;
            break;
        default:
            style = PdfBlendMode.normal;
            break;
    }
    return style;
}
/**
 * Convert float to string.
 *
 * @private
 * @param {number} value number value.
 * @returns {string} equal fixed length string value;
 */
function _floatToString(value) {
    let returnString = value.toFixed(2);
    if (returnString === '0.00') {
        returnString = '.00';
    }
    return returnString;
}
/**
 * Check and add proc set value.
 *
 * @private
 * @param {string} value entry.
 * @param {_PdfDictionary} dictionary source dictionary.
 * @returns {void} Nothing;
 */
function _addProcSet(value, dictionary) {
    const name = _PdfName.get(value);
    if (dictionary.has('ProcSet')) {
        const procset = dictionary.getArray('ProcSet');
        if (procset && procset.indexOf(name) === -1) {
            procset.push(name);
            dictionary.update('ProcSet', procset);
        }
    }
    else {
        dictionary.update('ProcSet', [name]);
    }
}
/**
 * Get new GUID string.
 *
 * @private
 * @returns {string} A new GUID string;
 */
function _getNewGuidString() {
    return 'aaaaaaaa-aaaa-4aaa-baaa-aaaaaaaaaaaa'.replace(/[ab]/g, (c) => {
        const random = Math.random() * 16 | 0;
        const result = c === 'a' ? random : (random & 0x3 | 0x8);
        return result.toString(16);
    });
}
/**
 * Escape PDF name.
 *
 * @private
 * @param {string} value name value.
 * @returns {string} equal and processed name value;
 */
function _escapePdfName(value) {
    const buffer = [];
    let start = 0;
    for (let i = 0; i < value.length; i++) {
        const char = value.charCodeAt(i);
        if (char < 0x21 ||
            char > 0x7e ||
            char === 0x23 ||
            char === 0x28 ||
            char === 0x29 ||
            char === 0x3c ||
            char === 0x3e ||
            char === 0x5b ||
            char === 0x5d ||
            char === 0x7b ||
            char === 0x7d ||
            char === 0x2f ||
            char === 0x25) {
            if (start < i) {
                buffer.push(value.substring(start, i));
            }
            buffer.push(`#${char.toString(16)}`);
            start = i + 1;
        }
    }
    if (buffer.length === 0) {
        return value;
    }
    if (start < value.length) {
        buffer.push(value.substring(start, value.length));
    }
    return buffer.join('');
}
/**
 * Calculate bezier arc points.
 *
 * @private
 * @param {number} x1 value.
 * @param {number} y1 value.
 * @param {number} x2 value.
 * @param {number} y2 value.
 * @param {number} start value.
 * @param {number} extent value.
 * @returns {number[]} bezier arc points;
 */
function _getBezierArc(x1, y1, x2, y2, start, extent) {
    if (x1 > x2) {
        const swap = x1;
        x1 = x2;
        x2 = swap;
    }
    if (y2 > y1) {
        const swap = y1;
        y1 = y2;
        y2 = swap;
    }
    let angle;
    let count;
    if (Math.abs(extent) <= 90) {
        angle = extent;
        count = 1;
    }
    else {
        count = Math.ceil(Math.abs(extent) / 90);
        angle = extent / count;
    }
    const first = ((x1 + x2) / 2);
    const second = ((y1 + y2) / 2);
    const firstAngle = ((x2 - x1) / 2);
    const secondAngle = ((y2 - y1) / 2);
    const half = (angle * (Math.PI / 360));
    const value = (Math.abs(4.0 / 3.0 * (1.0 - Math.cos(half)) / Math.sin(half)));
    const points = [];
    for (let i = 0; (i < count); i++) {
        const zero = (((start + (i * angle)) * (Math.PI / 180)));
        const one = (((start + ((i + 1) * angle)) * (Math.PI / 180)));
        const cosZero = (Math.cos(zero));
        const cosOne = (Math.cos(one));
        const sinZero = (Math.sin(zero));
        const sinOne = (Math.sin(one));
        if ((angle > 0)) {
            points.push(first + (firstAngle * cosZero));
            points.push(second - (secondAngle * sinZero));
            points.push(first + (firstAngle * (cosZero - (value * sinZero))));
            points.push(second - (secondAngle * (sinZero + (value * cosZero))));
            points.push(first + (firstAngle * (cosOne + (value * sinOne))));
            points.push(second - (secondAngle * (sinOne - (value * cosOne))));
            points.push(first + (firstAngle * cosOne));
            points.push(second - (secondAngle * sinOne));
        }
        else {
            points.push(first + (firstAngle * cosZero));
            points.push(second - (secondAngle * sinZero));
            points.push(first + (firstAngle * (cosZero + (value * sinZero))));
            points.push(second - (secondAngle * (sinZero - (value * cosZero))));
            points.push(first + (firstAngle * (cosOne - (value * sinOne))));
            points.push(second - (secondAngle * (sinOne + (value * cosOne))));
            points.push(first + (firstAngle * cosOne));
            points.push(second - (secondAngle * sinOne));
        }
    }
    return points;
}
/**
 * Find page of the annotation.
 *
 * @private
 * @param {PdfDocument} document PDF document.
 * @param {_PdfReference} reference Annotation reference.
 * @returns {PdfPage} Page of the annotation;
 */
function _findPage(document, reference) {
    let page;
    for (let i = 0; i < document.pageCount && typeof page === 'undefined'; i++) {
        const entry = document.getPage(i);
        if (entry && entry._pageDictionary.has('Annots')) {
            const annots = entry._pageDictionary.get('Annots');
            if (annots !== null && typeof annots !== 'undefined' && annots.length > 0) {
                for (let j = 0; j < annots.length && typeof page === 'undefined'; j++) {
                    const ref = annots[Number.parseInt(j.toString(), 10)];
                    if (ref !== null && typeof ref !== 'undefined' && ref instanceof _PdfReference && ref === reference) {
                        page = entry;
                    }
                }
            }
        }
    }
    return page;
}
/**
 * Check the field is checked or not.
 *
 * @private
 * @param {_PdfDictionary} dictionary PDF dictionary.
 * @returns {boolean} True if the field is checked, otherwise false;
 */
function _checkField(dictionary) {
    let check = false;
    if (dictionary.has('AS')) {
        const state = dictionary.get('AS');
        if (state) {
            check = state.name !== 'Off';
        }
        else {
            const actual = dictionary.get('V');
            if (actual) {
                check = actual.name === _getItemValue(dictionary);
            }
        }
    }
    return check;
}
/**
 * Get item value from state item field.
 *
 * @private
 * @param {_PdfDictionary} itemDictionary PDF document.
 * @returns {string} value of item;
 */
function _getItemValue(itemDictionary) {
    let itemValue = '';
    let name;
    if (itemDictionary.has('AS')) {
        name = itemDictionary.get('AS');
        if (name !== null && name.name !== 'Off') {
            itemValue = name.name;
        }
    }
    if (itemValue === '' && itemDictionary.has('AP')) {
        const dictionary = itemDictionary.get('AP');
        if (dictionary && dictionary.has('N')) {
            let appearance = dictionary.get('N');
            if (appearance instanceof _PdfBaseStream) {
                appearance = appearance.dictionary;
            }
            if (appearance && appearance instanceof _PdfDictionary) {
                const keys = [];
                appearance.forEach((key, value) => {
                    keys.push(key);
                });
                for (let i = 0; i < keys.length; i++) {
                    if (keys[Number.parseInt(i.toString(), 10)] !== 'Off') {
                        itemValue = keys[Number.parseInt(i.toString(), 10)];
                        break;
                    }
                }
            }
        }
    }
    return itemValue;
}
/**
 * Get state item template.
 *
 * @private
 * @param {_PdfCheckFieldState} state Check field state.
 * @param {PdfStateItem | PdfField} item source to check.
 * @returns {PdfTemplate} Appearance template;
 */
function _getStateTemplate(state, item) {
    const value = state === _PdfCheckFieldState.checked ? _getItemValue(item._dictionary) : 'Off';
    let template;
    if (item._dictionary.has('AP')) {
        const dictionary = item._dictionary.get('AP');
        if (dictionary && dictionary.has('N')) {
            let appearance = dictionary.get('N');
            if (appearance && appearance instanceof _PdfBaseStream) {
                appearance = appearance.dictionary;
            }
            if (appearance && appearance instanceof _PdfDictionary && (value && value !== '' && appearance.has(value))) {
                const stream = appearance.get(value);
                const reference = appearance.getRaw(value);
                if (reference) {
                    stream.reference = reference;
                }
                if (stream) {
                    template = new PdfTemplate(stream, item._crossReference);
                }
            }
        }
    }
    return template;
}
/**
 * Get color value
 *
 * @private
 * @param {string} colorName name of the color.
 * @returns {number[]} return color value as number array.
 */
function _getColorValue(colorName) {
    let color;
    switch (colorName) {
        case 'transparent':
            color = [255, 255, 255];
            break;
        case 'aliceblue':
            color = [240, 248, 255];
            break;
        case 'antiquewhite':
            color = [250, 235, 215];
            break;
        case 'aqua':
            color = [0, 255, 255];
            break;
        case 'aquamarine':
            color = [127, 255, 212];
            break;
        case 'azure':
            color = [240, 255, 255];
            break;
        case 'beige':
            color = [245, 245, 220];
            break;
        case 'bisque':
            color = [255, 228, 196];
            break;
        case 'black':
            color = [0, 0, 0];
            break;
        case 'blanchedalmond':
            color = [255, 235, 205];
            break;
        case 'blue':
            color = [0, 0, 255];
            break;
        case 'blueviolet':
            color = [138, 43, 226];
            break;
        case 'brown':
            color = [165, 42, 42];
            break;
        case 'burlywood':
            color = [222, 184, 135];
            break;
        case 'cadetBlue':
            color = [95, 158, 160];
            break;
        case 'chartreuse':
            color = [127, 255, 0];
            break;
        case 'chocolate':
            color = [210, 105, 30];
            break;
        case 'coral':
            color = [255, 127, 80];
            break;
        case 'cornflowerblue':
            color = [100, 149, 237];
            break;
        case 'cornsilk':
            color = [255, 248, 220];
            break;
        case 'crimson':
            color = [220, 20, 60];
            break;
        case 'cyan':
            color = [0, 255, 255];
            break;
        case 'darkblue':
            color = [0, 0, 139];
            break;
        case 'darkcyan':
            color = [0, 139, 139];
            break;
        case 'darkgoldenrod':
            color = [184, 134, 11];
            break;
        case 'darkgray':
            color = [169, 169, 169];
            break;
        case 'darkgreen':
            color = [0, 100, 0];
            break;
        case 'darkkhaki':
            color = [189, 183, 107];
            break;
        case 'darkmagenta':
            color = [139, 0, 139];
            break;
        case 'darkolivegreen':
            color = [85, 107, 47];
            break;
        case 'darkorange':
            color = [255, 140, 0];
            break;
        case 'darkorchid':
            color = [153, 50, 204];
            break;
        case 'darkred':
            color = [139, 0, 0];
            break;
        case 'darksalmon':
            color = [233, 150, 122];
            break;
        case 'darkseagreen':
            color = [143, 188, 139];
            break;
        case 'darkslateblue':
            color = [72, 61, 139];
            break;
        case 'darkslategray':
            color = [47, 79, 79];
            break;
        case 'darkturquoise':
            color = [0, 206, 209];
            break;
        case 'darkviolet':
            color = [148, 0, 211];
            break;
        case 'deeppink':
            color = [255, 20, 147];
            break;
        case 'deepskyblue':
            color = [0, 191, 255];
            break;
        case 'dimgray':
            color = [105, 105, 105];
            break;
        case 'dodgerblue':
            color = [30, 144, 255];
            break;
        case 'firebrick':
            color = [178, 34, 34];
            break;
        case 'floralwhite':
            color = [255, 250, 240];
            break;
        case 'forestgreen':
            color = [34, 139, 34];
            break;
        case 'fuchsia':
            color = [255, 0, 255];
            break;
        case 'gainsboro':
            color = [220, 220, 220];
            break;
        case 'ghostwhite':
            color = [248, 248, 255];
            break;
        case 'gold':
            color = [255, 215, 0];
            break;
        case 'goldenrod':
            color = [218, 165, 32];
            break;
        case 'gray':
            color = [128, 128, 128];
            break;
        case 'green':
            color = [0, 128, 0];
            break;
        case 'greenyellow':
            color = [173, 255, 47];
            break;
        case 'honeydew':
            color = [240, 255, 240];
            break;
        case 'hotpink':
            color = [255, 105, 180];
            break;
        case 'indianred':
            color = [205, 92, 92];
            break;
        case 'indigo':
            color = [75, 0, 130];
            break;
        case 'ivory':
            color = [255, 255, 240];
            break;
        case 'khaki':
            color = [240, 230, 140];
            break;
        case 'lavender':
            color = [230, 230, 250];
            break;
        case 'lavenderblush':
            color = [255, 240, 245];
            break;
        case 'lawngreen':
            color = [124, 252, 0];
            break;
        case 'lemonchiffon':
            color = [255, 250, 205];
            break;
        case 'lightblue':
            color = [173, 216, 230];
            break;
        case 'lightcoral':
            color = [240, 128, 128];
            break;
        case 'lightcyan':
            color = [224, 255, 255];
            break;
        case 'lightgoldenrodyellow':
            color = [250, 250, 210];
            break;
        case 'lightgreen':
            color = [144, 238, 144];
            break;
        case 'lightgray':
            color = [211, 211, 211];
            break;
        case 'LightPink':
            color = [255, 182, 193];
            break;
        case 'lightsalmon':
            color = [255, 160, 122];
            break;
        case 'lightseagreen':
            color = [32, 178, 170];
            break;
        case 'lightskyblue':
            color = [135, 206, 250];
            break;
        case 'lightslategray':
            color = [119, 136, 153];
            break;
        case 'lightsteelblue':
            color = [176, 196, 222];
            break;
        case 'lightyellow':
            color = [255, 255, 224];
            break;
        case 'lime':
            color = [0, 255, 0];
            break;
        case 'limeGreen':
            color = [50, 205, 50];
            break;
        case 'linen':
            color = [250, 240, 230];
            break;
        case 'magenta':
            color = [255, 0, 255];
            break;
        case 'maroon':
            color = [128, 0, 0];
            break;
        case 'mediumaquamarine':
            color = [102, 205, 170];
            break;
        case 'mediumblue':
            color = [0, 0, 205];
            break;
        case 'mediumorchid':
            color = [186, 85, 211];
            break;
        case 'mediumpurple':
            color = [147, 112, 219];
            break;
        case 'mediumseagreen':
            color = [60, 179, 113];
            break;
        case 'mediumslateblue':
            color = [123, 104, 238];
            break;
        case 'mediumspringgreen':
            color = [0, 250, 154];
            break;
        case 'mediumturquoise':
            color = [72, 209, 204];
            break;
        case 'mediumvioletred':
            color = [199, 21, 133];
            break;
        case 'midnightblue':
            color = [25, 25, 112];
            break;
        case 'mintcream':
            color = [245, 255, 250];
            break;
        case 'mistyrose':
            color = [255, 228, 225];
            break;
        case 'moccasin':
            color = [255, 228, 181];
            break;
        case 'navajowhite':
            color = [255, 222, 173];
            break;
        case 'navy':
            color = [0, 0, 128];
            break;
        case 'oldLace':
            color = [253, 245, 230];
            break;
        case 'olive':
            color = [128, 128, 0];
            break;
        case 'olivedrab':
            color = [107, 142, 35];
            break;
        case 'orange':
            color = [255, 165, 0];
            break;
        case 'orangered':
            color = [255, 69, 0];
            break;
        case 'orchid':
            color = [218, 112, 214];
            break;
        case 'palegoldenrod':
            color = [238, 232, 170];
            break;
        case 'palegreen':
            color = [152, 251, 152];
            break;
        case 'paleturquoise':
            color = [175, 238, 238];
            break;
        case 'palebioletred':
            color = [219, 112, 147];
            break;
        case 'papayawhip':
            color = [255, 239, 213];
            break;
        case 'peachpuff':
            color = [255, 218, 185];
            break;
        case 'peru':
            color = [205, 133, 63];
            break;
        case 'pink':
            color = [255, 192, 203];
            break;
        case 'plum':
            color = [221, 160, 221];
            break;
        case 'powderblue':
            color = [176, 224, 230];
            break;
        case 'purple':
            color = [128, 0, 128];
            break;
        case 'red':
            color = [255, 0, 0];
            break;
        case 'rosybrown':
            color = [188, 143, 143];
            break;
        case 'royalblue':
            color = [65, 105, 225];
            break;
        case 'saddlebrown':
            color = [139, 69, 19];
            break;
        case 'salmon':
            color = [250, 128, 114];
            break;
        case 'sandybrown':
            color = [244, 164, 96];
            break;
        case 'seagreen':
            color = [46, 139, 87];
            break;
        case 'seashell':
            color = [255, 245, 238];
            break;
        case 'sienna':
            color = [160, 82, 45];
            break;
        case 'silver':
            color = [192, 192, 192];
            break;
        case 'skyblue':
            color = [135, 206, 235];
            break;
        case 'slateblue':
            color = [106, 90, 205];
            break;
        case 'slategray':
            color = [112, 128, 144];
            break;
        case 'snow':
            color = [255, 250, 250];
            break;
        case 'springgreen':
            color = [0, 255, 127];
            break;
        case 'steelblue':
            color = [70, 130, 180];
            break;
        case 'tan':
            color = [210, 180, 140];
            break;
        case 'teal':
            color = [0, 128, 128];
            break;
        case 'thistle':
            color = [216, 191, 216];
            break;
        case 'tomato':
            color = [255, 99, 71];
            break;
        case 'turquoise':
            color = [64, 224, 208];
            break;
        case 'violet':
            color = [238, 130, 238];
            break;
        case 'wheat':
            color = [245, 222, 179];
            break;
        case 'white':
            color = [255, 255, 255];
            break;
        case 'whitesmoke':
            color = [245, 245, 245];
            break;
        case 'yellow':
            color = [255, 255, 0];
            break;
        case 'yellowgreen':
            color = [154, 205, 50];
            break;
    }
    return color;
}
/**
 * Update box value in template bounds.
 *
 * @private
 * @param {PdfTemplate} template Template object.
 * @param {number} angle Angle value.
 * @returns {void} Nothing.
 */
function _setMatrix(template, angle) {
    const box = template._content.dictionary.getArray('BBox');
    if (box && typeof angle !== 'undefined' && angle !== null) {
        if (angle === 0) {
            template._content.dictionary.set('Matrix', [1, 0, 0, 1, -box[0], -box[1]]);
        }
        else {
            const matrix = new _PdfTransformationMatrix();
            matrix._rotate(angle);
            template._content.dictionary.set('Matrix', matrix._matrix._elements);
        }
    }
}
/**
 * Get the state item style to string
 *
 * @private
 * @param {PdfCheckBoxStyle} style State item style.
 * @returns {string} return as string value.
 */
function _styleToString(style) {
    let value = '4';
    switch (style) {
        case PdfCheckBoxStyle.circle:
            value = 'l';
            break;
        case PdfCheckBoxStyle.cross:
            value = '8';
            break;
        case PdfCheckBoxStyle.diamond:
            value = 'u';
            break;
        case PdfCheckBoxStyle.square:
            value = 'n';
            break;
        case PdfCheckBoxStyle.star:
            value = 'H';
            break;
    }
    return value;
}
/**
 * Get the string to state item style
 *
 * @private
 * @param {string} style State item style as string.
 * @returns {PdfCheckBoxStyle} return as state item style.
 */
function _stringToStyle(style) {
    let value = PdfCheckBoxStyle.check;
    switch (style) {
        case 'l':
            value = PdfCheckBoxStyle.circle;
            break;
        case '8':
            value = PdfCheckBoxStyle.cross;
            break;
        case 'u':
            value = PdfCheckBoxStyle.diamond;
            break;
        case 'n':
            value = PdfCheckBoxStyle.square;
            break;
        case 'H':
            value = PdfCheckBoxStyle.star;
            break;
    }
    return value;
}
/**
 * Map measurement unit type.
 *
 * @private
 * @param {string} unitString measurement unit as string.
 * @returns {PdfMeasurementUnit} measurement unit.
 */
function _mapMeasurementUnit(unitString) {
    let unit;
    switch (unitString) {
        case 'cm':
            unit = PdfMeasurementUnit.centimeter;
            break;
        case 'in':
            unit = PdfMeasurementUnit.inch;
            break;
        case 'mm':
            unit = PdfMeasurementUnit.millimeter;
            break;
        case 'p':
            unit = PdfMeasurementUnit.pica;
            break;
        case 'pt':
            unit = PdfMeasurementUnit.point;
            break;
        default:
            unit = PdfMeasurementUnit.centimeter;
            break;
    }
    return unit;
}
/**
 * Map markup annotation type.
 *
 * @private
 * @param {string} text markup type as string.
 * @returns {PdfTextMarkupAnnotationType} markup type as name.
 */
function _mapMarkupAnnotationType(text) {
    let type;
    switch (text) {
        case 'Highlight':
            type = PdfTextMarkupAnnotationType.highlight;
            break;
        case 'Squiggly':
            type = PdfTextMarkupAnnotationType.squiggly;
            break;
        case 'StrikeOut':
            type = PdfTextMarkupAnnotationType.strikeOut;
            break;
        case 'Underline':
            type = PdfTextMarkupAnnotationType.underline;
            break;
        default:
            type = PdfTextMarkupAnnotationType.highlight;
            break;
    }
    return type;
}
/**
 * Reverse text markup annotation type.
 *
 * @private
 * @param {PdfTextMarkupAnnotationType} type markup type.
 * @returns {string} markup type as name.
 */
function _reverseMarkupAnnotationType(type) {
    let token = 'Highlight';
    switch (type) {
        case PdfTextMarkupAnnotationType.highlight:
            token = 'Highlight';
            break;
        case PdfTextMarkupAnnotationType.squiggly:
            token = 'Squiggly';
            break;
        case PdfTextMarkupAnnotationType.strikeOut:
            token = 'StrikeOut';
            break;
        case PdfTextMarkupAnnotationType.underline:
            token = 'Underline';
            break;
        default:
            token = 'Highlight';
            break;
    }
    return token;
}
/**
 * Map graphics unit.
 *
 * @private
 * @param {string} unitString String value.
 * @returns {_PdfGraphicsUnit} PDF graphics unit.
 */
function _mapGraphicsUnit(unitString) {
    let unit;
    switch (unitString) {
        case 'cm':
            unit = _PdfGraphicsUnit.centimeter;
            break;
        case 'in':
            unit = _PdfGraphicsUnit.inch;
            break;
        case 'mm':
            unit = _PdfGraphicsUnit.millimeter;
            break;
        case 'p':
            unit = _PdfGraphicsUnit.pica;
            break;
        case 'pt':
            unit = _PdfGraphicsUnit.point;
            break;
        default:
            unit = _PdfGraphicsUnit.centimeter;
            break;
    }
    return unit;
}
/**
 * Map rubber stamp icon.
 *
 * @param {string} iconString String value.
 * @returns {PdfRubberStampAnnotationIcon} Rubber stamp icon.
 */
function _mapRubberStampIcon(iconString) {
    let icon;
    switch (iconString) {
        case '#Approved':
            icon = PdfRubberStampAnnotationIcon.approved;
            break;
        case '#AsIs':
            icon = PdfRubberStampAnnotationIcon.asIs;
            break;
        case '#Completed':
            icon = PdfRubberStampAnnotationIcon.completed;
            break;
        case '#Confidential':
            icon = PdfRubberStampAnnotationIcon.confidential;
            break;
        case '#Departmental':
            icon = PdfRubberStampAnnotationIcon.departmental;
            break;
        case '#Draft':
            icon = PdfRubberStampAnnotationIcon.draft;
            break;
        case '#Experimental':
            icon = PdfRubberStampAnnotationIcon.experimental;
            break;
        case '#Expired':
            icon = PdfRubberStampAnnotationIcon.expired;
            break;
        case '#Final':
            icon = PdfRubberStampAnnotationIcon.final;
            break;
        case '#ForComment':
            icon = PdfRubberStampAnnotationIcon.forComment;
            break;
        case '#ForPublicRelease':
            icon = PdfRubberStampAnnotationIcon.forPublicRelease;
            break;
        case '#InformationOnly':
            icon = PdfRubberStampAnnotationIcon.informationOnly;
            break;
        case '#NotApproved':
            icon = PdfRubberStampAnnotationIcon.notApproved;
            break;
        case '#NotForPublicRelease':
            icon = PdfRubberStampAnnotationIcon.notForPublicRelease;
            break;
        case '#PreliminaryResults':
            icon = PdfRubberStampAnnotationIcon.preliminaryResults;
            break;
        case '#Sold':
            icon = PdfRubberStampAnnotationIcon.sold;
            break;
        case '#TopSecret':
            icon = PdfRubberStampAnnotationIcon.topSecret;
            break;
        case '#Void':
            icon = PdfRubberStampAnnotationIcon.void;
            break;
        default:
            icon = PdfRubberStampAnnotationIcon.draft;
            break;
    }
    return icon;
}
/**
 * Map popup icon.
 *
 * @private
 * @param {string} iconString String value.
 * @returns {PdfRubberStampAnnotationIcon} Popup icon.
 */
function _mapPopupIcon(iconString) {
    let icon;
    switch (iconString) {
        case 'Note':
            icon = PdfPopupIcon.note;
            break;
        case 'Comment':
            icon = PdfPopupIcon.comment;
            break;
        case 'Help':
            icon = PdfPopupIcon.help;
            break;
        case 'Insert':
            icon = PdfPopupIcon.insert;
            break;
        case 'Key':
            icon = PdfPopupIcon.key;
            break;
        case 'NewParagraph':
            icon = PdfPopupIcon.newParagraph;
            break;
        case 'Paragraph':
            icon = PdfPopupIcon.paragraph;
            break;
        default:
            icon = PdfPopupIcon.note;
            break;
    }
    return icon;
}
/**
 * Convert annotation state to string value.
 *
 * @private
 * @param {PdfAnnotationState} type Annotation state.
 * @returns {string} String value.
 */
function _reverseMapAnnotationState(type) {
    let token = 'None';
    switch (type) {
        case PdfAnnotationState.none:
            token = 'None';
            break;
        case PdfAnnotationState.accepted:
            token = 'Accepted';
            break;
        case PdfAnnotationState.rejected:
            token = 'Rejected';
            break;
        case PdfAnnotationState.cancel:
            token = 'Cancelled';
            break;
        case PdfAnnotationState.completed:
            token = 'Completed';
            break;
        case PdfAnnotationState.marked:
            token = 'Marked';
            break;
        case PdfAnnotationState.unmarked:
            token = 'Unmarked';
            break;
        case PdfAnnotationState.unknown:
            token = 'Unknown';
            break;
        default:
            token = 'None';
            break;
    }
    return token;
}
/**
 * Convert string value to annotation state.
 *
 * @private
 * @param {string} type String value.
 * @returns {PdfAnnotationState} Annotation state.
 */
function _mapAnnotationState(type) {
    let token = PdfAnnotationState.none;
    switch (type) {
        case 'None':
            token = PdfAnnotationState.none;
            break;
        case 'Accepted':
            token = PdfAnnotationState.accepted;
            break;
        case 'Rejected':
            token = PdfAnnotationState.rejected;
            break;
        case 'Cancelled':
            token = PdfAnnotationState.cancel;
            break;
        case 'Completed':
            token = PdfAnnotationState.completed;
            break;
        case 'Marked':
            token = PdfAnnotationState.marked;
            break;
        case 'Unmarked':
            token = PdfAnnotationState.unmarked;
            break;
        case 'Unknown':
            token = PdfAnnotationState.unknown;
            break;
    }
    return token;
}
/**
 * Convert annotation state model to string value.
 *
 * @private
 * @param {PdfAnnotationStateModel} type Annotation state model.
 * @returns {string} String value.
 */
function _reverseMapAnnotationStateModel(type) {
    let token = 'None';
    switch (type) {
        case PdfAnnotationStateModel.none:
            token = 'None';
            break;
        case PdfAnnotationStateModel.marked:
            token = 'Marked';
            break;
        case PdfAnnotationStateModel.review:
            token = 'Review';
            break;
        default:
            token = 'None';
            break;
    }
    return token;
}
/**
 * Convert string value to annotation state model.
 *
 * @private
 * @param {string} type String value.
 * @returns {PdfAnnotationStateModel} Annotation state model.
 */
function _mapAnnotationStateModel(type) {
    let token = PdfAnnotationStateModel.none;
    switch (type) {
        case 'None':
            token = PdfAnnotationStateModel.none;
            break;
        case 'Marked':
            token = PdfAnnotationStateModel.marked;
            break;
        case 'Review':
            token = PdfAnnotationStateModel.review;
            break;
    }
    return token;
}
/**
 * Map attachment icon.
 *
 * @private
 * @param {string} iconString String value.
 * @returns {PdfAttachmentIcon} Icon.
 */
function _mapAttachmentIcon(iconString) {
    let icon;
    switch (iconString) {
        case 'PushPin':
            icon = PdfAttachmentIcon.pushPin;
            break;
        case 'Tag':
            icon = PdfAttachmentIcon.tag;
            break;
        case 'Graph':
            icon = PdfAttachmentIcon.graph;
            break;
        case 'Paperclip':
            icon = PdfAttachmentIcon.paperClip;
            break;
        default:
            icon = PdfAttachmentIcon.pushPin;
            break;
    }
    return icon;
}
/**
 * Map attachment intent.
 *
 * @private
 * @param {string} intentString String value.
 * @returns {PdfAnnotationIntent} intent.
 */
function _mapAnnotationIntent(intentString) {
    let intent;
    switch (intentString) {
        case 'None':
            intent = PdfAnnotationIntent.none;
            break;
        case 'FreeTextCallout':
            intent = PdfAnnotationIntent.freeTextCallout;
            break;
        case 'FreeTextTypeWriter':
            intent = PdfAnnotationIntent.freeTextTypeWriter;
            break;
        default:
            intent = PdfAnnotationIntent.none;
            break;
    }
    return intent;
}
/**
 * Convert PDF font style to string value.
 *
 * @private
 * @param {PdfFontStyle} style Font style.
 * @returns {string} String value.
 */
function _reverseMapPdfFontStyle(style) {
    let value = '';
    switch (style) {
        case PdfFontStyle.regular:
            value = 'Regular';
            break;
        case PdfFontStyle.bold:
            value = 'Bold';
            break;
        case PdfFontStyle.italic:
            value = 'Italic';
            break;
        case PdfFontStyle.underline:
            value = 'Underline';
            break;
        case PdfFontStyle.strikeout:
            value = 'Strikeout';
            break;
        default:
            value = 'Regular';
            break;
    }
    return value;
}
/**
 * Get special character.
 *
 * @private
 * @param {string} input Input string.
 * @returns {string} String value.
 */
function _getSpecialCharacter(input) {
    let result;
    switch (input) {
        case 'head2right':
            result = '\u27A2';
            break;
        case 'aacute':
            result = 'a\u0301';
            break;
        case 'eacute':
            result = 'e\u0301';
            break;
        case 'iacute':
            result = 'i\u0301';
            break;
        case 'oacute':
            result = 'o\u0301';
            break;
        case 'uacute':
            result = 'u\u0301';
            break;
        case 'circleright':
            result = '\u27B2';
            break;
        case 'bleft':
            result = '\u21E6';
            break;
        case 'bright':
            result = '\u21E8';
            break;
        case 'bup':
            result = '\u21E7';
            break;
        case 'bdown':
            result = '\u21E9';
            break;
        case 'barb4right':
            result = '\u2794';
            break;
        case 'bleftright':
            result = '\u2B04';
            break;
        case 'bupdown':
            result = '\u21F3';
            break;
        case 'bnw':
            result = '\u2B00';
            break;
        case 'bne':
            result = '\u2B01';
            break;
        case 'bsw':
            result = '\u2B03';
            break;
        case 'bse':
            result = '\u2B02';
            break;
        case 'bdash1':
            result = '\u25AD';
            break;
        case 'bdash2':
            result = '\u25AB';
            break;
        case 'xmarkbld':
            result = '\u2717';
            break;
        case 'checkbld':
            result = '\u2713';
            break;
        case 'boxxmarkbld':
            result = '\u2612';
            break;
        case 'boxcheckbld':
            result = '\u2611';
            break;
        case 'space':
            result = '\u0020';
            break;
        case 'pencil':
            result = '\u270F';
            break;
        case 'scissors':
            result = '\u2702';
            break;
        case 'scissorscutting':
            result = '\u2701';
            break;
        case 'readingglasses':
            result = '\u2701';
            break;
        case 'bell':
            result = '\u2701';
            break;
        case 'book':
            result = '\u2701';
            break;
        case 'telephonesolid':
            result = '\u2701';
            break;
        case 'telhandsetcirc':
            result = '\u2701';
            break;
        case 'envelopeback':
            result = '\u2701';
            break;
        case 'hourglass':
            result = '\u231B';
            break;
        case 'keyboard':
            result = '\u2328';
            break;
        case 'tapereel':
            result = '\u2707';
            break;
        case 'handwrite':
            result = '\u270D';
            break;
        case 'handv':
            result = '\u270C';
            break;
        case 'handptleft':
            result = '\u261C';
            break;
        case 'handptright':
            result = '\u261E';
            break;
        case 'handptup':
            result = '\u261D';
            break;
        case 'handptdown':
            result = '\u261F';
            break;
        case 'smileface':
            result = '\u263A';
            break;
        case 'frownface':
            result = '\u2639';
            break;
        case 'skullcrossbones':
            result = '\u2620';
            break;
        case 'flag':
            result = '\u2690';
            break;
        case 'pennant':
            result = '\u1F6A9';
            break;
        case 'airplane':
            result = '\u2708';
            break;
        case 'sunshine':
            result = '\u263C';
            break;
        case 'droplet':
            result = '\u1F4A7';
            break;
        case 'snowflake':
            result = '\u2744';
            break;
        case 'crossshadow':
            result = '\u271E';
            break;
        case 'crossmaltese':
            result = '\u2720';
            break;
        case 'starofdavid':
            result = '\u2721';
            break;
        case 'crescentstar':
            result = '\u262A';
            break;
        case 'yinyang':
            result = '\u262F';
            break;
        case 'om':
            result = '\u0950';
            break;
        case 'wheel':
            result = '\u2638';
            break;
        case 'aries':
            result = '\u2648';
            break;
        case 'taurus':
            result = '\u2649';
            break;
        case 'gemini':
            result = '\u264A';
            break;
        case 'cancer':
            result = '\u264B';
            break;
        case 'leo':
            result = '\u264C';
            break;
        case 'virgo':
            result = '\u264D';
            break;
        case 'libra':
            result = '\u264E';
            break;
        case 'scorpio':
            result = '\u264F';
            break;
        case 'saggitarius':
            result = '\u2650';
            break;
        case 'capricorn':
            result = '\u2651';
            break;
        case 'aquarius':
            result = '\u2652';
            break;
        case 'pisces':
            result = '\u2653';
            break;
        case 'ampersanditlc':
            result = '\u0026';
            break;
        case 'ampersandit':
            result = '\u0026';
            break;
        case 'circle6':
            result = '\u25CF';
            break;
        case 'circleshadowdwn':
            result = '\u274D';
            break;
        case 'square6':
            result = '\u25A0';
            break;
        case 'box3':
            result = '\u25A1';
            break;
        case 'boxshadowdwn':
            result = '\u2751';
            break;
        case 'boxshadowup':
            result = '\u2752';
            break;
        case 'lozenge4':
            result = '\u2B27';
            break;
        case 'lozenge6':
            result = '\u29EB';
            break;
        case 'rhombus6':
            result = '\u25C6';
            break;
        case 'xrhombus':
            result = '\u2756';
            break;
        case 'rhombus4':
            result = '\u2B25';
            break;
        case 'clear':
            result = '\u2327';
            break;
        case 'escape':
            result = '\u2353';
            break;
        case 'command':
            result = '\u2318';
            break;
        case 'rosette':
            result = '\u2740';
            break;
        case 'rosettesolid':
            result = '\u273F';
            break;
        case 'quotedbllftbld':
            result = '\u275D';
            break;
        case 'quotedblrtbld':
            result = '\u275E';
            break;
        case '.notdef':
            result = '\u25AF';
            break;
        case 'zerosans':
            result = '\u24EA';
            break;
        case 'onesans':
            result = '\u2460';
            break;
        case 'twosans':
            result = '\u2461';
            break;
        case 'threesans':
            result = '\u2462';
            break;
        case 'foursans':
            result = '\u2463';
            break;
        case 'fivesans':
            result = '\u2464';
            break;
        case 'sixsans':
            result = '\u2465';
            break;
        case 'sevensans':
            result = '\u2466';
            break;
        case 'eightsans':
            result = '\u2467';
            break;
        case 'ninesans':
            result = '\u2468';
            break;
        case 'tensans':
            result = '\u2469';
            break;
        case 'zerosansinv':
            result = '\u24FF';
            break;
        case 'onesansinv':
            result = '\u2776';
            break;
        case 'twosansinv':
            result = '\u2777';
            break;
        case 'threesansinv':
            result = '\u2778';
            break;
        case 'foursansinv':
            result = '\u2779';
            break;
        case 'circle2':
            result = '\u00B7';
            break;
        case 'circle4':
            result = '\u2022';
            break;
        case 'square2':
            result = '\u25AA';
            break;
        case 'ring2':
            result = '\u25CB';
            break;
        case 'ringbutton2':
            result = '\u25C9';
            break;
        case 'target':
            result = '\u25CE';
            break;
        case 'square4':
            result = '\u25AA';
            break;
        case 'box2':
            result = '\u25FB';
            break;
        case 'crosstar2':
            result = '\u2726';
            break;
        case 'pentastar2':
            result = '\u2605';
            break;
        case 'hexstar2':
            result = '\u2736';
            break;
        case 'octastar2':
            result = '\u2734';
            break;
        case 'dodecastar3':
            result = '\u2739';
            break;
        case 'octastar4':
            result = '\u2735';
            break;
        case 'registercircle':
            result = '\u2316';
            break;
        case 'cuspopen':
            result = '\u27E1';
            break;
        case 'cuspopen1':
            result = '\u2311';
            break;
        case 'circlestar':
            result = '\u2605';
            break;
        case 'starshadow':
            result = '\u2730';
            break;
        case 'deleteleft':
            result = '\u232B';
            break;
        case 'deleteright':
            result = '\u2326';
            break;
        case 'scissorsoutline':
            result = '\u2704';
            break;
        case 'telephone':
            result = '\u260F';
            break;
        case 'telhandset':
            result = '\u1F4DE';
            break;
        case 'handptlft1':
            result = '\u261C';
            break;
        case 'handptrt1':
            result = '\u261E';
            break;
        case 'handptlftsld1':
            result = '\u261A';
            break;
        case 'handptrtsld1':
            result = '\u261B';
            break;
        case 'handptup1':
            result = '\u261D';
            break;
        case 'handptdwn1':
            result = '\u261F';
            break;
        case 'xmark':
            result = '\u2717';
            break;
        case 'check':
            result = '\u2713';
            break;
        case 'boxcheck':
            result = '\u2611';
            break;
        case 'boxx':
            result = '\u2612';
            break;
        case 'boxxbld':
            result = '\u2612';
            break;
        case 'circlex':
            result = '=\u2314';
            break;
        case 'circlexbld':
            result = '\u2314';
            break;
        case 'prohibit':
        case 'prohibitbld':
            result = '\u29B8';
            break;
        case 'ampersanditaldm':
        case 'ampersandbld':
        case 'ampersandsans':
        case 'ampersandsandm':
            result = '\u0026';
            break;
        case 'interrobang':
        case 'interrobangdm':
        case 'interrobangsans':
        case 'interrobngsandm':
            result = '\u203D';
            break;
        case 'sacute':
            result = 'ś';
            break;
        case 'Sacute':
            result = 'Ś';
            break;
        case 'eogonek':
            result = 'ę';
            break;
        case 'cacute':
            result = 'ć';
            break;
        case 'aogonek':
            result = 'ą';
            break;
        default:
            result = input;
            break;
    }
    return result;
}
/**
 * Get latin character.
 *
 * @private
 * @param {string} input Input string.
 * @returns {string} String value.
 */
function _getLatinCharacter(input) {
    let result;
    switch (input) {
        case 'zero':
            result = '0';
            break;
        case 'one':
            result = '1';
            break;
        case 'two':
            result = '2';
            break;
        case 'three':
            result = '3';
            break;
        case 'four':
            result = '4';
            break;
        case 'five':
            result = '5';
            break;
        case 'six':
            result = '6';
            break;
        case 'seven':
            result = '7';
            break;
        case 'eight':
            result = '8';
            break;
        case 'nine':
            result = '9';
            break;
        case 'aacute':
            result = 'á';
            break;
        case 'asciicircum':
            result = '^';
            break;
        case 'asciitilde':
            result = '~';
            break;
        case 'asterisk':
            result = '*';
            break;
        case 'at':
            result = '@';
            break;
        case 'atilde':
            result = 'ã';
            break;
        case 'backslash':
            result = '\\';
            break;
        case 'bar':
            result = '|';
            break;
        case 'braceleft':
            result = '{';
            break;
        case 'braceright':
            result = '}';
            break;
        case 'bracketleft':
            result = '[';
            break;
        case 'bracketright':
            result = ']';
            break;
        case 'breve':
            result = '˘';
            break;
        case 'brokenbar':
            result = '|';
            break;
        case 'bullet3':
            result = '•';
            break;
        case 'bullet':
            result = '•';
            break;
        case 'caron':
            result = 'ˇ';
            break;
        case 'ccedilla':
            result = 'ç';
            break;
        case 'cedilla':
            result = '¸';
            break;
        case 'cent':
            result = '¢';
            break;
        case 'circumflex':
            result = 'ˆ';
            break;
        case 'colon':
            result = ':';
            break;
        case 'comma':
            result = ',';
            break;
        case 'copyright':
            result = '©';
            break;
        case 'currency1':
            result = '¤';
            break;
        case 'dagger':
            result = '†';
            break;
        case 'daggerdbl':
            result = '‡';
            break;
        case 'degree':
            result = '°';
            break;
        case 'dieresis':
            result = '¨';
            break;
        case 'divide':
            result = '÷';
            break;
        case 'dollar':
            result = '$';
            break;
        case 'dotaccent':
            result = '˙';
            break;
        case 'dotlessi':
            result = 'ı';
            break;
        case 'eacute':
            result = 'é';
            break;
        case 'middot':
            result = '˙';
            break;
        case 'edieresis':
            result = 'ë';
            break;
        case 'egrave':
            result = 'è';
            break;
        case 'ellipsis':
            result = '...';
            break;
        case 'emdash':
            result = '—';
            break;
        case 'endash':
            result = '–';
            break;
        case 'equal':
            result = '=';
            break;
        case 'eth':
            result = 'ð';
            break;
        case 'exclam':
            result = '!';
            break;
        case 'exclamdown':
            result = '¡';
            break;
        case 'florin':
            result = 'ƒ';
            break;
        case 'fraction':
            result = '⁄';
            break;
        case 'germandbls':
            result = 'ß';
            break;
        case 'grave':
            result = '`';
            break;
        case 'greater':
            result = '>';
            break;
        case 'guillemotleft4':
            result = '«';
            break;
        case 'guillemotright4':
            result = '»';
            break;
        case 'guilsinglleft':
            result = '‹';
            break;
        case 'guilsinglright':
            result = '›';
            break;
        case 'hungarumlaut':
            result = '˝';
            break;
        case 'hyphen5':
            result = '-';
            break;
        case 'iacute':
            result = 'í';
            break;
        case 'icircumflex':
            result = 'î';
            break;
        case 'idieresis':
            result = 'ï';
            break;
        case 'igrave':
            result = 'ì';
            break;
        case 'less':
            result = '<';
            break;
        case 'logicalnot':
            result = '¬';
            break;
        case 'lslash':
            result = 'ł';
            break;
        case 'Lslash':
            result = 'Ł';
            break;
        case 'macron':
            result = '¯';
            break;
        case 'minus':
            result = '−';
            break;
        case 'mu':
            result = 'μ';
            break;
        case 'multiply':
            result = '×';
            break;
        case 'ntilde':
            result = 'ñ';
            break;
        case 'numbersign':
            result = '#';
            break;
        case 'oacute':
            result = 'ó';
            break;
        case 'ocircumflex':
            result = 'ô';
            break;
        case 'odieresis':
            result = 'ö';
            break;
        case 'oe':
            result = 'oe';
            break;
        case 'ogonek':
            result = '˛';
            break;
        case 'ograve':
            result = 'ò';
            break;
        case 'onehalf':
            result = '1/2';
            break;
        case 'onequarter':
            result = '1/4';
            break;
        case 'onesuperior':
            result = '¹';
            break;
        case 'ordfeminine':
            result = 'ª';
            break;
        case 'ordmasculine':
            result = 'º';
            break;
        case 'otilde':
            result = 'õ';
            break;
        case 'paragraph':
            result = '¶';
            break;
        case 'parenleft':
            result = '(';
            break;
        case 'parenright':
            result = ')';
            break;
        case 'percent':
            result = '%';
            break;
        case 'period':
            result = '.';
            break;
        case 'periodcentered':
            result = '·';
            break;
        case 'perthousand':
            result = '‰';
            break;
        case 'plus':
            result = '+';
            break;
        case 'plusminus':
            result = '±';
            break;
        case 'question':
            result = '?';
            break;
        case 'questiondown':
            result = '¿';
            break;
        case 'quotedbl':
            result = '\'';
            break;
        case 'quotedblbase':
            result = '„';
            break;
        case 'quotedblleft':
            result = '“';
            break;
        case 'quotedblright':
            result = '”';
            break;
        case 'quoteleft':
            result = '‘';
            break;
        case 'quoteright':
            result = '’';
            break;
        case 'quotesinglbase':
            result = '‚';
            break;
        case 'quotesingle':
            result = '\'';
            break;
        case 'registered':
            result = '®';
            break;
        case 'ring':
            result = '˚';
            break;
        case 'scaron':
            result = 'š';
            break;
        case 'section':
            result = '§';
            break;
        case 'semicolon':
            result = ';';
            break;
        case 'slash':
            result = '/';
            break;
        case 'space6':
            result = ' ';
            break;
        case 'space':
            result = ' ';
            break;
        case 'udieresis':
            result = 'ü';
            break;
        case 'uacute':
            result = 'ú';
            break;
        case 'Ecircumflex':
            result = 'Ê';
            break;
        case 'hyphen':
            result = '-';
            break;
        case 'underscore':
            result = '_';
            break;
        case 'adieresis':
            result = 'ä';
            break;
        case 'ampersand':
            result = '&';
            break;
        case 'Adieresis':
            result = 'Ä';
            break;
        case 'Udieresis':
            result = 'Ü';
            break;
        case 'ccaron':
            result = 'č';
            break;
        case 'Scaron':
            result = 'Š';
            break;
        case 'zcaron':
            result = 'ž';
            break;
        case 'sterling':
            result = '£';
            break;
        case 'agrave':
            result = 'à';
            break;
        case 'ecircumflex':
            result = 'ê';
            break;
        case 'acircumflex':
            result = 'â';
            break;
        case 'Oacute':
            result = 'Ó';
            break;
        default:
            result = input;
            break;
    }
    return result;
}
/**
 * Encode value to string.
 *
 * @private
 * @param {string} value Input string.
 * @returns {string} result.
 */
function _encodeValue(value) {
    let name = '';
    for (let i = 0; i < value.length; i++) {
        const code = value.charCodeAt(i) & 0xff;
        const entry = String.fromCharCode(code);
        let hex = '';
        switch (entry) {
            case ' ':
            case '%':
            case '(':
            case ')':
            case '<':
            case '>':
            case '[':
            case ']':
            case '{':
            case '}':
            case '/':
            case '#':
                name += '#';
                hex = code.toString(16).toUpperCase();
                name += (hex.length === 1 ? ('0' + hex) : hex);
                break;
            default:
                if (code > 126 || code < 37) {
                    name += '#';
                    hex = code.toString(16).toUpperCase();
                    name += (hex.length === 1 ? ('0' + hex) : hex);
                }
                else {
                    name += entry;
                }
                break;
        }
    }
    return name;
}
/**
 * Parse and retrieve comments and review history from the annotation.
 *
 * @private
 * @param {PdfComment} annotation Input annotation.
 * @param {boolean} isReview Input is review or not.
 * @returns {PdfPopupAnnotationCollection} result.
 */
function _getCommentsOrReview(annotation, isReview) {
    if (isReview) {
        return annotation.reviewHistory;
    }
    else {
        return annotation.comments;
    }
}
/**
 * Returns true if input dictionary is belongs to the review history.
 *
 * @private
 * @param {_PdfDictionary} dictionary Input dictionary.
 * @returns {boolean} Input is review or not.
 */
function _checkReview(dictionary) {
    const flag = dictionary.get('F');
    return ((dictionary.has('State') || dictionary.has('StateModel')) && (flag === 30 || flag === 128));
}
/**
 * Returns true if input dictionary is belongs to the comments.
 *
 * @private
 * @param {_PdfDictionary} dictionary Input dictionary.
 * @returns {boolean} Input is comments or not.
 */
function _checkComment(dictionary) {
    const flag = dictionary.get('F');
    return (!(dictionary.has('State') || dictionary.has('StateModel')) && (flag === 28 || flag === 128));
}
/**
 * Update visibility.
 *
 * @private
 * @param {_PdfDictionary} dictionary Input dictionary.
 * @param {PdfFormFieldVisibility} value Visibility.
 * @returns {void} Nothing.
 */
function _updateVisibility(dictionary, value) {
    if (dictionary.has('F')) {
        delete dictionary._map.F;
        dictionary._updated = true;
    }
    switch (value) {
        case PdfFormFieldVisibility.hidden:
            dictionary.update('F', PdfAnnotationFlag.hidden);
            break;
        case PdfFormFieldVisibility.hiddenPrintable:
            dictionary.update('F', (PdfAnnotationFlag.noView | PdfAnnotationFlag.print));
            break;
        case PdfFormFieldVisibility.visible:
            if (dictionary.has('DV')) {
                delete dictionary._map.DV;
                dictionary._updated = true;
            }
            if (dictionary.has('MK')) {
                const mkDict = dictionary.get('MK');
                if (mkDict && mkDict.has('BG')) {
                    delete mkDict._map.BG;
                    mkDict._updated = true;
                }
            }
            break;
    }
}
/**
 * Remove duplicate reference.
 *
 * @private
 * @param {_PdfDictionary} dictionary Input dictionary.
 * @param {_PdfCrossReference} crossTable Cross reference table.
 * @param {string} key Key string for appearance type.
 * @returns {void} Nothing.
 */
function _removeDuplicateReference(dictionary, crossTable, key) {
    if (dictionary && dictionary.has(key)) {
        const oldAppearance = dictionary.getRaw(key);
        if (oldAppearance && oldAppearance instanceof _PdfReference && oldAppearance._isNew) {
            let appearance = dictionary.get(key); // eslint-disable-line
            if (appearance) {
                if (appearance instanceof _PdfReference) {
                    appearance = crossTable._fetch(appearance);
                }
                let appearanceDictionary;
                if (appearance instanceof _PdfDictionary) {
                    appearanceDictionary = appearance;
                }
                else if (appearance instanceof _PdfBaseStream) {
                    appearanceDictionary = appearance.dictionary;
                }
                if (appearanceDictionary && appearanceDictionary.has('Resources')) {
                    _removeDuplicateFromResources(appearanceDictionary.get('Resources'), crossTable);
                }
            }
            crossTable._cacheMap.delete(oldAppearance);
        }
    }
}
/**
 * Remove duplicate reference from resources.
 *
 * @private
 * @param {_PdfDictionary} resources Input resources.
 * @param {_PdfCrossReference} crossTable Cross reference table.
 * @returns {void} Nothing.
 */
function _removeDuplicateFromResources(resources, crossTable) {
    if (resources && resources.size > 0) {
        resources.forEach((key, value) => {
            if (typeof key !== 'undefined' && typeof value !== 'undefined') {
                if (value instanceof _PdfReference) {
                    const reference = value;
                    if (reference._isNew) {
                        const dictionary = resources.get(key);
                        if (dictionary && dictionary instanceof _PdfDictionary) {
                            if (key === 'XObject' && dictionary.has('Resources')) {
                                _removeDuplicateFromResources(dictionary.get('Resources'), crossTable);
                            }
                            crossTable._cacheMap.delete(reference);
                        }
                    }
                }
                else if (value instanceof _PdfDictionary) {
                    if (value.has('Resources')) {
                        _removeDuplicateFromResources(value.get('Resources'), crossTable);
                    }
                    if (key === 'Font' || key === 'XObject' || key === 'ExtGState') {
                        _removeDuplicateFromResources(value, crossTable);
                    }
                }
            }
        });
    }
}
/**
 * Remove duplicate reference.
 *
 * @private
 * @param {any} normal Input.
 * @param {_PdfCrossReference} crossReference Cross reference table.
 * @param {string} firstKey Key string for appearance type.
 * @param {string} secondKey Key string for appearance type.
 * @returns {void} Nothing.
 */
function _removeReferences(normal, crossReference, firstKey, secondKey) {
    let normalElement;
    if (normal) {
        if (normal instanceof _PdfDictionary) {
            normalElement = normal;
        }
        else if (normal instanceof _PdfStream) {
            normalElement = normal.dictionary;
        }
    }
    if (normalElement) {
        _removeDuplicateReference(normalElement, crossReference, firstKey);
        _removeDuplicateReference(normalElement, crossReference, secondKey);
    }
}
class BaseException {
    constructor(message, name) {
        this.message = message;
        this.name = name;
    }
}
class FormatError extends BaseException {
    constructor(message) {
        super(message, 'FormatError');
    }
}
class ParserEndOfFileException extends BaseException {
    constructor(message) {
        super(message, 'ParserEndOfFileException');
    }
}
/**
 * Gets the default string.
 *
 * @param {string} item Input string.
 * @returns {string} result.
 */
function _defaultToString(item) {
    if (Object.prototype.toString.call(item) === '[object String]') {
        return '$s' + item;
    }
    else {
        return '$o' + item.toString();
    }
}
/**
 * Gets the form field font.
 *
 * @param {PdfForm} form form.
 * @param {PdfWidgetAnnotation} widget widget annotation.
 * @param {PdfField} field field.
 * @returns {PdfFont} font.
 */
function _obtainFontDetails(form, widget, field) {
    let fontFamily = '';
    let fontSize;
    let font;
    let defaultAppearance;
    if (widget && widget._dictionary.has('DA') || field._dictionary.has('DA')) {
        if (widget && widget._dictionary.has('DA')) {
            defaultAppearance = widget._dictionary.get('DA');
        }
        else {
            defaultAppearance = field._dictionary.get('DA');
        }
    }
    if (defaultAppearance && defaultAppearance !== '' && defaultAppearance.indexOf('Tf') !== -1) {
        const textCollection = defaultAppearance.split(' ');
        for (let i = 0; i < textCollection.length; i++) {
            if (textCollection[Number.parseInt(i.toString(), 10)].indexOf('Tf') !== -1) {
                fontFamily = textCollection[i - 2];
                while (fontFamily !== '' && fontFamily.length > 1 && fontFamily[0] === '/') {
                    fontFamily = fontFamily.substring(1);
                }
                fontSize = Number.parseFloat(textCollection[i - 1]);
            }
        }
    }
    if (fontFamily) {
        fontFamily = fontFamily.trim();
    }
    if (form && form._dictionary.has('DR')) {
        const resources = form._dictionary.get('DR');
        if (resources.has('Font')) {
            const fonts = resources.get('Font');
            if (fonts.has(fontFamily)) {
                const fontDictionary = fonts.get(fontFamily);
                if (fontDictionary && fontFamily && fontDictionary.has('BaseFont')) {
                    const baseFont = fontDictionary.get('BaseFont');
                    let textFontStyle = PdfFontStyle.regular;
                    if (baseFont) {
                        defaultAppearance = baseFont.name;
                        textFontStyle = _getFontStyle(baseFont.name);
                        if (defaultAppearance.includes('-')) {
                            defaultAppearance = defaultAppearance.substring(0, defaultAppearance.indexOf('-'));
                        }
                        if (widget && widget._dictionary.has('DA')) {
                            font = _mapFont(defaultAppearance, fontSize, textFontStyle, widget);
                        }
                        else if (field && field._dictionary.has('DA')) {
                            font = _mapFont(defaultAppearance, fontSize, textFontStyle, field);
                        }
                    }
                }
            }
        }
    }
    if ((font === null || typeof font === 'undefined') && fontSize) {
        font = new PdfStandardFont(PdfFontFamily.helvetica, fontSize, PdfFontStyle.regular);
    }
    if ((font === null || typeof font === 'undefined') || (font && font.size === 1)) {
        if (widget) {
            font = widget._circleCaptionFont;
        }
        else if (field) {
            font = field._circleCaptionFont;
        }
    }
    return font;
}
/**
 * Gets the font style.
 *
 * @param {string} fontFamilyString Font family string.
 * @returns {PdfFontStyle} result.
 */
function _getFontStyle(fontFamilyString) {
    let position = fontFamilyString.indexOf('-');
    if (position < 0) {
        position = fontFamilyString.indexOf(',');
    }
    let style = PdfFontStyle.regular;
    if (position >= 0) {
        const standardName = fontFamilyString.substring(position + 1, fontFamilyString.length);
        switch (standardName) {
            case 'Bold':
            case 'BoldMT':
                style = PdfFontStyle.bold;
                break;
            case 'Italic':
            case 'ItalicMT':
            case 'Oblique':
            case 'It':
                style = PdfFontStyle.italic;
                break;
            case 'BoldItalic':
            case 'BoldItalicMT':
            case 'BoldOblique':
                style = PdfFontStyle.bold | PdfFontStyle.italic;
                break;
        }
    }
    return style;
}
/**
 * Map the font.
 *
 * @param {string} name Font name.
 * @param {number} size Font size.
 * @param {PdfFontStyle} style Font style.
 * @param {PdfAnnotation} annotation Annotation or Field.
 * @returns {PdfFont} result.
 */
function _mapFont(name, size, style, annotation) {
    let font;
    let fontFamily = name ? name : '';
    if (fontFamily.includes('-')) {
        fontFamily = fontFamily.substring(0, fontFamily.indexOf('-'));
    }
    const fontSize = typeof size !== 'undefined' ? size : 1;
    if (annotation._dictionary.has('DS') || annotation._dictionary.has('DA')) {
        switch (fontFamily) {
            case 'Helvetica':
                font = new PdfStandardFont(PdfFontFamily.helvetica, fontSize, style);
                break;
            case 'Courier':
                font = new PdfStandardFont(PdfFontFamily.courier, fontSize, style);
                break;
            case 'Symbol':
                font = new PdfStandardFont(PdfFontFamily.symbol, fontSize, style);
                break;
            case 'Times':
            case 'TimesRoman':
                font = new PdfStandardFont(PdfFontFamily.timesRoman, fontSize, style);
                break;
            case 'ZapfDingbats':
                font = new PdfStandardFont(PdfFontFamily.zapfDingbats, fontSize, style);
                break;
            case 'MonotypeSungLight':
                font = new PdfCjkStandardFont(PdfCjkFontFamily.monotypeSungLight, fontSize, style);
                break;
            case 'SinoTypeSongLight':
                font = new PdfCjkStandardFont(PdfCjkFontFamily.sinoTypeSongLight, fontSize, style);
                break;
            case 'MonotypeHeiMedium':
                font = new PdfCjkStandardFont(PdfCjkFontFamily.monotypeHeiMedium, fontSize, style);
                break;
            case 'HanyangSystemsGothicMedium':
                font = new PdfCjkStandardFont(PdfCjkFontFamily.hanyangSystemsGothicMedium, fontSize, style);
                break;
            case 'HanyangSystemsShinMyeongJoMedium':
                font = new PdfCjkStandardFont(PdfCjkFontFamily.hanyangSystemsShinMyeongJoMedium, fontSize, style);
                break;
            case 'HeiseiKakuGothicW5':
                font = new PdfCjkStandardFont(PdfCjkFontFamily.heiseiKakuGothicW5, fontSize, style);
                break;
            case 'HeiseiMinchoW3':
                font = new PdfCjkStandardFont(PdfCjkFontFamily.heiseiMinchoW3, fontSize, style);
                break;
            default:
                if (annotation._dictionary.has('AP')) {
                    const fontData = _tryParseFontStream(annotation._dictionary, annotation._crossReference, annotation);
                    if (annotation._hasData) {
                        const base64String = _encode(fontData);
                        font = new PdfTrueTypeFont(base64String, fontSize, style);
                    }
                }
                break;
        }
    }
    if (font === null || typeof font === 'undefined') {
        if (annotation instanceof PdfAnnotation) {
            if (annotation._type !== _PdfAnnotationType.widgetAnnotation) {
                font = new PdfStandardFont(PdfFontFamily.helvetica, fontSize, style);
            }
            else {
                font = annotation._circleCaptionFont;
            }
        }
        else if (annotation instanceof PdfField) {
            font = annotation._circleCaptionFont;
        }
    }
    return font;
}
/**
 * Gets the font stream.
 *
 * @param {_PdfDictionary} widgetDictionary Widget dictionary.
 * @param {_PdfCrossReference} crossReference Cross reference.
 * @param {PdfAnnotation} annotation Annotation.
 * @returns {Uint8Array} result.
 */
function _tryParseFontStream(widgetDictionary, crossReference, annotation) {
    let fontData;
    const apperance = widgetDictionary.get('AP');
    if (apperance && apperance.has('N')) {
        const normal = apperance.get('N');
        if (normal && normal instanceof _PdfStream && normal.dictionary.has('Resources')) {
            const resourcesDictionary = normal.dictionary.get('Resources');
            if (resourcesDictionary && resourcesDictionary.has('Font')) {
                const fontDictionary = resourcesDictionary.get('Font');
                if (fontDictionary && fontDictionary instanceof _PdfDictionary) {
                    fontDictionary.forEach((key, value) => {
                        if (value) {
                            const dictionary = crossReference._fetch(value);
                            if (dictionary && dictionary.has('DescendantFonts')) {
                                let descendant = dictionary.getArray('DescendantFonts'); // eslint-disable-line
                                if (descendant && descendant.length > 0) {
                                    for (let i = 0; i < descendant.length; i++) {
                                        const descendantFont = descendant[Number.parseInt(i.toString(), 10)]; // eslint-disable-line
                                        if (descendantFont && descendantFont instanceof _PdfDictionary && descendantFont.has('FontDescriptor')) {
                                            const fontDescriptor = descendantFont.get('FontDescriptor');
                                            if (fontDescriptor && fontDescriptor.has('FontFile2')) {
                                                const fontFile = fontDescriptor.get('FontFile2');
                                                if (fontFile && fontFile instanceof _PdfStream && fontFile.length > 0) {
                                                    fontData = fontFile.getByteRange(fontFile.start, fontFile.end);
                                                    if (fontData && fontData.length > 0) {
                                                        annotation._hasData = true;
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    });
                }
            }
        }
    }
    return fontData;
}
/**
 * Gets the boolean if two arrays are equal.
 *
 * @param {Array<number[]>} inkPointsCollection Ink points collection.
 * @param {Array<number[]>} previousCollection Previous collection.
 * @returns {boolean} result.
 */
function _checkInkPoints(inkPointsCollection, previousCollection) {
    if (inkPointsCollection.length !== previousCollection.length) {
        return false;
    }
    for (let i = 0; i < inkPointsCollection.length; i++) {
        if (!_areArrayEqual(inkPointsCollection[Number.parseInt(i.toString(), 10)], previousCollection[Number.parseInt(i.toString(), 10)])) {
            return false;
        }
    }
    return true;
}

/* eslint-disable */
let nameCache = Object.create(null);
let cmdCache = Object.create(null);
let refCache = Object.create(null);
class _PdfName {
    constructor(name) {
        this.name = name;
    }
    static get(name) {
        return nameCache[name] || (nameCache[name] = new _PdfName(name));
    }
}
class _PdfCommand {
    constructor(command) {
        this.command = command;
    }
    static get(command) {
        return cmdCache[command] || (cmdCache[command] = new _PdfCommand(command));
    }
}
class _PdfReference {
    constructor(objectNumber, gen) {
        this._isNew = false;
        this.objectNumber = objectNumber;
        this.generationNumber = gen;
    }
    toString() {
        return `${this.objectNumber} ${this.generationNumber}`;
    }
    static get(objectNumber, generationNumber) {
        const key = generationNumber === 0 ? `${objectNumber}R` : `${objectNumber}R${generationNumber}`;
        return refCache[key] || (refCache[key] = new _PdfReference(objectNumber, generationNumber));
    }
}
class _PdfReferenceSet {
    constructor(parent = null) {
        this._set = new Set(parent && parent._set);
    }
    has(ref) {
        return this._set.has(ref.toString());
    }
    put(ref) {
        this._set.add(ref.toString());
    }
    remove(ref) {
        this._set.delete(ref.toString());
    }
    clear() {
        this._set.clear();
    }
}
class _PdfReferenceSetCache {
    constructor() {
        this._map = new Map();
    }
    get size() {
        return this._map.size;
    }
    get(ref) {
        return this._map.get(ref.toString());
    }
    has(ref) {
        return this._map.has(ref.toString());
    }
    put(ref, obj) {
        this._map.set(ref.toString(), obj);
    }
    set(objId, obj) {
        this._map.set(objId, obj);
    }
    clear() {
        this._map.clear();
    }
}
class Dictionary {
    constructor(toStringFunction) {
        this.table = {};
        this.nElements = 0;
        this.toStr = toStringFunction || _defaultToString;
    }
    getValue(key) {
        const pair = this.table['$' + this.toStr(key)];
        if (typeof pair === 'undefined') {
            return undefined;
        }
        return pair.value;
    }
    setValue(key, value) {
        let ret;
        const k = '$' + this.toStr(key);
        const previousElement = this.table[k];
        this.nElements++;
        ret = undefined;
        this.table[k] = {
            key: key,
            value: value
        };
        return ret;
    }
    keys() {
        const keysArray = [];
        let namesOfKeys = Object.keys(this.table);
        for (let index1 = 0; index1 < namesOfKeys.length; index1++) {
            const pair1 = this.table[namesOfKeys[index1]];
            keysArray.push(pair1.key);
        }
        return keysArray;
    }
    containsKey(key) {
        let retutnValue = true;
        if (typeof this.getValue(key) === 'undefined') {
            retutnValue = true;
        }
        else {
            retutnValue = false;
        }
        return !retutnValue;
    }
    _size() {
        return this.nElements;
    }
}
class _PdfDictionary {
    constructor(xref) {
        this._isFont = false;
        this._initialize(xref);
    }
    get size() {
        return Object.keys(this._map).length;
    }
    assignXref(xref) {
        this._crossReference = xref;
    }
    getRaw(key) {
        return this._map[key];
    }
    getRawValues() {
        return this._map.values;
    }
    get(key1, key2, key3) {
        let value = this._get(key1, key2, key3);
        if (this._crossReference && typeof value !== 'undefined' && value instanceof _PdfReference) {
            value = this._crossReference._fetch(value);
        }
        return value;
    }
    getArray(key1, key2, key3) {
        let value = this.get(key1, key2, key3);
        if (this._crossReference && typeof value !== 'undefined' && Array.isArray(value)) {
            value = value.slice();
            for (let i = 0; i < value.length; i++) {
                const reference = value[Number.parseInt(i.toString(), 10)];
                if (reference !== null && typeof reference !== 'undefined' && reference instanceof _PdfReference) {
                    value[Number.parseInt(i.toString(), 10)] = this._crossReference._fetch(reference);
                }
            }
        }
        return value;
    }
    set(key, value) {
        this._map[key] = value;
    }
    has(key) {
        return typeof this._map[key] !== 'undefined';
    }
    forEach(callback) {
        for (const key in this._map) {
            callback(key, this.getRaw(key));
        }
    }
    update(key, value) {
        if (this.has(key)) {
            let prevValue = this._map[key];
            if (prevValue !== null && typeof prevValue !== 'undefined' && prevValue instanceof _PdfReference && this._crossReference) {
                prevValue = this._crossReference._fetch(prevValue);
            }
            if (prevValue !== value) {
                this._map[key] = value;
                this._updated = true;
            }
        }
        else {
            this._map[key] = value;
            this._updated = true;
        }
    }
    static getEmpty(xref) {
        const emptyDict = new _PdfDictionary(xref);
        emptyDict.set = (key, value) => {
            throw new Error('Should not call set on the empty dictionary.');
        };
        return emptyDict;
    }
    static merge(xref, dictionaryArray, mergeSubDictionary = false) {
        const mergedDictionary = new _PdfDictionary(xref);
        const properties = Object.create(null);
        for (const dictionary of dictionaryArray) {
            if (!(dictionary instanceof _PdfDictionary)) {
                continue;
            }
            for (const [key, value] of dictionary._map) {
                let property = properties.get(key);
                if (typeof property === 'undefined') {
                    property = [];
                    properties.set(key, property);
                }
                else if (!mergeSubDictionary || !(value instanceof _PdfDictionary)) {
                    continue;
                }
                property.push(value);
            }
        }
        for (const [name, values] of properties) {
            if (values.length === 1 || !(values[0] instanceof _PdfDictionary)) {
                mergedDictionary._map[name] = values[0];
                continue;
            }
            const subDict = new _PdfDictionary(xref);
            for (const dictionary of values) {
                for (const [key, value] of dictionary._map) {
                    if (typeof subDict._map[key] === 'undefined') {
                        subDict._map[key] = value;
                    }
                }
            }
            if (subDict.size > 0) {
                mergedDictionary._map[name] = subDict;
            }
        }
        properties.clear();
        return mergedDictionary.size > 0 ? mergedDictionary : _PdfDictionary.getEmpty(xref);
    }
    _initialize(xref) {
        this._map = Object.create(null);
        this.suppressEncryption = false;
        this._updated = false;
        this.isCatalog = false;
        this._isNew = false;
        if (xref) {
            this._crossReference = xref;
        }
    }
    _get(key1, key2, key3) {
        let value = this._map[key1];
        if (typeof value === 'undefined') {
            value = this._map[key2];
            if (typeof key2 !== 'undefined' && key2 !== null) {
                value = this._map[key2];
            }
            else if (typeof key3 !== 'undefined' && key3 !== null) {
                value = this._map[key3];
            }
        }
        return value;
    }
}
class _PdfNull {
    constructor(value = []) {
        this.value = value;
    }
}
function _clearPrimitiveCaches() {
    nameCache = Object.create(null);
    cmdCache = Object.create(null);
    refCache = Object.create(null);
}
function _isName(value, name) {
    return value instanceof _PdfName && (typeof name === 'undefined' || value.name === name);
}
function _isCommand(value, command) {
    return value instanceof _PdfCommand && (typeof command === 'undefined' || value.command === command);
}

class _PdfBaseStream {
    constructor() {
        this._isCompress = true;
    }
    getByte() {
        return null;
    }
    getBytes(length) {
        return null;
    }
    get length() {
        throw new Error('Abstract getter `length` accessed');
    }
    get isEmpty() {
        throw new Error('Abstract getter `isEmpty` accessed');
    }
    get isDataLoaded() {
        return true;
    }
    peekByte() {
        const peekedByte = this.getByte();
        if (peekedByte !== -1) {
            this.offset--;
        }
        return peekedByte;
    }
    peekBytes(length) {
        const bytes = this.getBytes(length);
        this.offset -= bytes.length;
        return bytes;
    }
    getUnsignedInteger16() {
        const b0 = this.getByte();
        const b1 = this.getByte();
        if (b0 === -1 || b1 === -1) {
            return -1;
        }
        return (b0 << 8) + b1;
    }
    getInt32() {
        const b0 = this.getByte();
        const b1 = this.getByte();
        const b2 = this.getByte();
        const b3 = this.getByte();
        return (b0 << 24) + (b1 << 16) + (b2 << 8) + b3;
    }
    getByteRange(begin, end) {
        return null;
    }
    makeSubStream(start, length, dictionary) {
        return null;
    }
    readBlock() {
        return null;
    }
    reset() {
        return null;
    }
    moveStart() {
        return null;
    }
    getString(isHex = false) {
        const bytes = this.getBytes();
        if (typeof bytes === 'undefined' || bytes === null || typeof bytes.length === 'undefined') {
            throw new Error('Invalid argument for bytesToString');
        }
        if (isHex) {
            return _byteArrayToHexString(bytes);
        }
        else {
            const len = bytes.length;
            const max = 8192;
            if (len < max) {
                return String.fromCharCode.apply(null, bytes);
            }
            const stringBuffer = [];
            for (let i = 0; i < len; i += max) {
                stringBuffer.push(String.fromCharCode.apply(null, bytes.subarray(i, Math.min(i + max, len))));
            }
            return stringBuffer.join('');
        }
    }
    skip(n) {
        this.offset += n || 1;
    }
    getBaseStreams() {
        return null;
    }
}
class _PdfStream extends _PdfBaseStream {
    constructor(arrayBuffer, dictionary, start, length) {
        super();
        this.isImageStream = false;
        this.bytes = arrayBuffer instanceof Uint8Array ? arrayBuffer : new Uint8Array(arrayBuffer);
        if (typeof start !== 'undefined') {
            this.start = start;
        }
        else {
            this.start = 0;
        }
        this.position = this.start;
        this.end = start + length || this.bytes.length;
        this.dictionary = dictionary;
    }
    /**
     * Gets the position of the stream.
     *
     * @returns {number} offset position.
     */
    get position() {
        return this.offset;
    }
    /**
     * Sets the position of the stream.
     *
     * @param {number} value offset position.
     */
    set position(value) {
        this.offset = value;
    }
    /**
     * Gets the length of the stream (Read only).
     *
     * @returns {number} length.
     */
    get length() {
        return this.end - this.start;
    }
    /**
     * Gets a value indicating whether the stream is empty (Read only).
     *
     * @returns {boolean} stream empty or not.
     */
    get isEmpty() {
        return this.length === 0;
    }
    /**
     * Gets the data of the stream.
     *
     * @returns {string[]} data of the stream.
     */
    get data() {
        return this.dataStream2;
    }
    /**
     * Sets the data of the stream.
     *
     * @param {string[]} value data.
     */
    set data(value) {
        this.dataStream2 = [];
        this.dataStream2 = value;
    }
    getByte() {
        if (this.position >= this.end) {
            return -1;
        }
        return this.bytes[this.position++];
    }
    getBytes(length) {
        const bytes = this.bytes;
        const position = this.position;
        const strEnd = this.end;
        if (!length) {
            return bytes.subarray(position, strEnd);
        }
        let end = position + length;
        if (end > strEnd) {
            end = strEnd;
        }
        this.position = end;
        return bytes.subarray(position, end);
    }
    getByteRange(begin, end) {
        if (begin < 0) {
            begin = 0;
        }
        if (end > this.end) {
            end = this.end;
        }
        return this.bytes.subarray(begin, end);
    }
    reset() {
        this.position = this.start;
    }
    moveStart() {
        this.start = this.position;
    }
    makeSubStream(start, length, dictionary = null) {
        return new _PdfStream(this.bytes.buffer, dictionary, start, length);
    }
    readBlock() {
        throw new Error('Abstract method `readBlock` called');
    }
    _clearStream() {
        if (this.dictionary !== null && typeof this.dictionary !== 'undefined' && this.dictionary.has('Filter')) {
            delete this.dictionary._map.Filter;
        }
        this._isCompress = true;
        this.dictionary._updated = true;
    }
    _write(text) {
        this.bytes = new Uint8Array(text.length);
        for (let i = 0; i < text.length; i++) {
            this.bytes[Number.parseInt(i.toString(), 10)] = text.charCodeAt(i);
        }
        this.end = this.bytes.length;
        this.dictionary._updated = true;
    }
    _writeBytes(data) {
        let text = '';
        for (let i = 0; i < data.length; i++) {
            text = text + String.fromCharCode(data[Number.parseInt(i.toString(), 10)]);
        }
        this.bytes = new Uint8Array(data);
        this.end = this.bytes.length;
        this.dictionary._updated = true;
    }
}
class _PdfContentStream extends _PdfBaseStream {
    get length() {
        return this._bytes.length;
    }
    constructor(bytes) {
        super();
        this._bytes = bytes;
        this.dictionary = new _PdfDictionary();
        this.dictionary._updated = true;
    }
    write(data) {
        if (typeof data === 'string') {
            for (let i = 0; i < data.length; i++) {
                this._bytes.push(data.charCodeAt(i));
            }
        }
        else {
            for (let i = 0; i < data.length; i++) {
                this._bytes.push(data[Number.parseInt(i.toString(), 10)]);
            }
        }
        this.dictionary._updated = true;
    }
    getString(isHex = false) {
        const bytes = new Uint8Array(this._bytes);
        if (typeof bytes === 'undefined' || bytes === null || typeof bytes.length === 'undefined') {
            throw new Error('Invalid argument for bytesToString');
        }
        if (isHex) {
            return _byteArrayToHexString(bytes);
        }
        else {
            const len = bytes.length;
            const max = 8192;
            if (len < max) {
                return String.fromCharCode.apply(null, bytes);
            }
            const stringBuffer = [];
            for (let i = 0; i < len; i += max) {
                stringBuffer.push(String.fromCharCode.apply(null, bytes.subarray(i, Math.min(i + max, len))));
            }
            return stringBuffer.join('');
        }
    }
}
class _PdfNullStream extends _PdfStream {
    constructor() {
        super(new Uint8Array(0));
    }
}

class _ContentParser {
    constructor(contentStream) {
        this._recordCollection = [];
        this._operands = [];
        this._lexer = new _ContentLexer(contentStream);
    }
    _readContent() {
        this._parseObject(_TokenType.eof);
        return this._recordCollection;
    }
    _parseObject(tokenType) {
        let symbol;
        while ((symbol = this._getNextToken()) !== _TokenType.eof) { // eslint-disable-line
            if (symbol === tokenType || symbol === _TokenType.none) {
                return;
            }
            switch (symbol) {
                case _TokenType.comment:
                    break;
                case _TokenType.number:
                    if (this._lexer._operatorParams === '-') {
                        this._operands.push('0');
                    }
                    else {
                        this._operands.push(this._lexer._operatorParams);
                    }
                    break;
                case _TokenType.real:
                    this._operands.push(this._lexer._operatorParams);
                    break;
                case _TokenType.string:
                case _TokenType.hexString:
                case _TokenType.unicodeHexString:
                case _TokenType.unicodeString:
                    this._operands.push(this._lexer._operatorParams);
                    break;
                case _TokenType.name:
                    this._operands.push(this._lexer._operatorParams);
                    break;
                case _TokenType.operator:
                    this._createRecord();
                    this._operands = [];
                    break;
                case _TokenType.beginArray:
                    break;
                case _TokenType.endArray:
                    throw new Error('Error while parsing content');
            }
        }
    }
    _createRecord() {
        const operand = this._lexer._operatorParams;
        const record = new _PdfRecord(operand, this._operands);
        this._recordCollection.push(record);
    }
    _getNextToken() {
        return this._lexer._getNextToken();
    }
}
class _ContentLexer {
    constructor(data) {
        this._tokenType = _TokenType.none;
        this._currentCharacter = '\0';
        this._nextCharacter = '\0';
        this._offset = 0;
        this._data = data instanceof Uint8Array ? data : new Uint8Array(data);
    }
    _getNextToken() {
        this._operatorParams = '';
        const value = this._moveToNextChar();
        switch (value) {
            case '%':
                return this._tokenType = this._getComment();
            case '/':
                return this._tokenType = this._getName();
            case '[':
            case '(':
                return this._tokenType = this._getLiteralString();
            case '+':
            case '-':
                return this._tokenType = this._getNumber();
            case '<':
                return this._tokenType = this._getEncodedDecimalString();
            case '.':
                return this._tokenType = this._getNumber();
            case '"':
            case '\'':
                return this._tokenType = this._getOperator();
        }
        if (!isNaN(parseInt(value, 10))) {
            return this._tokenType = this._getNumber();
        }
        if ((/[a-zA-Z]/).test(value)) {
            return this._tokenType = this._getOperator();
        }
        if (value === String.fromCharCode(65535)) {
            return this._tokenType = _TokenType.eof;
        }
        return this._tokenType = _TokenType.none;
    }
    _getComment() {
        this._operatorParams = '';
        let value;
        let flag = (value = this._consumeValue()) !== '\x0A' && value !== String.fromCharCode(65535);
        while (flag) {
            flag = (value = this._consumeValue()) !== '\x0A' && value !== String.fromCharCode(65535);
        }
        return _TokenType.comment;
    }
    _getName() {
        this._operatorParams = '';
        let flag = false;
        while (!flag) {
            const value = this._consumeValue();
            switch (value) {
                case '\0':
                case '\t':
                case '\x0A':
                case '\f':
                case '\x0D':
                case '\b':
                case ' ':
                case '%':
                case '(':
                case ')':
                case '<':
                case '>':
                case '[':
                case ']':
                case '/':
                    flag = true;
                    return _TokenType.name;
                default:
                    break;
            }
        }
        return _TokenType.none;
    }
    _getNumber() {
        let value = this._currentCharacter;
        if (value === '+' || value === '-') {
            this._operatorParams += this._currentCharacter;
            value = this._getNextChar();
        }
        while (!isNaN(parseInt(value, 10)) || value === '.') {
            if (!isNaN(parseInt(value, 10))) {
                this._operatorParams += this._currentCharacter;
            }
            else if (value === '.') {
                if (this._operatorParams.includes('.')) {
                    break;
                }
                else {
                    this._operatorParams += this._currentCharacter;
                }
            }
            value = this._getNextChar();
        }
        return _TokenType.number;
    }
    _getOperator() {
        this._operatorParams = '';
        let value = this._currentCharacter;
        while (this._isOperator(value)) {
            value = this._consumeValue();
        }
        return _TokenType.operator;
    }
    _isOperator(value) {
        if ((/[a-zA-Z]/).test(value)) {
            return true;
        }
        switch (value) {
            case '*':
            case '\'':
            case '\"': // eslint-disable-line
            case '1':
            case '0':
                return true;
        }
        return false;
    }
    _getLiteralString() {
        this._operatorParams = '';
        const beginChar = this._currentCharacter;
        let literal;
        let value = this._consumeValue();
        let flag = true;
        while (flag) {
            if (beginChar === '(') {
                literal = this._getLiteralStringValue(value);
                this._operatorParams += literal;
                value = this._getNextChar();
                flag = false;
                break;
            }
            else {
                if (value === '(') {
                    value = this._consumeValue();
                    literal = this._getLiteralStringValue(value);
                    this._operatorParams += literal;
                    value = this._getNextChar();
                    continue;
                }
                else if (value === ']') {
                    flag = false;
                    value = this._consumeValue();
                    break;
                }
                value = this._consumeValue();
            }
        }
        return _TokenType.string;
    }
    _getEncodedDecimalString() {
        const startChar = '<';
        const endChar = '>';
        const space = ' ';
        let parentLevel = 0;
        let value = this._consumeValue();
        let flag = true;
        while (flag) {
            if (value === startChar) {
                parentLevel++;
                value = this._consumeValue();
            }
            else if (value === endChar) {
                if (parentLevel === 0) {
                    this._consumeValue();
                    flag = false;
                    break;
                }
                else if (parentLevel === 1) {
                    value = this._consumeValue();
                    if (value === '>') {
                        parentLevel--;
                    }
                    if (parentLevel === 1 && value === space) {
                        flag = false;
                        break;
                    }
                }
                else {
                    if (value === '>') {
                        parentLevel--;
                    }
                    value = this._consumeValue();
                }
            }
            else {
                value = this._consumeValue();
                if (value === String.fromCharCode(65535)) {
                    flag = false;
                    break;
                }
            }
        }
        return _TokenType.hexString;
    }
    _getLiteralStringValue(value) {
        let parenthesesCount = 0;
        let literal = '';
        let flag = true;
        while (flag) {
            if (value === '\\') {
                literal += value;
                value = this._getNextChar();
                literal += value;
                value = this._getNextChar();
                continue;
            }
            if (value === '(') {
                parenthesesCount++;
                literal += value;
                value = this._getNextChar();
                continue;
            }
            if (value === ')' && parenthesesCount !== 0) {
                literal += value;
                value = this._getNextChar();
                parenthesesCount--;
                continue;
            }
            if (value === ')' && parenthesesCount === 0) {
                literal += value;
                flag = false;
                return literal;
            }
            literal += value;
            value = this._getNextChar();
        }
        return literal;
    }
    _consumeValue() {
        this._operatorParams += this._currentCharacter;
        return this._getNextChar();
    }
    _moveToNextChar() {
        while (this._currentCharacter !== String.fromCharCode(65535)) {
            switch (this._currentCharacter) {
                case '\0':
                case '\t':
                case '\x0A':
                case '\f':
                case '\x0D':
                case '\b':
                case ' ':
                    this._getNextChar();
                    break;
                default:
                    return this._currentCharacter;
            }
        }
        return this._currentCharacter;
    }
    _getNextChar() {
        if (this._data.length <= this._offset) {
            if (this._nextCharacter === 'Q' || (this._currentCharacter === 'D' && this._nextCharacter === 'o')) {
                this._currentCharacter = this._nextCharacter;
                this._nextCharacter = String.fromCharCode(65535);
                return this._currentCharacter;
            }
            this._currentCharacter = String.fromCharCode(65535);
            this._nextCharacter = String.fromCharCode(65535);
        }
        else {
            this._currentCharacter = this._nextCharacter;
            this._nextCharacter = String.fromCharCode(this._data[this._offset++]);
            if (this._currentCharacter === '\x0D') {
                if (this._nextCharacter === '\x0A') {
                    this._currentCharacter = this._nextCharacter;
                    if (this._data.length <= this._offset) {
                        this._nextCharacter = String.fromCharCode(65535);
                    }
                    else {
                        this._nextCharacter = String.fromCharCode(this._data[this._offset++]);
                    }
                }
                else {
                    this._currentCharacter = '\x0A';
                }
            }
        }
        return this._currentCharacter;
    }
}
class _PdfRecord {
    constructor(operator, operands) {
        this._operator = operator;
        this._operands = operands;
    }
}

class _PdfDecodeStream extends _PdfBaseStream {
    constructor(maybeMinBufferLength) {
        super();
        this._rawMinBufferLength = maybeMinBufferLength || 0;
        this.offset = 0;
        this.bufferLength = 0;
        this.eof = false;
        this.buffer = new Uint8Array(0);
        this.minBufferLength = 512;
        if (maybeMinBufferLength) {
            while (this.minBufferLength < maybeMinBufferLength) {
                this.minBufferLength *= 2;
            }
        }
    }
    get isEmpty() {
        while (!this.eof && this.bufferLength === 0) {
            this.readBlock();
        }
        return this.bufferLength === 0;
    }
    ensureBuffer(requested) {
        const buffer = this.buffer;
        if (requested <= buffer.byteLength) {
            return buffer;
        }
        let size = this.minBufferLength;
        while (size < requested) {
            size *= 2;
        }
        const buffer2 = new Uint8Array(size);
        buffer2.set(buffer);
        this.buffer = buffer2;
        return this.buffer;
    }
    getByte() {
        const position = this.offset;
        while (this.bufferLength <= position) {
            if (this.eof) {
                return -1;
            }
            this.readBlock();
        }
        return this.buffer[this.offset++];
    }
    getBytes(length) {
        const position = this.offset;
        let end;
        if (length) {
            this.ensureBuffer(position + length);
            end = position + length;
            while (!this.eof && this.bufferLength < end) {
                this.readBlock();
            }
            const bufEnd = this.bufferLength;
            if (end > bufEnd) {
                end = bufEnd;
            }
        }
        else {
            while (!this.eof) {
                this.readBlock();
            }
            end = this.bufferLength;
        }
        this.offset = end;
        return this.buffer.subarray(position, end);
    }
    reset() {
        this.offset = 0;
    }
    makeSubStream(start, length, dictionary) {
        if (length === undefined) {
            while (!this.eof) {
                this.readBlock();
            }
        }
        else {
            const end = start + length;
            while (this.bufferLength <= end && !this.eof) {
                this.readBlock();
            }
        }
        return new _PdfStream(this.buffer, dictionary, start, length);
    }
    getBaseStreams() {
        return this.stream ? this.stream.getBaseStreams() : null;
    }
    moveStart() {
        throw new Error('Invalid call from decode stream');
    }
    getByteRange(begin, end) {
        throw new Error('Invalid call from decode stream. begin: ' + begin + ', end: ' + end);
    }
    readBlock() {
        throw new Error('Invalid call from decode stream');
    }
}

class _PdfDecryptStream extends _PdfDecodeStream {
    constructor(stream, maybeLength, cipher) {
        super(maybeLength);
        this._chunkSize = 512;
        this.stream = stream;
        this.dictionary = stream.dictionary;
        this._cipher = cipher;
        this._nextChunk = null;
        this._initialized = false;
    }
    readBlock() {
        let chunk;
        if (this._initialized) {
            chunk = this._nextChunk;
        }
        else {
            chunk = this.stream.getBytes(this._chunkSize);
            this._initialized = true;
        }
        if (!chunk || chunk.length === 0) {
            this.eof = true;
            return;
        }
        this._nextChunk = this.stream.getBytes(this._chunkSize);
        const hasMoreData = this._nextChunk && this._nextChunk.length > 0;
        chunk = this._cipher._decryptBlock(chunk, !hasMoreData);
        let bufferLength = this.bufferLength;
        const n = chunk.length;
        const buffer = this.ensureBuffer(bufferLength + n);
        for (let i = 0; i < n; i++) {
            buffer[bufferLength++] = chunk[Number.parseInt(i.toString(), 10)];
        }
        this.bufferLength = bufferLength;
    }
}

const codeLenCodeMap = new Int32Array([
    16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15
]);
const lengthDecode = new Int32Array([
    0x00003, 0x00004, 0x00005, 0x00006, 0x00007, 0x00008, 0x00009, 0x0000a,
    0x1000b, 0x1000d, 0x1000f, 0x10011, 0x20013, 0x20017, 0x2001b, 0x2001f,
    0x30023, 0x3002b, 0x30033, 0x3003b, 0x40043, 0x40053, 0x40063, 0x40073,
    0x50083, 0x500a3, 0x500c3, 0x500e3, 0x00102, 0x00102, 0x00102
]);
const distDecode = new Int32Array([
    0x00001, 0x00002, 0x00003, 0x00004, 0x10005, 0x10007, 0x20009, 0x2000d,
    0x30011, 0x30019, 0x40021, 0x40031, 0x50041, 0x50061, 0x60081, 0x600c1,
    0x70101, 0x70181, 0x80201, 0x80301, 0x90401, 0x90601, 0xa0801, 0xa0c01,
    0xb1001, 0xb1801, 0xc2001, 0xc3001, 0xd4001, 0xd6001
]);
const fixedLitCodeTab = [
    new Int32Array([
        0x70100, 0x80050, 0x80010, 0x80118, 0x70110, 0x80070, 0x80030, 0x900c0,
        0x70108, 0x80060, 0x80020, 0x900a0, 0x80000, 0x80080, 0x80040, 0x900e0,
        0x70104, 0x80058, 0x80018, 0x90090, 0x70114, 0x80078, 0x80038, 0x900d0,
        0x7010c, 0x80068, 0x80028, 0x900b0, 0x80008, 0x80088, 0x80048, 0x900f0,
        0x70102, 0x80054, 0x80014, 0x8011c, 0x70112, 0x80074, 0x80034, 0x900c8,
        0x7010a, 0x80064, 0x80024, 0x900a8, 0x80004, 0x80084, 0x80044, 0x900e8,
        0x70106, 0x8005c, 0x8001c, 0x90098, 0x70116, 0x8007c, 0x8003c, 0x900d8,
        0x7010e, 0x8006c, 0x8002c, 0x900b8, 0x8000c, 0x8008c, 0x8004c, 0x900f8,
        0x70101, 0x80052, 0x80012, 0x8011a, 0x70111, 0x80072, 0x80032, 0x900c4,
        0x70109, 0x80062, 0x80022, 0x900a4, 0x80002, 0x80082, 0x80042, 0x900e4,
        0x70105, 0x8005a, 0x8001a, 0x90094, 0x70115, 0x8007a, 0x8003a, 0x900d4,
        0x7010d, 0x8006a, 0x8002a, 0x900b4, 0x8000a, 0x8008a, 0x8004a, 0x900f4,
        0x70103, 0x80056, 0x80016, 0x8011e, 0x70113, 0x80076, 0x80036, 0x900cc,
        0x7010b, 0x80066, 0x80026, 0x900ac, 0x80006, 0x80086, 0x80046, 0x900ec,
        0x70107, 0x8005e, 0x8001e, 0x9009c, 0x70117, 0x8007e, 0x8003e, 0x900dc,
        0x7010f, 0x8006e, 0x8002e, 0x900bc, 0x8000e, 0x8008e, 0x8004e, 0x900fc,
        0x70100, 0x80051, 0x80011, 0x80119, 0x70110, 0x80071, 0x80031, 0x900c2,
        0x70108, 0x80061, 0x80021, 0x900a2, 0x80001, 0x80081, 0x80041, 0x900e2,
        0x70104, 0x80059, 0x80019, 0x90092, 0x70114, 0x80079, 0x80039, 0x900d2,
        0x7010c, 0x80069, 0x80029, 0x900b2, 0x80009, 0x80089, 0x80049, 0x900f2,
        0x70102, 0x80055, 0x80015, 0x8011d, 0x70112, 0x80075, 0x80035, 0x900ca,
        0x7010a, 0x80065, 0x80025, 0x900aa, 0x80005, 0x80085, 0x80045, 0x900ea,
        0x70106, 0x8005d, 0x8001d, 0x9009a, 0x70116, 0x8007d, 0x8003d, 0x900da,
        0x7010e, 0x8006d, 0x8002d, 0x900ba, 0x8000d, 0x8008d, 0x8004d, 0x900fa,
        0x70101, 0x80053, 0x80013, 0x8011b, 0x70111, 0x80073, 0x80033, 0x900c6,
        0x70109, 0x80063, 0x80023, 0x900a6, 0x80003, 0x80083, 0x80043, 0x900e6,
        0x70105, 0x8005b, 0x8001b, 0x90096, 0x70115, 0x8007b, 0x8003b, 0x900d6,
        0x7010d, 0x8006b, 0x8002b, 0x900b6, 0x8000b, 0x8008b, 0x8004b, 0x900f6,
        0x70103, 0x80057, 0x80017, 0x8011f, 0x70113, 0x80077, 0x80037, 0x900ce,
        0x7010b, 0x80067, 0x80027, 0x900ae, 0x80007, 0x80087, 0x80047, 0x900ee,
        0x70107, 0x8005f, 0x8001f, 0x9009e, 0x70117, 0x8007f, 0x8003f, 0x900de,
        0x7010f, 0x8006f, 0x8002f, 0x900be, 0x8000f, 0x8008f, 0x8004f, 0x900fe,
        0x70100, 0x80050, 0x80010, 0x80118, 0x70110, 0x80070, 0x80030, 0x900c1,
        0x70108, 0x80060, 0x80020, 0x900a1, 0x80000, 0x80080, 0x80040, 0x900e1,
        0x70104, 0x80058, 0x80018, 0x90091, 0x70114, 0x80078, 0x80038, 0x900d1,
        0x7010c, 0x80068, 0x80028, 0x900b1, 0x80008, 0x80088, 0x80048, 0x900f1,
        0x70102, 0x80054, 0x80014, 0x8011c, 0x70112, 0x80074, 0x80034, 0x900c9,
        0x7010a, 0x80064, 0x80024, 0x900a9, 0x80004, 0x80084, 0x80044, 0x900e9,
        0x70106, 0x8005c, 0x8001c, 0x90099, 0x70116, 0x8007c, 0x8003c, 0x900d9,
        0x7010e, 0x8006c, 0x8002c, 0x900b9, 0x8000c, 0x8008c, 0x8004c, 0x900f9,
        0x70101, 0x80052, 0x80012, 0x8011a, 0x70111, 0x80072, 0x80032, 0x900c5,
        0x70109, 0x80062, 0x80022, 0x900a5, 0x80002, 0x80082, 0x80042, 0x900e5,
        0x70105, 0x8005a, 0x8001a, 0x90095, 0x70115, 0x8007a, 0x8003a, 0x900d5,
        0x7010d, 0x8006a, 0x8002a, 0x900b5, 0x8000a, 0x8008a, 0x8004a, 0x900f5,
        0x70103, 0x80056, 0x80016, 0x8011e, 0x70113, 0x80076, 0x80036, 0x900cd,
        0x7010b, 0x80066, 0x80026, 0x900ad, 0x80006, 0x80086, 0x80046, 0x900ed,
        0x70107, 0x8005e, 0x8001e, 0x9009d, 0x70117, 0x8007e, 0x8003e, 0x900dd,
        0x7010f, 0x8006e, 0x8002e, 0x900bd, 0x8000e, 0x8008e, 0x8004e, 0x900fd,
        0x70100, 0x80051, 0x80011, 0x80119, 0x70110, 0x80071, 0x80031, 0x900c3,
        0x70108, 0x80061, 0x80021, 0x900a3, 0x80001, 0x80081, 0x80041, 0x900e3,
        0x70104, 0x80059, 0x80019, 0x90093, 0x70114, 0x80079, 0x80039, 0x900d3,
        0x7010c, 0x80069, 0x80029, 0x900b3, 0x80009, 0x80089, 0x80049, 0x900f3,
        0x70102, 0x80055, 0x80015, 0x8011d, 0x70112, 0x80075, 0x80035, 0x900cb,
        0x7010a, 0x80065, 0x80025, 0x900ab, 0x80005, 0x80085, 0x80045, 0x900eb,
        0x70106, 0x8005d, 0x8001d, 0x9009b, 0x70116, 0x8007d, 0x8003d, 0x900db,
        0x7010e, 0x8006d, 0x8002d, 0x900bb, 0x8000d, 0x8008d, 0x8004d, 0x900fb,
        0x70101, 0x80053, 0x80013, 0x8011b, 0x70111, 0x80073, 0x80033, 0x900c7,
        0x70109, 0x80063, 0x80023, 0x900a7, 0x80003, 0x80083, 0x80043, 0x900e7,
        0x70105, 0x8005b, 0x8001b, 0x90097, 0x70115, 0x8007b, 0x8003b, 0x900d7,
        0x7010d, 0x8006b, 0x8002b, 0x900b7, 0x8000b, 0x8008b, 0x8004b, 0x900f7,
        0x70103, 0x80057, 0x80017, 0x8011f, 0x70113, 0x80077, 0x80037, 0x900cf,
        0x7010b, 0x80067, 0x80027, 0x900af, 0x80007, 0x80087, 0x80047, 0x900ef,
        0x70107, 0x8005f, 0x8001f, 0x9009f, 0x70117, 0x8007f, 0x8003f, 0x900df,
        0x7010f, 0x8006f, 0x8002f, 0x900bf, 0x8000f, 0x8008f, 0x8004f, 0x900ff
    ]),
    9
];
const fixedDistCodeTab = [
    new Int32Array([
        0x50000, 0x50010, 0x50008, 0x50018, 0x50004, 0x50014, 0x5000c, 0x5001c,
        0x50002, 0x50012, 0x5000a, 0x5001a, 0x50006, 0x50016, 0x5000e, 0x00000,
        0x50001, 0x50011, 0x50009, 0x50019, 0x50005, 0x50015, 0x5000d, 0x5001d,
        0x50003, 0x50013, 0x5000b, 0x5001b, 0x50007, 0x50017, 0x5000f, 0x00000
    ]),
    5
];
class _PdfFlateStream extends _PdfDecodeStream {
    constructor(stream, maybeLength) {
        super(maybeLength);
        this.stream = stream;
        this.dictionary = stream.dictionary;
        const cmf = stream.getByte();
        const flg = stream.getByte();
        if ((cmf & 0x0f) !== 0x08) {
            throw new FormatError(`Unknown compression method in flate stream: ${cmf}, ${flg}`);
        }
        if (((cmf << 8) + flg) % 31 !== 0) {
            throw new FormatError(`Bad flag check in flate stream: ${cmf}, ${flg}`);
        }
        if (flg & 0x20) {
            throw new FormatError(`Bad flag bit set in flate stream: ${cmf}, ${flg}`);
        }
        this.codeSize = 0;
        this.codeBuffer = 0;
    }
    getBits(bits) {
        const stream = this.stream;
        let codeSize = this.codeSize;
        let codeBuffer = this.codeBuffer;
        let b;
        while (codeSize < bits) {
            b = stream.getByte();
            codeBuffer |= b << codeSize;
            codeSize += 8;
        }
        b = codeBuffer & ((1 << bits) - 1);
        this.codeBuffer = codeBuffer >> bits;
        this.codeSize = codeSize -= bits;
        return b;
    }
    getCode(table) {
        const stream = this.stream;
        const codes = table[0];
        const maxLen = table[1];
        let codeSize = this.codeSize;
        let codeBuffer = this.codeBuffer;
        let b;
        while (codeSize < maxLen) {
            b = stream.getByte();
            codeBuffer |= b << codeSize;
            codeSize += 8;
        }
        const code = codes[codeBuffer & ((1 << maxLen) - 1)];
        const codeLen = code >> 16;
        const codeVal = code & 0xffff;
        if (!(codeLen < 1 || codeSize < codeLen)) {
            this.codeBuffer = codeBuffer >> codeLen;
            this.codeSize = codeSize - codeLen;
        }
        return codeVal;
    }
    generateHuffmanTable(lengths) {
        const n = lengths.length;
        let maximumLength = 0;
        let i;
        for (i = 0; i < n; ++i) {
            if (lengths[i] > maximumLength) { // eslint-disable-line
                maximumLength = lengths[i]; // eslint-disable-line
            }
        }
        const size = 1 << maximumLength;
        const codes = new Int32Array(size);
        for (let len = 1, code = 0, skip = 2; len <= maximumLength; ++len, code <<= 1, skip <<= 1) {
            for (let val = 0; val < n; ++val) {
                if (lengths[val] === len) { // eslint-disable-line
                    let code2 = 0;
                    let t = code;
                    for (i = 0; i < len; ++i) {
                        code2 = (code2 << 1) | (t & 1);
                        t >>= 1;
                    }
                    for (i = code2; i < size; i += skip) {
                        codes[i] = (len << 16) | val; // eslint-disable-line
                    }
                    ++code;
                }
            }
        }
        return [codes, maximumLength];
    }
    readBlock() {
        let buffer;
        let length;
        const stream = this.stream;
        let hdr = this.getBits(3);
        if (hdr & 1) {
            this.eof = true;
        }
        hdr >>= 1;
        if (hdr === 0) {
            let b = stream.getByte();
            let blockLen = b;
            b = stream.getByte();
            blockLen |= b << 8;
            b = stream.getByte();
            let check = b;
            b = stream.getByte();
            check |= b << 8;
            if (!(check !== (~blockLen & 0xffff) && (blockLen !== 0 || check !== 0))) {
                this.codeBuffer = 0;
                this.codeSize = 0;
                const bufferLength = this.bufferLength;
                const end = bufferLength + blockLen;
                buffer = this.ensureBuffer(end);
                this.bufferLength = end;
                if (blockLen === 0) {
                    if (stream.peekByte() === -1) {
                        this.eof = true;
                    }
                }
                else {
                    const block = stream.getBytes(blockLen);
                    buffer.set(block, bufferLength);
                    if (block.length < blockLen) {
                        this.eof = true;
                    }
                }
                return;
            }
        }
        let litCodeTable;
        let distCodeTable;
        if (hdr === 1) {
            litCodeTable = fixedLitCodeTab;
            distCodeTable = fixedDistCodeTab;
        }
        else if (hdr === 2) {
            const numLitCodes = this.getBits(5) + 257;
            const numDistCodes = this.getBits(5) + 1;
            const numCodeLenCodes = this.getBits(4) + 4;
            const codeLenCodeLengths = new Uint8Array(codeLenCodeMap.length);
            let i;
            for (i = 0; i < numCodeLenCodes; ++i) {
                codeLenCodeLengths[codeLenCodeMap[i]] = this.getBits(3); // eslint-disable-line
            }
            const codeLenCodeTab = this.generateHuffmanTable(codeLenCodeLengths);
            length = 0;
            i = 0;
            const codes = numLitCodes + numDistCodes;
            const codeLengths = new Uint8Array(codes);
            let bitsLength;
            let bitsOffset;
            let what;
            while (i < codes) {
                const code = this.getCode(codeLenCodeTab);
                if (code === 16) {
                    bitsLength = 2;
                    bitsOffset = 3;
                    what = length;
                }
                else if (code === 17) {
                    bitsLength = 3;
                    bitsOffset = 3;
                    what = length = 0;
                }
                else if (code === 18) {
                    bitsLength = 7;
                    bitsOffset = 11;
                    what = length = 0;
                }
                else {
                    codeLengths[i++] = length = code;
                    continue;
                }
                let repeatLength = this.getBits(bitsLength) + bitsOffset;
                while (repeatLength-- > 0) {
                    codeLengths[i++] = what;
                }
            }
            litCodeTable = this.generateHuffmanTable(codeLengths.subarray(0, numLitCodes));
            distCodeTable = this.generateHuffmanTable(codeLengths.subarray(numLitCodes, codes));
        }
        buffer = this.buffer;
        let limit = buffer ? buffer.length : 0;
        let position = this.bufferLength;
        while (true) { // eslint-disable-line
            let code1 = this.getCode(litCodeTable);
            if (code1 < 256) {
                if (position + 1 >= limit) {
                    buffer = this.ensureBuffer(position + 1);
                    limit = buffer.length;
                }
                buffer[position++] = code1;
                continue;
            }
            if (code1 === 256) {
                this.bufferLength = position;
                return;
            }
            code1 -= 257;
            code1 = lengthDecode[code1]; // eslint-disable-line
            let code2 = code1 >> 16;
            if (code2 > 0) {
                code2 = this.getBits(code2);
            }
            length = (code1 & 0xffff) + code2;
            code1 = this.getCode(distCodeTable);
            code1 = distDecode[code1]; // eslint-disable-line
            code2 = code1 >> 16;
            if (code2 > 0) {
                code2 = this.getBits(code2);
            }
            const dist = (code1 & 0xffff) + code2;
            if (position + length >= limit) {
                buffer = this.ensureBuffer(position + length);
                limit = buffer.length;
            }
            for (let k = 0; k < length; ++k, ++position) {
                buffer[position] = buffer[position - dist]; // eslint-disable-line
            }
        }
    }
}

class _PdfCatalog {
    constructor(xref) {
        this._crossReference = xref;
        this._catalogDictionary = xref._getCatalogObj();
        if (!(this._catalogDictionary instanceof _PdfDictionary)) {
            throw new FormatError('Catalog object is not a dictionary.');
        }
        else {
            this._catalogDictionary.isCatalog = true;
        }
        this._topPagesDictionary = this._catalogDictionary.get('Pages');
        this.pageKidsCountCache = new _PdfReferenceSetCache();
        this.pageIndexCache = new _PdfReferenceSetCache();
    }
    get version() {
        let value;
        if (this._catalogDictionary.has('Version')) {
            const version = this._catalogDictionary.get('Version');
            if (version) {
                value = version.name;
            }
        }
        return value;
    }
    get pageCount() {
        const obj = this._topPagesDictionary.get('Count');
        if (typeof obj === 'undefined' || !Number.isInteger(obj)) {
            throw new FormatError('Invalid page count');
        }
        return obj;
    }
    get acroForm() {
        let form;
        if (this._catalogDictionary.has('AcroForm')) {
            form = this._catalogDictionary.get('AcroForm');
        }
        if (form === null || typeof form === 'undefined') {
            form = this._createForm();
        }
        return form;
    }
    /* eslint-disable */
    _createForm() {
        const form = new _PdfDictionary(this._crossReference);
        const ref = this._crossReference._getNextReference();
        this._crossReference._cacheMap.set(ref, form);
        this._catalogDictionary.set('AcroForm', ref);
        this._catalogDictionary._updated = true;
        return form;
    }
    getPageDictionary(pageIndex) {
        const nodesToVisit = [this._topPagesDictionary];
        const visitedNodes = new _PdfReferenceSet();
        const pagesRef = this._catalogDictionary.getRaw('Pages');
        if (pagesRef instanceof _PdfReference) {
            visitedNodes.put(pagesRef);
        }
        const xref = this._crossReference;
        const pageKidsCountCache = this.pageKidsCountCache;
        const pageIndexCache = this.pageIndexCache;
        let currentPageIndex = 0;
        while (nodesToVisit.length > 0) {
            const currentNode = nodesToVisit.pop();
            if (currentNode !== null && typeof currentNode !== 'undefined' && currentNode instanceof _PdfReference) {
                const count = pageKidsCountCache.get(currentNode);
                if (count >= 0 && currentPageIndex + count <= pageIndex) {
                    currentPageIndex += count;
                    continue;
                }
                if (visitedNodes.has(currentNode)) {
                    throw new FormatError('Pages tree contains circular reference.');
                }
                visitedNodes.put(currentNode);
                const obj = xref._fetch(currentNode);
                if (obj instanceof _PdfDictionary) {
                    let type = obj.getRaw('Type');
                    if (type !== null && typeof type !== 'undefined' && type instanceof _PdfReference) {
                        type = xref._fetch(type);
                    }
                    if (_isName(type, 'Page') || !obj.has('Kids')) {
                        if (!pageKidsCountCache.has(currentNode)) {
                            pageKidsCountCache.put(currentNode, 1);
                        }
                        if (!pageIndexCache.has(currentNode)) {
                            pageIndexCache.put(currentNode, currentPageIndex);
                        }
                        if (currentPageIndex === pageIndex) {
                            return { dictionary: obj, reference: currentNode };
                        }
                        currentPageIndex++;
                        continue;
                    }
                }
                nodesToVisit.push(obj);
                continue;
            }
            if (!(currentNode instanceof _PdfDictionary)) {
                throw new FormatError('Page dictionary kid reference points to wrong type of object.');
            }
            const { objId } = currentNode;
            let count = currentNode.get('Count');
            if (count !== null && typeof count !== 'undefined' && count instanceof _PdfReference) {
                count = xref._fetch(count);
            }
            if (count !== null && typeof count !== 'undefined' && Number.isInteger(count) && count >= 0) {
                if (objId && !pageKidsCountCache.has(objId)) {
                    pageKidsCountCache.set(objId, count);
                }
                if (currentPageIndex + count <= pageIndex) {
                    currentPageIndex += count;
                    continue;
                }
            }
            let kids = currentNode.getRaw('Kids');
            if (kids !== null && typeof kids !== 'undefined' && kids instanceof _PdfReference) {
                kids = xref._fetch(kids);
            }
            if (!Array.isArray(kids)) {
                let type = currentNode.getRaw('Type');
                if (type !== null && typeof type !== 'undefined' && type instanceof _PdfReference) {
                    type = xref._fetch(type);
                }
                if (_isName(type, 'Page') || !currentNode.has('Kids')) {
                    if (currentPageIndex === pageIndex) {
                        return { dictionary: currentNode, reference: null };
                    }
                    currentPageIndex++;
                    continue;
                }
                throw new FormatError('Page dictionary kids object is not an array.');
            }
            for (let last = kids.length - 1; last >= 0; last--) {
                nodesToVisit.push(kids[last]);
            }
        }
        throw new Error(`Page index ${pageIndex} not found.`);
    }
    _destroy() {
        if (this._catalogDictionary) {
            this._catalogDictionary = undefined;
        }
        if (this._topPagesDictionary) {
            this._topPagesDictionary = undefined;
        }
        if (this.pageIndexCache) {
            this.pageIndexCache.clear();
            this.pageIndexCache = undefined;
        }
        if (this.pageKidsCountCache) {
            this.pageKidsCountCache.clear();
            this.pageKidsCountCache = undefined;
        }
    }
}

class PdfPredictorStream extends _PdfDecodeStream {
    constructor(stream, maybeLength, params) {
        super(maybeLength);
        if (!(params instanceof _PdfDictionary)) {
            return stream;
        }
        const predictor = (this.predictor = params.get('Predictor') || 1);
        if (predictor <= 1) {
            return stream;
        }
        if (predictor !== 2 && (predictor < 10 || predictor > 15)) {
            throw new FormatError(`Unsupported predictor: ${predictor}`);
        }
        if (predictor === 2) {
            this.readBlock = this.readBlockTiff;
        }
        else {
            this.readBlock = this.readBlockPng;
        }
        this.stream = stream;
        this.dictionary = stream.dictionary;
        const colors = (this.colors = params.get('Colors') || 1);
        const bits = (this.bits = params.get('BPC', 'BitsPerComponent') || 8);
        const columns = (this.columns = params.get('Columns') || 1);
        this.pixBytes = (colors * bits + 7) >> 3;
        this.rowBytes = (columns * colors * bits + 7) >> 3;
        return this;
    }
    readBlockTiff() {
        const rowBytes = this.rowBytes;
        const bufferLength = this.bufferLength;
        const buffer = this.ensureBuffer(bufferLength + rowBytes);
        const bits = this.bits;
        const colors = this.colors;
        const rawBytes = this.stream.getBytes(rowBytes);
        this.eof = !rawBytes.length;
        if (this.eof) {
            return;
        }
        let inbuf = 0;
        let outbuf = 0;
        let inbits = 0;
        let outbits = 0;
        let position = bufferLength;
        let i;
        if (bits === 1 && colors === 1) {
            for (i = 0; i < rowBytes; ++i) {
                let c = rawBytes[i] ^ inbuf; // eslint-disable-line
                c ^= c >> 1;
                c ^= c >> 2;
                c ^= c >> 4;
                inbuf = (c & 1) << 7;
                buffer[position++] = c;
            }
        }
        else if (bits === 8) {
            for (i = 0; i < colors; ++i) {
                buffer[position++] = rawBytes[i]; // eslint-disable-line
            }
            for (; i < rowBytes; ++i) {
                buffer[position] = buffer[position - colors] + rawBytes[i]; // eslint-disable-line
                position++;
            }
        }
        else if (bits === 16) {
            const bytesPerPixel = colors * 2;
            for (i = 0; i < bytesPerPixel; ++i) {
                buffer[position++] = rawBytes[i]; // eslint-disable-line
            }
            for (; i < rowBytes; i += 2) {
                const sum = ((rawBytes[i] & 0xff) << 8) + // eslint-disable-line
                    (rawBytes[i + 1] & 0xff) +
                    ((buffer[position - bytesPerPixel] & 0xff) << 8) +
                    (buffer[position - bytesPerPixel + 1] & 0xff);
                buffer[position++] = (sum >> 8) & 0xff;
                buffer[position++] = sum & 0xff;
            }
        }
        else {
            const compArray = new Uint8Array(colors + 1);
            const bitMask = (1 << bits) - 1;
            let j = 0;
            let k = bufferLength;
            const columns = this.columns;
            for (i = 0; i < columns; ++i) {
                for (let kk = 0; kk < colors; ++kk) {
                    if (inbits < bits) {
                        inbuf = (inbuf << 8) | (rawBytes[j++] & 0xff);
                        inbits += 8;
                    }
                    compArray[kk] = (compArray[kk] + (inbuf >> (inbits - bits))) & bitMask; // eslint-disable-line
                    inbits -= bits;
                    outbuf = (outbuf << bits) | compArray[kk]; // eslint-disable-line
                    outbits += bits;
                    if (outbits >= 8) {
                        buffer[k++] = (outbuf >> (outbits - 8)) & 0xff;
                        outbits -= 8;
                    }
                }
            }
            if (outbits > 0) {
                buffer[k++] = (outbuf << (8 - outbits)) + (inbuf & ((1 << (8 - outbits)) - 1));
            }
        }
        this.bufferLength += rowBytes;
    }
    readBlockPng() {
        const rowBytes = this.rowBytes;
        const pixBytes = this.pixBytes;
        const predictor = this.stream.getByte();
        const rawBytes = this.stream.getBytes(rowBytes);
        this.eof = !rawBytes.length;
        if (this.eof) {
            return;
        }
        const bufferLength = this.bufferLength;
        const buffer = this.ensureBuffer(bufferLength + rowBytes);
        let prevRow = buffer.subarray(bufferLength - rowBytes, bufferLength);
        if (prevRow.length === 0) {
            prevRow = new Uint8Array(rowBytes);
        }
        let i;
        let j = bufferLength;
        let up;
        let c;
        switch (predictor) {
            case 0:
                for (i = 0; i < rowBytes; ++i) {
                    buffer[j++] = rawBytes[i]; // eslint-disable-line
                }
                break;
            case 1:
                for (i = 0; i < pixBytes; ++i) {
                    buffer[j++] = rawBytes[i]; // eslint-disable-line
                }
                for (; i < rowBytes; ++i) {
                    buffer[j] = (buffer[j - pixBytes] + rawBytes[i]) & 0xff; // eslint-disable-line
                    j++;
                }
                break;
            case 2:
                for (i = 0; i < rowBytes; ++i) {
                    buffer[j++] = (prevRow[i] + rawBytes[i]) & 0xff; // eslint-disable-line
                }
                break;
            case 3:
                for (i = 0; i < pixBytes; ++i) {
                    buffer[j++] = (prevRow[i] >> 1) + rawBytes[i]; // eslint-disable-line
                }
                for (; i < rowBytes; ++i) {
                    buffer[j] = (((prevRow[i] + buffer[j - pixBytes]) >> 1) + rawBytes[i]) & 0xff; // eslint-disable-line
                    j++;
                }
                break;
            case 4:
                for (i = 0; i < pixBytes; ++i) {
                    up = prevRow[i]; // eslint-disable-line
                    c = rawBytes[i]; // eslint-disable-line
                    buffer[j++] = up + c;
                }
                for (; i < rowBytes; ++i) {
                    up = prevRow[i]; // eslint-disable-line
                    const upLeft = prevRow[i - pixBytes];
                    const left = buffer[j - pixBytes];
                    const p = left + up - upLeft;
                    let pa = p - left;
                    if (pa < 0) {
                        pa = -pa;
                    }
                    let pb = p - up;
                    if (pb < 0) {
                        pb = -pb;
                    }
                    let pc = p - upLeft;
                    if (pc < 0) {
                        pc = -pc;
                    }
                    c = rawBytes[i]; // eslint-disable-line
                    if (pa <= pb && pa <= pc) {
                        buffer[j++] = left + c;
                    }
                    else if (pb <= pc) {
                        buffer[j++] = up + c;
                    }
                    else {
                        buffer[j++] = upLeft + c;
                    }
                }
                break;
            default:
                throw new FormatError(`Unsupported predictor: ${predictor}`);
        }
        this.bufferLength += rowBytes;
    }
}

const maxCacheLength = 1000;
const maxNumberLength = 5552;
const endOfFile = 'EOF';
const specialChars = [
    1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 1, 1, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    1, 0, 0, 0, 0, 2, 0, 0, 2, 2, 0, 0, 0, 0, 0, 2,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 2, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 2, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 2, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
];
class _PdfLexicalOperator {
    constructor(stream) {
        this.stream = stream;
        this.nextChar();
        this.stringBuffer = [];
        this._hexStringNumber = 0;
        this.beginInlineImagePosition = -1;
    }
    nextChar() {
        return (this.currentChar = this.stream.getByte());
    }
    peekChar() {
        return this.stream.peekByte();
    }
    getNumber() {
        let ch = this.currentChar;
        let eNotation = false;
        let divideBy = 0;
        let sign = 0;
        if (ch === 0x2d) {
            sign = -1;
            ch = this.nextChar();
            if (ch === 0x2d) {
                ch = this.nextChar();
            }
        }
        else if (ch === 0x2b) {
            sign = 1;
            ch = this.nextChar();
        }
        if (ch === 0x0a || ch === 0x0d) {
            do {
                ch = this.nextChar();
            } while (ch === 0x0a || ch === 0x0d);
        }
        if (ch === 0x2e) {
            divideBy = 10;
            ch = this.nextChar();
        }
        if (ch < 0x30 || ch > 0x39) {
            if (_isWhiteSpace(ch) || ch === -1) {
                if (divideBy === 10 && sign === 0) {
                    return 0;
                }
                if (divideBy === 0 && sign === -1) {
                    return 0;
                }
            }
            throw new FormatError(`Invalid number: ${String.fromCharCode(ch)} (charCode ${ch})`);
        }
        sign = sign || 1;
        let baseValue = ch - 0x30;
        let powerValue = 0;
        let powerValueSign = 1;
        ch = this.nextChar();
        while (ch >= 0) {
            if (ch >= 0x30 && ch <= 0x39) {
                const currentDigit = ch - 0x30;
                if (eNotation) {
                    powerValue = powerValue * 10 + currentDigit;
                }
                else {
                    if (divideBy !== 0) {
                        divideBy *= 10;
                    }
                    baseValue = baseValue * 10 + currentDigit;
                }
            }
            else if (ch === 0x2e) {
                if (divideBy === 0) {
                    divideBy = 1;
                }
                else {
                    break;
                }
            }
            else if (ch === 0x2d) {
                ch = this.nextChar();
                continue;
            }
            else if (ch === 0x45 || ch === 0x65) {
                ch = this.peekChar();
                if (ch === 0x2b || ch === 0x2d) {
                    powerValueSign = ch === 0x2d ? -1 : 1;
                    this.nextChar();
                }
                else if (ch < 0x30 || ch > 0x39) {
                    break;
                }
                eNotation = true;
            }
            else {
                break;
            }
            ch = this.nextChar();
        }
        if (divideBy !== 0) {
            baseValue /= divideBy;
        }
        if (eNotation) {
            baseValue *= Math.pow(10, (powerValueSign * powerValue));
        }
        return sign * baseValue;
    }
    getString() {
        let numParen = 1;
        let done = false;
        const stringBuffer = this.stringBuffer;
        stringBuffer.length = 0;
        let ch = this.nextChar();
        while (true) { // eslint-disable-line
            let charBuffered = false;
            switch (ch | 0) {
                case -1:
                    done = true;
                    break;
                case 0x28:
                    ++numParen;
                    stringBuffer.push('(');
                    break;
                case 0x29:
                    if (--numParen === 0) {
                        this.nextChar();
                        done = true;
                    }
                    else {
                        stringBuffer.push(')');
                    }
                    break;
                case 0x5c:
                    ch = this.nextChar();
                    switch (ch) {
                        case -1:
                            done = true;
                            break;
                        case 0x6e:
                            stringBuffer.push('\n');
                            break;
                        case 0x72:
                            stringBuffer.push('\r');
                            break;
                        case 0x74:
                            stringBuffer.push('\t');
                            break;
                        case 0x62:
                            stringBuffer.push('\b');
                            break;
                        case 0x66:
                            stringBuffer.push('\f');
                            break;
                        case 0x5c:
                        case 0x28:
                        case 0x29:
                            stringBuffer.push(String.fromCharCode(ch));
                            break;
                        case 0x30:
                        case 0x31:
                        case 0x32:
                        case 0x33:
                        case 0x34:
                        case 0x35:
                        case 0x36:
                        case 0x37:
                            let x = ch & 0x0f; // eslint-disable-line
                            ch = this.nextChar();
                            charBuffered = true;
                            if (ch >= 0x30 && ch <= 0x37) {
                                x = (x << 3) + (ch & 0x0f);
                                ch = this.nextChar();
                                if (ch >= 0x30 && ch <= 0x37) {
                                    charBuffered = false;
                                    x = (x << 3) + (ch & 0x0f);
                                }
                            }
                            stringBuffer.push(String.fromCharCode(x));
                            break;
                        case 0x0d:
                            if (this.peekChar() === 0x0a) {
                                this.nextChar();
                            }
                            break;
                        case 0x0a:
                            break;
                        default:
                            stringBuffer.push(String.fromCharCode(ch));
                            break;
                    }
                    break;
                default:
                    stringBuffer.push(String.fromCharCode(ch));
                    break;
            }
            if (done) {
                break;
            }
            if (!charBuffered) {
                ch = this.nextChar();
            }
        }
        return stringBuffer.join('');
    }
    getName() {
        let ch;
        let previousCh;
        const stringBuffer = this.stringBuffer;
        stringBuffer.length = 0;
        ch = this.nextChar();
        while (ch >= 0 && !specialChars[ch]) { // eslint-disable-line
            if (ch === 0x23) {
                ch = this.nextChar();
                if (specialChars[ch]) { // eslint-disable-line
                    stringBuffer.push('#');
                    break;
                }
                const x = this._toHexDigit(ch);
                if (x !== -1) {
                    previousCh = ch;
                    ch = this.nextChar();
                    const x2 = this._toHexDigit(ch);
                    if (x2 === -1) {
                        stringBuffer.push('#', String.fromCharCode(previousCh));
                        if (specialChars[ch]) { // eslint-disable-line
                            break;
                        }
                        stringBuffer.push(String.fromCharCode(ch));
                        ch = this.nextChar();
                        continue;
                    }
                    stringBuffer.push(String.fromCharCode((x << 4) | x2));
                }
                else {
                    stringBuffer.push('#', String.fromCharCode(ch));
                }
            }
            else {
                stringBuffer.push(String.fromCharCode(ch));
            }
            ch = this.nextChar();
        }
        return _PdfName.get(stringBuffer.join(''));
    }
    getHexString() {
        const stringBuffer = this.stringBuffer;
        stringBuffer.length = 0;
        let ch = this.currentChar;
        let isFirstHex = true;
        let firstDigit;
        let secondDigit;
        this._hexStringNumber = 0;
        while (true) { // eslint-disable-line
            if (ch < 0) {
                break;
            }
            else if (ch === 0x3e) {
                this.nextChar();
                break;
            }
            else if (specialChars[ch] === 1) { // eslint-disable-line
                ch = this.nextChar();
                continue;
            }
            else {
                if (isFirstHex) {
                    firstDigit = this._toHexDigit(ch);
                    if (firstDigit === -1) {
                        ch = this.nextChar();
                        continue;
                    }
                }
                else {
                    secondDigit = this._toHexDigit(ch);
                    if (secondDigit === -1) {
                        ch = this.nextChar();
                        continue;
                    }
                    stringBuffer.push(String.fromCharCode((firstDigit << 4) | secondDigit));
                }
                isFirstHex = !isFirstHex;
                ch = this.nextChar();
            }
        }
        return stringBuffer.join('');
    }
    getObject() {
        let comment = false;
        let ch = this.currentChar;
        while (true) { // eslint-disable-line
            if (ch < 0) {
                return endOfFile;
            }
            if (comment) {
                if (ch === 0x0a || ch === 0x0d) {
                    comment = false;
                }
            }
            else if (ch === 0x25) {
                comment = true;
            }
            else if (specialChars[ch] !== 1) { // eslint-disable-line
                break;
            }
            ch = this.nextChar();
        }
        switch (ch | 0) {
            case 0x30:
            case 0x31:
            case 0x32:
            case 0x33:
            case 0x34:
            case 0x35:
            case 0x36:
            case 0x37:
            case 0x38:
            case 0x39:
            case 0x2b:
            case 0x2d:
            case 0x2e:
                return this.getNumber();
            case 0x28:
                return this.getString();
            case 0x2f:
                return this.getName();
            case 0x5b:
                this.nextChar();
                return _PdfCommand.get('[');
            case 0x5d:
                this.nextChar();
                return _PdfCommand.get(']');
            case 0x3c:
                ch = this.nextChar();
                if (ch === 0x3c) {
                    this.nextChar();
                    return _PdfCommand.get('<<');
                }
                return this.getHexString();
            case 0x3e:
                ch = this.nextChar();
                if (ch === 0x3e) {
                    this.nextChar();
                    return _PdfCommand.get('>>');
                }
                return _PdfCommand.get('>');
            case 0x7b:
                this.nextChar();
                return _PdfCommand.get('{');
            case 0x7d:
                this.nextChar();
                return _PdfCommand.get('}');
            case 0x29:
                this.nextChar();
                throw new FormatError(`Illegal character: ${ch}`);
        }
        let str = String.fromCharCode(ch);
        if (ch < 0x20 || ch > 0x7f) {
            const nextCh = this.peekChar();
            if (nextCh >= 0x20 && nextCh <= 0x7f) {
                this.nextChar();
                return _PdfCommand.get(str);
            }
        }
        ch = this.nextChar();
        while (ch >= 0 && !specialChars[ch]) { // eslint-disable-line
            const possibleCommand = str + String.fromCharCode(ch);
            if (str.length === 128) {
                throw new FormatError(`Command token too long: ${str.length}`);
            }
            str = possibleCommand;
            ch = this.nextChar();
        }
        if (str === 'true') {
            return true;
        }
        if (str === 'false') {
            return false;
        }
        if (str === 'null') {
            return null;
        }
        if (str === 'BI') {
            this.beginInlineImagePosition = this.stream.position;
        }
        return _PdfCommand.get(str);
    }
    peekObj() {
        const streamPos = this.stream.position;
        const currentChar = this.currentChar;
        const beginInlineImagePosition = this.beginInlineImagePosition;
        let nextObj; // eslint-disable-line
        try {
            nextObj = this.getObject();
        }
        catch (ex) { } // eslint-disable-line
        this.stream.position = streamPos;
        this.currentChar = currentChar;
        this.beginInlineImagePosition = beginInlineImagePosition;
        return nextObj;
    }
    skipToNextLine() {
        let ch = this.currentChar;
        while (ch >= 0) {
            if (ch === 0x0d) {
                ch = this.nextChar();
                if (ch === 0x0a) {
                    this.nextChar();
                }
                break;
            }
            else if (ch === 0x0a) {
                this.nextChar();
                break;
            }
            ch = this.nextChar();
        }
    }
    _toHexDigit(ch) {
        if (ch >= 0x30 && ch <= 0x39) {
            return ch & 0x0f;
        }
        if ((ch >= 0x41 && ch <= 0x46) || (ch >= 0x61 && ch <= 0x66)) {
            return (ch & 0x0f) + 9;
        }
        return -1;
    }
}
class _PdfParser {
    constructor(lexicalOperator, xref, allowStreams = false, recoveryMode = false) {
        this.lexicalOperator = lexicalOperator;
        this.xref = xref;
        this.allowStreams = allowStreams;
        this.recoveryMode = recoveryMode;
        this.imageCache = new Map();
        this.refill();
    }
    refill() {
        this.first = this.lexicalOperator.getObject();
        this.second = this.lexicalOperator.getObject();
    }
    shift() {
        if (this.second instanceof _PdfCommand && this.second.command === 'ID') {
            this.first = this.second;
            this.second = null;
        }
        else {
            this.first = this.second;
            this.second = this.lexicalOperator.getObject();
        }
    }
    tryShift() {
        try {
            this.shift();
            return true;
        }
        catch (e) {
            return false;
        }
    }
    getObject(cipherTransform) {
        const first = this.first; // eslint-disable-line
        this.shift();
        if (first instanceof _PdfCommand) {
            switch (first.command) {
                case 'BI':
                    return this.makeInlineImage(cipherTransform);
                case '[':
                    const array = []; // eslint-disable-line
                    while (!_isCommand(this.first, ']') && this.first !== endOfFile) {
                        array.push(this.getObject(cipherTransform));
                    }
                    if (this.first === endOfFile) {
                        if (this.recoveryMode) {
                            return array;
                        }
                        throw new ParserEndOfFileException('End of file inside array.');
                    }
                    this.shift();
                    return array;
                case '<<':
                    const dictionary = new _PdfDictionary(this.xref); // eslint-disable-line
                    while (!_isCommand(this.first, '>>') && this.first !== endOfFile) {
                        if (!(this.first instanceof _PdfName)) {
                            this.shift();
                            continue;
                        }
                        const key = this.first.name;
                        this.shift();
                        const isEnd = this._checkEnd();
                        if (isEnd) {
                            break;
                        }
                        dictionary.set(key, this.getObject(cipherTransform));
                    }
                    if (this.first === endOfFile) {
                        if (this.recoveryMode) {
                            return dictionary;
                        }
                        throw new ParserEndOfFileException('End of file inside dictionary.');
                    }
                    if (_isCommand(this.second, 'stream')) {
                        if (this.allowStreams === true) {
                            return this.makeStream(dictionary, cipherTransform);
                        }
                        else {
                            return dictionary;
                        }
                    }
                    this.shift();
                    return dictionary;
                default:
                    return first;
            }
        }
        if (Number.isInteger(first)) {
            if (Number.isInteger(this.first) && _isCommand(this.second, 'R')) {
                const ref = _PdfReference.get(first, this.first);
                this.shift();
                this.shift();
                return ref;
            }
            return first;
        }
        if (typeof first === 'string') {
            if (cipherTransform) {
                return cipherTransform.decryptString(first);
            }
            return first;
        }
        return first;
    }
    findDiscreteDecodeInlineStreamEnd(stream) {
        const startPos = stream.position;
        let foundEnd = false;
        let b;
        let markerLength;
        b = stream.getByte();
        while (b !== -1) {
            if (b !== 0xff) {
                b = stream.getByte();
                continue;
            }
            switch (stream.getByte()) {
                case 0x00:
                    break;
                case 0xff:
                    stream.skip(-1);
                    break;
                case 0xd9:
                    foundEnd = true;
                    break;
                case 0xc0:
                case 0xc1:
                case 0xc2:
                case 0xc3:
                case 0xc5:
                case 0xc6:
                case 0xc7:
                case 0xc9:
                case 0xca:
                case 0xcb:
                case 0xcd:
                case 0xce:
                case 0xcf:
                case 0xc4:
                case 0xcc:
                case 0xda:
                case 0xdb:
                case 0xdc:
                case 0xdd:
                case 0xde:
                case 0xdf:
                case 0xe0:
                case 0xe1:
                case 0xe2:
                case 0xe3:
                case 0xe4:
                case 0xe5:
                case 0xe6:
                case 0xe7:
                case 0xe8:
                case 0xe9:
                case 0xea:
                case 0xeb:
                case 0xec:
                case 0xed:
                case 0xee:
                case 0xef:
                case 0xfe:
                    markerLength = stream.getUnsignedInteger16();
                    if (markerLength > 2) {
                        stream.skip(markerLength - 2);
                    }
                    else {
                        stream.skip(-2);
                    }
                    break;
            }
            if (foundEnd) {
                break;
            }
            b = stream.getByte();
        }
        const length = stream.position - startPos;
        if (b === -1) {
            stream.skip(-length);
            return this.findDefaultInlineStreamEnd(stream);
        }
        this.inlineStreamSkipEI(stream);
        return length;
    }
    findDecodeInlineStreamEnd(stream) {
        const startPos = stream.position;
        let ch;
        while ((ch = stream.getByte()) !== -1) { // eslint-disable-line
            if (ch === 0x7e) {
                const tildePos = stream.position;
                ch = stream.peekByte();
                while (_isWhiteSpace(ch)) {
                    stream.skip();
                    ch = stream.peekByte();
                }
                if (ch === 0x3e) {
                    stream.skip();
                    break;
                }
                if (stream.position > tildePos) {
                    const maybeEI = stream.peekBytes(2);
                    if (maybeEI[0] === 0x45 && maybeEI[1] === 0x49) {
                        break;
                    }
                }
            }
        }
        const length = stream.position - startPos;
        if (ch === -1) {
            stream.skip(-length);
            return this.findDefaultInlineStreamEnd(stream);
        }
        this.inlineStreamSkipEI(stream);
        return length;
    }
    findHexDecodeInlineStreamEnd(stream) {
        const startPos = stream.position;
        let ch;
        ch = stream.getByte();
        while (ch !== -1) {
            if (ch === 0x3e) {
                break;
            }
            ch = stream.getByte();
        }
        const length = stream.position - startPos;
        if (ch === -1) {
            stream.skip(-length);
            return this.findDefaultInlineStreamEnd(stream);
        }
        this.inlineStreamSkipEI(stream);
        return length;
    }
    inlineStreamSkipEI(stream) {
        let state = 0;
        let ch;
        ch = stream.getByte();
        while (ch !== -1) {
            if (state === 0) {
                state = ch === 0x45 ? 1 : 0;
            }
            else if (state === 1) {
                state = ch === 0x49 ? 2 : 0;
            }
            else if (state === 2) {
                break;
            }
            ch = stream.getByte();
        }
    }
    makeInlineImage(cipherTransform) {
        const lexicalOperator = this.lexicalOperator;
        const stream = lexicalOperator.stream;
        const dictionary = new _PdfDictionary(this.xref);
        let dictLength;
        while (!_isCommand(this.first, 'ID') && this.first !== endOfFile) {
            if (!(this.first instanceof _PdfName)) {
                throw new FormatError('Dictionary key must be a name object');
            }
            const key = this.first.name;
            this.shift();
            if (this.first.name === endOfFile) {
                break;
            }
            dictionary.set(key, this.getObject(cipherTransform));
        }
        if (lexicalOperator.beginInlineImagePosition !== -1) {
            dictLength = stream.position - lexicalOperator.beginInlineImagePosition;
        }
        const filter = dictionary.get('F', 'Filter'); // eslint-disable-line
        let filterName;
        if (filter instanceof _PdfName) {
            filterName = filter.name;
        }
        else if (Array.isArray(filter)) {
            const reference = filter[0]; // eslint-disable-line
            const filterZero = (reference !== null && typeof reference !== 'undefined' && reference instanceof _PdfReference) ?
                this.xref._fetch(reference) :
                reference;
            if (filterZero) {
                filterName = filterZero.name;
            }
        }
        const startPos = stream.position;
        let length;
        switch (filterName) {
            case 'DCT':
            case 'DCTDecode':
                length = this.findDiscreteDecodeInlineStreamEnd(stream);
                break;
            case 'A85':
            case 'ASCII85Decode':
                length = this.findDecodeInlineStreamEnd(stream);
                break;
            case 'AHx':
            case 'ASCIIHexDecode':
                length = this.findHexDecodeInlineStreamEnd(stream);
                break;
            default:
                length = this.findDefaultInlineStreamEnd(stream);
        }
        let imageStream = stream.makeSubStream(startPos, length, dictionary); // eslint-disable-line
        let cacheKey;
        if (length < maxCacheLength && dictLength < maxNumberLength) {
            const imageBytes = imageStream.getBytes();
            imageStream.reset();
            const initialStreamPos = stream.position;
            stream.position = lexicalOperator.beginInlineImagePosition;
            const dictBytes = stream.getBytes(dictLength);
            stream.position = initialStreamPos;
            cacheKey = this._computeMaxNumber(imageBytes) + '_' + this._computeMaxNumber(dictBytes);
            const cacheEntry = this.imageCache.get(cacheKey);
            if (cacheEntry !== undefined) {
                this.second = _PdfCommand.get('EI');
                this.shift();
                cacheEntry.reset();
                return cacheEntry;
            }
        }
        if (cipherTransform) {
            imageStream = cipherTransform.createStream(imageStream, length);
        }
        imageStream = this.filter(imageStream, dictionary, length);
        imageStream.dictionary = dictionary;
        if (cacheKey !== undefined) {
            this.imageCache.set(cacheKey, imageStream);
        }
        this.second = _PdfCommand.get('EI');
        this.shift();
        return imageStream;
    }
    _computeMaxNumber(bytes) {
        const bytesLength = bytes.length;
        let a = 1;
        let b = 0;
        for (let i = 0; i < bytesLength; ++i) {
            a += bytes[i] & 0xff; // eslint-disable-line
            b += a;
        }
        return (b % 65521 << 16) | a % 65521;
    }
    makeStream(dictionary, cipherTransform) {
        const lexicalOperator = this.lexicalOperator;
        let stream = lexicalOperator.stream; // eslint-disable-line
        lexicalOperator.skipToNextLine();
        const startPosition = stream.position - 1;
        let length = dictionary.get('Length');
        if (!Number.isInteger(length)) {
            length = 0;
        }
        stream.position = startPosition + length;
        lexicalOperator.nextChar();
        if (this.tryShift() && _isCommand(this.second, 'endstream')) {
            this.shift();
        }
        else {
            const endStreamSignature = new Uint8Array([0x65, 0x6e, 0x64, 0x73, 0x74, 0x72, 0x65, 0x61, 0x6d]);
            let actualLength = this._findStreamLength(startPosition, endStreamSignature);
            if (actualLength < 0) {
                const end = endStreamSignature.length - 1;
                const truncatedSignature = endStreamSignature.slice(0, end);
                const maybeLength = this._findStreamLength(startPosition, truncatedSignature);
                if (maybeLength >= 0) {
                    const lastByte = stream.peekBytes(end + 1)[end]; // eslint-disable-line
                    if (_isWhiteSpace(lastByte)) {
                        actualLength = maybeLength;
                    }
                }
                if (actualLength < 0) {
                    throw new FormatError('Missing endstream command.');
                }
            }
            length = actualLength;
            lexicalOperator.nextChar();
            this.shift();
            this.shift();
        }
        this.shift();
        stream = stream.makeSubStream(startPosition, length, dictionary);
        if (cipherTransform) {
            stream = cipherTransform.createStream(stream, length);
        }
        stream = this.filter(stream, dictionary, length);
        stream.dictionary = dictionary;
        return stream;
    }
    filter(stream, dictionary, length) {
        let filter = dictionary.get('F', 'Filter'); // eslint-disable-line
        let params = dictionary.get('DP', 'DecodeParms'); // eslint-disable-line
        if (filter instanceof _PdfName) {
            return this.makeFilter(stream, filter.name, length, params);
        }
        let maybeLength = length;
        if (Array.isArray(filter)) {
            const filterArray = filter; // eslint-disable-line
            const paramsArray = params; // eslint-disable-line
            for (let i = 0; i < filterArray.length; ++i) {
                const reference = filterArray[Number.parseInt(i.toString(), 10)]; // eslint-disable-line
                filter = reference instanceof _PdfReference ? this.xref._fetch(reference) : reference;
                if (!(filter instanceof _PdfName)) {
                    throw new FormatError(`Bad filter name '${filter}'`);
                }
                params = null;
                if (Array.isArray(paramsArray) && i in paramsArray) {
                    const ref = paramsArray[Number.parseInt(i.toString(), 10)]; // eslint-disable-line
                    params = ref instanceof _PdfReference ? this.xref._fetch(ref) : ref;
                }
                stream = this.makeFilter(stream, filter.name, maybeLength, params);
                maybeLength = null;
            }
        }
        return stream;
    }
    makeFilter(stream, name, maybeLength, params) {
        if (maybeLength === 0) {
            return new _PdfNullStream();
        }
        try {
            if (name === 'Fl' || name === 'FlateDecode') {
                if (params) {
                    return new PdfPredictorStream(new _PdfFlateStream(stream, maybeLength), maybeLength, params);
                }
                return new _PdfFlateStream(stream, maybeLength);
            }
            return stream;
        }
        catch (ex) {
            return new _PdfNullStream();
        }
    }
    _findStreamLength(startPosition, signature) {
        const stream = this.lexicalOperator.stream;
        stream.position = startPosition;
        const length = 2048;
        const signatureLength = signature.length;
        while (stream.position < stream.end) {
            const scanBytes = stream.peekBytes(length);
            const scanLength = scanBytes.length - signatureLength;
            if (scanLength <= 0) {
                break;
            }
            let position = 0;
            while (position < scanLength) {
                let j = 0;
                while (j < signatureLength && scanBytes[position + j] === signature[j]) { // eslint-disable-line
                    j++;
                }
                if (j >= signatureLength) {
                    stream.position += position;
                    return stream.position - startPosition;
                }
                position++;
            }
            stream.position += scanLength;
        }
        return -1;
    }
    findDefaultInlineStreamEnd(stream) {
        const startPosition = stream.position;
        const n = 10;
        let state = 0;
        let ch;
        let endImagePosition;
        ch = stream.getByte();
        while (ch !== -1) {
            if (state === 0) {
                state = ch === 0x45 ? 1 : 0;
            }
            else if (state === 1) {
                state = ch === 0x49 ? 2 : 0;
            }
            else {
                if (state !== 2) {
                    throw new Error('findDefaultInlineStreamEnd - invalid state.');
                }
                if (ch === 0x20 || ch === 0xa || ch === 0xd) {
                    endImagePosition = stream.position;
                    const followingBytes = stream.peekBytes(n);
                    for (let i = 0, ii = followingBytes.length; i < ii; i++) {
                        ch = followingBytes[i]; // eslint-disable-line
                        if (ch === 0x0 && followingBytes[i + 1] !== 0x0) {
                            continue;
                        }
                        if (ch !== 0xa && ch !== 0xd && (ch < 0x20 || ch > 0x7f)) {
                            state = 0;
                            break;
                        }
                    }
                    if (state !== 2) {
                        ch = stream.getByte();
                        continue;
                    }
                    if (state === 2) {
                        break;
                    }
                }
                else {
                    state = 0;
                }
            }
            ch = stream.getByte();
        }
        if (ch === -1) {
            if (typeof endImagePosition !== 'undefined') {
                stream.skip(-(stream.position - endImagePosition));
            }
        }
        let endOffset = 4;
        stream.skip(-endOffset);
        ch = stream.peekByte();
        stream.skip(endOffset);
        if (!_isWhiteSpace(ch)) {
            endOffset--;
        }
        return stream.position - endOffset - startPosition;
    }
    _checkEnd() {
        if (this.first === endOfFile) {
            return true;
        }
        else {
            return false;
        }
    }
}
/* eslint-disable */
class _Linearization {
    constructor(stream) {
        this.isValid = false;
        const parser = new _PdfParser(new _PdfLexicalOperator(stream), null);
        const obj1 = parser.getObject();
        const obj2 = parser.getObject();
        const obj3 = parser.getObject();
        const dictionary = parser.getObject();
        this.isValid = Number.isInteger(obj1) && Number.isInteger(obj2) && _isCommand(obj3, 'obj') && typeof dictionary !== 'undefined';
        if (this.isValid) {
            let obj = dictionary.get('Linearized');
            this.isValid = typeof obj !== 'undefined' && obj > 0;
        }
        if (this.isValid) {
            const length = this.getInt(dictionary, 'L');
            if (length !== stream.length) {
                throw new Error('The L parameter in the linearization dictionary ' + 'does not equal the stream length.');
            }
            this.length = length;
            this.hints = this.getHints(dictionary);
            this.objectNumberFirst = this.getInt(dictionary, 'O');
            this.endFirst = this.getInt(dictionary, 'E');
            this.pageCount = this.getInt(dictionary, 'N');
            this.mainXRefEntriesOffset = this.getInt(dictionary, 'T');
            this.pageFirst = dictionary.has('P') ? this.getInt(dictionary, 'P', true) : 0;
        }
    }
    getInt(dictionary, name, allowZeroValue = false) {
        const obj = dictionary.get(name);
        if (typeof obj !== 'undefined' && Number.isInteger(obj) && (allowZeroValue ? obj >= 0 : obj > 0)) {
            return obj;
        }
        throw new Error(`The '${name}' parameter in the linearization ` + 'dictionary is invalid.');
    }
    getHints(dictionary) {
        const hints = dictionary.getArray('H');
        let hintsLength = hints.length;
        if (hints && (hintsLength === 2 || hintsLength === 4)) {
            for (let index = 0; index < hintsLength; index++) {
                const hint = hints[index];
                if (!(Number.isInteger(hint) && hint > 0)) {
                    throw new Error(`Hint (${index}) in the linearization dictionary is invalid.`);
                }
            }
            return hints;
        }
        throw new Error('Hint array in the linearization dictionary is invalid.');
    }
}
/* eslint-enable */

class _PdfEncryptor {
    constructor(dictionary, id, password = '') {
        this._isUserPassword = true;
        this._hasUserPasswordOnly = false;
        this._encryptOnlyAttachment = false;
        this._encryptMetaData = true;
        this._defaultPasswordBytes = new Uint8Array([0x28, 0xbf, 0x4e, 0x5e, 0x4e, 0x75, 0x8a, 0x41, 0x64, 0x00, 0x4e, 0x56, 0xff,
            0xfa, 0x01, 0x08, 0x2e, 0x2e, 0x00, 0xb6, 0xd0, 0x68, 0x3e, 0x80, 0x2f, 0x0c, 0xa9, 0xfe, 0x64, 0x53, 0x69, 0x7a]);
        const filter = dictionary.get('Filter');
        if (!_isName(filter, 'Standard')) {
            throw new FormatError('unknown encryption method');
        }
        this._filterName = filter.name;
        this._dictionary = dictionary;
        const algorithm = dictionary.get('V');
        if (!Number.isInteger(algorithm) || (algorithm !== 1 && algorithm !== 2 && algorithm !== 4 && algorithm !== 5)) {
            throw new FormatError('unsupported encryption algorithm');
        }
        this._algorithm = algorithm;
        let keyLength = dictionary.get('Length');
        if (!keyLength) {
            if (algorithm <= 3) {
                keyLength = 40;
            }
            else {
                const cfDictionary = dictionary.get('CF');
                const streamCryptoName = dictionary.get('StmF');
                if (cfDictionary && streamCryptoName) {
                    cfDictionary.suppressEncryption = true;
                    const handlerDictionary = cfDictionary.get(streamCryptoName.name);
                    keyLength = (handlerDictionary && handlerDictionary.get('Length')) || 128;
                    if (keyLength < 40) {
                        keyLength <<= 3;
                    }
                }
            }
        }
        if (!Number.isInteger(keyLength) || keyLength < 40 || keyLength % 8 !== 0) {
            throw new FormatError('invalid key length');
        }
        const ownerPassword = _stringToBytes(dictionary.get('O')).subarray(0, 32);
        const userPassword = _stringToBytes(dictionary.get('U')).subarray(0, 32);
        const flag = dictionary.get('P');
        const revision = dictionary.get('R');
        this._encryptMetaData = (algorithm === 4 || algorithm === 5) && dictionary.get('EncryptMetadata') !== false;
        const fileIdBytes = _stringToBytes(id);
        let passwordBytes;
        if (password) {
            if (revision === 6) {
                password = encodeURIComponent(password);
            }
            passwordBytes = _stringToBytes(password);
        }
        let encryptionKey;
        if (algorithm !== 5) {
            encryptionKey = this._prepareKeyData(fileIdBytes, passwordBytes, ownerPassword, userPassword, flag, revision, keyLength, this._encryptMetaData);
            if (encryptionKey) {
                this._isUserPassword = true;
                if (password) {
                    const decodedPassword = this._decodeUserPassword(passwordBytes, ownerPassword, revision, keyLength);
                    const ownerEncryptionKey = this._prepareKeyData(fileIdBytes, decodedPassword, ownerPassword, userPassword, flag, revision, keyLength, this._encryptMetaData);
                    if (ownerEncryptionKey && _areArrayEqual(ownerEncryptionKey, encryptionKey)) {
                        this._hasUserPasswordOnly = true;
                    }
                }
            }
        }
        else {
            const ownerValidationKey = _stringToBytes(dictionary.get('O'));
            const ownerValidationSalt = ownerValidationKey.subarray(32, 40);
            const ownerKeySalt = ownerValidationKey.subarray(40, 48);
            const userValidationKey = _stringToBytes(dictionary.get('U'));
            const uBytes = userValidationKey.subarray(0, 48);
            const userValidationSalt = userValidationKey.subarray(32, 40);
            const userKeySalt = userValidationKey.subarray(40, 48);
            const ownerEncryption = _stringToBytes(dictionary.get('OE'));
            const userEncryption = _stringToBytes(dictionary.get('UE'));
            let algorithm;
            if (revision === 6) {
                algorithm = new _AdvancedEncryption();
            }
            else {
                algorithm = new _BasicEncryption();
            }
            let p;
            if (passwordBytes) {
                p = passwordBytes.subarray(0, Math.min(127, passwordBytes.length));
            }
            else {
                p = new Uint8Array([]);
            }
            if (algorithm._checkUserPassword(p, userValidationSalt, userPassword)) {
                encryptionKey = this._createEncryptionKey(true, p, ownerKeySalt, uBytes, userKeySalt, ownerEncryption, userEncryption, algorithm);
                this._isUserPassword = true;
                if (password.length && algorithm._checkOwnerPassword(p, ownerValidationSalt, uBytes, ownerPassword)) {
                    this._hasUserPasswordOnly = true;
                }
            }
            else if (password.length && algorithm._checkOwnerPassword(p, ownerValidationSalt, uBytes, ownerPassword)) {
                encryptionKey = this._createEncryptionKey(false, passwordBytes, ownerKeySalt, uBytes, userKeySalt, ownerEncryption, userEncryption, algorithm);
                this._isUserPassword = false;
            }
        }
        if (!encryptionKey) {
            if (password) {
                const decodedPassword = this._decodeUserPassword(passwordBytes, ownerPassword, revision, keyLength);
                encryptionKey = this._prepareKeyData(fileIdBytes, decodedPassword, ownerPassword, userPassword, flag, revision, keyLength, this._encryptMetaData);
                this._isUserPassword = false;
            }
            else {
                throw new Error('Cannot open an encrypted document. The password is invalid.');
            }
        }
        if (algorithm >= 4) {
            const cipherDictionary = dictionary.get('CF');
            if (cipherDictionary) {
                cipherDictionary.suppressEncryption = true;
                if (cipherDictionary.has('StdCF')) {
                    const standardCryptFilter = cipherDictionary.get('StdCF');
                    if (standardCryptFilter && standardCryptFilter.has('AuthEvent')) {
                        const event = standardCryptFilter.get('AuthEvent');
                        if (event && event.name === 'EFOpen') {
                            this._encryptOnlyAttachment = true;
                        }
                    }
                }
            }
            this._cipherDictionary = cipherDictionary;
            this._stream = dictionary.get('StmF') || _PdfName.get('Identity');
            this._string = dictionary.get('StrF') || _PdfName.get('Identity');
            this._eff = dictionary.get('EFF') || this._stream;
        }
        if (!encryptionKey && !this._encryptOnlyAttachment) {
            throw new Error('Cannot open an encrypted document. The password is invalid.');
        }
        this._encryptionKey = encryptionKey;
    }
    get _md5() {
        if (typeof this._messageDigest === 'undefined') {
            this._messageDigest = new _MD5();
        }
        return this._messageDigest;
    }
    _createEncryptionKey(isUserKey, password, ownerKeySalt, uBytes, userKeySalt, ownerEncryption, userEncryption, algorithm) {
        if (isUserKey) {
            return algorithm._getUserKey(password, userKeySalt, userEncryption);
        }
        else {
            return algorithm._getOwnerKey(password, ownerKeySalt, uBytes, ownerEncryption);
        }
    }
    _prepareKeyData(id, password, ownerPassword, userPassword, flags, revision, keyLength, encryptMetaData) {
        const hashData = new Uint8Array(40 + ownerPassword.length + id.length);
        let i = 0;
        let j = 0;
        let n;
        if (password) {
            n = Math.min(32, password.length);
            for (; i < n; ++i) {
                hashData[Number.parseInt(i.toString(), 10)] = password[Number.parseInt(i.toString(), 10)];
            }
        }
        while (i < 32) {
            hashData[i++] = this._defaultPasswordBytes[j++];
        }
        for (j = 0, n = ownerPassword.length; j < n; ++j) {
            hashData[i++] = ownerPassword[Number.parseInt(j.toString(), 10)];
        }
        hashData[i++] = flags & 0xff;
        hashData[i++] = (flags >> 8) & 0xff;
        hashData[i++] = (flags >> 16) & 0xff;
        hashData[i++] = (flags >>> 24) & 0xff;
        for (j = 0, n = id.length; j < n; ++j) {
            hashData[i++] = id[Number.parseInt(j.toString(), 10)];
        }
        if (revision >= 4 && !encryptMetaData) {
            hashData[i++] = 0xff;
            hashData[i++] = 0xff;
            hashData[i++] = 0xff;
            hashData[i++] = 0xff;
        }
        let hash = this._md5.hash(hashData, 0, i);
        const keyLengthInBytes = keyLength >> 3;
        if (revision >= 3) {
            for (j = 0; j < 50; ++j) {
                hash = this._md5.hash(hash, 0, keyLengthInBytes);
            }
        }
        const encryptionKey = hash.subarray(0, keyLengthInBytes);
        let cipher;
        let checkData;
        if (revision >= 3) {
            for (i = 0; i < 32; ++i) {
                hashData[Number.parseInt(i.toString(), 10)] = this._defaultPasswordBytes[Number.parseInt(i.toString(), 10)];
            }
            for (j = 0, n = id.length; j < n; ++j) {
                hashData[i++] = id[Number.parseInt(j.toString(), 10)];
            }
            cipher = new _NormalCipherFour(encryptionKey);
            checkData = cipher._encryptBlock(this._md5.hash(hashData, 0, i));
            n = encryptionKey.length;
            const derivedKey = new Uint8Array(n);
            for (j = 1; j <= 19; ++j) {
                for (let k = 0; k < n; ++k) {
                    derivedKey[Number.parseInt(k.toString(), 10)] = encryptionKey[Number.parseInt(k.toString(), 10)] ^ j;
                }
                cipher = new _NormalCipherFour(derivedKey);
                checkData = cipher._encryptBlock(checkData);
            }
            for (j = 0, n = checkData.length; j < n; ++j) {
                if (userPassword[Number.parseInt(j.toString(), 10)] !== checkData[Number.parseInt(j.toString(), 10)]) {
                    return null;
                }
            }
        }
        else {
            cipher = new _NormalCipherFour(encryptionKey);
            checkData = cipher._encryptBlock(this._defaultPasswordBytes);
            for (j = 0, n = checkData.length; j < n; ++j) {
                if (userPassword[Number.parseInt(j.toString(), 10)] !== checkData[Number.parseInt(j.toString(), 10)]) {
                    return null;
                }
            }
        }
        return encryptionKey;
    }
    _decodeUserPassword(password, ownerPassword, revision, keyLength) {
        const hashData = new Uint8Array(32);
        let i = 0;
        let j = 0;
        const n = Math.min(32, password.length);
        for (; i < n; ++i) {
            hashData[Number.parseInt(i.toString(), 10)] = password[Number.parseInt(i.toString(), 10)];
        }
        while (i < 32) {
            hashData[i++] = this._defaultPasswordBytes[j++];
        }
        let hash = this._md5.hash(hashData, 0, i);
        const keyLengthInBytes = keyLength >> 3;
        if (revision >= 3) {
            for (j = 0; j < 50; ++j) {
                hash = this._md5.hash(hash, 0, hash.length);
            }
        }
        let cipher;
        let userPassword;
        if (revision >= 3) {
            userPassword = ownerPassword;
            const derivedKey = new Uint8Array(keyLengthInBytes);
            for (j = 19; j >= 0; j--) {
                for (let k = 0; k < keyLengthInBytes; ++k) {
                    derivedKey[Number.parseInt(k.toString(), 10)] = hash[Number.parseInt(k.toString(), 10)] ^ j;
                }
                cipher = new _NormalCipherFour(derivedKey);
                userPassword = cipher._encryptBlock(userPassword);
            }
        }
        else {
            cipher = new _NormalCipherFour(hash.subarray(0, keyLengthInBytes));
            userPassword = cipher._encryptBlock(ownerPassword);
        }
        return userPassword;
    }
    _createCipherTransform(objectNumber, generationNumber) {
        if (this._algorithm === 4 || this._algorithm === 5) {
            const stringCipher = this._buildCipherConstructor(this._cipherDictionary, this._string, objectNumber, generationNumber, this._encryptionKey);
            const streamCipher = this._buildCipherConstructor(this._cipherDictionary, this._stream, objectNumber, generationNumber, this._encryptionKey);
            return new _CipherTransform(stringCipher, streamCipher);
        }
        const key = this._buildObjectKey(objectNumber, generationNumber, this._encryptionKey, false);
        return new _CipherTransform(new _NormalCipherFour(key), new _NormalCipherFour(key));
    }
    _buildCipherConstructor(cipherDictionary, name, objectNumber, generationNumber, key) {
        const cryptFilter = cipherDictionary.get(name.name);
        let cfm;
        if (cryptFilter) {
            cfm = cryptFilter.get('CFM');
        }
        if (!cfm) {
            return new _NullCipher();
        }
        switch (cfm.name) {
            case 'None':
                return new _NullCipher();
            case 'AESV2':
                return new _AdvancedEncryption128Cipher(this._buildObjectKey(objectNumber, generationNumber, key, true));
            case 'AESV3':
                return new _AdvancedEncryption256Cipher(key);
            case 'V2':
                return new _NormalCipherFour(this._buildObjectKey(objectNumber, generationNumber, key, false));
        }
        throw new FormatError('Unknown cryptography method');
    }
    _buildObjectKey(objectNumber, generationNumber, encryptionKey, isAdvancedEncryption = false) {
        const key = new Uint8Array(encryptionKey.length + 9);
        let i;
        for (i = 0; i < encryptionKey.length; ++i) {
            key[Number.parseInt(i.toString(), 10)] = encryptionKey[Number.parseInt(i.toString(), 10)];
        }
        key[i++] = objectNumber & 0xff;
        key[i++] = (objectNumber >> 8) & 0xff;
        key[i++] = (objectNumber >> 16) & 0xff;
        key[i++] = generationNumber & 0xff;
        key[i++] = (generationNumber >> 8) & 0xff;
        if (isAdvancedEncryption) {
            key[i++] = 0x73;
            key[i++] = 0x41;
            key[i++] = 0x6c;
            key[i++] = 0x54;
        }
        const hash = this._md5.hash(key, 0, i);
        return hash.subarray(0, Math.min(encryptionKey.length + 5, 16));
    }
}
class _MD5 {
    constructor() {
        this._r = new Uint8Array([7, 12, 17, 22, 7, 12, 17, 22, 7, 12, 17, 22, 7, 12, 17, 22, 5, 9, 14, 20, 5, 9,
            14, 20, 5, 9, 14, 20, 5, 9, 14, 20, 4, 11, 16, 23, 4, 11, 16, 23, 4, 11, 16, 23, 4, 11, 16, 23, 6, 10, 15, 21,
            6, 10, 15, 21, 6, 10, 15, 21, 6, 10, 15, 21]);
        this._k = new Int32Array([-680876936, -389564586, 606105819, -1044525330, -176418897, 1200080426, -1473231341, -45705983,
            1770035416, -1958414417, -42063, -1990404162, 1804603682, -40341101, -1502002290, 1236535329, -165796510, -1069501632,
            643717713, -373897302, -701558691, 38016083, -660478335, -405537848, 568446438, -1019803690, -187363961, 1163531501,
            -1444681467, -51403784, 1735328473, -1926607734, -378558, -2022574463, 1839030562, -35309556, -1530992060, 1272893353,
            -155497632, -1094730640, 681279174, -358537222, -722521979, 76029189, -640364487, -421815835, 530742520, -995338651,
            -198630844, 1126891415, -1416354905, -57434055, 1700485571, -1894986606, -1051523, -2054922799, 1873313359, -30611744,
            -1560198380, 1309151649, -145523070, -1120210379, 718787259, -343485551]);
    }
    hash(data, offset, length) {
        let h0 = 1732584193;
        let h1 = -271733879;
        let h2 = -1732584194;
        let h3 = 271733878;
        const paddedLength = (length + 72) & ~63;
        const padded = new Uint8Array(paddedLength);
        let i = 0;
        let j = 0;
        for (; i < length; ++i) {
            padded[Number.parseInt(i.toString(), 10)] = data[offset++];
        }
        padded[i++] = 0x80;
        const n = paddedLength - 8;
        while (i < n) {
            padded[i++] = 0;
        }
        padded[i++] = (length << 3) & 0xff;
        padded[i++] = (length >> 5) & 0xff;
        padded[i++] = (length >> 13) & 0xff;
        padded[i++] = (length >> 21) & 0xff;
        padded[i++] = (length >>> 29) & 0xff;
        padded[i++] = 0;
        padded[i++] = 0;
        padded[i++] = 0;
        const w = new Int32Array(16);
        for (i = 0; i < paddedLength;) {
            for (j = 0; j < 16; ++j, i += 4) {
                w[Number.parseInt(j.toString(), 10)] = padded[Number.parseInt(i.toString(), 10)] |
                    (padded[i + 1] << 8) |
                    (padded[i + 2] << 16) |
                    (padded[i + 3] << 24);
            }
            let a = h0;
            let b = h1;
            let c = h2;
            let d = h3;
            let e;
            let f;
            for (j = 0; j < 64; ++j) {
                if (j < 16) {
                    e = (b & c) | (~b & d);
                    f = j;
                }
                else if (j < 32) {
                    e = (d & b) | (~d & c);
                    f = (5 * j + 1) & 15;
                }
                else if (j < 48) {
                    e = b ^ c ^ d;
                    f = (3 * j + 5) & 15;
                }
                else {
                    e = c ^ (b | ~d);
                    f = (7 * j) & 15;
                }
                const previous = d;
                const current = (a + e + this._k[Number.parseInt(j.toString(), 10)] + w[Number.parseInt(f.toString(), 10)]) | 0;
                const rotate = this._r[Number.parseInt(j.toString(), 10)];
                d = c;
                c = b;
                b = (b + ((current << rotate) | (current >>> (32 - rotate)))) | 0;
                a = previous;
            }
            h0 = (h0 + a) | 0;
            h1 = (h1 + b) | 0;
            h2 = (h2 + c) | 0;
            h3 = (h3 + d) | 0;
        }
        return new Uint8Array([h0 & 0xFF, (h0 >> 8) & 0xFF, (h0 >> 16) & 0xFF, (h0 >>> 24) & 0xFF, h1 & 0xFF,
            (h1 >> 8) & 0xFF, (h1 >> 16) & 0xFF, (h1 >>> 24) & 0xFF, h2 & 0xFF, (h2 >> 8) & 0xFF, (h2 >> 16) & 0xFF,
            (h2 >>> 24) & 0xFF, h3 & 0xFF, (h3 >> 8) & 0xFF, (h3 >> 16) & 0xFF, (h3 >>> 24) & 0xFF
        ]);
    }
}
class _Sha256 {
    _rotateRight(x, n) {
        return (x >>> n) | (x << (32 - n));
    }
    _sigma(x) {
        return this._rotateRight(x, 2) ^ this._rotateRight(x, 13) ^ this._rotateRight(x, 22);
    }
    _sigmaPrime(x) {
        return this._rotateRight(x, 6) ^ this._rotateRight(x, 11) ^ this._rotateRight(x, 25);
    }
    _littleSigma(x) {
        return this._rotateRight(x, 7) ^ this._rotateRight(x, 18) ^ (x >>> 3);
    }
    _littleSigmaPrime(x) {
        return this._rotateRight(x, 17) ^ this._rotateRight(x, 19) ^ (x >>> 10);
    }
    _hash(data, offset, length) {
        let h0 = 0x6a09e667;
        let h1 = 0xbb67ae85;
        let h2 = 0x3c6ef372;
        let h3 = 0xa54ff53a;
        let h4 = 0x510e527f;
        let h5 = 0x9b05688c;
        let h6 = 0x1f83d9ab;
        let h7 = 0x5be0cd19;
        const k = [0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5, 0x3956c25b, 0x59f111f1, 0x923f82a4, 0xab1c5ed5, 0xd807aa98,
            0x12835b01, 0x243185be, 0x550c7dc3, 0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174, 0xe49b69c1, 0xefbe4786, 0x0fc19dc6,
            0x240ca1cc, 0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da, 0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7, 0xc6e00bf3,
            0xd5a79147, 0x06ca6351, 0x14292967, 0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13, 0x650a7354, 0x766a0abb, 0x81c2c92e,
            0x92722c85, 0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3, 0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070, 0x19a4c116,
            0x1e376c08, 0x2748774c, 0x34b0bcb5, 0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3, 0x748f82ee, 0x78a5636f, 0x84c87814,
            0x8cc70208, 0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2];
        const paddedLength = Math.ceil((length + 9) / 64) * 64;
        const padded = new Uint8Array(paddedLength);
        let i = 0;
        let j;
        for (; i < length; ++i) {
            padded[Number.parseInt(i.toString(), 10)] = data[offset++];
        }
        padded[i++] = 0x80;
        const n = paddedLength - 8;
        while (i < n) {
            padded[i++] = 0;
        }
        padded[i++] = 0;
        padded[i++] = 0;
        padded[i++] = 0;
        padded[i++] = (length >>> 29) & 0xff;
        padded[i++] = (length >> 21) & 0xff;
        padded[i++] = (length >> 13) & 0xff;
        padded[i++] = (length >> 5) & 0xff;
        padded[i++] = (length << 3) & 0xff;
        const w = new Uint32Array(64);
        for (i = 0; i < paddedLength;) {
            for (j = 0; j < 16; ++j) {
                w[Number.parseInt(j.toString(), 10)] = (padded[Number.parseInt(i.toString(), 10)] << 24) |
                    (padded[i + 1] << 16) |
                    (padded[i + 2] << 8) |
                    padded[i + 3];
                i += 4;
            }
            for (j = 16; j < 64; ++j) {
                w[Number.parseInt(j.toString(), 10)] = (this._littleSigmaPrime(w[j - 2]) +
                    w[j - 7] +
                    this._littleSigma(w[j - 15]) + w[j - 16]) | 0;
            }
            let a = h0;
            let b = h1;
            let c = h2;
            let d = h3;
            let e = h4;
            let f = h5;
            let g = h6;
            let h = h7;
            let t1;
            let t2;
            for (j = 0; j < 64; ++j) {
                t1 = h +
                    this._sigmaPrime(e) +
                    ((e & f) ^ (~e & g)) +
                    k[Number.parseInt(j.toString(), 10)] +
                    w[Number.parseInt(j.toString(), 10)];
                t2 = this._sigma(a) + ((a & b) ^ (a & c) ^ (b & c));
                h = g;
                g = f;
                f = e;
                e = (d + t1) | 0;
                d = c;
                c = b;
                b = a;
                a = (t1 + t2) | 0;
            }
            h0 = (h0 + a) | 0;
            h1 = (h1 + b) | 0;
            h2 = (h2 + c) | 0;
            h3 = (h3 + d) | 0;
            h4 = (h4 + e) | 0;
            h5 = (h5 + f) | 0;
            h6 = (h6 + g) | 0;
            h7 = (h7 + h) | 0;
        }
        return new Uint8Array([(h0 >> 24) & 0xFF, (h0 >> 16) & 0xFF, (h0 >> 8) & 0xFF, (h0) & 0xFF, (h1 >> 24) & 0xFF, (h1 >> 16) & 0xFF,
            (h1 >> 8) & 0xFF, (h1) & 0xFF, (h2 >> 24) & 0xFF, (h2 >> 16) & 0xFF, (h2 >> 8) & 0xFF, (h2) & 0xFF, (h3 >> 24) & 0xFF,
            (h3 >> 16) & 0xFF, (h3 >> 8) & 0xFF, (h3) & 0xFF, (h4 >> 24) & 0xFF, (h4 >> 16) & 0xFF, (h4 >> 8) & 0xFF, (h4) & 0xFF,
            (h5 >> 24) & 0xFF, (h5 >> 16) & 0xFF, (h5 >> 8) & 0xFF, (h5) & 0xFF, (h6 >> 24) & 0xFF, (h6 >> 16) & 0xFF, (h6 >> 8) & 0xFF,
            (h6) & 0xFF, (h7 >> 24) & 0xFF, (h7 >> 16) & 0xFF, (h7 >> 8) & 0xFF, (h7) & 0xFF
        ]);
    }
}
class _Sha512 {
    constructor() {
        this._k = [new _Word64(0x428a2f98, 0xd728ae22), new _Word64(0x71374491, 0x23ef65cd),
            new _Word64(0xb5c0fbcf, 0xec4d3b2f), new _Word64(0xe9b5dba5, 0x8189dbbc),
            new _Word64(0x3956c25b, 0xf348b538), new _Word64(0x59f111f1, 0xb605d019),
            new _Word64(0x923f82a4, 0xaf194f9b), new _Word64(0xab1c5ed5, 0xda6d8118),
            new _Word64(0xd807aa98, 0xa3030242), new _Word64(0x12835b01, 0x45706fbe),
            new _Word64(0x243185be, 0x4ee4b28c), new _Word64(0x550c7dc3, 0xd5ffb4e2),
            new _Word64(0x72be5d74, 0xf27b896f), new _Word64(0x80deb1fe, 0x3b1696b1),
            new _Word64(0x9bdc06a7, 0x25c71235), new _Word64(0xc19bf174, 0xcf692694),
            new _Word64(0xe49b69c1, 0x9ef14ad2), new _Word64(0xefbe4786, 0x384f25e3),
            new _Word64(0x0fc19dc6, 0x8b8cd5b5), new _Word64(0x240ca1cc, 0x77ac9c65),
            new _Word64(0x2de92c6f, 0x592b0275), new _Word64(0x4a7484aa, 0x6ea6e483),
            new _Word64(0x5cb0a9dc, 0xbd41fbd4), new _Word64(0x76f988da, 0x831153b5),
            new _Word64(0x983e5152, 0xee66dfab), new _Word64(0xa831c66d, 0x2db43210),
            new _Word64(0xb00327c8, 0x98fb213f), new _Word64(0xbf597fc7, 0xbeef0ee4),
            new _Word64(0xc6e00bf3, 0x3da88fc2), new _Word64(0xd5a79147, 0x930aa725),
            new _Word64(0x06ca6351, 0xe003826f), new _Word64(0x14292967, 0x0a0e6e70),
            new _Word64(0x27b70a85, 0x46d22ffc), new _Word64(0x2e1b2138, 0x5c26c926),
            new _Word64(0x4d2c6dfc, 0x5ac42aed), new _Word64(0x53380d13, 0x9d95b3df),
            new _Word64(0x650a7354, 0x8baf63de), new _Word64(0x766a0abb, 0x3c77b2a8),
            new _Word64(0x81c2c92e, 0x47edaee6), new _Word64(0x92722c85, 0x1482353b),
            new _Word64(0xa2bfe8a1, 0x4cf10364), new _Word64(0xa81a664b, 0xbc423001),
            new _Word64(0xc24b8b70, 0xd0f89791), new _Word64(0xc76c51a3, 0x0654be30),
            new _Word64(0xd192e819, 0xd6ef5218), new _Word64(0xd6990624, 0x5565a910),
            new _Word64(0xf40e3585, 0x5771202a), new _Word64(0x106aa070, 0x32bbd1b8),
            new _Word64(0x19a4c116, 0xb8d2d0c8), new _Word64(0x1e376c08, 0x5141ab53),
            new _Word64(0x2748774c, 0xdf8eeb99), new _Word64(0x34b0bcb5, 0xe19b48a8),
            new _Word64(0x391c0cb3, 0xc5c95a63), new _Word64(0x4ed8aa4a, 0xe3418acb),
            new _Word64(0x5b9cca4f, 0x7763e373), new _Word64(0x682e6ff3, 0xd6b2b8a3),
            new _Word64(0x748f82ee, 0x5defb2fc), new _Word64(0x78a5636f, 0x43172f60),
            new _Word64(0x84c87814, 0xa1f0ab72), new _Word64(0x8cc70208, 0x1a6439ec),
            new _Word64(0x90befffa, 0x23631e28), new _Word64(0xa4506ceb, 0xde82bde9),
            new _Word64(0xbef9a3f7, 0xb2c67915), new _Word64(0xc67178f2, 0xe372532b),
            new _Word64(0xca273ece, 0xea26619c), new _Word64(0xd186b8c7, 0x21c0c207),
            new _Word64(0xeada7dd6, 0xcde0eb1e), new _Word64(0xf57d4f7f, 0xee6ed178),
            new _Word64(0x06f067aa, 0x72176fba), new _Word64(0x0a637dc5, 0xa2c898a6),
            new _Word64(0x113f9804, 0xbef90dae), new _Word64(0x1b710b35, 0x131c471b),
            new _Word64(0x28db77f5, 0x23047d84), new _Word64(0x32caab7b, 0x40c72493),
            new _Word64(0x3c9ebe0a, 0x15c9bebc), new _Word64(0x431d67c4, 0x9c100d4c),
            new _Word64(0x4cc5d4be, 0xcb3e42b6), new _Word64(0x597f299c, 0xfc657e2a),
            new _Word64(0x5fcb6fab, 0x3ad6faec), new _Word64(0x6c44198c, 0x4a475817)];
    }
    _sigma(result, x, buffer) {
        result.assign(x);
        result.rotateRight(28);
        buffer.assign(x);
        buffer.rotateRight(34);
        result.xor(buffer);
        buffer.assign(x);
        buffer.rotateRight(39);
        result.xor(buffer);
    }
    _sigmaPrime(result, x, buffer) {
        result.assign(x);
        result.rotateRight(14);
        buffer.assign(x);
        buffer.rotateRight(18);
        result.xor(buffer);
        buffer.assign(x);
        buffer.rotateRight(41);
        result.xor(buffer);
    }
    _littleSigma(result, x, buffer) {
        result.assign(x);
        result.rotateRight(1);
        buffer.assign(x);
        buffer.rotateRight(8);
        result.xor(buffer);
        buffer.assign(x);
        buffer.shiftRight(7);
        result.xor(buffer);
    }
    _littleSigmaPrime(result, x, buffer) {
        result.assign(x);
        result.rotateRight(19);
        buffer.assign(x);
        buffer.rotateRight(61);
        result.xor(buffer);
        buffer.assign(x);
        buffer.shiftRight(6);
        result.xor(buffer);
    }
    _hash(data, offset, length, isMode384 = false) {
        let h0;
        let h1;
        let h2;
        let h3;
        let h4;
        let h5;
        let h6;
        let h7;
        if (isMode384) {
            h0 = new _Word64(0xcbbb9d5d, 0xc1059ed8);
            h1 = new _Word64(0x629a292a, 0x367cd507);
            h2 = new _Word64(0x9159015a, 0x3070dd17);
            h3 = new _Word64(0x152fecd8, 0xf70e5939);
            h4 = new _Word64(0x67332667, 0xffc00b31);
            h5 = new _Word64(0x8eb44a87, 0x68581511);
            h6 = new _Word64(0xdb0c2e0d, 0x64f98fa7);
            h7 = new _Word64(0x47b5481d, 0xbefa4fa4);
        }
        else {
            h0 = new _Word64(0x6a09e667, 0xf3bcc908);
            h1 = new _Word64(0xbb67ae85, 0x84caa73b);
            h2 = new _Word64(0x3c6ef372, 0xfe94f82b);
            h3 = new _Word64(0xa54ff53a, 0x5f1d36f1);
            h4 = new _Word64(0x510e527f, 0xade682d1);
            h5 = new _Word64(0x9b05688c, 0x2b3e6c1f);
            h6 = new _Word64(0x1f83d9ab, 0xfb41bd6b);
            h7 = new _Word64(0x5be0cd19, 0x137e2179);
        }
        const paddedLength = Math.ceil((length + 17) / 128) * 128;
        const padded = new Uint8Array(paddedLength);
        let i;
        for (i = 0; i < length; ++i) {
            padded[Number.parseInt(i.toString(), 10)] = data[offset++];
        }
        padded[i++] = 0x80;
        const n = paddedLength - 16;
        while (i < n) {
            padded[i++] = 0;
        }
        padded[i++] = 0;
        padded[i++] = 0;
        padded[i++] = 0;
        padded[i++] = 0;
        padded[i++] = 0;
        padded[i++] = 0;
        padded[i++] = 0;
        padded[i++] = 0;
        padded[i++] = 0;
        padded[i++] = 0;
        padded[i++] = 0;
        padded[i++] = (length >>> 29) & 0xff;
        padded[i++] = (length >> 21) & 0xff;
        padded[i++] = (length >> 13) & 0xff;
        padded[i++] = (length >> 5) & 0xff;
        padded[i++] = (length << 3) & 0xff;
        const w = new Array(80);
        for (i = 0; i < 80; i++) {
            w[Number.parseInt(i.toString(), 10)] = new _Word64(0, 0);
        }
        let a = new _Word64(0, 0);
        let b = new _Word64(0, 0);
        let c = new _Word64(0, 0);
        let d = new _Word64(0, 0);
        let e = new _Word64(0, 0);
        let f = new _Word64(0, 0);
        let g = new _Word64(0, 0);
        let h = new _Word64(0, 0);
        const t1 = new _Word64(0, 0);
        const t2 = new _Word64(0, 0);
        const buffer1 = new _Word64(0, 0);
        const buffer2 = new _Word64(0, 0);
        let buffer3;
        for (i = 0; i < paddedLength;) {
            let j;
            for (j = 0; j < 16; ++j) {
                w[Number.parseInt(j.toString(), 10)].high =
                    (padded[Number.parseInt(i.toString(), 10)] << 24) |
                        (padded[i + 1] << 16) |
                        (padded[i + 2] << 8) |
                        padded[i + 3];
                w[Number.parseInt(j.toString(), 10)].low =
                    (padded[i + 4] << 24) |
                        (padded[i + 5] << 16) |
                        (padded[i + 6] << 8) |
                        padded[i + 7];
                i += 8;
            }
            for (j = 16; j < 80; ++j) {
                buffer3 = w[Number.parseInt(j.toString(), 10)];
                this._littleSigmaPrime(buffer3, w[j - 2], buffer2);
                buffer3.add(w[j - 7]);
                this._littleSigma(buffer1, w[j - 15], buffer2);
                buffer3.add(buffer1);
                buffer3.add(w[j - 16]);
            }
            a.assign(h0);
            b.assign(h1);
            c.assign(h2);
            d.assign(h3);
            e.assign(h4);
            f.assign(h5);
            g.assign(h6);
            h.assign(h7);
            for (j = 0; j < 80; ++j) {
                t1.assign(h);
                this._sigmaPrime(buffer1, e, buffer2);
                t1.add(buffer1);
                buffer1.assign(e);
                buffer1.and(f);
                buffer2.assign(e);
                buffer2.not();
                buffer2.and(g);
                buffer1.xor(buffer2);
                t1.add(buffer1);
                t1.add(this._k[Number.parseInt(j.toString(), 10)]);
                t1.add(w[Number.parseInt(j.toString(), 10)]);
                this._sigma(t2, a, buffer2);
                buffer1.assign(a);
                buffer1.and(b);
                buffer2.assign(a);
                buffer2.and(c);
                buffer1.xor(buffer2);
                buffer2.assign(b);
                buffer2.and(c);
                buffer1.xor(buffer2);
                t2.add(buffer1);
                buffer3 = h;
                h = g;
                g = f;
                f = e;
                d.add(t1);
                e = d;
                d = c;
                c = b;
                b = a;
                buffer3.assign(t1);
                buffer3.add(t2);
                a = buffer3;
            }
            h0.add(a);
            h1.add(b);
            h2.add(c);
            h3.add(d);
            h4.add(e);
            h5.add(f);
            h6.add(g);
            h7.add(h);
        }
        let result;
        if (!isMode384) {
            result = new Uint8Array(64);
            h0.copyTo(result, 0);
            h1.copyTo(result, 8);
            h2.copyTo(result, 16);
            h3.copyTo(result, 24);
            h4.copyTo(result, 32);
            h5.copyTo(result, 40);
            h6.copyTo(result, 48);
            h7.copyTo(result, 56);
        }
        else {
            result = new Uint8Array(48);
            h0.copyTo(result, 0);
            h1.copyTo(result, 8);
            h2.copyTo(result, 16);
            h3.copyTo(result, 24);
            h4.copyTo(result, 32);
            h5.copyTo(result, 40);
        }
        return result;
    }
}
class _Word64 {
    constructor(high, low) {
        this.high = high | 0;
        this.low = low | 0;
    }
    and(word) {
        this.high &= word.high;
        this.low &= word.low;
    }
    or(word) {
        this.high |= word.high;
        this.low |= word.low;
    }
    not() {
        this.high = ~this.high;
        this.low = ~this.low;
    }
    xor(word) {
        this.high ^= word.high;
        this.low ^= word.low;
    }
    shiftRight(places) {
        if (places >= 32) {
            this.low = (this.high >>> (places - 32)) | 0;
            this.high = 0;
        }
        else {
            this.low = (this.low >>> places) | (this.high << (32 - places));
            this.high = (this.high >>> places) | 0;
        }
    }
    shiftLeft(places) {
        if (places >= 32) {
            this.high = this.low << (places - 32);
            this.low = 0;
        }
        else {
            this.high = (this.high << places) | (this.low >>> (32 - places));
            this.low <<= places;
        }
    }
    rotateRight(places) {
        let low;
        let high;
        if (places & 32) {
            high = this.low;
            low = this.high;
        }
        else {
            low = this.low;
            high = this.high;
        }
        places &= 31;
        this.low = (low >>> places) | (high << (32 - places));
        this.high = (high >>> places) | (low << (32 - places));
    }
    add(word) {
        const lowAdd = (this.low >>> 0) + (word.low >>> 0);
        let highAdd = (this.high >>> 0) + (word.high >>> 0);
        if (lowAdd > 0xffffffff) {
            highAdd += 1;
        }
        this.low = lowAdd | 0;
        this.high = highAdd | 0;
    }
    copyTo(bytes, offset) {
        bytes[Number.parseInt(offset.toString(), 10)] = (this.high >>> 24) & 0xff;
        bytes[offset + 1] = (this.high >> 16) & 0xff;
        bytes[offset + 2] = (this.high >> 8) & 0xff;
        bytes[offset + 3] = this.high & 0xff;
        bytes[offset + 4] = (this.low >>> 24) & 0xff;
        bytes[offset + 5] = (this.low >> 16) & 0xff;
        bytes[offset + 6] = (this.low >> 8) & 0xff;
        bytes[offset + 7] = this.low & 0xff;
    }
    assign(word) {
        this.high = word.high;
        this.low = word.low;
    }
}
class _EncryptionKey {
    get _sha256() {
        if (typeof this._sha256Obj === 'undefined') {
            this._sha256Obj = new _Sha256();
        }
        return this._sha256Obj;
    }
    get _sha512() {
        if (typeof this._sha512Obj === 'undefined') {
            this._sha512Obj = new _Sha512();
        }
        return this._sha512Obj;
    }
}
// PDF17 encryption support
class _BasicEncryption extends _EncryptionKey {
    _checkOwnerPassword(password, ownerValidationSalt, userBytes, ownerPassword) {
        const hashData = new Uint8Array(password.length + 56);
        hashData.set(password, 0);
        hashData.set(ownerValidationSalt, password.length);
        hashData.set(userBytes, password.length + ownerValidationSalt.length);
        const result = this._sha256._hash(hashData, 0, hashData.length);
        return _areArrayEqual(result, ownerPassword);
    }
    _checkUserPassword(password, userValidationSalt, userPassword) {
        const hashData = new Uint8Array(password.length + 8);
        hashData.set(password, 0);
        hashData.set(userValidationSalt, password.length);
        const result = this._sha256._hash(hashData, 0, hashData.length);
        return _areArrayEqual(result, userPassword);
    }
    _getOwnerKey(password, ownerKeySalt, userBytes, ownerEncryption) {
        const hashData = new Uint8Array(password.length + 56);
        hashData.set(password, 0);
        hashData.set(ownerKeySalt, password.length);
        hashData.set(userBytes, password.length + ownerKeySalt.length);
        const key = this._sha256._hash(hashData, 0, hashData.length);
        return (new _AdvancedEncryption256Cipher(key))._decryptBlock(ownerEncryption, false, new Uint8Array(16));
    }
    _getUserKey(password, userKeySalt, userEncryption) {
        const hashData = new Uint8Array(password.length + 8);
        hashData.set(password, 0);
        hashData.set(userKeySalt, password.length);
        const key = this._sha256._hash(hashData, 0, hashData.length);
        return (new _AdvancedEncryption256Cipher(key))._decryptBlock(userEncryption, false, new Uint8Array(16));
    }
}
// PDF20 encryption support
class _AdvancedEncryption extends _EncryptionKey {
    _checkOwnerPassword(password, ownerValidationSalt, userBytes, ownerPassword) {
        const hashData = new Uint8Array(password.length + 56);
        hashData.set(password, 0);
        hashData.set(ownerValidationSalt, password.length);
        hashData.set(userBytes, password.length + ownerValidationSalt.length);
        const result = this._hash(password, hashData, userBytes);
        return _areArrayEqual(result, ownerPassword);
    }
    _checkUserPassword(password, userValidationSalt, userPassword) {
        const hashData = new Uint8Array(password.length + 8);
        hashData.set(password, 0);
        hashData.set(userValidationSalt, password.length);
        const result = this._hash(password, hashData, new Uint8Array([]));
        return _areArrayEqual(result, userPassword);
    }
    _getOwnerKey(password, ownerKeySalt, userBytes, ownerEncryption) {
        const hashData = new Uint8Array(password.length + 56);
        hashData.set(password, 0);
        hashData.set(ownerKeySalt, password.length);
        hashData.set(userBytes, password.length + ownerKeySalt.length);
        const key = this._hash(password, hashData, userBytes);
        return (new _AdvancedEncryption256Cipher(key))._decryptBlock(ownerEncryption, false, new Uint8Array(16));
    }
    _getUserKey(password, userKeySalt, userEncryption) {
        const hashData = new Uint8Array(password.length + 8);
        hashData.set(password, 0);
        hashData.set(userKeySalt, password.length);
        const key = this._hash(password, hashData, new Uint8Array([]));
        const cipher = new _AdvancedEncryption256Cipher(key);
        return cipher._decryptBlock(userEncryption, false, new Uint8Array(16));
    }
    _hash(password, input, userBytes) {
        let data = this._sha256._hash(input, 0, input.length).subarray(0, 32);
        let encrypted = new Uint8Array([0]);
        let i = 0;
        while (i < 64 || encrypted[encrypted.length - 1] > i - 32) {
            const combinedLength = password.length + data.length + userBytes.length;
            const combinedArray = new Uint8Array(combinedLength);
            let writeOffset = 0;
            combinedArray.set(password, writeOffset);
            writeOffset += password.length;
            combinedArray.set(data, writeOffset);
            writeOffset += data.length;
            combinedArray.set(userBytes, writeOffset);
            const k1 = new Uint8Array(combinedLength * 64);
            for (let j = 0, pos = 0; j < 64; j++) {
                k1.set(combinedArray, pos);
                pos += combinedLength;
            }
            const cipher = new _AdvancedEncryption128Cipher(data.subarray(0, 16));
            encrypted = cipher._encrypt(k1, data.subarray(16, 32));
            let remainder = 0;
            for (let z = 0; z < 16; z++) {
                remainder *= 256 % 3;
                remainder %= 3;
                remainder += (encrypted[Number.parseInt(z.toString(), 10)] >>> 0) % 3;
                remainder %= 3;
            }
            if (remainder === 2) {
                data = this._sha512._hash(encrypted, 0, encrypted.length);
            }
            else if (remainder === 1) {
                data = this._sha512._hash(encrypted, 0, encrypted.length, true);
            }
            else if (remainder === 0) {
                data = this._sha256._hash(encrypted, 0, encrypted.length);
            }
            i++;
        }
        return data.subarray(0, 32);
    }
}
class _Cipher {
}
class _NormalCipherFour extends _Cipher {
    constructor(key) {
        super();
        this._a = 0;
        this._b = 0;
        const s = new Uint8Array(256);
        for (let i = 0; i < 256; ++i) {
            s[Number.parseInt(i.toString(), 10)] = i;
        }
        const keyLength = key.length;
        for (let i = 0, j = 0; i < 256; ++i) {
            const buffer = s[Number.parseInt(i.toString(), 10)];
            j = (j + buffer + key[i % keyLength]) & 0xff;
            s[Number.parseInt(i.toString(), 10)] = s[Number.parseInt(j.toString(), 10)];
            s[Number.parseInt(j.toString(), 10)] = buffer;
        }
        this._s = s;
    }
    _encryptBlock(data) {
        let a = this._a;
        let b = this._b;
        const s = this._s;
        const n = data.length;
        const output = new Uint8Array(n);
        for (let i = 0; i < n; ++i) {
            a = (a + 1) & 0xff;
            const first = s[Number.parseInt(a.toString(), 10)];
            b = (b + first) & 0xff;
            const second = s[Number.parseInt(b.toString(), 10)];
            s[Number.parseInt(a.toString(), 10)] = second;
            s[Number.parseInt(b.toString(), 10)] = first;
            output[Number.parseInt(i.toString(), 10)] = data[Number.parseInt(i.toString(), 10)] ^ s[(first + second) & 0xff];
        }
        this._a = a;
        this._b = b;
        return output;
    }
    _decryptBlock(data) {
        return this._encryptBlock(data);
    }
    _encrypt(data) {
        return this._encryptBlock(data);
    }
}
class _AdvancedEncryptionBaseCipher extends _Cipher {
    constructor() {
        super(...arguments);
        this._buffer = new Uint8Array(16);
        this._position = 0;
        this._s = new Uint8Array([
            0x63, 0x7c, 0x77, 0x7b, 0xf2, 0x6b, 0x6f, 0xc5, 0x30, 0x01, 0x67, 0x2b,
            0xfe, 0xd7, 0xab, 0x76, 0xca, 0x82, 0xc9, 0x7d, 0xfa, 0x59, 0x47, 0xf0,
            0xad, 0xd4, 0xa2, 0xaf, 0x9c, 0xa4, 0x72, 0xc0, 0xb7, 0xfd, 0x93, 0x26,
            0x36, 0x3f, 0xf7, 0xcc, 0x34, 0xa5, 0xe5, 0xf1, 0x71, 0xd8, 0x31, 0x15,
            0x04, 0xc7, 0x23, 0xc3, 0x18, 0x96, 0x05, 0x9a, 0x07, 0x12, 0x80, 0xe2,
            0xeb, 0x27, 0xb2, 0x75, 0x09, 0x83, 0x2c, 0x1a, 0x1b, 0x6e, 0x5a, 0xa0,
            0x52, 0x3b, 0xd6, 0xb3, 0x29, 0xe3, 0x2f, 0x84, 0x53, 0xd1, 0x00, 0xed,
            0x20, 0xfc, 0xb1, 0x5b, 0x6a, 0xcb, 0xbe, 0x39, 0x4a, 0x4c, 0x58, 0xcf,
            0xd0, 0xef, 0xaa, 0xfb, 0x43, 0x4d, 0x33, 0x85, 0x45, 0xf9, 0x02, 0x7f,
            0x50, 0x3c, 0x9f, 0xa8, 0x51, 0xa3, 0x40, 0x8f, 0x92, 0x9d, 0x38, 0xf5,
            0xbc, 0xb6, 0xda, 0x21, 0x10, 0xff, 0xf3, 0xd2, 0xcd, 0x0c, 0x13, 0xec,
            0x5f, 0x97, 0x44, 0x17, 0xc4, 0xa7, 0x7e, 0x3d, 0x64, 0x5d, 0x19, 0x73,
            0x60, 0x81, 0x4f, 0xdc, 0x22, 0x2a, 0x90, 0x88, 0x46, 0xee, 0xb8, 0x14,
            0xde, 0x5e, 0x0b, 0xdb, 0xe0, 0x32, 0x3a, 0x0a, 0x49, 0x06, 0x24, 0x5c,
            0xc2, 0xd3, 0xac, 0x62, 0x91, 0x95, 0xe4, 0x79, 0xe7, 0xc8, 0x37, 0x6d,
            0x8d, 0xd5, 0x4e, 0xa9, 0x6c, 0x56, 0xf4, 0xea, 0x65, 0x7a, 0xae, 0x08,
            0xba, 0x78, 0x25, 0x2e, 0x1c, 0xa6, 0xb4, 0xc6, 0xe8, 0xdd, 0x74, 0x1f,
            0x4b, 0xbd, 0x8b, 0x8a, 0x70, 0x3e, 0xb5, 0x66, 0x48, 0x03, 0xf6, 0x0e,
            0x61, 0x35, 0x57, 0xb9, 0x86, 0xc1, 0x1d, 0x9e, 0xe1, 0xf8, 0x98, 0x11,
            0x69, 0xd9, 0x8e, 0x94, 0x9b, 0x1e, 0x87, 0xe9, 0xce, 0x55, 0x28, 0xdf,
            0x8c, 0xa1, 0x89, 0x0d, 0xbf, 0xe6, 0x42, 0x68, 0x41, 0x99, 0x2d, 0x0f,
            0xb0, 0x54, 0xbb, 0x16
        ]);
        this._inverseS = new Uint8Array([
            0x52, 0x09, 0x6a, 0xd5, 0x30, 0x36, 0xa5, 0x38, 0xbf, 0x40, 0xa3, 0x9e,
            0x81, 0xf3, 0xd7, 0xfb, 0x7c, 0xe3, 0x39, 0x82, 0x9b, 0x2f, 0xff, 0x87,
            0x34, 0x8e, 0x43, 0x44, 0xc4, 0xde, 0xe9, 0xcb, 0x54, 0x7b, 0x94, 0x32,
            0xa6, 0xc2, 0x23, 0x3d, 0xee, 0x4c, 0x95, 0x0b, 0x42, 0xfa, 0xc3, 0x4e,
            0x08, 0x2e, 0xa1, 0x66, 0x28, 0xd9, 0x24, 0xb2, 0x76, 0x5b, 0xa2, 0x49,
            0x6d, 0x8b, 0xd1, 0x25, 0x72, 0xf8, 0xf6, 0x64, 0x86, 0x68, 0x98, 0x16,
            0xd4, 0xa4, 0x5c, 0xcc, 0x5d, 0x65, 0xb6, 0x92, 0x6c, 0x70, 0x48, 0x50,
            0xfd, 0xed, 0xb9, 0xda, 0x5e, 0x15, 0x46, 0x57, 0xa7, 0x8d, 0x9d, 0x84,
            0x90, 0xd8, 0xab, 0x00, 0x8c, 0xbc, 0xd3, 0x0a, 0xf7, 0xe4, 0x58, 0x05,
            0xb8, 0xb3, 0x45, 0x06, 0xd0, 0x2c, 0x1e, 0x8f, 0xca, 0x3f, 0x0f, 0x02,
            0xc1, 0xaf, 0xbd, 0x03, 0x01, 0x13, 0x8a, 0x6b, 0x3a, 0x91, 0x11, 0x41,
            0x4f, 0x67, 0xdc, 0xea, 0x97, 0xf2, 0xcf, 0xce, 0xf0, 0xb4, 0xe6, 0x73,
            0x96, 0xac, 0x74, 0x22, 0xe7, 0xad, 0x35, 0x85, 0xe2, 0xf9, 0x37, 0xe8,
            0x1c, 0x75, 0xdf, 0x6e, 0x47, 0xf1, 0x1a, 0x71, 0x1d, 0x29, 0xc5, 0x89,
            0x6f, 0xb7, 0x62, 0x0e, 0xaa, 0x18, 0xbe, 0x1b, 0xfc, 0x56, 0x3e, 0x4b,
            0xc6, 0xd2, 0x79, 0x20, 0x9a, 0xdb, 0xc0, 0xfe, 0x78, 0xcd, 0x5a, 0xf4,
            0x1f, 0xdd, 0xa8, 0x33, 0x88, 0x07, 0xc7, 0x31, 0xb1, 0x12, 0x10, 0x59,
            0x27, 0x80, 0xec, 0x5f, 0x60, 0x51, 0x7f, 0xa9, 0x19, 0xb5, 0x4a, 0x0d,
            0x2d, 0xe5, 0x7a, 0x9f, 0x93, 0xc9, 0x9c, 0xef, 0xa0, 0xe0, 0x3b, 0x4d,
            0xae, 0x2a, 0xf5, 0xb0, 0xc8, 0xeb, 0xbb, 0x3c, 0x83, 0x53, 0x99, 0x61,
            0x17, 0x2b, 0x04, 0x7e, 0xba, 0x77, 0xd6, 0x26, 0xe1, 0x69, 0x14, 0x63,
            0x55, 0x21, 0x0c, 0x7d
        ]);
        this._mix = new Uint32Array([
            0x00000000, 0x0e090d0b, 0x1c121a16, 0x121b171d, 0x3824342c, 0x362d3927,
            0x24362e3a, 0x2a3f2331, 0x70486858, 0x7e416553, 0x6c5a724e, 0x62537f45,
            0x486c5c74, 0x4665517f, 0x547e4662, 0x5a774b69, 0xe090d0b0, 0xee99ddbb,
            0xfc82caa6, 0xf28bc7ad, 0xd8b4e49c, 0xd6bde997, 0xc4a6fe8a, 0xcaaff381,
            0x90d8b8e8, 0x9ed1b5e3, 0x8ccaa2fe, 0x82c3aff5, 0xa8fc8cc4, 0xa6f581cf,
            0xb4ee96d2, 0xbae79bd9, 0xdb3bbb7b, 0xd532b670, 0xc729a16d, 0xc920ac66,
            0xe31f8f57, 0xed16825c, 0xff0d9541, 0xf104984a, 0xab73d323, 0xa57ade28,
            0xb761c935, 0xb968c43e, 0x9357e70f, 0x9d5eea04, 0x8f45fd19, 0x814cf012,
            0x3bab6bcb, 0x35a266c0, 0x27b971dd, 0x29b07cd6, 0x038f5fe7, 0x0d8652ec,
            0x1f9d45f1, 0x119448fa, 0x4be30393, 0x45ea0e98, 0x57f11985, 0x59f8148e,
            0x73c737bf, 0x7dce3ab4, 0x6fd52da9, 0x61dc20a2, 0xad766df6, 0xa37f60fd,
            0xb16477e0, 0xbf6d7aeb, 0x955259da, 0x9b5b54d1, 0x894043cc, 0x87494ec7,
            0xdd3e05ae, 0xd33708a5, 0xc12c1fb8, 0xcf2512b3, 0xe51a3182, 0xeb133c89,
            0xf9082b94, 0xf701269f, 0x4de6bd46, 0x43efb04d, 0x51f4a750, 0x5ffdaa5b,
            0x75c2896a, 0x7bcb8461, 0x69d0937c, 0x67d99e77, 0x3daed51e, 0x33a7d815,
            0x21bccf08, 0x2fb5c203, 0x058ae132, 0x0b83ec39, 0x1998fb24, 0x1791f62f,
            0x764dd68d, 0x7844db86, 0x6a5fcc9b, 0x6456c190, 0x4e69e2a1, 0x4060efaa,
            0x527bf8b7, 0x5c72f5bc, 0x0605bed5, 0x080cb3de, 0x1a17a4c3, 0x141ea9c8,
            0x3e218af9, 0x302887f2, 0x223390ef, 0x2c3a9de4, 0x96dd063d, 0x98d40b36,
            0x8acf1c2b, 0x84c61120, 0xaef93211, 0xa0f03f1a, 0xb2eb2807, 0xbce2250c,
            0xe6956e65, 0xe89c636e, 0xfa877473, 0xf48e7978, 0xdeb15a49, 0xd0b85742,
            0xc2a3405f, 0xccaa4d54, 0x41ecdaf7, 0x4fe5d7fc, 0x5dfec0e1, 0x53f7cdea,
            0x79c8eedb, 0x77c1e3d0, 0x65daf4cd, 0x6bd3f9c6, 0x31a4b2af, 0x3fadbfa4,
            0x2db6a8b9, 0x23bfa5b2, 0x09808683, 0x07898b88, 0x15929c95, 0x1b9b919e,
            0xa17c0a47, 0xaf75074c, 0xbd6e1051, 0xb3671d5a, 0x99583e6b, 0x97513360,
            0x854a247d, 0x8b432976, 0xd134621f, 0xdf3d6f14, 0xcd267809, 0xc32f7502,
            0xe9105633, 0xe7195b38, 0xf5024c25, 0xfb0b412e, 0x9ad7618c, 0x94de6c87,
            0x86c57b9a, 0x88cc7691, 0xa2f355a0, 0xacfa58ab, 0xbee14fb6, 0xb0e842bd,
            0xea9f09d4, 0xe49604df, 0xf68d13c2, 0xf8841ec9, 0xd2bb3df8, 0xdcb230f3,
            0xcea927ee, 0xc0a02ae5, 0x7a47b13c, 0x744ebc37, 0x6655ab2a, 0x685ca621,
            0x42638510, 0x4c6a881b, 0x5e719f06, 0x5078920d, 0x0a0fd964, 0x0406d46f,
            0x161dc372, 0x1814ce79, 0x322bed48, 0x3c22e043, 0x2e39f75e, 0x2030fa55,
            0xec9ab701, 0xe293ba0a, 0xf088ad17, 0xfe81a01c, 0xd4be832d, 0xdab78e26,
            0xc8ac993b, 0xc6a59430, 0x9cd2df59, 0x92dbd252, 0x80c0c54f, 0x8ec9c844,
            0xa4f6eb75, 0xaaffe67e, 0xb8e4f163, 0xb6edfc68, 0x0c0a67b1, 0x02036aba,
            0x10187da7, 0x1e1170ac, 0x342e539d, 0x3a275e96, 0x283c498b, 0x26354480,
            0x7c420fe9, 0x724b02e2, 0x605015ff, 0x6e5918f4, 0x44663bc5, 0x4a6f36ce,
            0x587421d3, 0x567d2cd8, 0x37a10c7a, 0x39a80171, 0x2bb3166c, 0x25ba1b67,
            0x0f853856, 0x018c355d, 0x13972240, 0x1d9e2f4b, 0x47e96422, 0x49e06929,
            0x5bfb7e34, 0x55f2733f, 0x7fcd500e, 0x71c45d05, 0x63df4a18, 0x6dd64713,
            0xd731dcca, 0xd938d1c1, 0xcb23c6dc, 0xc52acbd7, 0xef15e8e6, 0xe11ce5ed,
            0xf307f2f0, 0xfd0efffb, 0xa779b492, 0xa970b999, 0xbb6bae84, 0xb562a38f,
            0x9f5d80be, 0x91548db5, 0x834f9aa8, 0x8d4697a3
        ]);
    }
    get _mixCol() {
        if (typeof this._mixC === 'undefined') {
            this._mixC = new Uint8Array(256);
            for (let i = 0; i < 256; i++) {
                if (i < 128) {
                    this._mixC[Number.parseInt(i.toString(), 10)] = i << 1;
                }
                else {
                    this._mixC[Number.parseInt(i.toString(), 10)] = (i << 1) ^ 0x1b;
                }
            }
        }
        return this._mixC;
    }
    _decrypt(input, key) {
        let t;
        let u;
        let v;
        const state = new Uint8Array(16);
        state.set(input);
        for (let j = 0, k = this._keySize; j < 16; ++j, ++k) {
            state[Number.parseInt(j.toString(), 10)] ^= key[Number.parseInt(k.toString(), 10)];
        }
        for (let i = this._cyclesOfRepetition - 1; i >= 1; --i) {
            t = state[13];
            state[13] = state[9];
            state[9] = state[5];
            state[5] = state[1];
            state[1] = t;
            t = state[14];
            u = state[10];
            state[14] = state[6];
            state[10] = state[2];
            state[6] = t;
            state[2] = u;
            t = state[15];
            u = state[11];
            v = state[7];
            state[15] = state[3];
            state[11] = t;
            state[7] = u;
            state[3] = v;
            for (let j = 0; j < 16; ++j) {
                state[Number.parseInt(j.toString(), 10)] = this._inverseS[state[Number.parseInt(j.toString(), 10)]];
            }
            for (let j = 0, k = i * 16; j < 16; ++j, ++k) {
                state[Number.parseInt(j.toString(), 10)] ^= key[Number.parseInt(k.toString(), 10)];
            }
            for (let j = 0; j < 16; j += 4) {
                const s0 = this._mix[state[Number.parseInt(j.toString(), 10)]];
                const s1 = this._mix[state[j + 1]];
                const s2 = this._mix[state[j + 2]];
                const s3 = this._mix[state[j + 3]];
                t = s0 ^ (s1 >>> 8) ^ (s1 << 24) ^ (s2 >>> 16) ^ (s2 << 16) ^ (s3 >>> 24) ^ (s3 << 8);
                state[Number.parseInt(j.toString(), 10)] = (t >>> 24) & 0xff;
                state[j + 1] = (t >> 16) & 0xff;
                state[j + 2] = (t >> 8) & 0xff;
                state[j + 3] = t & 0xff;
            }
        }
        t = state[13];
        state[13] = state[9];
        state[9] = state[5];
        state[5] = state[1];
        state[1] = t;
        t = state[14];
        u = state[10];
        state[14] = state[6];
        state[10] = state[2];
        state[6] = t;
        state[2] = u;
        t = state[15];
        u = state[11];
        v = state[7];
        state[15] = state[3];
        state[11] = t;
        state[7] = u;
        state[3] = v;
        for (let j = 0; j < 16; ++j) {
            state[Number.parseInt(j.toString(), 10)] = this._inverseS[state[Number.parseInt(j.toString(), 10)]];
            state[Number.parseInt(j.toString(), 10)] ^= key[Number.parseInt(j.toString(), 10)];
        }
        return state;
    }
    _encryptBlock(input, key) {
        const s = this._s;
        let t;
        let u;
        let v;
        const state = new Uint8Array(16);
        state.set(input);
        for (let j = 0; j < 16; ++j) {
            state[Number.parseInt(j.toString(), 10)] ^= key[Number.parseInt(j.toString(), 10)];
        }
        for (let i = 1; i < this._cyclesOfRepetition; i++) {
            for (let j = 0; j < 16; ++j) {
                state[Number.parseInt(j.toString(), 10)] = s[state[Number.parseInt(j.toString(), 10)]];
            }
            v = state[1];
            state[1] = state[5];
            state[5] = state[9];
            state[9] = state[13];
            state[13] = v;
            v = state[2];
            u = state[6];
            state[2] = state[10];
            state[6] = state[14];
            state[10] = v;
            state[14] = u;
            v = state[3];
            u = state[7];
            t = state[11];
            state[3] = state[15];
            state[7] = v;
            state[11] = u;
            state[15] = t;
            for (let j = 0; j < 16; j += 4) {
                const s0 = state[j + 0];
                const s1 = state[j + 1];
                const s2 = state[j + 2];
                const s3 = state[j + 3];
                t = s0 ^ s1 ^ s2 ^ s3;
                state[j + 0] ^= t ^ this._mixCol[s0 ^ s1];
                state[j + 1] ^= t ^ this._mixCol[s1 ^ s2];
                state[j + 2] ^= t ^ this._mixCol[s2 ^ s3];
                state[j + 3] ^= t ^ this._mixCol[s3 ^ s0];
            }
            for (let j = 0, k = i * 16; j < 16; ++j, ++k) {
                state[Number.parseInt(j.toString(), 10)] ^= key[Number.parseInt(k.toString(), 10)];
            }
        }
        for (let j = 0; j < 16; ++j) {
            state[Number.parseInt(j.toString(), 10)] = s[state[Number.parseInt(j.toString(), 10)]];
        }
        v = state[1];
        state[1] = state[5];
        state[5] = state[9];
        state[9] = state[13];
        state[13] = v;
        v = state[2];
        u = state[6];
        state[2] = state[10];
        state[6] = state[14];
        state[10] = v;
        state[14] = u;
        v = state[3];
        u = state[7];
        t = state[11];
        state[3] = state[15];
        state[7] = v;
        state[11] = u;
        state[15] = t;
        for (let j = 0, k = this._keySize; j < 16; ++j, ++k) {
            state[Number.parseInt(j.toString(), 10)] ^= key[Number.parseInt(k.toString(), 10)];
        }
        return state;
    }
    _decryptBlockHelper(data, finalize) {
        const sourceLength = data.length;
        let buffer = this._buffer;
        let bufferLength = this._position;
        const result = [];
        let iv = this._iv;
        for (let i = 0; i < sourceLength; ++i) {
            buffer[Number.parseInt(bufferLength.toString(), 10)] = data[Number.parseInt(i.toString(), 10)];
            ++bufferLength;
            if (bufferLength < 16) {
                continue;
            }
            const plain = this._decrypt(buffer, this._key);
            for (let j = 0; j < 16; ++j) {
                plain[Number.parseInt(j.toString(), 10)] ^= iv[Number.parseInt(j.toString(), 10)];
            }
            iv = buffer;
            result.push(plain);
            buffer = new Uint8Array(16);
            bufferLength = 0;
        }
        this._buffer = buffer;
        this._bufferLength = bufferLength;
        this._iv = iv;
        if (result.length === 0) {
            return new Uint8Array(0);
        }
        let outputLength = 16 * result.length;
        if (finalize) {
            const lastBlock = result[result.length - 1];
            let length = lastBlock[15];
            if (length <= 16) {
                for (let i = 15, ii = 16 - length; i >= ii; --i) {
                    if (lastBlock[Number.parseInt(i.toString(), 10)] !== length) {
                        length = 0;
                        break;
                    }
                }
                outputLength -= length;
                result[result.length - 1] = lastBlock.subarray(0, 16 - length);
            }
        }
        const output = new Uint8Array(outputLength);
        for (let i = 0, j = 0; i < result.length; ++i, j += 16) {
            output.set(result[Number.parseInt(i.toString(), 10)], j);
        }
        return output;
    }
    _decryptBlock(data, finalize, iv) {
        const sourceLength = data.length;
        const buffer = this._buffer;
        let bufferLength = this._position;
        if (iv) {
            this._iv = iv;
        }
        else {
            for (let i = 0; bufferLength < 16 && i < sourceLength; ++i, ++bufferLength) {
                buffer[Number.parseInt(bufferLength.toString(), 10)] = data[Number.parseInt(i.toString(), 10)];
            }
            if (bufferLength < 16) {
                this._bufferLength = bufferLength;
                return new Uint8Array(0);
            }
            this._iv = buffer;
            data = data.subarray(16);
        }
        this._buffer = new Uint8Array(16);
        this._bufferLength = 0;
        this._decryptBlock = this._decryptBlockHelper;
        return this._decryptBlock(data, finalize);
    }
    _encrypt(data, iv) {
        const sourceLength = data.length;
        let buffer = this._buffer;
        let bufferLength = this._position;
        const result = [];
        if (!iv) {
            iv = new Uint8Array(16);
        }
        for (let i = 0; i < sourceLength; ++i) {
            buffer[Number.parseInt(bufferLength.toString(), 10)] = data[Number.parseInt(i.toString(), 10)];
            ++bufferLength;
            if (bufferLength < 16) {
                continue;
            }
            for (let j = 0; j < 16; ++j) {
                buffer[Number.parseInt(j.toString(), 10)] ^= iv[Number.parseInt(j.toString(), 10)];
            }
            const cipher = this._encryptBlock(buffer, this._key);
            iv = cipher;
            result.push(cipher);
            buffer = new Uint8Array(16);
            bufferLength = 0;
        }
        this._buffer = buffer;
        this._bufferLength = bufferLength;
        this._iv = iv;
        if (result.length === 0) {
            return new Uint8Array(0);
        }
        const outputLength = 16 * result.length;
        const output = new Uint8Array(outputLength);
        for (let i = 0, j = 0; i < result.length; ++i, j += 16) {
            output.set(result[Number.parseInt(i.toString(), 10)], j);
        }
        return output;
    }
}
class _AdvancedEncryption128Cipher extends _AdvancedEncryptionBaseCipher {
    constructor(key) {
        super();
        this._cyclesOfRepetition = 10;
        this._keySize = 160;
        this._key = new Uint8Array([
            0x8d, 0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x1b, 0x36, 0x6c,
            0xd8, 0xab, 0x4d, 0x9a, 0x2f, 0x5e, 0xbc, 0x63, 0xc6, 0x97, 0x35, 0x6a,
            0xd4, 0xb3, 0x7d, 0xfa, 0xef, 0xc5, 0x91, 0x39, 0x72, 0xe4, 0xd3, 0xbd,
            0x61, 0xc2, 0x9f, 0x25, 0x4a, 0x94, 0x33, 0x66, 0xcc, 0x83, 0x1d, 0x3a,
            0x74, 0xe8, 0xcb, 0x8d, 0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80,
            0x1b, 0x36, 0x6c, 0xd8, 0xab, 0x4d, 0x9a, 0x2f, 0x5e, 0xbc, 0x63, 0xc6,
            0x97, 0x35, 0x6a, 0xd4, 0xb3, 0x7d, 0xfa, 0xef, 0xc5, 0x91, 0x39, 0x72,
            0xe4, 0xd3, 0xbd, 0x61, 0xc2, 0x9f, 0x25, 0x4a, 0x94, 0x33, 0x66, 0xcc,
            0x83, 0x1d, 0x3a, 0x74, 0xe8, 0xcb, 0x8d, 0x01, 0x02, 0x04, 0x08, 0x10,
            0x20, 0x40, 0x80, 0x1b, 0x36, 0x6c, 0xd8, 0xab, 0x4d, 0x9a, 0x2f, 0x5e,
            0xbc, 0x63, 0xc6, 0x97, 0x35, 0x6a, 0xd4, 0xb3, 0x7d, 0xfa, 0xef, 0xc5,
            0x91, 0x39, 0x72, 0xe4, 0xd3, 0xbd, 0x61, 0xc2, 0x9f, 0x25, 0x4a, 0x94,
            0x33, 0x66, 0xcc, 0x83, 0x1d, 0x3a, 0x74, 0xe8, 0xcb, 0x8d, 0x01, 0x02,
            0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x1b, 0x36, 0x6c, 0xd8, 0xab, 0x4d,
            0x9a, 0x2f, 0x5e, 0xbc, 0x63, 0xc6, 0x97, 0x35, 0x6a, 0xd4, 0xb3, 0x7d,
            0xfa, 0xef, 0xc5, 0x91, 0x39, 0x72, 0xe4, 0xd3, 0xbd, 0x61, 0xc2, 0x9f,
            0x25, 0x4a, 0x94, 0x33, 0x66, 0xcc, 0x83, 0x1d, 0x3a, 0x74, 0xe8, 0xcb,
            0x8d, 0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x1b, 0x36, 0x6c,
            0xd8, 0xab, 0x4d, 0x9a, 0x2f, 0x5e, 0xbc, 0x63, 0xc6, 0x97, 0x35, 0x6a,
            0xd4, 0xb3, 0x7d, 0xfa, 0xef, 0xc5, 0x91, 0x39, 0x72, 0xe4, 0xd3, 0xbd,
            0x61, 0xc2, 0x9f, 0x25, 0x4a, 0x94, 0x33, 0x66, 0xcc, 0x83, 0x1d, 0x3a,
            0x74, 0xe8, 0xcb, 0x8d
        ]);
        this._key = this._expandKey(key);
    }
    _expandKey(cipherKey) {
        const count = 176;
        const s = this._s;
        const rcon = this._key;
        const result = new Uint8Array(count);
        result.set(cipherKey);
        for (let j = 16, i = 1; j < count; ++i) {
            let t1 = result[j - 3];
            let t2 = result[j - 2];
            let t3 = result[j - 1];
            let t4 = result[j - 4];
            t1 = s[Number.parseInt(t1.toString(), 10)];
            t2 = s[Number.parseInt(t2.toString(), 10)];
            t3 = s[Number.parseInt(t3.toString(), 10)];
            t4 = s[Number.parseInt(t4.toString(), 10)];
            t1 ^= rcon[Number.parseInt(i.toString(), 10)];
            for (let n = 0; n < 4; ++n) {
                result[Number.parseInt(j.toString(), 10)] = t1 ^= result[j - 16];
                result[j + 1] = t2 ^= result[j - 15];
                result[j + 2] = t3 ^= result[j - 14];
                result[j + 3] = t4 ^= result[j - 13];
                j += 4;
            }
        }
        return result;
    }
}
class _AdvancedEncryption256Cipher extends _AdvancedEncryptionBaseCipher {
    constructor(key) {
        super();
        this._cyclesOfRepetition = 14;
        this._keySize = 224;
        this._key = this._expandKey(key);
    }
    _expandKey(cipherKey) {
        const count = 240;
        const s = this._s;
        const result = new Uint8Array(count);
        result.set(cipherKey);
        let r = 1;
        let t1;
        let t2;
        let t3;
        let t4;
        for (let j = 32, i = 1; j < count; ++i) {
            if (j % 32 === 16) {
                t1 = s[Number.parseInt(t1.toString(), 10)];
                t2 = s[Number.parseInt(t2.toString(), 10)];
                t3 = s[Number.parseInt(t3.toString(), 10)];
                t4 = s[Number.parseInt(t4.toString(), 10)];
            }
            else if (j % 32 === 0) {
                t1 = result[j - 3];
                t2 = result[j - 2];
                t3 = result[j - 1];
                t4 = result[j - 4];
                t1 = s[Number.parseInt(t1.toString(), 10)];
                t2 = s[Number.parseInt(t2.toString(), 10)];
                t3 = s[Number.parseInt(t3.toString(), 10)];
                t4 = s[Number.parseInt(t4.toString(), 10)];
                t1 ^= r;
                r = r << 1;
                if (r >= 256) {
                    r = (r ^ 0x1b) & 0xff;
                }
            }
            for (let n = 0; n < 4; ++n) {
                result[Number.parseInt(j.toString(), 10)] = t1 ^= result[j - 32];
                result[j + 1] = t2 ^= result[j - 31];
                result[j + 2] = t3 ^= result[j - 30];
                result[j + 3] = t4 ^= result[j - 29];
                j += 4;
            }
        }
        return result;
    }
}
class _NullCipher extends _Cipher {
    _decryptBlock(data) {
        return data;
    }
    _encrypt(data) {
        return data;
    }
}
class _CipherTransform {
    constructor(stringCipher, streamCipher) {
        this._stringCipher = stringCipher;
        this._streamCipher = streamCipher;
    }
    createStream(stream, length) {
        return new _PdfDecryptStream(stream, length, this._streamCipher);
    }
    decryptString(s) {
        return _bytesToString(this._stringCipher._decryptBlock(_stringToBytes(s), true));
    }
    encryptString(s) {
        if (this._stringCipher instanceof _AdvancedEncryptionBaseCipher) {
            const length = s.length;
            const pad = 16 - (length % 16);
            s += String.fromCharCode(pad).repeat(pad);
            const iv = new Uint8Array(16);
            if (typeof crypto !== 'undefined') {
                crypto.getRandomValues(iv);
            }
            else {
                for (let i = 0; i < 16; i++) {
                    iv[Number.parseInt(i.toString(), 10)] = Math.floor(256 * Math.random());
                }
            }
            const data = this._stringCipher._encrypt(_stringToBytes(s), iv);
            const buffer = new Uint8Array(16 + data.length);
            buffer.set(iv);
            buffer.set(data, 16);
            return _bytesToString(buffer);
        }
        return _bytesToString(this._stringCipher._encrypt(_stringToBytes(s)));
    }
}

class _PdfCrossReference {
    constructor(document, password) {
        this._version = '';
        this._newLine = '\r\n';
        this._password = password;
        this._document = document;
        this._stream = document._stream;
        this._entries = [];
        this._crossReferencePosition = Object.create(null);
        this._cacheMap = new Map(); // eslint-disable-line
        this._pendingRefs = new _PdfReferenceSet();
    }
    _setStartXRef(startXRef) {
        this._startXRefQueue = [startXRef];
        this._prevStartXref = startXRef;
    }
    _parse(recoveryMode) {
        let trailerDictionary;
        if (!recoveryMode) {
            trailerDictionary = this._readXRef();
        }
        else {
            trailerDictionary = this._indexObjects();
        }
        trailerDictionary.assignXref(this);
        this._nextReferenceNumber = trailerDictionary.get('Size');
        this._trailer = trailerDictionary;
        const encrypt = trailerDictionary.get('Encrypt');
        if (encrypt) {
            this._document._isEncrypted = true;
            this._ids = trailerDictionary.get('ID');
            this._permissionFlags = encrypt.get('P');
            const fileId = this._ids && this._ids.length ? this._ids[0] : '';
            encrypt.suppressEncryption = true;
            this._encrypt = new _PdfEncryptor(encrypt, fileId, this._password);
            this._document._fileStructure._crossReferenceType = PdfCrossReferenceType.stream;
            this._document._isUserPassword = this._encrypt._isUserPassword;
            this._document._encryptOnlyAttachment = this._encrypt._encryptOnlyAttachment;
            if (this._encrypt._encryptOnlyAttachment) {
                this._document._hasUserPasswordOnly = true;
                this._document._encryptMetaData = false;
            }
            else {
                this._document._hasUserPasswordOnly = this._encrypt._hasUserPasswordOnly;
                this._document._encryptMetaData = encrypt.has('EncryptMetadata') ? encrypt.get('EncryptMetadata') : true;
            }
        }
        let hasRoot = false;
        let root;
        try {
            root = trailerDictionary.get('Root');
        }
        catch (e) {
            throw new BaseException('Invalid cross reference', 'XRefParseException');
        }
        if (root) {
            try {
                const pagesEntry = root.get('Pages');
                if (pagesEntry) {
                    this._root = root;
                    hasRoot = true;
                }
            }
            catch (ex) {
                throw new BaseException('Invalid cross reference', 'InvalidXRef');
            }
        }
        if (!hasRoot) {
            if (!recoveryMode) {
                throw new BaseException('Invalid cross reference', 'XRefParseException');
            }
            else {
                throw new BaseException('Invalid cross reference', 'InvalidXRef');
            }
        }
    }
    _getEntry(i) {
        const xrefEntry = this._entries[i]; // eslint-disable-line
        if (xrefEntry && !xrefEntry.free && xrefEntry.offset) {
            return xrefEntry;
        }
        return null;
    }
    _fetch(ref, suppressEncryption) {
        let entry; // eslint-disable-line
        if (!(ref instanceof _PdfReference)) {
            throw new Error('ref object is not a reference');
        }
        const objectNumber = ref.objectNumber;
        const cacheEntry = this._cacheMap.get(ref); // eslint-disable-line
        if (typeof cacheEntry !== 'undefined') {
            if (cacheEntry instanceof _PdfDictionary && !cacheEntry.objId) {
                cacheEntry.objId = objectNumber;
            }
            return cacheEntry;
        }
        const xrefEntry = this._getEntry(objectNumber);
        if (xrefEntry === null) {
            this._cacheMap.set(ref, xrefEntry);
            return xrefEntry;
        }
        if (this._pendingRefs.has(ref)) {
            this._pendingRefs.remove(ref);
            throw new Error('circular reference');
        }
        this._pendingRefs.put(ref);
        try {
            if (xrefEntry.uncompressed) {
                entry = this._fetchUncompressed(ref, xrefEntry, suppressEncryption);
            }
            else {
                entry = this._fetchCompressed(ref, xrefEntry);
            }
            this._pendingRefs.remove(ref);
        }
        catch (ex) {
            this._pendingRefs.remove(ref);
            throw ex;
        }
        return entry;
    }
    _fetchUncompressed(reference, xrefEntry, suppressEncryption) {
        const generationNumber = reference.generationNumber;
        const objectNumber = reference.objectNumber;
        if (xrefEntry.gen !== generationNumber) {
            throw new BaseException(`Inconsistent generation in XRef: ${reference}`, 'XRefEntryException');
        }
        const stream = this._stream.makeSubStream(xrefEntry.offset + this._stream.start, undefined);
        const parser = new _PdfParser(new _PdfLexicalOperator(stream), this, true);
        const obj1 = parser.getObject();
        const obj2 = parser.getObject();
        const obj3 = parser.getObject();
        if (obj1 !== objectNumber || obj2 !== generationNumber || typeof obj3 === 'undefined') {
            throw new BaseException(`Bad (uncompressed) XRef entry: ${reference}`, 'XRefEntryException');
        }
        let entry; // eslint-disable-line
        if (this._encrypt && !suppressEncryption) {
            entry = parser.getObject(this._encrypt._createCipherTransform(reference.objectNumber, reference.generationNumber));
        }
        else {
            entry = parser.getObject();
        }
        if (!(entry instanceof _PdfBaseStream)) {
            this._cacheMap.set(reference, entry);
        }
        if (entry instanceof _PdfDictionary) {
            entry.objId = reference.toString();
        }
        else if (entry instanceof _PdfBaseStream) {
            entry.dictionary.objId = reference.toString();
        }
        return entry;
    }
    _fetchCompressed(ref, xrefEntry) {
        const tableOffset = xrefEntry.offset;
        const stream = this._fetch(_PdfReference.get(tableOffset, 0));
        if (typeof stream === 'undefined') {
            throw new FormatError('bad ObjStm stream');
        }
        const first = stream.dictionary.get('First');
        const n = stream.dictionary.get('N');
        const gen = ref.generationNumber;
        if (!Number.isInteger(first) || !Number.isInteger(n)) {
            throw new FormatError('invalid first and n parameters for ObjStm stream');
        }
        let parser = new _PdfParser(new _PdfLexicalOperator(stream), this, true);
        const nums = new Array(n);
        const offsets = new Array(n);
        for (let i = 0; i < n; ++i) {
            const value = parser.getObject();
            if (!Number.isInteger(value)) {
                throw new FormatError(`invalid object number in the ObjStm stream: ${value}`);
            }
            const offset = parser.getObject();
            if (!Number.isInteger(offset)) {
                throw new FormatError(`invalid object offset in the ObjStm stream: ${offset}`);
            }
            nums[i] = value; // eslint-disable-line
            offsets[i] = offset; // eslint-disable-line
        }
        const start = (stream.start || 0) + first;
        const entries = new Array(n); // eslint-disable-line
        for (let i = 0; i < n; ++i) {
            const length = (i < n - 1 ? (offsets[i + 1] - offsets[i]) : undefined); // eslint-disable-line
            if (length < 0) {
                throw new FormatError('Invalid offset in the ObjStm stream.');
            }
            parser = new _PdfParser(new _PdfLexicalOperator(stream.makeSubStream(start + offsets[i], length, stream.dictionary)), this, true); // eslint-disable-line
            const obj = parser.getObject(); // eslint-disable-line
            entries[i] = obj; // eslint-disable-line
            if (obj instanceof _PdfBaseStream) {
                continue;
            }
            const value = nums[i]; // eslint-disable-line
            const entry = this._entries[value]; // eslint-disable-line
            if (entry && entry.offset === tableOffset && entry.gen === i) {
                const objId = `${value} ${gen}`;
                this._cacheMap.set(_PdfReference.get(value, gen), obj);
                if (obj instanceof _PdfDictionary) {
                    obj.objId = objId;
                }
            }
        }
        const result = entries[xrefEntry.gen]; // eslint-disable-line
        if (typeof result === 'undefined') {
            throw new BaseException(`Bad (compressed) XRef entry: ${ref}`, 'XRefEntryException');
        }
        return result;
    }
    _readXRef(recoveryMode = false) {
        const stream = this._stream;
        const startXRefParsedCache = new Set();
        try {
            while (this._startXRefQueue.length) {
                const startXRef = this._startXRefQueue[0];
                if (this._prevStartXref < startXRef) {
                    this._prevStartXref = startXRef;
                }
                if (startXRefParsedCache.has(startXRef)) {
                    this._startXRefQueue.shift();
                    continue;
                }
                startXRefParsedCache.add(startXRef);
                stream.position = startXRef + stream.start;
                const parser = new _PdfParser(new _PdfLexicalOperator(stream), this, true);
                let obj = parser.getObject(); // eslint-disable-line
                let dictionary;
                if (_isCommand(obj, 'xref')) {
                    if (typeof this._document._fileStructure._crossReferenceType === 'undefined') {
                        this._document._fileStructure._crossReferenceType = PdfCrossReferenceType.table;
                    }
                    dictionary = this._processXRefTable(parser);
                    if (!this._topDictionary) {
                        this._topDictionary = dictionary;
                    }
                    obj = dictionary.get('XRefStm');
                    if (Number.isInteger(obj)) {
                        const position = obj; // eslint-disable-line
                        if (!(position in this._crossReferencePosition)) {
                            this._crossReferencePosition[position] = 1; // eslint-disable-line
                            this._startXRefQueue.push(position);
                        }
                    }
                }
                else if (Number.isInteger(obj)) {
                    if (typeof this._document._fileStructure._crossReferenceType === 'undefined') {
                        this._document._fileStructure._crossReferenceType = PdfCrossReferenceType.stream;
                    }
                    const gen = parser.getObject();
                    const command = parser.getObject();
                    obj = parser.getObject();
                    if (typeof gen === 'undefined' ||
                        !Number.isInteger(gen) ||
                        !_isCommand(command, 'obj') ||
                        !(obj instanceof _PdfBaseStream)) {
                        throw new FormatError('Invalid cross reference stream');
                    }
                    dictionary = this._processXRefStream(obj);
                    if (!this._topDictionary) {
                        this._topDictionary = dictionary;
                    }
                    if (!dictionary) {
                        throw new FormatError('Failed to read XRef stream');
                    }
                }
                else {
                    throw new FormatError('Invalid XRef stream header');
                }
                obj = dictionary.get('Prev');
                if (Number.isInteger(obj)) {
                    this._startXRefQueue.push(obj);
                }
                else if (obj instanceof _PdfReference) {
                    this._startXRefQueue.push(obj.objectNumber);
                }
                this._startXRefQueue.shift();
            }
            return this._topDictionary;
        }
        catch (e) {
            this._startXRefQueue.shift();
        }
        if (recoveryMode) {
            return undefined;
        }
        throw new BaseException('Invalid cross reference', 'XRefParseException');
    }
    _readToken(data, offset) {
        const lf = 0xa;
        const cr = 0xd;
        const lt = 0x3c;
        let token = '';
        let ch = data[offset]; // eslint-disable-line
        while (ch !== lf && ch !== cr && ch !== lt) {
            if (++offset >= data.length) {
                break;
            }
            token += String.fromCharCode(ch);
            ch = data[offset]; // eslint-disable-line
        }
        return token;
    }
    _skipUntil(data, offset, what) {
        const length = what.length;
        const dataLength = data.length;
        let skipped = 0;
        while (offset < dataLength) {
            let i = 0;
            while (i < length && data[offset + i] === what[i]) { // eslint-disable-line
                ++i;
            }
            if (i >= length) {
                break;
            }
            offset++;
            skipped++;
        }
        return skipped;
    }
    _indexObjects() {
        const tab = 0x9;
        const lf = 0xa;
        const cr = 0xd;
        const space = 0x20;
        const percent = 0x25;
        const objRegExp = /^(\d+)\s+(\d+)\s+obj\b/;
        const endobjRegExp = /\bendobj[\b\s]$/;
        const nestedObjRegExp = /\s+(\d+\s+\d+\s+obj[\b\s<])$/;
        const checkContentLength = 25;
        const trailerBytes = new Uint8Array([116, 114, 97, 105, 108, 101, 114]);
        const startxrefBytes = new Uint8Array([115, 116, 97, 114, 116, 120, 114, 101, 102]);
        const objBytes = new Uint8Array([111, 98, 106]);
        const xrefBytes = new Uint8Array([47, 88, 82, 101, 102]);
        this._entries.length = 0;
        this._cacheMap.clear();
        const stream = this._stream;
        stream.position = 0;
        const buffer = stream.getBytes();
        const length = buffer.length;
        let position = stream.start;
        const trailers = [];
        const crossReferencePosition = [];
        while (position < length) {
            let ch = buffer[position]; // eslint-disable-line
            if (ch === tab || ch === lf || ch === cr || ch === space) {
                ++position;
                continue;
            }
            if (ch === percent) {
                do {
                    ++position;
                    if (position >= length) {
                        break;
                    }
                    ch = buffer[position]; // eslint-disable-line
                } while (ch !== lf && ch !== cr);
                continue;
            }
            const token = this._readToken(buffer, position);
            let m; // eslint-disable-line
            if (token.startsWith('xref') && (token.length === 4 || /\s/.test(token[4]))) {
                position += this._skipUntil(buffer, position, trailerBytes);
                trailers.push(position);
                position += this._skipUntil(buffer, position, startxrefBytes);
            }
            else {
                m = objRegExp.exec(token);
                if (m) {
                    const objectNumber = Number.parseInt(m[1]) | 0; // eslint-disable-line
                    const gen = Number.parseInt(m[2]) | 0; // eslint-disable-line
                    let contentLength;
                    let startPos = position + token.length;
                    let updateEntries = false;
                    if (!this._entries[objectNumber]) { // eslint-disable-line
                        updateEntries = true;
                    }
                    else if (this._entries[objectNumber].gen === gen) { // eslint-disable-line
                        try {
                            const subStream = stream.makeSubStream(startPos, stream.length - startPos);
                            const lexicalOperator = new _PdfLexicalOperator(subStream);
                            const parser = new _PdfParser(lexicalOperator, null);
                            parser.getObject();
                            updateEntries = true;
                        }
                        catch (ex) {
                            updateEntries = !(ex instanceof ParserEndOfFileException);
                        }
                    }
                    if (updateEntries) {
                        const info = new _PdfObjectInformation();
                        info.offset = position - stream.start;
                        info.gen = gen;
                        info.uncompressed = true;
                        this._entries[objectNumber] = info; // eslint-disable-line
                    }
                    while (startPos < buffer.length) {
                        const endPos = startPos + this._skipUntil(buffer, startPos, objBytes) + 4;
                        contentLength = endPos - position;
                        const checkPos = Math.max(endPos - checkContentLength, startPos);
                        const tokenStr = _bytesToString(buffer.subarray(checkPos, endPos));
                        if (endobjRegExp.test(tokenStr)) {
                            break;
                        }
                        else {
                            const objToken = nestedObjRegExp.exec(tokenStr); // eslint-disable-line
                            if (objToken && objToken[1]) {
                                contentLength -= objToken[1].length;
                                break;
                            }
                        }
                        startPos = endPos;
                    }
                    const content = buffer.subarray(position, position + contentLength);
                    const xrefTagOffset = this._skipUntil(content, 0, xrefBytes);
                    if (xrefTagOffset < contentLength && content[xrefTagOffset + 5] < 64) {
                        crossReferencePosition.push(position - stream.start);
                        this._crossReferencePosition[position - stream.start] = 1;
                    }
                    position += contentLength;
                }
                else if (token.startsWith('trailer') && (token.length === 7 || /\s/.test(token[7]))) {
                    trailers.push(position);
                    position += this._skipUntil(buffer, position, startxrefBytes);
                }
                else {
                    position += token.length + 1;
                }
            }
        }
        for (let i = 0; i < crossReferencePosition.length; ++i) {
            this._startXRefQueue.push(crossReferencePosition[i]); // eslint-disable-line
            this._readXRef(true);
        }
        let trailerDict;
        for (let i = 0; i < trailers.length; ++i) {
            stream.position = trailers[i]; // eslint-disable-line
            const parser = new _PdfParser(new _PdfLexicalOperator(stream), this, true, true);
            const obj = parser.getObject(); // eslint-disable-line
            if (!_isCommand(obj, 'trailer')) {
                continue;
            }
            const dictionary = parser.getObject(); // eslint-disable-line
            if (!(dictionary instanceof _PdfDictionary)) {
                continue;
            }
            try {
                const rootDict = dictionary.get('Root'); // eslint-disable-line
                if (!(rootDict instanceof _PdfDictionary)) {
                    continue;
                }
                const pagesDict = rootDict.get('Pages'); // eslint-disable-line
                if (!(pagesDict instanceof _PdfDictionary)) {
                    continue;
                }
                const pagesCount = pagesDict.get('Count');
                if (typeof pagesCount === 'undefined' || !Number.isInteger(pagesCount)) {
                    continue;
                }
            }
            catch (ex) {
                continue;
            }
            if (dictionary.has('ID')) {
                return dictionary;
            }
            trailerDict = dictionary;
        }
        if (trailerDict) {
            return trailerDict;
        }
        if (this._topDictionary) {
            return this._topDictionary;
        }
        throw new BaseException('Invalid PDF structure.', 'InvalidPDFException');
    }
    _processXRefTable(parser) {
        if (typeof this._tableState === 'undefined') {
            const tableState = new _PdfCrossTableState();
            tableState.entryNum = 0;
            tableState.streamPos = parser.lexicalOperator.stream.position;
            tableState.parserBuf1 = parser.first;
            tableState.parserBuf2 = parser.second;
            this._tableState = tableState;
        }
        const obj = this._readXRefTable(parser);
        if (!_isCommand(obj, 'trailer')) {
            throw new FormatError('Invalid XRef table: could not find trailer dictionary');
        }
        let topDictionary = parser.getObject(); // eslint-disable-line
        let dictionary;
        if (topDictionary) {
            if (topDictionary instanceof _PdfDictionary) {
                dictionary = topDictionary;
            }
            else if (topDictionary instanceof _PdfBaseStream && topDictionary.dictionary) {
                dictionary = topDictionary.dictionary;
            }
        }
        if (!dictionary) {
            throw new FormatError('Invalid cross reference: could not parse trailer dictionary');
        }
        this._tableState = undefined;
        return dictionary;
    }
    _readXRefTable(parser) {
        const stream = parser.lexicalOperator.stream;
        stream.position = this._tableState.streamPos;
        parser.first = this._tableState.parserBuf1;
        parser.second = this._tableState.parserBuf2;
        let obj; // eslint-disable-line
        while (true) { // eslint-disable-line
            if (typeof this._tableState.firstEntryNum === 'undefined' || typeof this._tableState.entryCount === 'undefined') {
                obj = parser.getObject();
                if (_isCommand(obj, 'trailer')) {
                    break;
                }
                this._tableState.firstEntryNum = obj;
                this._tableState.entryCount = parser.getObject();
            }
            let first = this._tableState.firstEntryNum;
            const count = this._tableState.entryCount;
            if (!Number.isInteger(first) || !Number.isInteger(count)) {
                throw new FormatError('Invalid cross reference: wrong types in subsection header');
            }
            for (let i = this._tableState.entryNum; i < count; i++) {
                this._tableState.streamPos = stream.position;
                this._tableState.entryNum = i;
                this._tableState.parserBuf1 = parser.first;
                this._tableState.parserBuf2 = parser.second;
                const entry = new _PdfObjectInformation();
                entry.offset = parser.getObject();
                entry.gen = parser.getObject();
                const type = parser.getObject();
                if (type) {
                    switch (type.command) {
                        case 'f':
                            entry.free = true;
                            break;
                        case 'n':
                            entry.uncompressed = true;
                            break;
                    }
                }
                if (!Number.isInteger(entry.offset) || !Number.isInteger(entry.gen) || !(entry.free || entry.uncompressed)) {
                    throw new FormatError(`Invalid entry in cross reference subsection: ${first}, ${count}`);
                }
                if (i === 0 && entry.free && first === 1) {
                    first = 0;
                }
                if (!this._entries[i + first]) {
                    this._entries[i + first] = entry;
                }
            }
            this._tableState.entryNum = 0;
            this._tableState.streamPos = stream.position;
            this._tableState.parserBuf1 = parser.first;
            this._tableState.parserBuf2 = parser.second;
            this._tableState.firstEntryNum = undefined;
            this._tableState.entryCount = undefined;
        }
        if (this._entries[0] && !this._entries[0].free) {
            throw new FormatError('Invalid XRef table: unexpected first object');
        }
        return obj;
    }
    _processXRefStream(stream) {
        if (typeof this._streamState === 'undefined') {
            const streamParameters = stream.dictionary;
            const streamState = new _PdfStreamState();
            let index = streamParameters.getArray('Index');
            if (!index) {
                index = [0, streamParameters.get('Size')];
            }
            streamState.entryRanges = index;
            streamState.byteWidths = streamParameters.getArray('W');
            streamState.entryNum = 0;
            streamState.streamPos = stream.position;
            this._streamState = streamState;
        }
        this._readXRefStream(stream);
        this._streamState = undefined;
        return stream.dictionary;
    }
    _readXRefStream(stream) {
        stream.position = this._streamState.streamPos;
        const typeFieldWidth = this._streamState.byteWidths[0];
        const offsetFieldWidth = this._streamState.byteWidths[1];
        const generationFieldWidth = this._streamState.byteWidths[2];
        const entryRanges = this._streamState.entryRanges;
        while (entryRanges.length > 0) {
            const first = entryRanges[0];
            const n = entryRanges[1];
            if (!Number.isInteger(first) || !Number.isInteger(n)) {
                throw new FormatError(`Invalid XRef range fields: ${first}, ${n}`);
            }
            if (!Number.isInteger(typeFieldWidth) || !Number.isInteger(offsetFieldWidth) || !Number.isInteger(generationFieldWidth)) {
                throw new FormatError(`Invalid XRef entry fields length: ${first}, ${n}`);
            }
            for (let i = this._streamState.entryNum; i < n; ++i) {
                this._streamState.entryNum = i;
                this._streamState.streamPos = stream.position;
                let type = 0;
                let offset = 0;
                let generation = 0;
                for (let j = 0; j < typeFieldWidth; ++j) {
                    const typeByte = stream.getByte();
                    if (typeByte === -1) {
                        throw new FormatError('invalid cross reference byte width type.');
                    }
                    type = (type << 8) | typeByte;
                }
                if (typeFieldWidth === 0) {
                    type = 1;
                }
                for (let j = 0; j < offsetFieldWidth; ++j) {
                    const offsetByte = stream.getByte();
                    if (offsetByte === -1) {
                        throw new FormatError('invalid cross reference byte width offset.');
                    }
                    offset = (offset << 8) | offsetByte;
                }
                for (let j = 0; j < generationFieldWidth; ++j) {
                    const generationByte = stream.getByte();
                    if (generationByte === -1) {
                        throw new FormatError('invalid cross reference byte width generation.');
                    }
                    generation = (generation << 8) | generationByte;
                }
                const entry = new _PdfObjectInformation();
                entry.offset = offset;
                entry.gen = generation;
                switch (type) {
                    case 0:
                        entry.free = true;
                        break;
                    case 1:
                        entry.uncompressed = true;
                        break;
                    case 2:
                        break;
                    default:
                        throw new FormatError(`Invalid XRef entry type: ${type}`);
                }
                if (!this._entries[first + i]) {
                    this._entries[first + i] = entry;
                }
            }
            this._streamState.entryNum = 0;
            this._streamState.streamPos = stream.position;
            entryRanges.splice(0, 2);
        }
    }
    _getCatalogObj() {
        return this._root;
    }
    _save() {
        const currentLength = this._stream.length;
        const buffer = [this._newLine.charCodeAt(0), this._newLine.charCodeAt(1), 37, 80, 68, 70, 45];
        this._writeString(`${this._version}${this._newLine}`, buffer);
        buffer.push(0x25, 0x83, 0x92, 0xfa, 0xfe);
        this._writeString(this._newLine, buffer);
        let updatedCount = 0;
        let uncompressedCount = 0;
        if (this._document._fileStructure._crossReferenceType === PdfCrossReferenceType.stream) {
            const data = [];
            const updatedStream = [];
            let archiveXRef = '';
            const indexes = [];
            indexes.push(0, 1);
            const collection = [];
            const uncompressedOffsets = [];
            this._cacheMap.forEach((value, key) => {
                let dictionary;
                if (value instanceof _PdfBaseStream) {
                    dictionary = value.dictionary;
                }
                if (dictionary && dictionary._updated && (!dictionary.isCatalog || this._allowCatalog)) {
                    indexes.push(key.objectNumber, 1);
                    uncompressedOffsets.push(currentLength + buffer.length);
                    let cipher;
                    if (this._encrypt) {
                        cipher = this._encrypt._createCipherTransform(key.objectNumber, key.generationNumber);
                    }
                    this._writeObject(value, buffer, key, cipher);
                    uncompressedCount++;
                    dictionary._updated = false;
                }
            });
            this._cacheMap.forEach((value, key) => {
                if (value instanceof _PdfDictionary) {
                    if (value._updated && (!value.isCatalog || this._allowCatalog)) {
                        archiveXRef += `${key.objectNumber} ${updatedStream.length}${this._newLine}`;
                        collection.push(key.objectNumber, 1);
                        updatedCount++;
                        this._writeObject(value, updatedStream);
                    }
                }
                else if (value instanceof _PdfBaseStream) {
                    const dictionary = value.dictionary;
                    if (dictionary && dictionary._updated && (!dictionary.isCatalog || this._allowCatalog)) {
                        indexes.push(key.objectNumber, 1);
                        uncompressedOffsets.push(currentLength + buffer.length);
                        this._writeObject(value, buffer, key);
                        uncompressedCount++;
                        dictionary._updated = false;
                    }
                }
            });
            for (let i = 0; i < collection.length; i++) {
                indexes.push(collection[parseInt(i.toString(), 10)]);
            }
            let archiveOffset;
            let archiveRef;
            if (updatedCount > 0) {
                archiveRef = this._getNextReference();
                indexes.push(archiveRef.objectNumber, 2);
                this._writeString(archiveXRef, data);
                this._writeBytes(updatedStream, data);
                const newDict = new _PdfDictionary(this);
                newDict.set('Type', _PdfName.get('ObjStm'));
                newDict.set('N', updatedCount);
                newDict.set('First', archiveXRef.length);
                newDict.set('Length', data.length);
                const archiveStream = new _PdfStream(data, newDict, 0, data.length);
                archiveOffset = currentLength + buffer.length;
                let cipher;
                if (this._encrypt) {
                    cipher = this._encrypt._createCipherTransform(archiveRef.objectNumber, archiveRef.generationNumber);
                }
                this._writeObject(archiveStream, buffer, archiveRef, cipher);
            }
            const newRef = this._getNextReference();
            const newStartXref = currentLength + buffer.length;
            const newXref = new _PdfDictionary(this);
            newXref.set('Type', _PdfName.get('XRef'));
            newXref.set('Index', indexes);
            newXref.set('W', [1, 3, 1]);
            this._copyTrailer(newXref);
            if (this._ids && this._ids.length > 0) {
                newXref.update('ID', [this._ids[0], this._computeMessageDigest(newStartXref)]);
            }
            const newXrefData = [];
            this._writeLong(0, 1, newXrefData);
            this._writeLong(1, 3, newXrefData);
            this._writeLong(-1, 1, newXrefData);
            if (uncompressedCount > 0) {
                for (let index = 0; index < uncompressedCount; index++) {
                    this._writeLong(1, 1, newXrefData);
                    this._writeLong(uncompressedOffsets[index], 3, newXrefData); // eslint-disable-line
                    this._writeLong(0, 1, newXrefData);
                }
            }
            if (updatedCount > 0) {
                for (let index = 0; index < updatedCount; index++) {
                    this._writeLong(2, 1, newXrefData);
                    this._writeLong(archiveRef.objectNumber, 3, newXrefData);
                    this._writeLong(index, 1, newXrefData);
                }
                this._writeLong(1, 1, newXrefData);
                this._writeLong(archiveOffset, 3, newXrefData);
                this._writeLong(0, 1, newXrefData);
            }
            this._writeLong(1, 1, newXrefData);
            this._writeLong(newStartXref, 3, newXrefData);
            this._writeLong(0, 1, newXrefData);
            newXref.set('Length', newXrefData.length);
            const newXrefStream = new _PdfStream(newXrefData, newXref, 0, newXrefData.length);
            let cipher;
            if (this._encrypt) {
                cipher = this._encrypt._createCipherTransform(newRef.objectNumber, newRef.generationNumber);
            }
            this._writeObject(newXrefStream, buffer, newRef, cipher, true);
            this._writeString(`startxref${this._newLine}${newStartXref}${this._newLine}%%EOF${this._newLine}`, buffer);
        }
        else {
            let tempBuffer = '';
            this._cacheMap.forEach((value, key) => {
                let dictionary;
                if (value instanceof _PdfDictionary) {
                    dictionary = value;
                }
                else if (value instanceof _PdfBaseStream) {
                    dictionary = value.dictionary;
                }
                if (dictionary && dictionary._updated && (!dictionary.isCatalog || this._allowCatalog)) {
                    let offsetString = (currentLength + buffer.length).toString();
                    while (offsetString.length < 10) {
                        offsetString = '0' + offsetString;
                    }
                    let genString = key.generationNumber.toString();
                    while (genString.length < 5) {
                        genString = '0' + genString;
                    }
                    tempBuffer += `${key.objectNumber} 1${this._newLine}${offsetString} ${genString} n${this._newLine}`;
                    updatedCount++;
                    this._writeObject(value, buffer, key);
                }
            });
            const newStartXref = buffer.length + currentLength;
            this._writeString(`xref${this._newLine}0 1${this._newLine}0000000000 65535 f${this._newLine}`, buffer);
            if (updatedCount > 0) {
                this._writeString(tempBuffer, buffer);
            }
            this._writeString(`trailer${this._newLine}`, buffer);
            const newXref = new _PdfDictionary(this);
            this._copyTrailer(newXref);
            this._writeDictionary(newXref, buffer, this._newLine);
            this._writeString(`startxref${this._newLine}${newStartXref}${this._newLine}%%EOF${this._newLine}`, buffer);
        }
        const array = new Uint8Array(this._stream.length + buffer.length);
        array.set(this._stream.bytes);
        array.set(buffer, this._stream.length);
        return array;
    }
    _copyTrailer(newXref) {
        newXref.set('Size', this._nextReferenceNumber);
        newXref.set('Prev', this._prevStartXref);
        const root = this._trailer.getRaw('Root'); // eslint-disable-line
        if (typeof root !== 'undefined' && root !== null) {
            newXref.set('Root', root);
        }
        const info = this._trailer.getRaw('Info'); // eslint-disable-line
        if (typeof info !== 'undefined' && info !== null) {
            newXref.set('Info', info);
        }
        const encrypt = this._trailer.getRaw('Encrypt'); // eslint-disable-line
        if (typeof encrypt !== 'undefined' && encrypt !== null) {
            newXref.set('Encrypt', encrypt);
        }
    }
    _computeMessageDigest(size) {
        const time = Math.floor(Date.now() / 1000);
        const buffer = [time.toString(), '', size.toString()];
        const info = this._trailer.getRaw('Info');
        const crossReferenceInfo = new _PdfDictionary();
        if (info && info instanceof _PdfDictionary) {
            info.forEach((key, value) => {
                if (value && typeof value === 'string') {
                    crossReferenceInfo.set(key, _stringToPdfString(value));
                }
            });
        }
        crossReferenceInfo.forEach((key, value) => {
            buffer.push(value);
        });
        const array = [];
        buffer.forEach((str) => {
            this._writeString(str, array);
        });
        return _bytesToString((new _MD5().hash(new Uint8Array(array))));
    }
    _getNextReference() {
        const reference = new _PdfReference(this._nextReferenceNumber++, 0);
        reference._isNew = true;
        return reference;
    }
    _writeObject(obj, buffer, reference, transform, isCrossReference) {
        if (reference && reference instanceof _PdfReference) {
            this._writeString(`${reference.objectNumber} ${reference.generationNumber} obj${this._newLine}`, buffer);
        }
        if (obj instanceof _PdfDictionary) {
            this._writeDictionary(obj, buffer, this._newLine, transform, isCrossReference);
        }
        else if (obj instanceof _PdfBaseStream) {
            this._writeStream(obj, buffer, transform, isCrossReference);
        }
        if (reference && reference instanceof _PdfReference) {
            this._writeString(`endobj${this._newLine}`, buffer);
        }
    }
    _writeDictionary(dictionary, buffer, spaceChar, transform, isCrossReference) {
        if (dictionary._currentObj) {
            dictionary._currentObj._beginSave();
        }
        if (dictionary._isFont) {
            this._writeFontDictionary(dictionary);
        }
        this._writeString(`<<${spaceChar}`, buffer);
        dictionary.forEach((key, value) => {
            this._writeString(`/${_escapePdfName(key)} `, buffer);
            this._writeValue(value, buffer, transform, isCrossReference);
            this._writeString(spaceChar, buffer);
        });
        this._writeString(`>>${this._newLine}`, buffer);
    }
    _writeFontDictionary(dictionary) {
        if (dictionary.has('DescendantFonts')) {
            const fonts = dictionary.get('DescendantFonts'); // eslint-disable-line
            const reference = this._getNextReference();
            this._cacheMap.set(reference, fonts);
            dictionary.update('DescendantFonts', [reference]);
        }
        if (dictionary.has('ToUnicode')) {
            const fonts = dictionary.get('ToUnicode'); // eslint-disable-line
            const reference = this._getNextReference();
            this._cacheMap.set(reference, fonts);
            dictionary.update('ToUnicode', reference);
        }
        if (dictionary.has('FontFile2')) {
            const fonts = dictionary.get('FontFile2'); // eslint-disable-line
            const reference = this._getNextReference();
            this._cacheMap.set(reference, fonts);
            dictionary.update('FontFile2', reference);
        }
        if (dictionary.has('FontDescriptor')) {
            const fonts = dictionary.get('FontDescriptor'); // eslint-disable-line
            const reference = this._getNextReference();
            this._cacheMap.set(reference, fonts);
            dictionary.update('FontDescriptor', reference);
        }
    }
    _writeStream(stream, buffer, transform, isCrossReference) {
        const streamBuffer = [];
        let value = stream.getString();
        if (!isCrossReference) {
            const byteArray = [];
            for (let i = 0; i < value.length; i++) {
                byteArray.push(value.charCodeAt(i));
            }
            if (stream._isCompress) {
                const dataArray = new Uint8Array(byteArray);
                const sw = new CompressedStreamWriter();
                sw.write(dataArray, 0, dataArray.length);
                sw.close();
                value = sw.getCompressedString;
                stream.dictionary.update('Filter', _PdfName.get('FlateDecode'));
            }
            if (transform) {
                value = transform.encryptString(value);
            }
        }
        this._writeString(value, streamBuffer);
        stream.dictionary.update('Length', streamBuffer.length);
        this._writeDictionary(stream.dictionary, buffer, this._newLine, transform, isCrossReference);
        this._writeString(`stream${this._newLine}`, buffer);
        this._writeBytes(streamBuffer, buffer);
        this._writeString(`${this._newLine}endstream${this._newLine}`, buffer);
    }
    _writeValue(value, buffer, transform, isCrossReference) {
        if (value instanceof _PdfName) {
            this._writeString(`/${value.name}`, buffer);
        }
        else if (value instanceof _PdfReference) {
            this._writeString(`${value.toString()} R`, buffer);
        }
        else if (Array.isArray(value)) {
            this._writeString('[', buffer);
            let first = true;
            for (const val of value) {
                if (!first) {
                    this._writeString(' ', buffer);
                }
                else {
                    first = false;
                }
                this._writeValue(val, buffer, transform, isCrossReference);
            }
            this._writeString(']', buffer);
        }
        else if (typeof value === 'string') {
            if (!isCrossReference && transform) {
                value = transform.encryptString(value);
            }
            this._writeString(`(${this._escapeString(value)})`, buffer);
        }
        else if (typeof value === 'number') {
            this._writeString(_numberToString(value), buffer);
        }
        else if (typeof value === 'boolean') {
            this._writeString(value.toString(), buffer);
        }
        else if (value instanceof _PdfDictionary) {
            this._writeDictionary(value, buffer, this._newLine, transform, isCrossReference);
        }
        else if (value instanceof _PdfBaseStream) {
            this._writeStream(value, buffer, transform, isCrossReference);
        }
        else if (value === null) {
            this._writeString('null', buffer);
        }
    }
    _writeString(value, buffer) {
        for (let i = 0; i < value.length; i++) {
            buffer.push(value.charCodeAt(i) & 0xff);
        }
    }
    _writeBytes(data, buffer) {
        for (let i = 0; i < data.length; i++) {
            buffer.push(data[i]); // eslint-disable-line
        }
    }
    _writeLong(value, count, buffer) {
        for (let i = count - 1; i >= 0; --i) {
            buffer.push(value >> (i << 3) & 0xff);
        }
    }
    _escapeString(value) {
        return value.replace(/([()\\\n\r])/g, (substring) => {
            if (substring === '\n') {
                return '\\n';
            }
            else if (substring === '\r') {
                return '\\r';
            }
            return `\\${substring}`;
        });
    }
    _destroy() {
        this._entries = undefined;
        this._pendingRefs.clear();
        this._pendingRefs = undefined;
        this._cacheMap.clear();
        this._pendingRefs = undefined;
        this._root = undefined;
        this._startXRefQueue = [];
        this._startXRefQueue = undefined;
        this._stream = undefined;
        this._streamState = undefined;
        this._tableState = undefined;
        this._topDictionary = undefined;
        this._trailer = undefined;
        this._version = undefined;
        this._crossReferencePosition = undefined;
    }
}
class _PdfObjectInformation {
}
class _PdfCrossTableState {
}
class _PdfStreamState {
}

/**
 * Represents a PDF form.
 * ```typescript
 * // Load an existing PDF document
 * let document: PdfDocument = new PdfDocument(data, password);
 * // Access the form of the PDF document
 * let form: PdfForm = document.form;
 * // Save the document
 * document.save('output.pdf');
 * // Destroy the document
 * document.destroy();
 * ```
 */
class PdfForm {
    /**
     * Represents a loaded from the PDF document.
     *
     * @private
     * @param {_PdfDictionary} dictionary Form dictionary.
     * @param {_PdfCrossReference} crossReference Cross reference object.
     */
    constructor(dictionary, crossReference) {
        this._hasKids = false;
        this._setAppearance = false;
        this._exportEmptyFields = false;
        this._fieldCollection = [];
        this._signFlag = _SignatureFlag.none;
        this._dictionary = dictionary;
        this._crossReference = crossReference;
        this._parsedFields = new Map();
        this._fields = [];
        this._createFields();
    }
    /**
     * Gets the fields count (Read only).
     *
     * @returns {number} Fields count.
     *
     * ```typescript
     * // Load an existing PDF document
     * let document: PdfDocument = new PdfDocument(data, password);
     * // Access loaded form
     * let form: PdfForm = document.form;
     * // Gets the fields count
     * let count: number = form.count;
     * // Destroy the document
     * document.destroy();
     * ```
     */
    get count() {
        return this._fields.length;
    }
    /**
     *  Gets a value indicating whether need appearances (Read only).
     *
     * @returns {boolean} Need appearances.
     *
     * ```typescript
     * // Load an existing PDF document
     * let document: PdfDocument = new PdfDocument(data, password);
     * // Access loaded form
     * let form: PdfForm = document.form;
     * // Gets the boolean flag indicating need appearances
     * let needAppearances: number = form.needAppearances;
     * // Destroy the document
     * document.destroy();
     * ```
     */
    get needAppearances() {
        if (this._dictionary.has('NeedAppearances')) {
            this._needAppearances = this._dictionary.get('NeedAppearances');
        }
        return this._needAppearances;
    }
    /**
     *  Gets a value indicating whether allow to export empty fields or not.
     *
     * @returns {boolean} Export empty fields.
     * ```typescript
     * // Load an existing PDF document
     * let document: PdfDocument = new PdfDocument(data, password);
     * // Access loaded form
     * let form: PdfForm = document.form;
     * // Gets a value indicating whether allow to export empty fields or not.
     * let exportEmptyFields: boolean = form.exportEmptyFields;
     * // Save the document
     * document.save('output.pdf');
     * // Destroy the document
     * document.destroy();
     * ```
     */
    get exportEmptyFields() {
        return this._exportEmptyFields;
    }
    /**
     *  Sets a value indicating whether allow to export empty fields or not.
     *
     * @param {boolean} value Export empty fields.
     * ```typescript
     * // Load an existing PDF document
     * let document: PdfDocument = new PdfDocument(data, password);
     * // Access loaded form
     * let form: PdfForm = document.form;
     * // Sets a value indicating whether allow to export empty fields or not.
     * form.exportEmptyFields = false;
     * // Save the document
     * document.save('output.pdf');
     * // Destroy the document
     * document.destroy();
     * ```
     */
    set exportEmptyFields(value) {
        this._exportEmptyFields = value;
    }
    get _signatureFlag() {
        return this._signFlag;
    }
    set _signatureFlag(value) {
        if (value !== this._signFlag) {
            this._signFlag = value;
            this._dictionary.update('SigFlags', value);
        }
    }
    /**
     * Gets the `PdfField` at the specified index.
     *
     * @param {number} index Field index.
     * @returns {PdfField} Loaded PDF form field at the specified index.
     *
     * ```typescript
     * // Load an existing PDF document
     * let document: PdfDocument = new PdfDocument(data, password);
     * // Access the loaded form field
     * let field: PdfField = document.form.fieldAt(0);
     * // Save the document
     * document.save('output.pdf');
     * // Destroy the document
     * document.destroy();
     * ```
     */
    fieldAt(index) {
        if (index < 0 || index >= this._fields.length) {
            throw Error('Index out of range.');
        }
        let field;
        if (this._parsedFields.has(index)) {
            field = this._parsedFields.get(index);
        }
        else {
            let dictionary;
            const ref = this._fields[index]; // eslint-disable-line
            if (ref && ref instanceof _PdfReference) {
                dictionary = this._crossReference._fetch(ref);
            }
            if (dictionary) {
                const key = _getInheritableProperty(dictionary, 'FT', false, true, 'Parent');
                let fieldFlags = 0;
                const flag = _getInheritableProperty(dictionary, 'Ff', false, true, 'Parent');
                if (typeof flag !== 'undefined') {
                    fieldFlags = flag;
                }
                if (key) {
                    switch (key.name.toLowerCase()) {
                        case 'tx':
                            field = PdfTextBoxField._load(this, dictionary, this._crossReference, ref);
                            break;
                        case 'btn':
                            if ((fieldFlags & _FieldFlag.pushButton) !== 0) {
                                field = PdfButtonField._load(this, dictionary, this._crossReference, ref);
                            }
                            else if ((fieldFlags & _FieldFlag.radio) !== 0) {
                                field = PdfRadioButtonListField._load(this, dictionary, this._crossReference, ref);
                            }
                            else {
                                field = PdfCheckBoxField._load(this, dictionary, this._crossReference, ref);
                            }
                            break;
                        case 'ch':
                            if ((fieldFlags & _FieldFlag.combo) !== 0) {
                                field = PdfComboBoxField._load(this, dictionary, this._crossReference, ref);
                            }
                            else {
                                field = PdfListBoxField._load(this, dictionary, this._crossReference, ref);
                            }
                            break;
                        case 'sig':
                            field = PdfSignatureField._load(this, dictionary, this._crossReference, ref);
                            break;
                    }
                }
                this._parsedFields.set(index, field);
                if (field && field instanceof PdfField) {
                    field._annotationIndex = index;
                }
            }
        }
        return field;
    }
    /**
     * Add a new `PdfField`.
     *
     * @param {PdfField} field Field object to add.
     * @returns {number} Field index.
     *
     * ```typescript
     * // Load an existing PDF document
     * let document: PdfDocument = new PdfDocument(data, password);
     * // Add a new form field
     * let index: number = document.form.add(field);
     * // Save the document
     * document.save('output.pdf');
     * // Destroy the document
     * document.destroy();
     * ```
     */
    add(field) {
        this._fields.push(field._ref);
        this._dictionary.update('Fields', this._fields);
        this._parsedFields.set(this._fields.length - 1, field);
        field._form = this;
        this._crossReference._allowCatalog = true;
        this._crossReference._root._updated = true;
        if (field._kidsCount > 0) {
            for (let i = 0; i < field._kidsCount; i++) {
                const item = field.itemAt(i);
                const page = item._page;
                page.annotations._annotations.push(item._ref);
                page._pageDictionary.set('Annots', page.annotations._annotations);
                page._pageDictionary._updated = true;
            }
        }
        else if (field._dictionary.has('Subtype') && field._dictionary.get('Subtype').name === 'Widget') {
            const page = field._page;
            page.annotations._annotations.push(field._ref);
            field._page._pageDictionary.set('Annots', field.page.annotations._annotations);
            field._page._pageDictionary._updated = true;
        }
        if (field instanceof PdfSignatureField) {
            field._form._signatureFlag = _SignatureFlag.signatureExists | _SignatureFlag.appendOnly;
        }
        return (this._fields.length - 1);
    }
    /**
     * Remove the specified PDF form field.
     *
     * @param {PdfField} field Field object to remove.
     * @returns {void} Nothing.
     *
     * ```typescript
     * // Load an existing PDF document
     * let document: PdfDocument = new PdfDocument(data, password);
     * // Access the loaded form field
     * let field: PdfField = document.form.fieldAt(3);
     * // Remove the form field
     * document.form.removeField(field);
     * // Save the document
     * document.save('output.pdf');
     * // Destroy the document
     * document.destroy();
     * ```
     */
    removeField(field) {
        const index = this._fields.indexOf(field._ref);
        if (index >= 0) {
            this.removeFieldAt(index);
        }
    }
    /**
     * Remove the PDF form field from specified index.
     *
     * @param {number} index Field index to remove.
     * @returns {void} Nothing.
     *
     * ```typescript
     * // Load an existing PDF document
     * let document: PdfDocument = new PdfDocument(data, password);
     * // Remove the form field from the specified index
     * document.form.removeFieldAt(3);
     * // Save the document
     * document.save('output.pdf');
     * // Destroy the document
     * document.destroy();
     * ```
     */
    removeFieldAt(index) {
        const field = this.fieldAt(index);
        if (field) {
            if (field._kidsCount > 0) {
                for (let i = field._kidsCount - 1; i >= 0; i--) {
                    const item = field.itemAt(i);
                    const page = item._getPage();
                    if (page) {
                        page._removeAnnotation(item._ref);
                    }
                }
            }
            else if (field._dictionary.has('Subtype') && field._dictionary.get('Subtype').name === 'Widget') {
                const page = field.page;
                if (page) {
                    page._removeAnnotation(field._ref);
                }
            }
            this._parsedFields.delete(index);
        }
        this._fields.splice(index, 1);
        this._dictionary.set('Fields', this._fields);
        this._dictionary._updated = true;
    }
    /**
     * Sets the flag to indicate the new appearance creation
     * If true, appearance will not be created. Default appearance has been considered.
     * If false, new appearance stream has been created from field values and updated as normal appearance.
     *
     * @param {boolean} value Set default appearance.
     * @returns {void} Nothing.
     *
     * ```typescript
     * // Load an existing PDF document
     * let document: PdfDocument = new PdfDocument(data, password);
     * // Set boolean flag to create a new appearance stream for form fields.
     * document.form.setDefaultAppearance(false);
     * // Save the document
     * document.save('output.pdf');
     * // Destroy the document
     * document.destroy();
     * ```
     */
    setDefaultAppearance(value) {
        this._setAppearance = !value;
        this._needAppearances = value;
        this._dictionary.update('NeedAppearances', value);
    }
    orderFormFields(tabOrder) {
        if (tabOrder === null || typeof tabOrder === 'undefined') {
            this.orderFormFields(new Map());
        }
        else {
            let tab;
            const document = this._crossReference._document;
            let value;
            if (tabOrder && tabOrder instanceof Map) {
                let setTabOrder = true;
                if (tabOrder.size > 0) {
                    this._tabCollection = tabOrder;
                }
                else {
                    setTabOrder = false;
                    this._tabCollection = tabOrder;
                }
                const fieldCollection = new Map();
                this._fieldCollection = this._getFields();
                if (this._fieldCollection && this._fieldCollection.length > 0) {
                    const page = this._fieldCollection[0].page;
                    if (page && document) {
                        for (let i = 0; i < this._fieldCollection.length; i++) {
                            const field = this._fieldCollection[Number.parseInt(i.toString(), 10)];
                            if (field.page) {
                                const index = _getPageIndex(document, this._sortItemByPageIndex(field, true)._pageDictionary);
                                if (index >= 0) {
                                    if (fieldCollection.has(index)) {
                                        value = fieldCollection.get(index);
                                        value.push(field);
                                    }
                                    else {
                                        value = [];
                                        value.push(field);
                                        fieldCollection.set(index, value);
                                    }
                                    const page = document.getPage(index);
                                    if (!this._tabCollection.has(index)) {
                                        this._tabCollection.set(index, page.tabOrder);
                                    }
                                    if (setTabOrder) {
                                        page.tabOrder = this._tabCollection.get(index);
                                    }
                                }
                            }
                        }
                        let fieldsCount = 0;
                        fieldCollection.forEach((value, key) => {
                            this._tabOrder = this._tabCollection.get(key);
                            if (this._tabOrder !== PdfFormFieldsTabOrder.structure) {
                                const fields = value;
                                fields.sort((pdfField1, pdfField2) => {
                                    return this._compareFields(pdfField1, pdfField2);
                                });
                                for (let j = 0; j < fields.length; j++) {
                                    const fieldIndex = this._fieldCollection.indexOf(fields[Number.parseInt(j.toString(), 10)]);
                                    if (fieldIndex !== -1 && fieldIndex !== fieldsCount + j) {
                                        const field = this._fieldCollection[Number.parseInt(fieldIndex.toString(), 10)];
                                        this._fieldCollection.splice(fieldIndex, 1);
                                        this._fieldCollection.splice(fieldsCount + j, 0, field);
                                    }
                                }
                            }
                            fieldsCount += value.length;
                        });
                    }
                }
            }
            else {
                this._tabOrder = tabOrder;
                tab = this._getOrder(this._tabOrder);
                this._fieldCollection = this._getFields();
                this._fieldCollection.sort((pdfField1, pdfField2) => {
                    return this._compareFields(pdfField1, pdfField2);
                });
            }
            this._parsedFields.clear();
            for (let i = 0; i < this._fieldCollection.length; i++) {
                this._parsedFields.set(Number.parseInt(i.toString(), 10), this._fieldCollection[Number.parseInt(i.toString(), 10)]);
                this._fields[Number.parseInt(i.toString(), 10)] = this._fieldCollection[Number.parseInt(i.toString(), 10)]._ref;
                if (tab) {
                    this._fieldCollection[Number.parseInt(i.toString(), 10)].page._pageDictionary.update('Tabs', tab);
                }
            }
            this._dictionary.update('Fields', this._fields);
        }
    }
    _createFields() {
        let fields; // eslint-disable-line
        if (this._dictionary.has('Fields')) {
            fields = this._dictionary.get('Fields');
        }
        let count = 0;
        const nodes = []; // eslint-disable-line
        while (typeof fields !== 'undefined' && fields !== null) {
            for (; count < fields.length; count++) {
                const ref = fields[count]; // eslint-disable-line
                let fieldDictionary;
                if (ref && ref instanceof _PdfReference) {
                    fieldDictionary = this._crossReference._fetch(ref);
                }
                let fieldKids;
                if (fieldDictionary && fieldDictionary.has('Kids')) {
                    fieldKids = fieldDictionary.get('Kids');
                    if (typeof fieldKids !== 'undefined' && fieldKids.length > 0) {
                        for (let i = 0; i < fieldKids.length; i++) {
                            const reference = fieldKids[Number.parseInt(i.toString(), 10)];
                            if (reference && reference instanceof _PdfReference) {
                                const kidsDict = this._crossReference._fetch(reference);
                                if (typeof kidsDict !== 'undefined' && !kidsDict.has('Parent')) {
                                    kidsDict.update('Parent', ref);
                                }
                            }
                        }
                    }
                }
                if (typeof fieldKids === 'undefined') {
                    if (typeof fieldDictionary !== 'undefined') {
                        if (this._fields.indexOf(ref) === -1) {
                            this._fields.push(ref);
                        }
                    }
                }
                else {
                    const isNode = (!fieldDictionary.has('FT')) || this._isNode(fieldKids);
                    if (isNode) {
                        nodes.push({ fields, count });
                        this._hasKids = true;
                        count = -1;
                        fields = fieldKids;
                    }
                    else {
                        this._fields.push(ref);
                    }
                }
            }
            if (nodes.length === 0) {
                break;
            }
            const entry = nodes.pop(); // eslint-disable-line
            fields = entry.fields;
            count = entry.count + 1;
        }
    }
    _isNode(kids) {
        let isNode = false;
        if (typeof kids !== 'undefined' && kids.length > 0) {
            const entry = kids[0]; // eslint-disable-line
            let dictionary;
            if (typeof entry !== 'undefined' && entry !== null) {
                if (entry instanceof _PdfDictionary) {
                    dictionary = entry;
                }
                else if (entry instanceof _PdfReference) {
                    dictionary = this._crossReference._fetch(entry);
                }
            }
            if (typeof dictionary !== 'undefined' && dictionary.has('Subtype')) {
                const subtype = dictionary.get('Subtype');
                if (subtype && subtype.name !== 'Widget') {
                    isNode = true;
                }
            }
        }
        return isNode;
    }
    _parseWidgetReferences() {
        if (typeof this._widgetReferences === 'undefined' && this.count > 0) {
            this._widgetReferences = [];
            this._fields.forEach((fieldReference) => {
                const dictionary = this._crossReference._fetch(fieldReference);
                if (dictionary) {
                    if (dictionary.has('Kids')) {
                        const fieldKids = dictionary.get('Kids');
                        if (fieldKids && fieldKids.length > 0) {
                            fieldKids.forEach((kidReference) => {
                                let kidDictionary;
                                if (kidReference instanceof _PdfDictionary) {
                                    kidDictionary = kidReference;
                                }
                                else if (kidReference instanceof _PdfReference) {
                                    kidDictionary = this._crossReference._fetch(kidReference);
                                }
                                if (typeof kidDictionary !== 'undefined' && kidDictionary.has('Subtype')) {
                                    const subtype = kidDictionary.get('Subtype');
                                    if (subtype && subtype.name === 'Widget') {
                                        this._widgetReferences.push(kidReference);
                                    }
                                }
                            });
                        }
                    }
                    else {
                        this._widgetReferences.push(fieldReference);
                    }
                }
            });
        }
        return this._widgetReferences;
    }
    _doPostProcess(isFlatten) {
        for (let i = this.count - 1; i >= 0; i--) {
            const field = this.fieldAt(i);
            if (field) {
                field._doPostProcess(isFlatten || field.flatten);
                if (!isFlatten && field.flatten) {
                    this.removeFieldAt(i);
                }
            }
        }
    }
    _getFieldIndex(name) {
        let index = -1;
        if (this.count > 0) {
            if (!this._fieldNames) {
                this._fieldNames = [];
            }
            if (!this._indexedFieldNames) {
                this._indexedFieldNames = [];
            }
            if (!this._actualFieldNames) {
                this._actualFieldNames = [];
            }
            if (!this._indexedActualFieldNames) {
                this._indexedActualFieldNames = [];
            }
            for (let i = 0; i < this.count; i++) {
                const field = this.fieldAt(i);
                if (field) {
                    const fieldName = field.name;
                    if (fieldName) {
                        this._fieldNames.push(fieldName);
                        this._indexedFieldNames.push(fieldName.split('[')[0]);
                    }
                    const actualName = field.actualName;
                    if (actualName) {
                        this._actualFieldNames.push(actualName);
                        this._indexedActualFieldNames.push(actualName.split('[')[0]);
                    }
                }
            }
            let nameIndex = this._fieldNames.indexOf(name);
            if (nameIndex !== -1) {
                index = nameIndex;
            }
            else {
                nameIndex = this._indexedFieldNames.indexOf(name);
                if (nameIndex !== -1) {
                    index = nameIndex;
                }
                else {
                    nameIndex = this._actualFieldNames.indexOf(name);
                    if (nameIndex !== -1) {
                        index = nameIndex;
                    }
                    else {
                        nameIndex = this._indexedActualFieldNames.indexOf(name);
                        if (nameIndex !== -1) {
                            index = nameIndex;
                        }
                    }
                }
            }
        }
        return index;
    }
    _getFields() {
        const fields = [];
        for (let i = 0; i < this._fields.length; i++) {
            const field = this.fieldAt(i);
            if (field && field instanceof PdfField) {
                fields.push(field);
            }
        }
        return fields;
    }
    _getOrder(tabOrder) {
        if (tabOrder !== PdfFormFieldsTabOrder.none) {
            let tabs = '';
            if (tabOrder === PdfFormFieldsTabOrder.row) {
                tabs = 'R';
            }
            else if (tabOrder === PdfFormFieldsTabOrder.column) {
                tabs = 'C';
            }
            else if (tabOrder === PdfFormFieldsTabOrder.structure) {
                tabs = 'S';
            }
            return _PdfName.get(tabs);
        }
        return null;
    }
    _compareFields(field1, field2) {
        let result = 0;
        let xdiff;
        let index;
        const page1 = field1.page;
        const page2 = field2.page;
        if (page1 && page1 instanceof PdfPage && page2 && page2 instanceof PdfPage) {
            const page1Index = this._sortItemByPageIndex(field1, false)._pageIndex;
            const page2Index = this._sortItemByPageIndex(field2, false)._pageIndex;
            let rectangle1;
            if (field1._dictionary.has('Kids')) {
                rectangle1 = this._getItemRectangle(field1);
            }
            else {
                rectangle1 = this._getRectangle(field1._dictionary);
            }
            let rectangle2;
            if (field2._dictionary.has('Kids')) {
                rectangle2 = this._getItemRectangle(field2);
            }
            else {
                rectangle2 = this._getRectangle(field2._dictionary);
            }
            const firstHeight = rectangle1[3] - rectangle1[1];
            const secondHeight = rectangle2[3] - rectangle2[1];
            if (rectangle1 && rectangle1.length >= 2 && rectangle2 && rectangle2.length >= 2) {
                const x1 = rectangle1[0];
                const y1 = rectangle1[1];
                const x2 = rectangle2[0];
                const y2 = rectangle2[1];
                if (typeof x1 === 'number' && typeof x2 === 'number' &&
                    typeof y1 === 'number' && typeof y2 === 'number') {
                    index = page1Index - page2Index;
                    if (this._tabOrder === PdfFormFieldsTabOrder.row) {
                        xdiff = this._compare(y2, y1);
                        if (xdiff !== 0) {
                            let isValid = xdiff === -1 && y1 > y2 && (y1 - firstHeight / 2) < y2;
                            isValid = isValid || (xdiff === 1 && y2 > y1 && (y2 - secondHeight / 2) < y1);
                            if (isValid) {
                                xdiff = 0;
                            }
                        }
                        if (index !== 0) {
                            result = index;
                        }
                        else if (xdiff !== 0) {
                            result = xdiff;
                        }
                        else {
                            result = this._compare(x1, x2);
                        }
                    }
                    else if (this._tabOrder === PdfFormFieldsTabOrder.column) {
                        xdiff = this._compare(x1, x2);
                        if (index !== 0) {
                            result = index;
                        }
                        else if (xdiff !== 0) {
                            result = xdiff;
                        }
                        else {
                            result = this._compare(y2, y1);
                        }
                    }
                    else if (this._tabOrder === PdfFormFieldsTabOrder.manual ||
                        this._tabOrder === PdfFormFieldsTabOrder.none || this._tabOrder === PdfFormFieldsTabOrder.structure) {
                        if (field1 instanceof PdfField && field2 instanceof PdfField) {
                            const field1Index = field1.tabIndex;
                            const field2Index = field2.tabIndex;
                            xdiff = this._compare(field1Index, field2Index);
                            if (index !== 0) {
                                result = index;
                            }
                            else {
                                result = xdiff;
                            }
                        }
                    }
                }
            }
        }
        return result;
    }
    _getRectangle(dictionary) {
        let rect;
        if (dictionary.has('Rect')) {
            rect = dictionary.getArray('Rect');
        }
        return rect;
    }
    _getItemRectangle(field) {
        let result;
        const dictionary = field._dictionary;
        if (dictionary.has('Kids')) {
            const kids = dictionary.getArray('Kids');
            if (kids && kids.length >= 1) {
                if (kids.length === 1) {
                    result = this._getRectangle(kids[0]);
                }
                else {
                    if (field && field.itemsCount > 1) {
                        result = this._getRectangle(field.itemAt(0)._dictionary);
                    }
                    else {
                        result = this._getRectangle(kids[0]);
                    }
                }
            }
        }
        return result;
    }
    _compare(x, y) {
        if (x > y) {
            return 1;
        }
        else if (x < y) {
            return -1;
        }
        else {
            return 0;
        }
    }
    _compareKidsElement(x, y) {
        const xDictionary = this._crossReference._fetch(x);
        const yDictionary = this._crossReference._fetch(y);
        const xRect = this._getRectangle(xDictionary);
        const yRect = this._getRectangle(yDictionary);
        let result;
        if (xRect && xRect.length >= 2 && yRect && yRect.length >= 2) {
            const x1 = xRect[0];
            const y1 = xRect[1];
            const x2 = yRect[0];
            const y2 = yRect[1];
            if (typeof x1 === 'number' && typeof x2 === 'number' &&
                typeof y1 === 'number' && typeof y2 === 'number') {
                let xdiff;
                if (this._tabOrder === PdfFormFieldsTabOrder.row) {
                    xdiff = this._compare(y2, y1);
                    if (xdiff !== 0) {
                        result = xdiff;
                    }
                    else {
                        result = this._compare(x1, x2);
                    }
                }
                else if (this._tabOrder === PdfFormFieldsTabOrder.column) {
                    xdiff = this._compare(x1, x2);
                    if (xdiff !== 0) {
                        result = xdiff;
                    }
                    else {
                        result = this._compare(y2, y1);
                    }
                }
                else {
                    result = 0;
                }
                return result;
            }
        }
        return result;
    }
    _sortItemByPageIndex(field, hasPageTabOrder) {
        let page = field.page;
        const tabOrder = this._tabOrder;
        this._tabOrder = hasPageTabOrder ? field.page.tabOrder : tabOrder;
        this._sortFieldItems(field);
        if (field._isLoaded && field._kidsCount > 1) {
            page = field.itemAt(0).page;
        }
        this._tabOrder = tabOrder;
        if (typeof page === 'undefined') {
            page = field.page;
        }
        return page;
    }
    _sortFieldItems(field) {
        if (field._isLoaded && (field instanceof PdfTextBoxField ||
            field instanceof PdfListBoxField ||
            field instanceof PdfCheckBoxField ||
            field instanceof PdfRadioButtonListField)) {
            const collection = field._parseItems(); // eslint-disable-line
            collection.sort((item1, item2) => {
                return this._compareFieldItem(item1, item2);
            });
            field._parsedItems.clear();
            for (let i = 0; i < collection.length; i++) {
                field._parsedItems.set(i, collection[Number.parseInt(i.toString(), 10)]);
            }
        }
    }
    _compareFieldItem(item1, item2) {
        let result = 0;
        if (typeof item1 !== 'undefined' && typeof item2 !== 'undefined') {
            const page1 = item1.page;
            const page2 = item2.page;
            const array1 = this._getRectangle(item1._dictionary);
            const array2 = this._getRectangle(item2._dictionary);
            if (array1 && array2) {
                const x1 = array1[0];
                const y1 = array1[1];
                const x2 = array2[0];
                const y2 = array2[1];
                let xdiff;
                if (this._tabOrder === PdfFormFieldsTabOrder.row) {
                    xdiff = this._compare(page1._pageIndex, page2._pageIndex);
                    if (xdiff !== 0) {
                        result = xdiff;
                    }
                    else {
                        xdiff = this._compare(y2, y1);
                        if (xdiff !== 0) {
                            result = xdiff;
                        }
                        else {
                            result = this._compare(x1, x2);
                        }
                    }
                }
                else if (this._tabOrder === PdfFormFieldsTabOrder.column) {
                    xdiff = this._compare(page1._pageIndex, page2._pageIndex);
                    if (xdiff !== 0) {
                        result = xdiff;
                    }
                    else {
                        xdiff = this._compare(x1, x2);
                        if (xdiff !== 0) {
                            result = xdiff;
                        }
                        else {
                            result = this._compare(y2, y1);
                        }
                    }
                }
            }
        }
        return result;
    }
    _clear() {
        this._fields = [];
        this._parsedFields = new Map();
    }
}

class _XmlWriter {
    constructor(isAppearance = false) {
        this._position = 0;
        this._bufferText = '';
        this._buffer = new Uint8Array(0);
        this._namespaceStack = [];
        this._elementStack = [];
        if (!isAppearance) {
            this._currentState = 'Initial';
            this._namespaceStack.push(new _Namespace());
            this._elementStack.push(new _XmlElement());
            this._namespaceStack[0]._set('xmlns', 'http://www.w3.org/2000/xmlns/', 'Special');
            this._namespaceStack.push(new _Namespace());
            this._namespaceStack[1]._set('xml', 'http://www.w3.org/XML/1998/namespace', 'Special');
            this._namespaceStack.push(new _Namespace());
            this._namespaceStack[2]._set('', '', 'Implied');
            this._elementStack[0]._set('', '', '', this._namespaceStack.length - 1);
        }
        else {
            this._currentState = 'StartDocument';
            this._skipNamespace = true;
        }
        this._attributeStack = [];
    }
    get buffer() {
        this._flush();
        return this._buffer;
    }
    _writeStartDocument(standalone) {
        if (this._currentState !== 'Initial' || typeof this._buffer === 'undefined') {
            throw new Error('InvalidOperationException: Wrong Token');
        }
        this._currentState = 'StartDocument';
        this._rawText('<?xml version="1.0" encoding="utf-8');
        if (typeof standalone !== 'undefined' && standalone !== null) {
            this._rawText('" standalone="');
            this._rawText(standalone ? 'yes' : 'no');
        }
        this._rawText('"?>');
    }
    _writeStartElement(localName, prefix, namespace) {
        if (typeof this._buffer === 'undefined') {
            throw new Error('InvalidOperationException: Wrong Token');
        }
        if (typeof localName === 'undefined' || localName === null || localName.length === 0) {
            throw new Error('ArgumentException: localName cannot be undefined, null or empty');
        }
        this._checkName(localName);
        if (this._currentState === 'Initial') {
            this._writeStartDocument();
        }
        if (this._currentState === 'StartElement') {
            this._startElementContent();
        }
        this._currentState = 'StartElement';
        if (typeof prefix === 'undefined' || prefix === null) {
            if (typeof namespace !== 'undefined' && namespace !== null) {
                prefix = this._lookupPrefix(namespace);
            }
            if (typeof prefix === 'undefined' || prefix === null) {
                prefix = '';
            }
        }
        else if (prefix.length > 0) {
            if (typeof namespace === 'undefined' || namespace === null) {
                namespace = this._lookupNamespace(prefix);
            }
            if (typeof namespace === 'undefined' || namespace === null || (typeof namespace !== 'undefined' && namespace.length === 0)) {
                throw new Error('ArgumentException: Cannot use a prefix with an empty namespace');
            }
        }
        if (typeof namespace === 'undefined' || namespace === null) {
            namespace = this._lookupNamespace(prefix);
        }
        this._writeStartElementInternal(prefix, localName, namespace);
    }
    _writeEndElement() {
        if (this._currentState === 'StartElement') {
            this._startElementContent();
            this._currentState = 'ElementContent';
        }
        else if (this._currentState === 'ElementContent') {
            this._currentState = 'ElementContent';
        }
        this._currentState = 'EndElement';
        const top = this._elementStack.length - 1;
        this._writeEndElementInternal(this._elementStack[Number.parseInt(top.toString(), 10)]._prefix, this._elementStack[Number.parseInt(top.toString(), 10)]._localName);
        this._namespaceStack.splice(this._elementStack[Number.parseInt(top.toString(), 10)]._previousTop + 1);
        this._elementStack.splice(top);
        // if (this._bufferText.length > 10240) {
        //     this._flush();
        // }
    }
    _writeElementString(localName, value, prefix, namespace) {
        this._writeStartElement(localName, prefix, namespace);
        if (typeof value !== 'undefined' && value !== null && value.length !== 0) {
            this._writeString(value);
        }
        this._writeEndElement();
    }
    _writeAttributeString(localName, value, prefix, namespace) {
        this._writeStartAttribute(localName, value, prefix, namespace);
        this._writeStringInternal(value, true);
        this._writeEndAttribute();
    }
    _writeString(text) {
        this._writeInternal(text, false);
    }
    _writeRaw(text) {
        this._writeInternal(text, true);
    }
    _writeInternal(text, isRawString) {
        if (text !== null && typeof text !== 'undefined') {
            if (this._currentState !== 'StartElement' && this._currentState !== 'ElementContent') {
                throw new Error('InvalidOperationException: Wrong Token');
            }
            if (this._currentState === 'StartElement') {
                this._startElementContent();
            }
            this._currentState = 'ElementContent';
            if (isRawString) {
                this._rawText(text);
            }
            else {
                this._writeStringInternal(text, false);
            }
        }
    }
    _save() {
        while (this._elementStack.length - 1 > 0) {
            this._writeEndElement();
        }
        if (this._bufferText !== '') {
            this._flush();
        }
        return this._buffer;
    }
    _destroy() {
        this._buffer = undefined;
        for (let i = 0; i < this._namespaceStack.length; i++) {
            this._namespaceStack[Number.parseInt(i.toString(), 10)]._destroy();
        }
        this._namespaceStack = [];
        for (let i = 0; i < this._elementStack.length; i++) {
            this._elementStack[Number.parseInt(i.toString(), 10)]._destroy();
        }
        this._elementStack = [];
        this._bufferText = '';
        this._position = 0;
    }
    _flush() {
        if (this._buffer && this._bufferText && this._bufferText !== '') {
            if (this._buffer.length > 0) {
                const buffer = new Array(this._bufferText.length);
                for (let i = 0; i < this._bufferText.length; i++) {
                    buffer[Number.parseInt(i.toString(), 10)] = this._bufferText.charCodeAt(i) & 0xff;
                }
                const array = new Uint8Array(this._buffer.length + buffer.length);
                array.set(this._buffer);
                array.set(buffer, this._buffer.length);
                this._buffer = array;
            }
            else {
                this._buffer = _stringToBytes(this._bufferText);
            }
            this._bufferText = '';
        }
    }
    _writeStartAttribute(localName, value, prefix, namespace) {
        if (typeof localName === 'undefined' || localName === null || localName.length === 0) {
            if (prefix === 'xmlns') {
                localName = 'xmlns';
                prefix = '';
            }
            else {
                throw new Error('ArgumentException: localName cannot be undefined, null or empty');
            }
        }
        if (this._currentState !== 'StartElement') {
            throw new Error('InvalidOperationException: Wrong Token');
        }
        this._checkName(localName);
        this._writeStartAttributePrefixAndNameSpace(localName, value, prefix, namespace);
    }
    _writeStartAttributePrefixAndNameSpace(localName, value, prefix, namespace) {
        if (typeof prefix === 'undefined' || prefix === null) {
            if (typeof namespace !== 'undefined' && namespace !== null) {
                if (!(localName === 'xmlns' && namespace === 'http://www.w3.org/2000/xmlns/')) {
                    prefix = this._lookupPrefix(namespace);
                }
            }
            if (typeof prefix === 'undefined' || prefix === null) {
                prefix = '';
            }
        }
        if (typeof namespace === 'undefined' || namespace === null) {
            if (typeof prefix !== 'undefined' && prefix !== null && prefix.length > 0) {
                namespace = this._lookupNamespace(prefix);
            }
            if (typeof namespace === 'undefined' || namespace === null) {
                namespace = '';
            }
        }
        this._writeStartAttributeSpecialAttribute(prefix, localName, namespace, value);
    }
    _writeStartAttributeSpecialAttribute(prefix, localName, namespace, value) {
        if (prefix.length === 0) {
            if (localName[0] === 'x' && localName === 'xmlns') {
                this._skipPushAndWrite(prefix, localName, namespace);
                this._pushNamespaceExplicit('', value);
                return;
            }
            else if (namespace.length > 0) {
                prefix = this._lookupPrefix(namespace);
            }
        }
        else {
            if (prefix[0] === 'x') {
                if (prefix === 'xmlns') {
                    this._skipPushAndWrite(prefix, localName, namespace);
                    this._pushNamespaceExplicit(localName, value);
                    return;
                }
                else if (prefix === 'xml') {
                    if (localName === 'space' || localName === 'lang') {
                        this._skipPushAndWrite(prefix, localName, namespace);
                        return;
                    }
                }
            }
            if (namespace.length === 0) {
                prefix = '';
            }
        }
        if (typeof prefix !== 'undefined' && prefix !== null && prefix.length !== 0) {
            this._pushNamespaceImplicit(prefix, namespace);
        }
        this._skipPushAndWrite(prefix, localName, namespace);
    }
    _writeEndAttribute() {
        this._currentState = 'StartElement';
        this._bufferText += '"';
    }
    _writeStartElementInternal(prefix, localName, namespace) {
        this._bufferText += '<';
        if (prefix.length > 0) {
            this._rawText(prefix);
            this._bufferText += ':';
        }
        this._rawText(localName);
        const top = this._elementStack.length;
        this._elementStack.push(new _XmlElement());
        this._elementStack[Number.parseInt(top.toString(), 10)]._set(prefix, localName, namespace, this._namespaceStack.length - 1);
        this._pushNamespaceImplicit(prefix, namespace);
        for (let i = 0; i < this._attributeStack.length; i++) {
            this._attributeStack[Number.parseInt(i.toString(), 10)]._destroy();
        }
        this._attributeStack = [];
    }
    _writeEndElementInternal(prefix, localName) {
        if (this._position !== this._bufferText.length + 1) {
            this._bufferText += '</';
            if (typeof prefix !== 'undefined' && prefix !== null && prefix.length !== 0) {
                this._rawText(prefix);
                this._bufferText += ':';
            }
            this._rawText(localName);
            this._bufferText += '>';
        }
        else {
            this._bufferText = this._bufferText.substring(0, this._bufferText.length - 1);
            this._bufferText += ' />';
        }
    }
    _writeStartAttributeInternal(prefix, localName) {
        this._bufferText += ' ';
        if (typeof prefix !== 'undefined' && prefix !== null && prefix.length > 0) {
            this._rawText(prefix);
            this._bufferText += ':';
        }
        this._rawText(localName);
        this._bufferText += '="';
    }
    _writeNamespaceDeclaration(prefix, namespaceUri) {
        if (!this._skipNamespace) {
            this._writeStartNamespaceDeclaration(prefix);
            this._writeStringInternal(namespaceUri, true);
            this._bufferText += '"';
        }
    }
    _writeStartNamespaceDeclaration(prefix) {
        if (typeof prefix === 'undefined' || prefix === null || prefix.length === 0) {
            this._rawText(' xmlns="');
        }
        else {
            this._rawText(' xmlns:');
            this._rawText(prefix);
            this._bufferText += '=';
            this._bufferText += '"';
        }
    }
    _writeStringInternal(text, inAttributeValue) {
        if (typeof text === 'undefined' || text === null) {
            text = '';
        }
        text = text.replace(/\&/g, '&amp;'); // eslint-disable-line
        text = text.replace(/\</g, '&lt;'); // eslint-disable-line
        text = text.replace(/\>/g, '&gt;'); // eslint-disable-line
        if (inAttributeValue) {
            text = text.replace(/\"/g, '&quot;'); // eslint-disable-line
        }
        this._bufferText += text;
        if (!inAttributeValue) {
            this._position = 0;
        }
    }
    _startElementContent() {
        const start = this._elementStack[this._elementStack.length - 1]._previousTop;
        for (let i = this._namespaceStack.length - 1; i > start; i--) {
            if (this._namespaceStack[Number.parseInt(i.toString(), 10)]._kind === 'NeedToWrite') {
                this._writeNamespaceDeclaration(this._namespaceStack[Number.parseInt(i.toString(), 10)]._prefix, this._namespaceStack[Number.parseInt(i.toString(), 10)]._namespaceUri);
            }
        }
        this._bufferText += '>';
        this._position = this._bufferText.length + 1;
    }
    _rawText(text) {
        this._bufferText += text;
    }
    _addNamespace(prefix, ns, kind) {
        const top = this._namespaceStack.length;
        this._namespaceStack.push(new _Namespace());
        this._namespaceStack[Number.parseInt(top.toString(), 10)]._set(prefix, ns, kind);
    }
    _lookupPrefix(namespace) {
        for (let i = this._namespaceStack.length - 1; i >= 0; i--) {
            if (this._namespaceStack[Number.parseInt(i.toString(), 10)]._namespaceUri === namespace) {
                return this._namespaceStack[Number.parseInt(i.toString(), 10)]._prefix;
            }
        }
        return undefined;
    }
    _lookupNamespace(prefix) {
        for (let i = this._namespaceStack.length - 1; i >= 0; i--) {
            if (this._namespaceStack[Number.parseInt(i.toString(), 10)]._prefix === prefix) {
                return this._namespaceStack[Number.parseInt(i.toString(), 10)]._namespaceUri;
            }
        }
        return undefined;
    }
    _lookupNamespaceIndex(prefix) {
        for (let i = this._namespaceStack.length - 1; i >= 0; i--) {
            if (this._namespaceStack[Number.parseInt(i.toString(), 10)]._prefix === prefix) {
                return i;
            }
        }
        return -1;
    }
    _pushNamespaceImplicit(prefix, ns) {
        let kind;
        const existingNsIndex = this._lookupNamespaceIndex(prefix);
        let isValid = true;
        if (existingNsIndex !== -1) {
            if (existingNsIndex > this._elementStack[this._elementStack.length - 1]._previousTop) {
                if (this._namespaceStack[Number.parseInt(existingNsIndex.toString(), 10)]._namespaceUri !== ns) {
                    throw new Error('XmlException namespace Uri needs to be the same as the one that is already declared');
                }
                isValid = false;
            }
            else {
                if (this._namespaceStack[Number.parseInt(existingNsIndex.toString(), 10)]._kind === 'Special') {
                    if (prefix === 'xml') {
                        if (ns !== this._namespaceStack[Number.parseInt(existingNsIndex.toString(), 10)]._namespaceUri) {
                            throw new Error('InvalidArgumentException: Xml String');
                        }
                        else {
                            kind = 'Implied';
                        }
                    }
                    else {
                        throw new Error('InvalidArgumentException: Prefix "xmlns" is reserved for use by XML.');
                    }
                }
                else {
                    kind = (this._namespaceStack[Number.parseInt(existingNsIndex.toString(), 10)]._namespaceUri === ns) ?
                        'Implied' :
                        'NeedToWrite';
                }
            }
        }
        else {
            if ((ns === 'http://www.w3.org/XML/1998/namespace' && prefix !== 'xml') ||
                (ns === 'http://www.w3.org/2000/xmlns/' && prefix !== 'xmlns')) {
                throw new Error('InvalidArgumentException');
            }
            kind = 'NeedToWrite';
        }
        if (isValid) {
            this._addNamespace(prefix, ns, kind);
        }
    }
    _pushNamespaceExplicit(prefix, ns) {
        const existingNsIndex = this._lookupNamespaceIndex(prefix);
        if (existingNsIndex !== -1) {
            if (existingNsIndex > this._elementStack[this._elementStack.length - 1]._previousTop) {
                this._namespaceStack[Number.parseInt(existingNsIndex.toString(), 10)]._kind = 'Written';
                return;
            }
        }
        this._addNamespace(prefix, ns, 'Written');
        return;
    }
    _addAttribute(prefix, localName, namespaceName) {
        const top = this._attributeStack.length;
        this._attributeStack.push(new _XmlAttribute());
        this._attributeStack[Number.parseInt(top.toString(), 10)]._set(prefix, localName, namespaceName);
        for (let i = 0; i < top; i++) {
            if (this._attributeStack[Number.parseInt(i.toString(), 10)]._isDuplicate(prefix, localName, namespaceName)) {
                throw new Error('XmlException: duplicate attribute name');
            }
        }
    }
    _skipPushAndWrite(prefix, localName, namespace) {
        this._addAttribute(prefix, localName, namespace);
        this._writeStartAttributeInternal(prefix, localName);
    }
    _checkName(text) {
        const format = /[ !@#$%^&*()+\=\[\]{};':"\\|,<>\/?]/; // eslint-disable-line
        if (format.test(text)) {
            throw new Error('InvalidArgumentException: invalid name character');
        }
    }
}
class _Namespace {
    _set(prefix, namespaceUri, kind) {
        this._prefix = prefix;
        this._namespaceUri = namespaceUri;
        this._kind = kind;
    }
    _destroy() {
        this._prefix = undefined;
        this._namespaceUri = undefined;
        this._kind = undefined;
    }
}
class _XmlElement {
    _set(prefix, localName, namespaceUri, previousTop) {
        this._previousTop = previousTop;
        this._prefix = prefix;
        this._namespaceUri = namespaceUri;
        this._localName = localName;
    }
    _destroy() {
        this._previousTop = undefined;
        this._prefix = undefined;
        this._localName = undefined;
        this._namespaceUri = undefined;
    }
}
class _XmlAttribute {
    _set(prefix, localName, namespaceUri) {
        this._prefix = prefix;
        this._namespaceUri = namespaceUri;
        this._localName = localName;
    }
    _isDuplicate(prefix, localName, namespaceUri) {
        return ((this._localName === localName) && ((this._prefix === prefix) || (this._namespaceUri === namespaceUri)));
    }
    _destroy() {
        this._prefix = undefined;
        this._namespaceUri = undefined;
        this._localName = undefined;
    }
}

class _ExportHelper {
    constructor() {
        this._asPerSpecification = false;
        this._fileName = '';
        this._formKey = '';
        this._exportEmptyFields = false;
        this._groupReferences = new Map();
        this._groupHolders = [];
        this._richTextPrefix = '<?xml version="1.0"?>';
        this._table = new Map(); // eslint-disable-line
        this._fields = new Map();
        this._richTextValues = new Map();
        this._jsonData = [];
        this._openingBrace = 123;
        this._openingBracket = 91;
        this._closingBrace = 125;
        this._closingBracket = 93;
        this._colon = 58;
        this._doubleQuotes = 34;
        this._comma = 44;
        this._space = 32;
        this.fdfString = '';
        this._xmlImport = false;
    }
    _exportFormFieldsData(field) {
        let textValue = '';
        if (field !== null && typeof field !== 'undefined' && field.export) {
            const type = _getInheritableProperty(field._dictionary, 'FT', false, true, 'Parent');
            if (type && type.name !== null && typeof type.name !== 'undefined') {
                const font = this._getEncodedFontDictionary(field._dictionary);
                let fieldName = field.name;
                if (font !== null && typeof font !== 'undefined') {
                    fieldName = this._getEncodedValue(fieldName, font);
                }
                let value; // eslint-disable-line
                let selectedValue;
                switch (type.name) {
                    case 'Tx':
                        textValue = _getInheritableProperty(field._dictionary, 'V', false, true, 'Parent');
                        if (textValue !== null && typeof textValue !== 'undefined') {
                            textValue = this._getEncodedValue(textValue, font);
                            this._table.set(fieldName, textValue);
                        }
                        else if (this._exportEmptyFields) {
                            textValue = '';
                            this._table.set(fieldName, textValue);
                        }
                        break;
                    case 'Ch':
                        value = _getInheritableProperty(field._dictionary, 'V', true, true, 'Parent');
                        if (value !== null && typeof value !== 'undefined') {
                            selectedValue = this._getExportValue(value);
                        }
                        if (!value && field._dictionary.has('I') && (field instanceof PdfListBoxField || field instanceof PdfComboBoxField)) {
                            selectedValue = field._obtainSelectedValue();
                        }
                        if (selectedValue !== null && typeof selectedValue !== 'undefined') {
                            if (typeof selectedValue === 'string' && selectedValue !== '') {
                                selectedValue = this._getEncodedValue(selectedValue, font);
                                textValue = selectedValue;
                                this._table.set(fieldName, textValue);
                            }
                            else if (selectedValue instanceof Array && selectedValue.length > 0) {
                                const values = [];
                                for (let i = 0; i < selectedValue.length; i++) {
                                    values.push(this._getEncodedValue(selectedValue[Number.parseInt(i.toString(), 10)], font));
                                }
                                this._table.set(fieldName, values);
                                return values;
                            }
                        }
                        else if (this._exportEmptyFields) {
                            textValue = '';
                            this._table.set(fieldName, textValue);
                        }
                        break;
                    case 'Btn':
                        value = _getInheritableProperty(field._dictionary, 'V', false, true, 'Parent');
                        if (value !== null && typeof value !== 'undefined') {
                            let text = this._getExportValue(value, field);
                            if (text !== null && typeof text !== 'undefined' && text !== '') {
                                let radioButton;
                                if (field instanceof PdfRadioButtonListField) {
                                    radioButton = field;
                                }
                                if (!field._dictionary.has('Opt') ||
                                    (radioButton !== null &&
                                        typeof radioButton !== 'undefined'
                                        && radioButton.selectedIndex === -1)) {
                                    text = this._getEncodedValue(text, font);
                                    textValue = text;
                                    this._table.set(fieldName, textValue);
                                }
                                else {
                                    if (field._dictionary.has('Opt')) {
                                        const options = field._dictionary.getArray('Opt');
                                        let index = Number.parseInt(text, 10);
                                        if (index === null || typeof index === 'undefined' || Number.isNaN(index)) {
                                            index = 0;
                                        }
                                        if (options !== null && typeof options !== 'undefined') {
                                            let current;
                                            if (radioButton) {
                                                current = options[radioButton.selectedIndex];
                                            }
                                            else {
                                                current = options[Number.parseInt(index.toString(), 10)];
                                            }
                                            if (current !== null && typeof current !== 'undefined') {
                                                text = current;
                                            }
                                            if (text !== null && typeof text !== 'undefined' && text !== '') {
                                                text = this._getEncodedValue(text, font);
                                                textValue = text;
                                                this._table.set(fieldName, textValue);
                                            }
                                        }
                                    }
                                }
                            }
                            else if (field instanceof PdfRadioButtonListField || field instanceof PdfCheckBoxField) {
                                if (this._exportEmptyFields) {
                                    textValue = text;
                                }
                                else {
                                    textValue = 'Off';
                                }
                                this._table.set(fieldName, textValue);
                            }
                        }
                        else {
                            if (field instanceof PdfRadioButtonListField) {
                                textValue = field._getAppearanceStateValue();
                                if (!textValue) {
                                    if (this._exportEmptyFields) {
                                        textValue = '';
                                    }
                                    else {
                                        textValue = 'Off';
                                    }
                                }
                                this._table.set(fieldName, textValue);
                            }
                            else {
                                const widget = field.itemAt(field._defaultIndex);
                                let dictionary;
                                if (widget) {
                                    dictionary = widget._dictionary;
                                }
                                else {
                                    dictionary = field._dictionary;
                                }
                                if (dictionary && dictionary.has('AS')) {
                                    textValue = dictionary.get('AS').name;
                                    this._table.set(fieldName, textValue);
                                }
                                else if (this._exportEmptyFields) {
                                    textValue = '';
                                    this._table.set(fieldName, textValue);
                                }
                            }
                        }
                        break;
                }
            }
        }
        return textValue;
    }
    _exportFormFieldData(field) {
        const type = _getInheritableProperty(field._dictionary, 'FT', false, true, 'Parent');
        if (type && type.name !== null && typeof type.name !== 'undefined') {
            const font = this._getEncodedFontDictionary(field._dictionary);
            let fieldName = field.name;
            if (font !== null && typeof font !== 'undefined') {
                fieldName = this._getEncodedValue(fieldName, font);
            }
            let textValue;
            let value; // eslint-disable-line
            switch (type.name) {
                case 'Tx':
                    textValue = _getInheritableProperty(field._dictionary, 'V', false, true, 'Parent');
                    if (this._asPerSpecification) {
                        if (field._dictionary.has('RV')) {
                            textValue = _getInheritableProperty(field._dictionary, 'RV', false, true, 'Parent');
                            if (textValue !== null && typeof textValue !== 'undefined') {
                                textValue += this._key;
                                this._formKey = this._key;
                                this._table.set(fieldName, textValue);
                            }
                        }
                        else if (textValue !== null && typeof textValue !== 'undefined') {
                            textValue = this._getEncodedValue(textValue, font);
                            let replaceValue = textValue;
                            if (field instanceof PdfTextBoxField && field.multiLine) {
                                replaceValue = replaceValue.replace('\n', '');
                                replaceValue = replaceValue.replace('\r', '\r\n');
                                textValue = replaceValue;
                            }
                            this._table.set(fieldName, textValue);
                        }
                    }
                    else {
                        if (textValue !== null && typeof textValue !== 'undefined') {
                            textValue = this._getEncodedValue(textValue, font);
                            this._table.set(fieldName, textValue);
                        }
                        else if (this._exportEmptyFields) {
                            this._table.set(fieldName, '');
                        }
                    }
                    break;
                case 'Ch':
                    value = _getInheritableProperty(field._dictionary, 'V', true, true, 'Parent');
                    if (this._asPerSpecification) {
                        if (field instanceof PdfListField) {
                            if (Array.isArray(value)) {
                                this._table.set(fieldName, value);
                            }
                            else {
                                if (typeof value === 'string') {
                                    value = this._getEncodedValue(value, font);
                                    this._table.set(fieldName, value);
                                }
                                else if ((value === null || typeof value === 'undefined') && field._dictionary.has('I')) {
                                    let selectedValue = field._obtainSelectedValue();
                                    if (selectedValue !== null && typeof selectedValue !== 'undefined') {
                                        if (typeof selectedValue === 'string' && selectedValue !== '') {
                                            selectedValue = this._getEncodedValue(selectedValue, font);
                                            this._table.set(fieldName, textValue);
                                        }
                                        else if (selectedValue instanceof Array && selectedValue.length > 0) {
                                            const values = [];
                                            for (let i = 0; i < selectedValue.length; i++) {
                                                values.push(this._getEncodedValue(selectedValue[Number.parseInt(i.toString(), 10)], font));
                                            }
                                            this._table.set(fieldName, values);
                                        }
                                    }
                                }
                            }
                        }
                    }
                    else {
                        let selectedValue;
                        if (value !== null && typeof value !== 'undefined') {
                            selectedValue = this._getExportValue(value);
                        }
                        if (!value && field._dictionary.has('I') && (field instanceof PdfListBoxField || field instanceof PdfComboBoxField)) {
                            selectedValue = field._obtainSelectedValue();
                        }
                        if (selectedValue !== null && typeof selectedValue !== 'undefined') {
                            if (typeof selectedValue === 'string' && selectedValue !== '') {
                                selectedValue = this._getEncodedValue(selectedValue, font);
                                this._table.set(fieldName, selectedValue);
                            }
                            else if (selectedValue instanceof Array && selectedValue.length > 0) {
                                const values = [];
                                for (let i = 0; i < selectedValue.length; i++) {
                                    values.push(this._getEncodedValue(selectedValue[Number.parseInt(i.toString(), 10)], font));
                                }
                                this._table.set(fieldName, values);
                            }
                            else if (this._exportEmptyFields) {
                                this._table.set(fieldName, '');
                            }
                        }
                        else if (this._exportEmptyFields) {
                            this._table.set(fieldName, '');
                        }
                    }
                    break;
                case 'Btn':
                    value = _getInheritableProperty(field._dictionary, 'V', false, true, 'Parent');
                    if (value !== null && typeof value !== 'undefined') {
                        let text = this._getExportValue(value, field);
                        if (text !== null && typeof text !== 'undefined' && text !== '') {
                            if (this._asPerSpecification && this._format !== 'XML') {
                                text = _hexStringToString(text);
                            }
                            let radioButton;
                            if (field instanceof PdfRadioButtonListField) {
                                radioButton = field;
                            }
                            if (!field._dictionary.has('Opt') ||
                                (radioButton !== null &&
                                    typeof radioButton !== 'undefined'
                                    && radioButton.selectedIndex === -1)) {
                                text = this._getEncodedValue(text, font);
                                this._table.set(fieldName, text);
                            }
                            else {
                                if (field._dictionary.has('Opt')) {
                                    const options = field._dictionary.getArray('Opt');
                                    let index = Number.parseInt(text, 10);
                                    if (index === null || typeof index === 'undefined' || Number.isNaN(index)) {
                                        index = 0;
                                    }
                                    if (options !== null && typeof options !== 'undefined') {
                                        let current;
                                        if (radioButton) {
                                            current = options[radioButton.selectedIndex];
                                        }
                                        else {
                                            current = options[Number.parseInt(index.toString(), 10)];
                                        }
                                        if (current !== null && typeof current !== 'undefined') {
                                            text = current;
                                        }
                                        if (text !== null && typeof text !== 'undefined' && text !== '') {
                                            text = this._getEncodedValue(text, font);
                                            this._table.set(fieldName, text);
                                        }
                                    }
                                }
                            }
                        }
                        else if (field instanceof PdfRadioButtonListField || field instanceof PdfCheckBoxField) {
                            if (this._exportEmptyFields) {
                                this._table.set(fieldName, text);
                            }
                            else {
                                this._table.set(fieldName, 'Off');
                            }
                        }
                    }
                    else {
                        if (field instanceof PdfRadioButtonListField) {
                            let text = field._getAppearanceStateValue();
                            if (!text) {
                                if (this._exportEmptyFields) {
                                    text = '';
                                }
                                else {
                                    text = 'Off';
                                }
                            }
                            this._table.set(fieldName, text);
                        }
                        else {
                            const widget = field.itemAt(field._defaultIndex);
                            let dictionary;
                            if (widget) {
                                dictionary = widget._dictionary;
                            }
                            else {
                                dictionary = field._dictionary;
                            }
                            if (dictionary && dictionary.has('AS')) {
                                this._table.set(fieldName, dictionary.get('AS').name);
                            }
                            else if (this._exportEmptyFields) {
                                this._table.set(fieldName, '');
                            }
                        }
                    }
                    break;
            }
        }
    }
    _getAnnotationType(dictionary) {
        let type = '';
        if (dictionary.has('Subtype')) {
            const subtype = dictionary.get('Subtype');
            if (subtype) {
                type = subtype.name;
            }
        }
        return type;
    }
    _getValue(primitive, isJson = false) {
        let value = '';
        if (typeof primitive !== 'undefined' && primitive !== null) {
            if (primitive instanceof _PdfName) {
                value = primitive.name;
            }
            else if (typeof primitive === 'boolean') {
                value = primitive ? isJson ? 'true' : 'yes' : isJson ? 'false' : 'no';
            }
            else if (typeof primitive === 'string') {
                value = this._getValidString(primitive);
            }
            else if (Array.isArray(primitive)) {
                const colorArray = primitive; // eslint-disable-line
                if (colorArray.length > 0) {
                    value = this._getValue(colorArray[0], isJson);
                }
                for (let i = 1; i < colorArray.length; i++) {
                    value += ',' + this._getValue(colorArray[Number.parseInt(i.toString(), 10)], isJson);
                }
            }
            else if (typeof primitive === 'number') {
                value = primitive.toString();
            }
        }
        return value;
    }
    _getColor(primitive) {
        let color = '';
        if (primitive && Array.isArray(primitive) && primitive.length >= 3) {
            const r = Math.round(primitive[0] * 255).toString(16).toUpperCase();
            const g = Math.round(primitive[1] * 255).toString(16).toUpperCase();
            const b = Math.round(primitive[2] * 255).toString(16).toUpperCase();
            color = '#' + (r.length === 1 ? ('0' + r) : r) + (g.length === 1 ? ('0' + g) : g) + (b.length === 1 ? ('0' + b) : b);
        }
        return color;
    }
    _getValidString(value) {
        if (value.indexOf('\n') !== -1) {
            value = value.replace(/\n/g, '\\n');
        }
        if (value.indexOf('\r') !== -1) {
            value = value.replace(/\r/g, '\\r');
        }
        return value;
    }
    _getEncodedFontDictionary(source) {
        let font;
        let kids; // eslint-disable-line
        if (source.has('Kids') && !source.has('AP')) {
            kids = source.getArray('Kids');
        }
        if (source.has('AP') || (kids !== null && typeof kids !== 'undefined' && Array.isArray(kids))) {
            let appearance;
            if (kids !== null && typeof kids !== 'undefined' && kids.length > 0) {
                const kid = kids[0];
                if (kid !== null && typeof kid !== 'undefined' && kid.has('AP')) {
                    appearance = kid.get('AP');
                }
            }
            else {
                appearance = source.get('AP');
            }
            if (appearance !== null && typeof appearance !== 'undefined' && appearance.has('N')) {
                const normal = appearance.get('N');
                if (normal !== null && typeof normal !== 'undefined' && normal instanceof _PdfBaseStream && normal.dictionary.has('Resources')) {
                    const resource = normal.dictionary.get('Resources');
                    if (resource !== null && typeof resource !== 'undefined' && resource.has('Font')) {
                        font = resource.get('Font');
                    }
                }
            }
        }
        return font;
    }
    _getEncodedValue(value, dictionary) {
        const text = value;
        let structure;
        if (this._encodeDictionary !== null && typeof this._encodeDictionary !== 'undefined') {
            structure = new _FontStructure(this._encodeDictionary);
            return this._replaceNotUsedCharacters(text, structure);
        }
        else {
            const root = this._document.form._dictionary;
            if (root !== null && typeof root !== 'undefined' && root.has('DR')) {
                const resource = root.get('DR');
                if (resource !== null && typeof resource !== 'undefined' && resource.has('Encoding')) {
                    const encoding = resource.get('Encoding');
                    if (encoding !== null && typeof encoding !== 'undefined' && encoding.has('PDFDocEncoding')) {
                        const pdfEncoding = encoding.get('PDFDocEncoding');
                        if (pdfEncoding !== null && typeof pdfEncoding !== 'undefined' && pdfEncoding.has('Differences')) {
                            const encodingDictionary = new _PdfDictionary(this._crossReference);
                            encodingDictionary.set('Differences', pdfEncoding.get('Differences'));
                            const reference = this._crossReference._getNextReference();
                            this._crossReference._cacheMap.set(reference, encodingDictionary);
                            const fontEncodeDictionary = new _PdfDictionary(this._crossReference);
                            fontEncodeDictionary.set('Subtype', _PdfName.get('Type1'));
                            fontEncodeDictionary.set('Encoding', reference);
                            structure = new _FontStructure(fontEncodeDictionary);
                            if (structure !== null &&
                                typeof structure !== 'undefined' &&
                                structure.differencesDictionary !== null &&
                                typeof structure.differencesDictionary !== 'undefined' &&
                                structure.differencesDictionary.size > 0) {
                                this._encodeDictionary = fontEncodeDictionary;
                                return this._replaceNotUsedCharacters(text, structure);
                            }
                        }
                    }
                }
            }
            if (value !== null &&
                typeof value !== 'undefined' &&
                dictionary !== null &&
                typeof dictionary !== 'undefined' &&
                dictionary.size > 0) {
                let result;
                let isSkip = false;
                dictionary.forEach((key, value) => {
                    if (!isSkip && value !== null && typeof value !== 'undefined') {
                        let fontDictionary;
                        if (value instanceof _PdfDictionary) {
                            fontDictionary = value;
                        }
                        else if (value instanceof _PdfReference) {
                            const holder = this._crossReference._fetch(value); // eslint-disable-line
                            if (holder !== null && typeof holder !== 'undefined' && holder instanceof _PdfDictionary) {
                                fontDictionary = holder;
                            }
                        }
                        if (fontDictionary) {
                            structure = new _FontStructure(fontDictionary);
                            result = this._replaceNotUsedCharacters(text, structure);
                            isSkip = true;
                        }
                    }
                });
                if (!isSkip) {
                    return result;
                }
            }
            return text;
        }
    }
    _replaceNotUsedCharacters(input, structure) {
        let updatedString = '';
        const differencesDictionary = structure.differencesDictionary;
        for (let i = 0; i < input.length; i++) {
            const text = input[Number.parseInt(i.toString(), 10)];
            const code = input.charCodeAt(i);
            if (differencesDictionary.has(text)) {
                const difference = differencesDictionary.get(text);
                if ((difference.length > 1 && structure._fontType !== 'Type3') ||
                    (code > 127 && code <= 255 && structure._fontType === 'Type1' &&
                        structure._baseFontEncoding !== 'WinAnsiEncoding' &&
                        structure._fontEncoding === 'Encoding' && structure._fontName === 'ZapfDingbats')) {
                    updatedString += text;
                }
                else {
                    updatedString += difference;
                }
            }
            else {
                updatedString += text;
            }
        }
        return updatedString;
    }
    _getExportValue(primitive, field) {
        let value;
        if (primitive !== null && typeof primitive !== 'undefined') {
            if (field !== null && typeof field !== 'undefined') {
                if (primitive instanceof _PdfName) {
                    value = primitive.name;
                }
                else if (typeof primitive === 'string') {
                    value = primitive;
                }
                if (value !== null &&
                    typeof value !== 'undefined' &&
                    value !== '' &&
                    field instanceof PdfRadioButtonListField &&
                    field.selectedIndex !== -1) {
                    const item = field.itemAt(field.selectedIndex);
                    if (item !== null && typeof item !== 'undefined' && item.value === value) {
                        value = item.value;
                    }
                }
            }
            else {
                if (primitive instanceof _PdfName) {
                    value = primitive.name;
                }
                else if (typeof primitive === 'string') {
                    value = primitive;
                }
                else if (Array.isArray(primitive)) {
                    const values = [];
                    for (let i = 0; i < primitive.length; i++) {
                        const element = primitive[Number.parseInt(i.toString(), 10)]; // eslint-disable-line
                        if (element instanceof _PdfName) {
                            values.push(element.name);
                        }
                        else if (typeof element === 'string') {
                            values.push(element);
                        }
                    }
                    return values;
                }
            }
        }
        return value;
    }
    _addReferenceToGroup(reference, dictionary) {
        let name = dictionary.get('NM');
        if (name && name !== '') {
            this._groupReferences.set(name, reference);
            if (dictionary.has('IRT')) {
                this._groupHolders.push(dictionary);
            }
        }
        else if (!name && dictionary.has('IRT')) {
            name = dictionary.get('IRT');
            if (name && name !== '' && this._groupReferences.has(name)) {
                dictionary.update('IRT', this._groupReferences.get(name));
            }
        }
    }
    _handlePopup(annotations, reference, annotationDictionary, pageDictionary) {
        if (annotationDictionary.has('Popup')) {
            const popupReference = annotationDictionary.getRaw('Popup');
            const popup = annotationDictionary.get('Popup');
            if (popup instanceof _PdfDictionary) {
                if (popupReference && popup) {
                    popup.update('Parent', reference);
                }
                const popupAnnotation = annotations._parseAnnotation(popup);
                const index = annotations._annotations.length;
                annotations._annotations.push(reference);
                pageDictionary.set('Annots', annotations._annotations);
                pageDictionary._updated = true;
                annotations._parsedAnnotations.set(index, popupAnnotation);
            }
        }
    }
    _importField() {
        const form = this._document.form;
        const count = form.count;
        if (count) {
            this._fields.forEach((value, key) => {
                let richTextValue;
                if (this._richTextValues.size > 0 && this._richTextValues.has(key)) {
                    richTextValue = this._richTextValues.get(key);
                }
                const index = form._getFieldIndex(key);
                if (index !== -1 && index < count) {
                    const field = form.fieldAt(index);
                    if (field && field !== null && typeof field !== 'undefined') {
                        if (richTextValue && richTextValue !== '') {
                            field._dictionary.update('RV', richTextValue);
                        }
                        this._importFieldData(field, value);
                    }
                }
            });
        }
    }
    _importFieldData(field, values) {
        if (values !== null &&
            typeof values !== 'undefined' &&
            values.length > 0 &&
            field !== null &&
            typeof field !== 'undefined' &&
            !field.readOnly) {
            let value = values[0];
            if (field instanceof PdfTextBoxField) {
                if (value !== null && typeof value !== 'undefined') {
                    if (field instanceof PdfTextBoxField && field.multiLine) {
                        value = value.replace('\r\n', '\r');
                        value = value.replace('\n', '\r');
                    }
                    field.text = value;
                }
            }
            else if (field instanceof PdfListBoxField || field instanceof PdfComboBoxField) {
                let selectedValues;
                if (values.length > 1) {
                    selectedValues = values;
                }
                else {
                    if (this._xmlImport) {
                        selectedValues = (value.indexOf(',') !== -1 ? value.split(',') : [value]);
                    }
                    else {
                        selectedValues = [value.indexOf(',') !== -1 ? value.split(',')[0] : value];
                    }
                }
                const indexes = [];
                const options = field._options;
                if (options && options.length > 0) {
                    options.forEach((option) => {
                        if (selectedValues.indexOf(option[0]) !== -1 || selectedValues.indexOf(option[1]) !== -1) {
                            indexes.push(options.indexOf(option));
                        }
                    });
                }
                if (indexes.length > 0) {
                    field.selectedIndex = indexes;
                    if (field instanceof PdfComboBoxField && this._asPerSpecification && field._dictionary.has('AP')) {
                        delete field._dictionary._map.AP;
                        field._dictionary._updated = true;
                    }
                }
            }
            else if (field instanceof PdfCheckBoxField) {
                const lowerCase = value.toLowerCase();
                if (this._containsExportValue(value, field) || lowerCase === 'on' || lowerCase === 'yes') {
                    field.checked = true;
                }
                else {
                    field.checked = false;
                }
            }
            else if (field instanceof PdfRadioButtonListField) {
                let index = -1;
                for (let i = 0; i < field._kidsCount; i++) {
                    const item = field.itemAt(i);
                    if (item && item.value && item.value === value) {
                        index = i;
                        break;
                    }
                }
                if (index !== -1 && field.selectedIndex !== index) {
                    field.selectedIndex = index;
                }
            }
        }
    }
    _containsExportValue(value, field) {
        let result = false;
        if (field._kidsCount > 0) {
            for (let i = 0; i < field._kidsCount; i++) {
                const kid = field.itemAt(i);
                if (kid && this._checkSelected(kid._dictionary, value)) {
                    return true;
                }
            }
        }
        else {
            result = this._checkSelected(field._dictionary, value);
            if (!result && this._asPerSpecification && field._dictionary.has('AS')) {
                const asEntry = field._dictionary.get('AS');
                if (asEntry && (asEntry.name === 'Off' || asEntry.name === 'No')) {
                    if (field._dictionary.has('Opt')) {
                        const options = field._dictionary.getArray('Opt');
                        if (options && options.length > 0) {
                            options.forEach((option) => {
                                if (option === value) {
                                    result = true;
                                }
                            });
                        }
                    }
                }
                else {
                    result = true;
                }
            }
        }
        return result;
    }
    _checkSelected(dictionary, value) {
        if (dictionary && dictionary.has('AP')) {
            const appearance = dictionary.get('AP');
            if (appearance && appearance instanceof _PdfDictionary && appearance.has('N')) {
                const normalTemplate = appearance.get('N');
                if (normalTemplate &&
                    normalTemplate instanceof _PdfDictionary &&
                    normalTemplate.has(value) &&
                    !(value.toLocaleLowerCase() === 'off' || value.toLocaleLowerCase() === 'no')) {
                    return true;
                }
            }
        }
        return false;
    }
    _dispose() {
        this.exportAppearance = undefined;
        this._asPerSpecification = undefined;
        this._skipBorderStyle = undefined;
        this._fileName = undefined;
        this._document = undefined;
        this._crossReference = undefined;
        this._isAnnotationExport = undefined;
        this._isAnnotationImport = undefined;
        this._key = undefined;
        this._formKey = undefined;
        this._exportEmptyFields = undefined;
        this._groupReferences = undefined;
        this._groupHolders = undefined;
        this._encodeDictionary = undefined;
        this._annotationTypes = undefined;
        this._annotationAttributes = undefined;
        this._xmlDocument = undefined;
        this._parser = undefined;
        this._table = undefined;
        this._fields = undefined;
        this._richTextValues = undefined;
        this._jsonData = undefined;
    }
}
class _XfdfDocument extends _ExportHelper {
    constructor(fileName) {
        super();
        if (fileName !== null && typeof fileName !== 'undefined') {
            this._fileName = fileName;
        }
    }
    // #region Export Annotations
    _exportAnnotations(document) {
        this._document = document;
        this._crossReference = document._crossReference;
        this._isAnnotationExport = true;
        return this._save();
    }
    _exportFormFields(document) {
        this._document = document;
        this._crossReference = document._crossReference;
        this._isAnnotationExport = false;
        this._key = _getNewGuidString();
        return this._save();
    }
    _save() {
        const writer = new _XmlWriter();
        writer._writeStartDocument();
        writer._writeStartElement('xfdf');
        writer._writeAttributeString(null, 'http://ns.adobe.com/xfdf/', 'xmlns', null);
        writer._writeAttributeString('space', 'preserve', 'xml', null);
        if (this._isAnnotationExport) {
            writer._writeStartElement('annots');
            if (this._document) {
                for (let i = 0; i < this._document.pageCount; i++) {
                    const page = this._document.getPage(i);
                    const annotations = page.annotations;
                    for (let j = 0; j < annotations.count; j++) {
                        const annotation = annotations.at(j);
                        if (annotation && (!this._annotationTypes ||
                            this._annotationTypes.length === 0 ||
                            (this._annotationTypes && this._annotationTypes.length > 0 && this._checkAnnotationType(annotation)))) {
                            this._exportAnnotationData(annotation, writer, i);
                        }
                    }
                }
            }
            writer._writeEndElement();
        }
        else {
            const form = this._document.form;
            if (form !== null && typeof form !== 'undefined') {
                this._exportEmptyFields = form.exportEmptyFields;
                const count = this._document.form.count;
                for (let i = 0; i < count; i++) {
                    const field = this._document.form.fieldAt(i);
                    if (field !== null && typeof field !== 'undefined' && field.export) {
                        this._exportFormFieldData(field);
                    }
                }
                this._writeFormFieldData(writer, this._asPerSpecification);
            }
        }
        if (!this._asPerSpecification) {
            writer._writeStartElement('f');
            writer._writeAttributeString('href', this._fileName);
        }
        const result = writer._save();
        writer._destroy();
        return result;
    }
    _writeFormFieldData(writer, isAcrobat = false) {
        if (isAcrobat) {
            writer._writeStartElement('f');
            writer._writeAttributeString('href', this._fileName);
            writer._writeEndElement();
            const elements = this._getElements(this._table); // eslint-disable-line
            if (elements && elements.size > 0) {
                writer._writeStartElement('fields');
                let flag = false;
                elements.forEach((value, key) => {
                    writer._writeStartElement('field');
                    writer._writeAttributeString('name', key.toString());
                    if (Array.isArray(value)) {
                        value.forEach((item) => {
                            writer._writeStartElement('value');
                            writer._writeString(item.toString());
                            writer._writeEndElement();
                            flag = true;
                        });
                    }
                    if (value instanceof Map) {
                        this._writeFieldName(value, writer);
                    }
                    else if (!flag && !value.toString().endsWith(this._formKey) || (!flag && this._formKey === '')) {
                        writer._writeStartElement('value');
                        writer._writeString(value.toString());
                        writer._writeEndElement();
                    }
                    else if (this._formKey !== '' && value.toString().endsWith(this._formKey)) {
                        writer._writeStartElement('value-richtext');
                        let text = value.toString();
                        if (text.startsWith('<?xml version="1.0"?>')) {
                            text = text.substring(21);
                        }
                        const start = text.length - this._formKey.length;
                        text = text.substring(0, start) + text.substring(start + this._formKey.length);
                        writer._writeRaw(text);
                        writer._writeEndElement();
                    }
                    writer._writeEndElement();
                    flag = false;
                });
                writer._writeEndElement();
            }
            writer._writeStartElement('ids');
            let hasId = false;
            if (this._crossReference._root.has('ID')) {
                const id = this._crossReference._root.getArray('ID');
                if (id && id.length >= 1) {
                    writer._writeAttributeString('original', id[0]);
                    writer._writeAttributeString('modified', id[1]);
                    hasId = true;
                }
            }
            if (!hasId) {
                writer._writeAttributeString('original', '');
                writer._writeAttributeString('modified', '');
            }
            writer._writeEndElement();
        }
        else {
            writer._writeStartElement('fields');
            this._table.forEach((value, key) => {
                writer._writeStartElement('field');
                writer._writeAttributeString('name', key.toString());
                if (Array.isArray(value)) {
                    value.forEach((item) => {
                        writer._writeStartElement('value');
                        writer._writeString(item.toString());
                        writer._writeEndElement();
                    });
                }
                else {
                    writer._writeStartElement('value');
                    writer._writeString(value.toString());
                    writer._writeEndElement();
                }
                writer._writeEndElement();
            });
            writer._writeEndElement();
        }
    }
    _writeFieldName(value, writer) {
        value.forEach((value, key) => {
            if (value instanceof Map) {
                writer._writeStartElement('field');
                writer._writeAttributeString('name', key.toString());
                this._writeFieldName(value, writer);
                writer._writeEndElement();
            }
            else {
                writer._writeStartElement('field');
                writer._writeAttributeString('name', key.toString());
                if (Array.isArray(value)) {
                    value.forEach((item) => {
                        writer._writeStartElement('value');
                        writer._writeString(item.toString());
                        writer._writeEndElement();
                    });
                }
                else {
                    if (!value.toString().endsWith(this._formKey) || this._formKey === '') {
                        writer._writeStartElement('value');
                        writer._writeString(value.toString());
                    }
                    else {
                        writer._writeStartElement('value-richtext');
                        let text = value.toString();
                        if (text.startsWith('<?xml version="1.0"?>')) {
                            text = text.substring(21);
                        }
                        const start = text.length - this._formKey.length;
                        text = text.substring(0, start) + text.substring(start + this._formKey.length);
                        writer._writeRaw(text);
                    }
                    writer._writeEndElement();
                }
                writer._writeEndElement();
            }
        });
    }
    _getElements(table) {
        const elements = new Map(); // eslint-disable-line
        table.forEach((value, key) => {
            let parentElements = elements; // eslint-disable-line
            if (key.toString().indexOf('.') !== -1) {
                const values = key.toString().split('.');
                for (let i = 0; i < values.length; i++) {
                    const element = values[Number.parseInt(i.toString(), 10)];
                    if (parentElements.has(element)) {
                        this._getElements(parentElements[element]); // eslint-disable-line
                        parentElements = parentElements[element]; // eslint-disable-line
                    }
                    else {
                        if (i === values.length - 1) {
                            parentElements.set(element, value);
                        }
                        else {
                            const newTable = new Map(); // eslint-disable-line
                            parentElements.set(element, newTable);
                            parentElements = newTable;
                        }
                    }
                }
            }
            else {
                parentElements.set(key, value);
            }
        });
        return elements;
    }
    _checkAnnotationType(annotation) {
        return (typeof annotation._type !== 'undefined' && this._annotationTypes.indexOf(annotation._type) !== -1);
    }
    _exportAnnotationData(annotation, writer, pageIndex) {
        if (annotation._dictionary &&
            !(annotation instanceof PdfFileLinkAnnotation ||
                annotation instanceof PdfTextWebLinkAnnotation ||
                annotation instanceof PdfDocumentLinkAnnotation ||
                annotation instanceof PdfUriAnnotation)) {
            this._writeAnnotationData(writer, pageIndex, annotation);
        }
    }
    _writeAnnotationData(writer, pageIndex, source) {
        let hasAppearance = false;
        let annotation;
        let dictionary;
        if (source instanceof PdfAnnotation) {
            annotation = source;
            dictionary = source._dictionary;
        }
        else {
            dictionary = source;
        }
        const type = this._getAnnotationType(dictionary);
        this._skipBorderStyle = false;
        if (type && type !== '') {
            if (!this._annotationAttributes) {
                this._annotationAttributes = [];
            }
            writer._writeStartElement(type.toLowerCase());
            writer._writeAttributeString('page', pageIndex.toString());
            let lineAnnotation;
            let points;
            switch (type) {
                case 'Line':
                    lineAnnotation = annotation;
                    points = lineAnnotation.linePoints;
                    writer._writeAttributeString('start', points[0].toString() + ',' + points[1].toString());
                    writer._writeAttributeString('end', points[2].toString() + ',' + points[3].toString());
                    break;
                case 'Stamp':
                    hasAppearance = true;
                    break;
                case 'Square':
                    hasAppearance = true;
                    break;
            }
            if (dictionary && dictionary.has('BE') && dictionary.has('BS')) {
                const borderEffect = dictionary.get('BE');
                if (borderEffect && borderEffect.has('S')) {
                    this._skipBorderStyle = true;
                }
            }
            this._writeDictionary(dictionary, pageIndex, writer, hasAppearance);
            writer._writeEndElement();
            this._annotationAttributes = [];
        }
    }
    _writeDictionary(dictionary, pageIndex, writer, hasAppearance) {
        let isBorderStyle = false;
        if (dictionary.has('Type')) {
            const type = dictionary.get('Type');
            isBorderStyle = (type && type.name === 'Border' && this._skipBorderStyle);
        }
        dictionary.forEach((key, value) => {
            if (!((!hasAppearance && key === 'AP') || key === 'P' || key === 'Parent')) {
                let entry; // eslint-disable-line
                if (value instanceof _PdfReference) {
                    entry = dictionary.get(key);
                }
                if (entry && entry instanceof _PdfDictionary) {
                    switch (key) {
                        case 'BS':
                            this._writeDictionary(entry, pageIndex, writer, false);
                            break;
                        case 'BE':
                            this._writeDictionary(entry, pageIndex, writer, false);
                            break;
                        case 'IRT':
                            if (entry.has('NM')) {
                                writer._writeAttributeString('inreplyto', this._getValue(entry.get('NM')));
                            }
                            break;
                    }
                }
                else if (value instanceof _PdfDictionary) {
                    this._writeDictionary(value, pageIndex, writer, false);
                }
                else if ((!isBorderStyle) || (isBorderStyle && key !== 'S')) {
                    this._writeAttribute(writer, key, value);
                }
            }
        });
        if ((this.exportAppearance || hasAppearance) && dictionary.has('AP')) {
            const stream = this._getAppearanceString(dictionary.get('AP'));
            if (stream && stream.length > 0) {
                writer._writeStartElement('appearance');
                writer._writeRaw(_encode(stream));
                writer._writeEndElement();
            }
        }
        if (dictionary.has('Measure')) {
            this._exportMeasureDictionary(dictionary.get('Measure'), writer);
        }
        if (dictionary.has('Sound')) {
            const sound = dictionary.get('Sound');
            if (sound && sound.dictionary) {
                const soundDictionary = sound.dictionary;
                if (soundDictionary.has('B')) {
                    writer._writeAttributeString('bits', this._getValue(soundDictionary.get('B')));
                }
                if (soundDictionary.has('C')) {
                    writer._writeAttributeString('channels', this._getValue(soundDictionary.get('C')));
                }
                if (soundDictionary.has('E')) {
                    writer._writeAttributeString('encoding', this._getValue(soundDictionary.get('E')));
                }
                if (soundDictionary.has('R')) {
                    writer._writeAttributeString('rate', this._getValue(soundDictionary.get('R')));
                }
                if (soundDictionary.has('Length') && soundDictionary.get('Length') > 0) {
                    const data = _byteArrayToHexString(sound.getBytes());
                    if (data && data !== '') {
                        writer._writeStartElement('data');
                        writer._writeAttributeString('MODE', 'raw');
                        writer._writeAttributeString('encoding', 'hex');
                        if (soundDictionary.has('Length')) {
                            writer._writeAttributeString('length', this._getValue(soundDictionary.get('Length')));
                        }
                        if (soundDictionary.has('Filter')) {
                            writer._writeAttributeString('filter', this._getValue(soundDictionary.get('Filter')));
                        }
                        writer._writeRaw(data);
                        writer._writeEndElement();
                    }
                }
            }
        }
        else if (dictionary.has('FS')) {
            const fsDictionary = dictionary.get('FS');
            if (fsDictionary) {
                if (fsDictionary.has('F')) {
                    writer._writeAttributeString('file', this._getValue(fsDictionary.get('F')));
                }
                if (fsDictionary.has('EF')) {
                    const efDictionary = fsDictionary.get('EF');
                    if (efDictionary && efDictionary.has('F')) {
                        const fStream = efDictionary.get('F');
                        if (fStream && fStream.dictionary) {
                            const fDictionary = fStream.dictionary;
                            if (fDictionary.has('Params')) {
                                const paramsDictionary = fDictionary.get('Params');
                                if (paramsDictionary) {
                                    if (paramsDictionary.has('CreationDate')) {
                                        const value = this._getValue(paramsDictionary.get('CreationDate'));
                                        writer._writeAttributeString('creation', value);
                                    }
                                    if (paramsDictionary.has('ModificationDate')) {
                                        const value = this._getValue(paramsDictionary.get('ModificationDate'));
                                        writer._writeAttributeString('modification', value);
                                    }
                                    if (paramsDictionary.has('Size')) {
                                        writer._writeAttributeString('size', this._getValue(paramsDictionary.get('Size')));
                                    }
                                    if (paramsDictionary.has('CheckSum')) {
                                        const value = this._getValue(paramsDictionary.get('CheckSum'));
                                        const checksum = _stringToBytes(value);
                                        const hexString = _byteArrayToHexString(checksum);
                                        writer._writeAttributeString('checksum', hexString);
                                    }
                                }
                            }
                            const data = _byteArrayToHexString(fStream.getBytes());
                            if (data && data !== '') {
                                writer._writeStartElement('data');
                                writer._writeAttributeString('MODE', 'raw');
                                writer._writeAttributeString('encoding', 'hex');
                                if (fDictionary.has('Length')) {
                                    writer._writeAttributeString('length', this._getValue(fDictionary.get('Length')));
                                }
                                if (fDictionary.has('Filter')) {
                                    writer._writeAttributeString('filter', this._getValue(fDictionary.get('Filter')));
                                }
                                writer._writeRaw(data);
                                writer._writeEndElement();
                            }
                        }
                    }
                }
            }
        }
        if (dictionary.has('Vertices')) {
            writer._writeStartElement('vertices');
            const vertices = dictionary.getArray('Vertices');
            if (vertices && vertices.length > 0) {
                const elementCount = vertices.length;
                if (elementCount % 2 === 0) {
                    let value = '';
                    for (let i = 0; i < elementCount - 1; i++) {
                        value += this._getValue(vertices[Number.parseInt(i.toString(), 10)]) + (i % 2 !== 0 ? ';' : ',');
                    }
                    value += this._getValue(vertices[elementCount - 1]);
                    if (value && value !== '') {
                        writer._writeRaw(value);
                    }
                }
            }
            writer._writeEndElement();
        }
        if (dictionary.has('Popup')) {
            const popup = dictionary.get('Popup');
            if (popup) {
                this._writeAnnotationData(writer, pageIndex, popup);
            }
        }
        if (dictionary.has('DA')) {
            const defaultAppearance = dictionary.get('DA');
            if (defaultAppearance) {
                this._writeRawData(writer, 'defaultappearance', defaultAppearance);
            }
        }
        if (dictionary.has('DS')) {
            const defaultStyle = dictionary.get('DS');
            if (defaultStyle) {
                this._writeRawData(writer, 'defaultstyle', defaultStyle);
            }
        }
        if (dictionary.has('InkList')) {
            const inkList = dictionary.getArray('InkList');
            if (inkList && inkList.length > 0) {
                writer._writeStartElement('inklist');
                for (let j = 0; j < inkList.length; j++) {
                    writer._writeElementString('gesture', this._getValue(inkList[Number.parseInt(j.toString(), 10)]));
                }
                writer._writeEndElement();
            }
        }
        if (dictionary.has('RC')) {
            let value = dictionary.get('RC');
            if (value && value !== '') {
                const index = value.indexOf('<body');
                if (index > 0) {
                    value = value.substring(index);
                }
                this._writeRawData(writer, 'contents-richtext', value);
            }
        }
        if (dictionary.has('Contents')) {
            const value = dictionary.get('Contents');
            if (value && value.length > 0) {
                writer._writeStartElement('contents');
                writer._writeString(value);
                writer._writeEndElement();
            }
        }
    }
    _getAppearanceString(appearance) {
        const textWriter = new _XmlWriter(true);
        textWriter._writeStartElement('DICT');
        textWriter._writeAttributeString('KEY', 'AP');
        this._writeAppearanceDictionary(textWriter, appearance);
        textWriter._writeEndElement();
        const buffer = textWriter.buffer;
        textWriter._destroy();
        return buffer;
    }
    _writeAppearanceDictionary(writer, dictionary) {
        if (dictionary && dictionary.size > 0) {
            dictionary.forEach((key, value) => {
                this._writeObject(writer, value instanceof _PdfReference ? dictionary.get(key) : value, dictionary, key);
            });
        }
    }
    _writeObject(writer, primitive, dictionary, key) {
        if (primitive !== null && typeof primitive !== 'undefined') {
            if (primitive instanceof _PdfName) {
                this._writePrefix(writer, 'NAME', key);
                writer._writeAttributeString('VAL', primitive.name);
                writer._writeEndElement();
            }
            else if (Array.isArray(primitive)) {
                this._writePrefix(writer, 'ARRAY', key);
                this._writeArray(writer, dictionary.getArray(key), dictionary);
                writer._writeEndElement();
            }
            else if (typeof primitive === 'string') {
                this._writePrefix(writer, 'STRING', key);
                writer._writeAttributeString('VAL', primitive);
                writer._writeEndElement();
            }
            else if (typeof primitive === 'number') {
                if (Number.isInteger(primitive)) {
                    this._writePrefix(writer, 'INT', key);
                    writer._writeAttributeString('VAL', primitive.toString());
                }
                else {
                    this._writePrefix(writer, 'FIXED', key);
                    writer._writeAttributeString('VAL', primitive.toFixed(6));
                }
                writer._writeEndElement();
            }
            else if (typeof primitive === 'boolean') {
                this._writePrefix(writer, 'BOOL', key);
                writer._writeAttributeString('VAL', primitive ? 'true' : 'false');
                writer._writeEndElement();
            }
            else if (primitive instanceof _PdfDictionary) {
                this._writePrefix(writer, 'DICT', key);
                this._writeAppearanceDictionary(writer, primitive);
                writer._writeEndElement();
            }
            else if (primitive === null) {
                this._writePrefix(writer, 'NULL', key);
                writer._writeEndElement();
            }
            else if (primitive instanceof _PdfBaseStream && primitive.dictionary) {
                const streamDictionary = primitive.dictionary;
                this._writePrefix(writer, 'STREAM', key);
                writer._writeAttributeString('DEFINE', '');
                if ((streamDictionary.has('Subtype') &&
                    this._getValue(streamDictionary.get('Subtype')) === 'Image') ||
                    (!streamDictionary.has('Type') && !streamDictionary.has('Subtype'))) {
                    const data = primitive.getString(true);
                    if (!streamDictionary.has('Length') && data && data !== '') {
                        streamDictionary.update('Length', primitive.length);
                    }
                    this._writeAppearanceDictionary(writer, streamDictionary);
                    writer._writeStartElement('DATA');
                    writer._writeAttributeString('MODE', 'RAW');
                    writer._writeAttributeString('ENCODING', 'HEX');
                    if (data && data !== '') {
                        writer._writeRaw(data);
                    }
                }
                else {
                    const data = primitive.getString();
                    if (!streamDictionary.has('Length') && data && data !== '') {
                        streamDictionary.update('Length', primitive.length);
                    }
                    this._writeAppearanceDictionary(writer, streamDictionary);
                    writer._writeStartElement('DATA');
                    writer._writeAttributeString('MODE', 'FILTERED');
                    writer._writeAttributeString('ENCODING', 'ASCII');
                    if (data && data !== '') {
                        writer._writeRaw(data);
                    }
                }
                writer._writeEndElement();
                writer._writeEndElement();
            }
            else if (primitive instanceof _PdfReference && this._crossReference) {
                this._writeObject(writer, this._crossReference._fetch(primitive), dictionary, key);
            }
        }
    }
    _writePrefix(writer, name, key) {
        writer._writeStartElement(name);
        if (key) {
            writer._writeAttributeString('KEY', key);
        }
    }
    _writeArray(writer, array, dictionary) {
        array.forEach((entry) => {
            this._writeObject(writer, entry, dictionary);
        });
    }
    _getFormatedString(value, isParsing = false) {
        if (isParsing) {
            value = value.replace('&amp;', '&');
            value = value.replace('&lt;', '<');
            value = value.replace('&gt;', '>');
        }
        else {
            value = value.replace('&', '&amp;');
            value = value.replace('<', '&lt;');
            value = value.replace('>', '&gt;');
        }
        return value;
    }
    _writeAttribute(writer, key, primitive) {
        if (this._annotationAttributes && this._annotationAttributes.indexOf(key) === -1) {
            switch (key) {
                case 'C':
                    this._writeColor(writer, primitive, 'color', 'c');
                    break;
                case 'IC':
                    this._writeColor(writer, primitive, 'interior-color');
                    break;
                case 'M':
                    this._writeAttributeString(writer, 'date', primitive);
                    break;
                case 'NM':
                    this._writeAttributeString(writer, 'name', primitive);
                    break;
                case 'Name':
                    this._writeAttributeString(writer, 'icon', primitive);
                    break;
                case 'Subj':
                    this._writeAttributeString(writer, 'subject', primitive);
                    break;
                case 'T':
                    this._writeAttributeString(writer, 'title', primitive);
                    break;
                case 'Rotate':
                    this._writeAttributeString(writer, 'rotation', primitive);
                    break;
                case 'W':
                    this._writeAttributeString(writer, 'width', primitive);
                    break;
                case 'LE':
                    if (primitive && Array.isArray(primitive)) {
                        if (primitive.length === 2) {
                            writer._writeAttributeString('head', this._getValue(primitive[0]));
                            writer._writeAttributeString('tail', this._getValue(primitive[1]));
                        }
                    }
                    else if (primitive instanceof _PdfName) {
                        this._writeAttributeString(writer, 'head', primitive);
                    }
                    break;
                case 'S':
                    if (this._annotationAttributes.indexOf('style') === -1) {
                        switch (this._getValue(primitive)) {
                            case 'D':
                                writer._writeAttributeString('style', 'dash');
                                break;
                            case 'C':
                                writer._writeAttributeString('style', 'cloudy');
                                break;
                            case 'S':
                                writer._writeAttributeString('style', 'solid');
                                break;
                            case 'B':
                                writer._writeAttributeString('style', 'bevelled');
                                break;
                            case 'I':
                                writer._writeAttributeString('style', 'inset');
                                break;
                            case 'U':
                                writer._writeAttributeString('style', 'underline');
                                break;
                        }
                        this._annotationAttributes.push('style');
                    }
                    break;
                case 'D':
                    this._writeAttributeString(writer, 'dashes', primitive);
                    break;
                case 'I':
                    this._writeAttributeString(writer, 'intensity', primitive);
                    break;
                case 'RD':
                    this._writeAttributeString(writer, 'fringe', primitive);
                    break;
                case 'IT':
                    this._writeAttributeString(writer, 'IT', primitive);
                    break;
                case 'RT':
                    this._writeAttributeString(writer, 'replyType', primitive, true);
                    break;
                case 'LL':
                    this._writeAttributeString(writer, 'leaderLength', primitive);
                    break;
                case 'LLE':
                    this._writeAttributeString(writer, 'leaderExtend', primitive);
                    break;
                case 'Cap':
                    this._writeAttributeString(writer, 'caption', primitive);
                    break;
                case 'Q':
                    this._writeAttributeString(writer, 'justification', primitive);
                    break;
                case 'CP':
                    this._writeAttributeString(writer, 'caption-style', primitive);
                    break;
                case 'CL':
                    this._writeAttributeString(writer, 'callout', primitive);
                    break;
                case 'QuadPoints':
                    this._writeAttributeString(writer, 'coords', primitive);
                    break;
                case 'CA':
                    this._writeAttributeString(writer, 'opacity', primitive);
                    break;
                case 'F':
                    if (typeof primitive === 'number' && this._annotationAttributes.indexOf('flags') === -1) {
                        const flag = _annotationFlagsToString(primitive);
                        writer._writeAttributeString('flags', flag);
                        this._annotationAttributes.push('flags');
                    }
                    break;
                case 'InkList':
                case 'Type':
                case 'Subtype':
                case 'P':
                case 'Parent':
                case 'L':
                case 'Contents':
                case 'RC':
                case 'DA':
                case 'DS':
                case 'FS':
                case 'MeasurementTypes':
                case 'Vertices':
                case 'GroupNesting':
                case 'ITEx':
                case 'TextMarkupContent':
                    break;
                default:
                    this._writeAttributeString(writer, key.toLowerCase(), primitive);
                    break;
            }
        }
    }
    _writeAttributeString(writer, attribute, primitive, isLowerCase = false) {
        if (this._annotationAttributes.indexOf(attribute) === -1) {
            const value = this._getValue(primitive);
            writer._writeAttributeString(attribute, isLowerCase ? value.toLowerCase() : value);
            this._annotationAttributes.push(attribute);
        }
    }
    _writeRawData(writer, name, value) {
        if (value && value !== '') {
            writer._writeStartElement(name);
            writer._writeRaw(value);
            writer._writeEndElement();
        }
    }
    _writeColor(writer, primitive, attribute, tag) {
        const color = this._getColor(primitive);
        if (typeof primitive === 'number' && tag) {
            const c = this._getValue(primitive);
            if (c && c !== '' && this._annotationAttributes.indexOf(tag) === -1) {
                writer._writeAttributeString(tag, c);
                this._annotationAttributes.push(tag);
            }
        }
        if (color && color !== '' && this._annotationAttributes.indexOf(attribute) === -1) {
            writer._writeAttributeString(attribute, color);
            this._annotationAttributes.push(attribute);
        }
    }
    _exportMeasureDictionary(dictionary, writer) {
        writer._writeStartElement('measure');
        if (dictionary) {
            if (dictionary.has('R')) {
                writer._writeAttributeString('rateValue', this._getValue(dictionary.get('R')));
            }
            if (dictionary.has('A')) {
                const array = dictionary.getArray('A');
                writer._writeStartElement('area');
                this._exportMeasureFormatDetails(array[0], writer);
                writer._writeEndElement();
            }
            if (dictionary.has('D')) {
                const array = dictionary.getArray('D');
                writer._writeStartElement('distance');
                this._exportMeasureFormatDetails(array[0], writer);
                writer._writeEndElement();
            }
            if (dictionary.has('X')) {
                const array = dictionary.getArray('X');
                writer._writeStartElement('xformat');
                this._exportMeasureFormatDetails(array[0], writer);
                writer._writeEndElement();
            }
        }
        writer._writeEndElement();
    }
    _exportMeasureFormatDetails(measurementDetails, writer) {
        if (measurementDetails.has('C')) {
            writer._writeAttributeString('c', this._getValue(measurementDetails.get('C')));
        }
        if (measurementDetails.has('F')) {
            writer._writeAttributeString('f', this._getValue(measurementDetails.get('F')));
        }
        if (measurementDetails.has('D')) {
            writer._writeAttributeString('d', this._getValue(measurementDetails.get('D')));
        }
        if (measurementDetails.has('RD')) {
            writer._writeAttributeString('rd', this._getValue(measurementDetails.get('RD')));
        }
        if (measurementDetails.has('U')) {
            writer._writeAttributeString('u', this._getValue(measurementDetails.get('U')));
        }
        if (measurementDetails.has('RT')) {
            writer._writeAttributeString('rt', this._getValue(measurementDetails.get('RT')));
        }
        if (measurementDetails.has('SS')) {
            writer._writeAttributeString('ss', this._getValue(measurementDetails.get('SS')));
        }
        if (measurementDetails.has('FD')) {
            writer._writeAttributeString('fd', this._getValue(measurementDetails.get('FD')));
        }
    }
    //#endregion Export Annotations
    //#region Import Annotations
    _importAnnotations(document, data) {
        this._document = document;
        this._crossReference = document._crossReference;
        this._isAnnotationExport = false;
        const xml = _bytesToString(data);
        this._xmlDocument = (new DOMParser()).parseFromString(xml, 'text/xml');
        this._isAnnotationImport = true;
        this._readXmlData(this._xmlDocument.documentElement);
    }
    _importFormData(document, data) {
        this._document = document;
        this._crossReference = document._crossReference;
        this._isAnnotationExport = false;
        this._xmlDocument = (new DOMParser()).parseFromString(_bytesToString(data), 'text/xml');
        this._readXmlData(this._xmlDocument.documentElement);
    }
    _readXmlData(root) {
        if (root && root.nodeType === 1) {
            this._checkXfdf(root);
            if (this._isAnnotationImport) {
                const xList = root.getElementsByTagName('annots');
                if (xList && xList.length > 0) {
                    for (let i = 0; i < xList.length; i++) {
                        const child = xList.item(i);
                        if (child && child.localName === 'annots' && child.hasChildNodes()) {
                            const childeNodes = child.childNodes;
                            for (let j = 0; j < childeNodes.length; j++) {
                                const childNode = childeNodes.item(j);
                                if (childNode && childNode.nodeType === 1) {
                                    const element = childNode;
                                    if (element && element.nodeType === 1) {
                                        this._parseAnnotationData(element);
                                    }
                                }
                            }
                        }
                    }
                }
                if (this._groupHolders.length > 0) {
                    for (let i = 0; i < this._groupHolders.length; i++) {
                        const dictionary = this._groupHolders[Number.parseInt(i.toString(), 10)];
                        const inReplyTo = dictionary.get('IRT');
                        if (inReplyTo && inReplyTo !== '') {
                            if (this._groupReferences.has(inReplyTo)) {
                                dictionary.update('IRT', this._groupReferences.get(inReplyTo));
                            }
                            else {
                                delete dictionary._map.IRT;
                            }
                        }
                    }
                }
                this._groupHolders = [];
                this._groupReferences = new Map();
            }
            else {
                this._parseFormData(root);
            }
        }
        this._dispose();
    }
    _checkXfdf(element) {
        if (element.nodeName !== 'xfdf') {
            throw new Error('Invalid XFDF file.');
        }
    }
    _parseFormData(root) {
        let list = root.getElementsByTagName('f');
        if (list && list.length > 0) {
            const fileNameElement = list.item(0);
            if (fileNameElement && fileNameElement.localName === 'f' && fileNameElement.hasAttribute('href')) {
                const fileName = fileNameElement.getAttribute('href');
                if (fileName && fileName !== '') {
                    this._fileName = fileName;
                }
            }
        }
        list = root.getElementsByTagName('ids');
        if (list && list.length > 0) {
            this._asPerSpecification = true;
        }
        const child = root.childNodes;
        if (child && child.length > 0) {
            for (let i = 0; i < child.length; i++) {
                const childNode = child.item(i);
                if (childNode && childNode.nodeType === 1) {
                    const element = childNode;
                    if (element && element.localName === 'fields' && element.hasChildNodes()) {
                        const fieldList = element.childNodes;
                        const elements = [];
                        for (let j = 0; j < fieldList.length; j++) {
                            const field = fieldList.item(j);
                            if (field && field.nodeType === 1) {
                                const filedElement = field;
                                if (filedElement && filedElement.localName === 'field') {
                                    elements.push(filedElement);
                                }
                            }
                        }
                        this._importFormNodes(elements);
                    }
                }
            }
        }
        this._importField();
    }
    _importFormNodes(list) {
        for (let i = 0; i < list.length; i++) {
            const child = list[Number.parseInt(i.toString(), 10)];
            let fieldName = '';
            if (child) {
                if (child.hasAttribute('name')) {
                    fieldName = child.getAttribute('name');
                }
                if (fieldName && fieldName !== '') {
                    let values = child.getElementsByTagName('value');
                    if (values && values.length > 0) {
                        let node = child;
                        let textName = '';
                        while (node.localName !== 'fields') {
                            if (textName.length > 0) {
                                textName = '.' + textName;
                            }
                            let skip = false;
                            if (node.hasAttribute('name')) {
                                const name = node.getAttribute('name');
                                if (name && name !== '') {
                                    textName = name + textName;
                                    skip = true;
                                }
                            }
                            if (!skip) {
                                textName += node.localName;
                            }
                            node = node.parentElement;
                        }
                        fieldName = textName;
                        let dataValues;
                        if (this._fields.has(fieldName)) {
                            dataValues = this._fields.get(fieldName);
                        }
                        else {
                            dataValues = [];
                        }
                        for (let j = 0; j < values.length; j++) {
                            dataValues.push(values.item(j).textContent);
                        }
                        this._fields.set(fieldName, dataValues);
                    }
                    else {
                        values = child.getElementsByTagName('value-richtext');
                        if (values && values.length > 0) {
                            const element = values.item(0);
                            if (element) {
                                let node = child;
                                let textName = '';
                                while (node.localName !== 'fields') {
                                    if (textName.length > 0) {
                                        textName = '.' + textName;
                                    }
                                    let skip = false;
                                    if (node.hasAttribute('name')) {
                                        const name = node.getAttribute('name');
                                        if (name && name !== '') {
                                            textName = name + textName;
                                            skip = true;
                                        }
                                    }
                                    if (!skip) {
                                        textName += node.localName;
                                    }
                                    node = node.parentElement;
                                }
                                fieldName = textName;
                                let richText = element.textContent;
                                if (element.childNodes && element.childNodes.length > 0) {
                                    const childNode = element.childNodes[0];
                                    if (childNode && childNode.hasChildNodes()) {
                                        richText = '';
                                        const childNodes = childNode.childNodes;
                                        for (let j; j < childNodes.length; j++) {
                                            richText += childNodes.item(j).textContent + '\r';
                                        }
                                        if (richText.length > 0) {
                                            richText = richText.substring(0, richText.length - 1);
                                        }
                                        else {
                                            richText = element.textContent;
                                        }
                                    }
                                }
                                let dataValues;
                                if (this._fields.has(fieldName)) {
                                    dataValues = this._fields.get(fieldName);
                                }
                                else {
                                    dataValues = [];
                                }
                                for (let j = 0; j < values.length; j++) {
                                    dataValues.push(richText);
                                }
                                this._fields.set(fieldName, dataValues);
                                if (!this._richTextValues.has(fieldName)) {
                                    this._richTextValues.set(fieldName, element.innerHTML);
                                }
                            }
                        }
                    }
                }
            }
        }
    }
    _parseAnnotationData(element) {
        if (element) {
            let pageIndex = -1;
            if (element.hasAttributes && element.hasAttribute('page')) {
                pageIndex = Number.parseInt(element.getAttribute('page'), 10);
                if (pageIndex >= 0 && pageIndex < this._document.pageCount) {
                    const page = this._document.getPage(pageIndex);
                    const annotationDictionary = this._getAnnotationDictionary(page, element);
                    if (annotationDictionary && annotationDictionary.size > 0) {
                        const pageDictionary = page._pageDictionary;
                        if (pageDictionary) {
                            const annotations = page.annotations;
                            const annotation = annotations._parseAnnotation(annotationDictionary);
                            if (annotation) {
                                annotation._isImported = true;
                                const reference = this._crossReference._getNextReference();
                                this._crossReference._cacheMap.set(reference, annotationDictionary);
                                if (annotationDictionary.has('NM') || annotationDictionary.has('IRT')) {
                                    this._addReferenceToGroup(reference, annotationDictionary);
                                }
                                annotation._ref = reference;
                                const index = annotations._annotations.length;
                                annotations._annotations.push(reference);
                                pageDictionary.set('Annots', annotations._annotations);
                                pageDictionary._updated = true;
                                annotations._parsedAnnotations.set(index, annotation);
                                this._handlePopup(annotations, reference, annotationDictionary, pageDictionary);
                            }
                        }
                    }
                }
            }
        }
    }
    _getAnnotationDictionary(page, element) {
        const dictionary = new _PdfDictionary(this._crossReference);
        dictionary.update('Type', _PdfName.get('Annot'));
        let isValidType = true;
        switch (element.localName.toLowerCase()) {
            case 'line':
                dictionary.update('Subtype', _PdfName.get('Line'));
                if (element.hasAttribute('start') && element.hasAttribute('end')) {
                    const points = [];
                    element.getAttribute('start').split(',').forEach((value) => {
                        points.push(Number.parseFloat(value));
                    });
                    element.getAttribute('end').split(',').forEach((value) => {
                        points.push(Number.parseFloat(value));
                    });
                    if (points.length === 4) {
                        dictionary.update('L', points);
                    }
                }
                this._addLineEndStyle(dictionary, element);
                break;
            case 'circle':
                dictionary.update('Subtype', _PdfName.get('Circle'));
                break;
            case 'square':
                dictionary.update('Subtype', _PdfName.get('Square'));
                break;
            case 'polyline':
                dictionary.update('Subtype', _PdfName.get('PolyLine'));
                this._addLineEndStyle(dictionary, element);
                break;
            case 'polygon':
                dictionary.update('Subtype', _PdfName.get('Polygon'));
                this._addLineEndStyle(dictionary, element);
                break;
            case 'ink':
                dictionary.update('Subtype', _PdfName.get('Ink'));
                break;
            case 'popup':
                dictionary.update('Subtype', _PdfName.get('Popup'));
                break;
            case 'text':
                dictionary.update('Subtype', _PdfName.get('Text'));
                break;
            case 'freetext':
                dictionary.update('Subtype', _PdfName.get('FreeText'));
                this._addLineEndStyle(dictionary, element);
                break;
            case 'stamp':
                dictionary.update('Subtype', _PdfName.get('Stamp'));
                break;
            case 'highlight':
                dictionary.update('Subtype', _PdfName.get('Highlight'));
                break;
            case 'squiggly':
                dictionary.update('Subtype', _PdfName.get('Squiggly'));
                break;
            case 'underline':
                dictionary.update('Subtype', _PdfName.get('Underline'));
                break;
            case 'strikeout':
                dictionary.update('Subtype', _PdfName.get('StrikeOut'));
                break;
            case 'fileattachment':
                dictionary.update('Subtype', _PdfName.get('FileAttachment'));
                break;
            case 'sound':
                dictionary.update('Subtype', _PdfName.get('Sound'));
                break;
            case 'caret':
                dictionary.update('Subtype', _PdfName.get('Caret'));
                break;
            case 'redact':
                dictionary.update('Subtype', _PdfName.get('Redact'));
                break;
            default:
                isValidType = false;
                break;
        }
        if (isValidType) {
            this._addAnnotationData(dictionary, element, page);
        }
        return dictionary;
    }
    _addAnnotationData(dictionary, element, page) {
        this._addBorderStyle(dictionary, element);
        this._applyAttributeValues(dictionary, element.attributes);
        this._parseInnerElements(dictionary, element, page);
        this._addMeasureDictionary(dictionary, element);
    }
    _addBorderStyle(dictionary, element) {
        const borderEffectDictionary = new _PdfDictionary(this._crossReference);
        const borderStyleDictionary = new _PdfDictionary(this._crossReference);
        if (element.hasAttribute('width')) {
            borderStyleDictionary.update('W', Number.parseFloat(element.getAttribute('width')));
        }
        let isBasicStyle = true;
        if (element.hasAttribute('style')) {
            let style = '';
            switch (element.getAttribute('style')) {
                case 'dash':
                    style = 'D';
                    break;
                case 'solid':
                    style = 'S';
                    break;
                case 'bevelled':
                    style = 'B';
                    break;
                case 'inset':
                    style = 'I';
                    break;
                case 'underline':
                    style = 'U';
                    break;
                case 'cloudy':
                    style = 'C';
                    isBasicStyle = false;
                    break;
            }
            if (style !== '') {
                (isBasicStyle ? borderStyleDictionary : borderEffectDictionary).update('S', _PdfName.get(style));
                if (!isBasicStyle && element.hasAttribute('intensity')) {
                    borderEffectDictionary.update('I', Number.parseFloat(element.getAttribute('intensity')));
                }
                else if (element.hasAttribute('dashes')) {
                    const dashes = [];
                    element.getAttribute('dashes').split(',').forEach((value) => {
                        dashes.push(Number.parseFloat(value));
                    });
                    borderStyleDictionary.update('D', dashes);
                }
            }
        }
        if (borderEffectDictionary.size > 0) {
            dictionary.update('BE', borderEffectDictionary);
        }
        if (borderStyleDictionary.size > 0) {
            borderStyleDictionary.update('Type', 'Border');
            dictionary.update('BS', borderStyleDictionary);
        }
    }
    _applyAttributeValues(dictionary, attributes) {
        for (let i = 0; i < attributes.length; i++) {
            const attribute = attributes[Number.parseInt(i.toString(), 10)];
            const value = attribute.value;
            let values;
            let leaderExtend;
            switch (attribute.name.toLowerCase()) {
                case 'page':
                case 'start':
                case 'end':
                case 'width':
                case 'head':
                case 'tail':
                case 'style':
                case 'intensity':
                case 'itex':
                    break;
                case 'state':
                    this._addString(dictionary, 'State', value);
                    break;
                case 'statemodel':
                    this._addString(dictionary, 'StateModel', value);
                    break;
                case 'replytype':
                    if (value === 'group') {
                        dictionary.update('RT', _PdfName.get('Group'));
                    }
                    break;
                case 'inreplyto':
                    this._addString(dictionary, 'IRT', value);
                    break;
                case 'rect':
                    values = this._obtainPoints(value);
                    if (values && values.length === 4) {
                        dictionary.update('Rect', values);
                    }
                    break;
                case 'color':
                    values = _convertToColor(value);
                    if (values && values.length === 3) {
                        dictionary.update('C', [values[0] / 255, values[1] / 255, values[2] / 255]);
                    }
                    break;
                case 'interior-color':
                    values = _convertToColor(value);
                    if (values && values.length === 3) {
                        dictionary.update('IC', [values[0] / 255, values[1] / 255, values[2] / 255]);
                    }
                    break;
                case 'date':
                    this._addString(dictionary, 'M', value);
                    break;
                case 'creationdate':
                    this._addString(dictionary, 'CreationDate', value);
                    break;
                case 'name':
                    this._addString(dictionary, 'NM', value);
                    break;
                case 'icon':
                    if (value && value !== '') {
                        dictionary.update('Name', _PdfName.get(value));
                    }
                    break;
                case 'subject':
                    this._addString(dictionary, 'Subj', this._getFormatedString(value, true));
                    break;
                case 'title':
                    this._addString(dictionary, 'T', this._getFormatedString(value, true));
                    break;
                case 'rotation':
                    this._addInt(dictionary, 'Rotate', value);
                    break;
                case 'justification':
                    this._addInt(dictionary, 'Q', value);
                    break;
                case 'fringe':
                    this._addFloatPoints(dictionary, this._obtainPoints(value), 'RD');
                    break;
                case 'it':
                    if (value && value !== '') {
                        dictionary.update('IT', _PdfName.get(value));
                    }
                    break;
                case 'leaderlength':
                    this._addFloat(dictionary, 'LL', value);
                    break;
                case 'leaderextend':
                    leaderExtend = Number.parseFloat(value);
                    if (typeof leaderExtend !== 'undefined') {
                        dictionary.update('LLE', leaderExtend);
                    }
                    break;
                case 'caption':
                    if (value && value !== '') {
                        dictionary.update('Cap', value.toLowerCase() === 'yes' ? true : false);
                    }
                    break;
                case 'caption-style':
                    if (value && value !== '') {
                        dictionary.update('CP', _PdfName.get(value));
                    }
                    break;
                case 'callout':
                    this._addFloatPoints(dictionary, this._obtainPoints(value), 'CL');
                    break;
                case 'coords':
                    this._addFloatPoints(dictionary, this._obtainPoints(value), 'QuadPoints');
                    break;
                case 'border':
                    this._addFloatPoints(dictionary, this._obtainPoints(value), 'Border');
                    break;
                case 'opacity':
                    this._addFloat(dictionary, 'CA', value);
                    break;
                case 'flags':
                    if (value && value !== '') {
                        let annotFlag = PdfAnnotationFlag.default;
                        const flags = value.split(',');
                        for (let i = 0; i < flags.length; i++) {
                            const flagType = _stringToAnnotationFlags(flags[Number.parseInt(i.toString(), 10)]);
                            if (i === 0) {
                                annotFlag = flagType;
                            }
                            else {
                                annotFlag |= flagType;
                            }
                        }
                        dictionary.update('F', annotFlag);
                    }
                    break;
                case 'open':
                    if (value && value !== '') {
                        dictionary.update('Open', (value === 'true' || value === 'yes') ? true : false);
                    }
                    break;
                case 'calibrate':
                    this._addString(dictionary, 'Calibrate', value);
                    break;
                case 'customdata':
                    this._addString(dictionary, 'CustomData', value);
                    break;
                case 'overlaytext':
                    dictionary.update('OverlayText', value);
                    break;
                case 'repeat':
                    dictionary.update('Repeat', (value === 'true' || value === 'yes') ? true : false);
                    break;
                default:
                    if (this._document._allowImportCustomData) {
                        this._addString(dictionary, attribute.name, value);
                    }
                    break;
            }
        }
    }
    _obtainPoints(value) {
        const points = [];
        value.split(',').forEach((value) => {
            points.push(Number.parseFloat(value));
        });
        return points;
    }
    _parseInnerElements(dictionary, element, page) {
        if (element.hasChildNodes) {
            const children = element.childNodes;
            for (let index = 0; index < children.length; index++) {
                const child = children[Number.parseInt(index.toString(), 10)];
                if (child.nodeType === 1) {
                    const childElement = child;
                    const textContent = child.textContent;
                    const innerHTML = childElement.innerHTML;
                    switch (child.nodeName.toLowerCase()) {
                        case 'popup':
                            if (childElement && childElement.hasAttributes) {
                                const popupDictionary = this._getAnnotationDictionary(page, childElement);
                                if (popupDictionary.size > 0) {
                                    const reference = this._crossReference._getNextReference();
                                    this._crossReference._cacheMap.set(reference, popupDictionary);
                                    dictionary.update('Popup', reference);
                                    if (popupDictionary.has('NM')) {
                                        this._addReferenceToGroup(reference, popupDictionary);
                                    }
                                }
                            }
                            break;
                        case 'contents':
                            if (textContent && textContent !== '') {
                                dictionary.update('Contents', this._getFormatedString(textContent, true));
                            }
                            break;
                        case 'contents-richtext':
                            if (innerHTML && innerHTML !== '') {
                                dictionary.update('RC', this._richTextPrefix + innerHTML);
                            }
                            break;
                        case 'defaultstyle':
                            this._addString(dictionary, 'DS', textContent);
                            break;
                        case 'defaultappearance':
                            this._addString(dictionary, 'DA', textContent);
                            break;
                        case 'vertices':
                            if (textContent && textContent !== '') {
                                const vertices = [];
                                textContent.split(',').forEach((value) => {
                                    if (value.indexOf(';') !== -1) {
                                        value.split(';').forEach((innerValue) => {
                                            vertices.push(innerValue);
                                        });
                                    }
                                    else {
                                        vertices.push(value);
                                    }
                                });
                                if (vertices.length > 0) {
                                    const verticesArray = [];
                                    vertices.forEach((value) => {
                                        verticesArray.push(Number.parseFloat(value));
                                    });
                                    dictionary.update('Vertices', verticesArray);
                                }
                            }
                            break;
                        case 'appearance':
                            this._addAppearanceData(child, dictionary);
                            break;
                        case 'inklist':
                            if (child.hasChildNodes) {
                                const inkListCollection = [];
                                const childNodes = child.childNodes;
                                for (let i = 0; i < childNodes.length; i++) {
                                    const inkChild = childNodes[Number.parseInt(i.toString(), 10)];
                                    if (inkChild && inkChild.nodeType === 1) {
                                        const inkChildElement = inkChild;
                                        if (inkChildElement.nodeName.toLowerCase() === 'gesture') {
                                            if (inkChildElement.textContent && inkChildElement.textContent !== '') {
                                                const points = [];
                                                inkChildElement.textContent.split(',').forEach((value) => {
                                                    if (value.indexOf(';') !== -1) {
                                                        value.split(';').forEach((innerValue) => {
                                                            points.push(innerValue);
                                                        });
                                                    }
                                                    else {
                                                        points.push(value);
                                                    }
                                                });
                                                if (points.length > 0) {
                                                    const pointsArray = [];
                                                    points.forEach((value) => {
                                                        pointsArray.push(Number.parseFloat(value));
                                                    });
                                                    inkListCollection.push(pointsArray);
                                                }
                                            }
                                        }
                                    }
                                }
                                dictionary.update('InkList', inkListCollection);
                            }
                            break;
                        case 'data':
                            this._addStreamData(child, dictionary, element);
                            break;
                    }
                }
            }
        }
    }
    _addStreamData(child, dictionary, parent) {
        if (child && child.textContent && child.textContent !== '') {
            const raw = _hexStringToByteArray(child.textContent, true);
            if (raw && raw.length > 0) {
                if (dictionary.has('Subtype')) {
                    const subtype = dictionary.get('Subtype');
                    if (subtype && subtype.name === 'FileAttachment') {
                        this._addFileAttachment(dictionary, parent, raw);
                    }
                    else if (subtype && subtype.name === 'Sound') {
                        this._addSound(dictionary, parent, raw);
                    }
                }
            }
        }
    }
    _addSound(dictionary, element, raw) {
        const soundStream = new _PdfContentStream(raw);
        soundStream.dictionary._crossReference = this._crossReference;
        soundStream.dictionary.update('Type', _PdfName.get('Sound'));
        if (element.hasAttribute('bits')) {
            this._addInt(soundStream.dictionary, 'B', element.getAttribute('bits'));
        }
        if (element.hasAttribute('rate')) {
            this._addInt(soundStream.dictionary, 'R', element.getAttribute('rate'));
        }
        if (element.hasAttribute('channels')) {
            this._addInt(soundStream.dictionary, 'C', element.getAttribute('channels'));
        }
        if (element.hasAttribute('encoding')) {
            const value = element.getAttribute('encoding');
            if (value && value !== '') {
                soundStream.dictionary.update('E', _PdfName.get(value));
            }
        }
        if (element.hasAttribute('filter')) {
            soundStream.dictionary.update('Filter', _PdfName.get('FlateDecode'));
        }
        const soundReference = this._crossReference._getNextReference();
        this._crossReference._cacheMap.set(soundReference, soundStream);
        dictionary.update('Sound', soundReference);
    }
    _addFileAttachment(dictionary, element, raw) {
        const fileDictionary = new _PdfDictionary(this._crossReference);
        fileDictionary.update('Type', _PdfName.get('Filespec'));
        if (element.hasAttribute('file')) {
            const value = element.getAttribute('file');
            this._addString(fileDictionary, 'F', value);
            this._addString(fileDictionary, 'UF', value);
        }
        const fileStream = new _PdfContentStream(raw);
        fileStream.dictionary._crossReference = this._crossReference;
        const param = new _PdfDictionary(this._crossReference);
        if (element.hasAttribute('size')) {
            const size = Number.parseInt(element.getAttribute('size'), 10);
            if (typeof size !== 'undefined') {
                param.update('Size', size);
                fileStream.dictionary.update('DL', size);
            }
        }
        if (element.hasAttribute('modification')) {
            this._addString(param, 'ModDate', element.getAttribute('modification'));
        }
        if (element.hasAttribute('creation')) {
            this._addString(param, 'CreationDate', element.getAttribute('creation'));
        }
        fileStream.dictionary.update('Params', param);
        if (element.hasAttribute('mimetype')) {
            this._addString(fileStream.dictionary, 'Subtype', element.getAttribute('mimetype'));
        }
        fileStream.dictionary.update('Filter', _PdfName.get('FlateDecode'));
        const embeddedFile = new _PdfDictionary(this._crossReference);
        const reference = this._crossReference._getNextReference();
        this._crossReference._cacheMap.set(reference, fileStream);
        embeddedFile.update('F', reference);
        fileDictionary.update('EF', embeddedFile);
        const fileReference = this._crossReference._getNextReference();
        this._crossReference._cacheMap.set(fileReference, fileDictionary);
        dictionary.update('FS', fileReference);
    }
    _addAppearanceData(element, dictionary) {
        const innerText = element.textContent;
        if (innerText && innerText !== '') {
            const document = (new DOMParser()).parseFromString(atob(innerText), 'text/xml');
            if (document && document.hasChildNodes) {
                let childNodes = document.childNodes;
                if (childNodes && childNodes.length === 1) {
                    const rootNode = childNodes[0];
                    if (rootNode && rootNode.nodeType === 1) {
                        const rootElement = rootNode;
                        if (rootElement.nodeName.toUpperCase() === 'DICT' && rootElement.hasAttribute('KEY')) {
                            const key = rootElement.getAttribute('KEY');
                            if (key && key === 'AP' && rootElement.hasChildNodes) {
                                const appearance = new _PdfDictionary(this._crossReference);
                                childNodes = rootElement.childNodes;
                                for (let i = 0; i < childNodes.length; i++) {
                                    this._getAppearance(appearance, childNodes[Number.parseInt(i.toString(), 10)]);
                                }
                                if (appearance.size > 0) {
                                    dictionary.update('AP', appearance);
                                }
                            }
                        }
                    }
                }
            }
        }
    }
    _getAppearance(source, child) {
        const appearance = source instanceof _PdfDictionary ? source : source.dictionary;
        if (child && child.nodeType === 1) {
            const element = child;
            if (element && element.localName) {
                let stream;
                let dictionary;
                let data;
                switch (element.localName) {
                    case 'STREAM':
                        stream = this._getStream(element);
                        if (stream) {
                            const reference = this._crossReference._getNextReference();
                            this._crossReference._cacheMap.set(reference, stream);
                            this._addKey(reference, appearance, element);
                        }
                        break;
                    case 'DICT':
                        dictionary = this._getDictionary(element);
                        if (dictionary) {
                            const reference = this._crossReference._getNextReference();
                            this._crossReference._cacheMap.set(reference, dictionary);
                            this._addKey(reference, appearance, element);
                        }
                        break;
                    case 'ARRAY':
                        this._addKey(this._getArray(element), appearance, element);
                        break;
                    case 'FIXED':
                        this._addKey(this._getFixed(element), appearance, element);
                        break;
                    case 'INT':
                        this._addKey(this._getInt(element), appearance, element);
                        break;
                    case 'STRING':
                        this._addKey(this._getString(element), appearance, element);
                        break;
                    case 'NAME':
                        this._addKey(this._getName(element), appearance, element);
                        break;
                    case 'BOOL':
                        this._addKey(this._getBoolean(element), appearance, element);
                        break;
                    case 'DATA':
                        data = this._getData(element);
                        if (data && data.length > 0 && source instanceof _PdfContentStream) {
                            source._bytes = data;
                            let isImage = false;
                            if (appearance && appearance.has('Subtype')) {
                                const type = appearance.get('Subtype');
                                isImage = type && type.name === 'Image';
                            }
                            if (isImage) {
                                source._isCompress = false;
                            }
                            else {
                                if (source.dictionary.has('Length')) {
                                    delete source.dictionary._map.Length;
                                }
                                if (source.dictionary.has('Filter')) {
                                    delete source.dictionary._map.Filter;
                                }
                            }
                        }
                        break;
                }
            }
        }
    }
    _getStream(element) {
        const stream = new _PdfContentStream([]);
        stream.dictionary._crossReference = this._crossReference;
        if (element.hasChildNodes) {
            const childNodes = element.childNodes;
            for (let i = 0; i < childNodes.length; i++) {
                const child = childNodes[Number.parseInt(i.toString(), 10)];
                if (child && child.nodeType === 1) {
                    this._getAppearance(stream, child);
                }
            }
        }
        return stream;
    }
    _getDictionary(element) {
        const dictionary = new _PdfDictionary(this._crossReference);
        if (element.hasChildNodes) {
            const childNodes = element.childNodes;
            for (let i = 0; i < childNodes.length; i++) {
                const child = childNodes[Number.parseInt(i.toString(), 10)];
                if (child && child.nodeType === 1) {
                    this._getAppearance(dictionary, child);
                }
            }
        }
        return dictionary;
    }
    _getArray(element) {
        const array = []; // eslint-disable-line
        if (element.hasChildNodes) {
            const childNodes = element.childNodes;
            for (let i = 0; i < childNodes.length; i++) {
                const child = childNodes[Number.parseInt(i.toString(), 10)];
                if (child && child.nodeType === 1) {
                    this._addArrayElements(array, child);
                }
            }
        }
        return array;
    }
    _getData(element) {
        let data = [];
        if (element && element.textContent &&
            element.textContent !== '' &&
            element.hasAttribute('MODE') && element.hasAttribute('ENCODING')) {
            const mode = element.getAttribute('MODE');
            const encoding = element.getAttribute('ENCODING');
            if (mode && encoding) {
                const innerText = this._getFormatedString(element.textContent, true);
                if (mode === 'FILTERED' && encoding === 'ASCII') {
                    data = _stringToBytes(innerText, true);
                }
                else if (mode === 'RAW' && encoding === 'HEX') {
                    data = _hexStringToByteArray(innerText, true);
                }
            }
        }
        return data;
    }
    _addArrayElements(array, child) {
        if (child && child.nodeType === 1) {
            const element = child;
            let stream;
            let dictionary;
            let value; // eslint-disable-line
            let floatValue;
            let intValue;
            let name;
            let bool;
            switch (element.localName) {
                case 'STREAM':
                    stream = this._getStream(element);
                    if (stream) {
                        const reference = this._crossReference._getNextReference();
                        stream.reference = reference;
                        this._crossReference._cacheMap.set(reference, stream);
                        array.push(reference);
                    }
                    break;
                case 'DICT':
                    dictionary = this._getDictionary(element);
                    if (dictionary) {
                        const reference = this._crossReference._getNextReference();
                        this._crossReference._cacheMap.set(reference, dictionary);
                        array.push(reference);
                    }
                    break;
                case 'ARRAY':
                    value = this._getArray(element);
                    if (value) {
                        array.push(value);
                    }
                    break;
                case 'FIXED':
                    floatValue = this._getFixed(element);
                    if (typeof floatValue !== 'undefined' && !isNaN(floatValue)) {
                        array.push(floatValue);
                    }
                    break;
                case 'INT':
                    intValue = this._getInt(element);
                    if (typeof intValue !== 'undefined' && !isNaN(intValue)) {
                        array.push(intValue);
                    }
                    break;
                case 'NAME':
                    name = this._getName(element);
                    if (name) {
                        array.push(name);
                    }
                    break;
                case 'BOOL':
                    bool = this._getBoolean(element);
                    if (typeof bool !== 'undefined' && bool !== null) {
                        array.push(bool);
                    }
                    break;
            }
        }
    }
    _getFixed(element) {
        let value;
        if (element && element.hasAttribute('VAL')) {
            value = Number.parseFloat(element.getAttribute('VAL'));
        }
        return value;
    }
    _getInt(element) {
        let value;
        if (element && element.hasAttribute('VAL')) {
            value = Number.parseInt(element.getAttribute('VAL'), 10);
        }
        return value;
    }
    _getString(element) {
        let value;
        if (element && element.hasAttribute('VAL')) {
            value = element.getAttribute('VAL');
        }
        return value;
    }
    _getName(element) {
        let value;
        if (element && element.hasAttribute('VAL')) {
            value = _PdfName.get(element.getAttribute('VAL'));
        }
        return value;
    }
    _getBoolean(element) {
        let value;
        if (element && element.hasAttribute('VAL')) {
            value = element.getAttribute('VAL') === 'true' ? true : false;
        }
        return value;
    }
    _addMeasureDictionary(dictionary, element) {
        let measurement;
        let area;
        let distance;
        let xformat;
        if (element.hasChildNodes) {
            const childNodes = element.childNodes;
            for (let i = 0; i < childNodes.length; i++) {
                const childElement = childNodes[Number.parseInt(i.toString(), 10)];
                if (childElement && childElement.localName === 'measure') {
                    measurement = childElement;
                    break;
                }
            }
        }
        const measureDictionary = new _PdfDictionary(this._crossReference);
        const dDict = new _PdfDictionary(this._crossReference);
        const aDict = new _PdfDictionary(this._crossReference);
        const xDict = new _PdfDictionary(this._crossReference);
        const dArray = [];
        const aArray = [];
        const xArray = [];
        if (measurement) {
            measureDictionary.update('Type', _PdfName.get('Measure'));
            if (measurement.hasAttribute('rateValue')) {
                const attribute = measurement.getAttribute('rateValue');
                if (attribute && attribute !== '') {
                    measureDictionary.update('R', attribute);
                }
            }
            if (measurement.hasChildNodes) {
                const childNodes = measurement.childNodes;
                for (let i = 0; i < childNodes.length; i++) {
                    const child = childNodes[Number.parseInt(i.toString(), 10)];
                    if (child && child.nodeType === 1) {
                        const childElement = child;
                        switch (childElement.nodeName.toLowerCase()) {
                            case 'distance':
                                distance = childElement;
                                break;
                            case 'area':
                                area = childElement;
                                break;
                            case 'xformat':
                                xformat = childElement;
                                break;
                        }
                    }
                }
            }
        }
        if (xformat) {
            this._addElements(xformat, xDict);
            xArray.push(xDict);
        }
        if (distance) {
            this._addElements(distance, dDict);
            dArray.push(dDict);
        }
        if (area) {
            this._addElements(area, aDict);
            aArray.push(aDict);
        }
        measureDictionary.set('A', aArray);
        measureDictionary.set('D', dArray);
        measureDictionary.set('X', xArray);
        if (measureDictionary.size > 0 && measureDictionary.has('Type')) {
            const reference = this._crossReference._getNextReference();
            this._crossReference._cacheMap.set(reference, measureDictionary);
            dictionary.update('Measure', reference);
        }
    }
    _addElements(element, dictionary) {
        if (element.hasAttribute('d')) {
            this._addFloat(dictionary, 'D', element.getAttribute('d'));
        }
        if (element.hasAttribute('c')) {
            this._addFloat(dictionary, 'C', element.getAttribute('c'));
        }
        if (element.hasAttribute('rt')) {
            dictionary.update('RT', element.getAttribute('rt'));
        }
        if (element.hasAttribute('rd')) {
            dictionary.update('RD', element.getAttribute('rt'));
        }
        if (element.hasAttribute('ss')) {
            dictionary.update('SS', element.getAttribute('ss'));
        }
        if (element.hasAttribute('u')) {
            dictionary.update('U', element.getAttribute('u'));
        }
        if (element.hasAttribute('f')) {
            dictionary.update('F', _PdfName.get(element.getAttribute('f')));
        }
        if (element.hasAttribute('fd')) {
            dictionary.update('FD', element.getAttribute('fd') === 'yes' ? true : false);
        }
    }
    _addString(dictionary, key, value) {
        if (value && value !== '') {
            dictionary.update(key, value);
        }
    }
    _addInt(dictionary, key, value) {
        const intValue = Number.parseInt(value, 10);
        if (typeof intValue !== 'undefined') {
            dictionary.update(key, intValue);
        }
    }
    _addFloat(dictionary, key, value) {
        const floatValue = Number.parseFloat(value);
        if (typeof floatValue !== 'undefined') {
            dictionary.update(key, floatValue);
        }
    }
    _addFloatPoints(dictionary, points, key) {
        if (points && points.length > 0) {
            dictionary.update(key, points);
        }
    }
    _addKey(primitive, dictionary, element) {
        if (typeof primitive !== 'undefined' && primitive !== null && element.hasAttribute('KEY')) {
            dictionary.update(element.getAttribute('KEY'), primitive);
        }
    }
    _addLineEndStyle(dictionary, element) {
        let beginLineStyle = '';
        if (element.hasAttribute('head')) {
            beginLineStyle = element.getAttribute('head');
        }
        let endLineStyle = '';
        if (element.hasAttribute('tail')) {
            endLineStyle = element.getAttribute('tail');
        }
        if (beginLineStyle && beginLineStyle !== '') {
            if (endLineStyle && endLineStyle !== '') {
                const lineEndingStyles = [];
                lineEndingStyles.push(_PdfName.get(beginLineStyle));
                lineEndingStyles.push(_PdfName.get(endLineStyle));
                dictionary.update('LE', lineEndingStyles);
            }
            else {
                dictionary.update('LE', _PdfName.get(beginLineStyle));
            }
        }
        else if (endLineStyle && endLineStyle !== '') {
            dictionary.update('LE', _PdfName.get(endLineStyle));
        }
    }
}
class _FontStructure {
    constructor(dictionary) {
        this._baseFontEncoding = '';
        this._dictionary = dictionary;
        this._fontType = this._dictionary.get('Subtype').name;
    }
    get differencesDictionary() {
        if (!this._differencesDictionary) {
            this._differencesDictionary = this._getDifferencesDictionary();
        }
        return this._differencesDictionary;
    }
    get baseFontEncoding() {
        return this._baseFontEncoding;
    }
    get fontEncoding() {
        if (!this._fontEncoding) {
            this._fontEncoding = this._getFontEncoding();
        }
        return this._fontEncoding;
    }
    get fontName() {
        if (!this._fontName) {
            this._fontName = this._getFontName();
        }
        return this._fontName;
    }
    _getFontEncoding() {
        let encoding = '';
        if (this._dictionary !== null && typeof this._dictionary !== 'undefined' && this._dictionary.has('Encoding')) {
            const baseFont = this._dictionary.get('Encoding'); // eslint-disable-line
            if (baseFont instanceof _PdfName) {
                encoding = baseFont.name;
            }
            else if (baseFont instanceof _PdfDictionary) {
                if (baseFont.has('BaseEncoding')) {
                    const baseFontEncoding = baseFont.get('BaseEncoding');
                    if (baseFontEncoding && baseFontEncoding instanceof _PdfName) {
                        this._baseFontEncoding = baseFontEncoding.name;
                    }
                }
                if (baseFont.has('Type')) {
                    const fontEncoding = baseFont.get('Type');
                    if (fontEncoding !== null && typeof fontEncoding !== 'undefined') {
                        encoding = fontEncoding.name;
                    }
                }
            }
        }
        if (encoding.toString() === 'identity#2dh' || encoding === 'CMap') {
            encoding = 'Identity-H';
        }
        return encoding;
    }
    _getDifferencesDictionary() {
        const result = new Map();
        if (this._dictionary !== null && typeof this._dictionary !== 'undefined' && this._dictionary.has('Encoding')) {
            const encoding = this._dictionary.get('Encoding');
            if (encoding !== null &&
                typeof encoding !== 'undefined' &&
                encoding instanceof _PdfDictionary &&
                encoding.has('Differences')) {
                const differences = encoding.getArray('Differences'); // eslint-disable-line
                let count = 0;
                if (differences !== null && typeof differences !== 'undefined') {
                    for (let i = 0; i < differences.length; i++) {
                        let text = '';
                        const item = differences[Number.parseInt(i.toString(), 10)]; // eslint-disable-line
                        if (typeof item === 'number') {
                            text = item.toString();
                            count = Number.parseInt(text, 10);
                        }
                        else if (item instanceof _PdfName) {
                            text = item.name;
                            if (this._fontType === 'Type1' && text === '.notdef') {
                                text = ' ';
                                result.set(count.toString(), _getLatinCharacter(text));
                            }
                            else {
                                text = _getLatinCharacter(text);
                                text = _getSpecialCharacter(text);
                                if (!result.has(count.toString())) {
                                    result.set(count.toString(), _getLatinCharacter(text));
                                }
                                count++;
                            }
                        }
                    }
                }
            }
        }
        return result;
    }
    _getFontName() {
        let fontName = '';
        if (this._dictionary !== null && typeof this._dictionary !== 'undefined' && this._dictionary.has('BaseFont')) {
            const baseFont = this._dictionary.get('BaseFont');
            let font = baseFont.name;
            if (font.indexOf('#20') !== -1 && font.indexOf('+') === -1) {
                const index = font.lastIndexOf('#20');
                font = font.substring(0, index);
                font += '+';
            }
            if (baseFont.name.indexOf('+') !== -1) {
                fontName = baseFont.name.split('+')[1];
            }
            else {
                fontName = baseFont.name;
            }
            if (fontName.indexOf('-') !== -1) {
                fontName = fontName.split('-')[0];
            }
            else if (fontName.indexOf(',') !== -1) {
                fontName = fontName.split(',')[0];
            }
            if (fontName.indexOf('MT') !== -1) {
                fontName = fontName.replace('MT', '');
            }
            if (fontName.indexOf('#20') !== -1) {
                fontName = fontName.replace('#20', ' ');
            }
            if (fontName.indexOf('#') !== -1) {
                fontName = this._decodeHexFontName(fontName);
            }
        }
        return fontName;
    }
    _decodeHexFontName(fontName) {
        let result = fontName;
        for (let i = 0; i < fontName.length; i++) {
            if (fontName[Number.parseInt(i.toString(), 10)] === '#') {
                const hexValue = fontName[i + 1] + fontName[i + 2];
                const value = Number.parseInt(hexValue, 16);
                if (value !== 0) {
                    result = result.replace(`#${hexValue}`, String.fromCharCode(value));
                    i += 2;
                }
                if (result.indexOf('#') === -1) {
                    break;
                }
            }
        }
        return result;
    }
}

class _JsonDocument extends _ExportHelper {
    constructor(fileName) {
        super();
        if (fileName !== null && typeof fileName !== 'undefined') {
            this._fileName = fileName;
        }
    }
    // #region Export Annotations
    _exportAnnotations(document) {
        this._document = document;
        this._crossReference = document._crossReference;
        this._isAnnotationExport = true;
        this._exportAnnotationData(document, document.pageCount);
        return this._save();
    }
    _exportFormFields(document) {
        this._document = document;
        this._crossReference = document._crossReference;
        this._isAnnotationExport = false;
        const form = this._document.form;
        if (form !== null && typeof form !== 'undefined') {
            this._exportEmptyFields = form.exportEmptyFields;
            const count = this._document.form.count;
            for (let i = 0; i < count; i++) {
                const field = this._document.form.fieldAt(i);
                this._exportFormFieldsData(field);
            }
            this._writeFormFieldData();
        }
        return this._save();
    }
    _save() {
        const result = new Uint8Array(this._jsonData);
        this._jsonData = [];
        return result;
    }
    _writeFormFieldData() {
        this._jsonData.push(this._openingBrace);
        let index = 0;
        this._table.forEach((value, key) => {
            key = this._getValidString(key);
            this._jsonData.push(this._doubleQuotes);
            for (let i = 0; i < key.length; i++) {
                this._jsonData.push(key.charCodeAt(i));
            }
            if (typeof value === 'string' || (Array.isArray(value) && value.length === 1)) {
                value = this._getValidString(typeof value === 'string' ? value : value[0]);
                this._jsonData.push(this._doubleQuotes, this._colon, this._doubleQuotes);
                for (let i = 0; i < value.length; i++) {
                    this._jsonData.push(value.charCodeAt(i));
                }
                this._jsonData.push(this._doubleQuotes);
            }
            else {
                this._jsonData.push(this._doubleQuotes, this._colon, this._openingBracket);
                for (let j = 0; j < value.length; j++) {
                    this._jsonData.push(this._doubleQuotes);
                    const entry = value[Number.parseInt(j.toString(), 10)];
                    for (let k = 0; k < entry.length; k++) {
                        this._jsonData.push(entry.charCodeAt(k));
                    }
                    this._jsonData.push(this._doubleQuotes);
                    if (j < value.length - 1) {
                        this._jsonData.push(this._comma);
                    }
                }
                this._jsonData.push(this._closingBracket);
            }
            if (index < this._table.size - 1) {
                this._jsonData.push(this._comma);
            }
            index++;
        });
        this._jsonData.push(this._closingBrace);
    }
    _exportAnnotationData(document, pageCount) {
        let isAnnotationAdded = false;
        this._jsonData.push(this._openingBrace, this._doubleQuotes, 112, 100, 102, 65, 110, 110, 111, 116, 97, 116, 105, 111, 110, this._doubleQuotes, this._colon, this._openingBrace);
        for (let i = 0; i < pageCount; i++) {
            const page = document.getPage(i);
            if (page && page.annotations.count > 0) {
                this._jsonData.push(i !== 0 && isAnnotationAdded ? this._comma : this._space, this._doubleQuotes);
                const pageNumber = _convertStringToBytes(i.toString(), []);
                pageNumber.forEach((entry) => {
                    this._jsonData.push(entry);
                });
                this._jsonData.push(this._doubleQuotes, this._colon, this._openingBrace, this._doubleQuotes, 115, 104, 97, 112, 101, 65, 110, 110, 111, 116, 97, 116, 105, 111, 110, this._doubleQuotes, this._colon, this._openingBracket);
                isAnnotationAdded = true;
            }
            for (let k = 0; k < page.annotations.count; k++) {
                const annotation = page.annotations.at(k);
                if (annotation) {
                    this._exportAnnotation(annotation, i);
                    this._jsonData = _convertStringToBytes(this._convertToJson(this._table), this._jsonData);
                    if (k < page.annotations.count - 1) {
                        this._jsonData.push(this._comma);
                    }
                    this._table.clear();
                }
            }
            if (page && page.annotations.count > 0) {
                this._jsonData.push(this._closingBracket, this._closingBrace);
            }
        }
        this._jsonData.push(this._closingBrace, this._closingBrace);
    }
    _exportAnnotation(annotation, index) {
        let hasAppearance = false;
        const dictionary = annotation._dictionary;
        const type = this._getAnnotationType(annotation._dictionary);
        this._skipBorderStyle = false;
        if (type && type !== '') {
            this._table.set('type', type);
            this._table.set('page', index.toString());
            let lineAnnotation;
            let points;
            switch (type) {
                case 'Line':
                    lineAnnotation = annotation;
                    points = lineAnnotation.linePoints;
                    this._table.set('start', points[0].toString() + ',' + points[1].toString());
                    this._table.set('end', points[2].toString() + ',' + points[3].toString());
                    break;
                case 'Stamp':
                    hasAppearance = true;
                    break;
                case 'Square':
                    hasAppearance = true;
                    break;
            }
            if (dictionary && dictionary.has('BE') && dictionary.has('BS')) {
                const borderEffect = dictionary.get('BE');
                if (borderEffect && borderEffect.has('S')) {
                    this._skipBorderStyle = true;
                }
            }
            this._writeDictionary(dictionary, index, hasAppearance);
        }
    }
    _writeDictionary(dictionary, pageIndex, hasAppearance) {
        let isBorderStyle = false;
        if (dictionary.has('Type')) {
            const type = dictionary.get('Type');
            isBorderStyle = (type && type.name === 'Border' && this._skipBorderStyle);
        }
        dictionary.forEach((key, value) => {
            if (!((!hasAppearance && key === 'AP') || key === 'P' || key === 'Parent')) {
                let entry; // eslint-disable-line
                if (value instanceof _PdfReference) {
                    entry = dictionary.get(key);
                }
                if (entry && entry instanceof _PdfDictionary) {
                    switch (key) {
                        case 'BS':
                        case 'BE':
                            this._writeDictionary(entry, pageIndex, false);
                            break;
                        case 'IRT':
                            if (entry.has('NM')) {
                                this._table.set('inreplyto', this._getValue(entry.get('NM'), true));
                            }
                            break;
                    }
                }
                else if (value instanceof _PdfDictionary) {
                    this._writeDictionary(value, pageIndex, false);
                }
                else if ((!isBorderStyle) || (isBorderStyle && key !== 'S')) {
                    this._writeAttribute(key, value, dictionary);
                }
            }
        });
        if (dictionary.has('Measure')) {
            this._exportMeasureDictionary(dictionary.get('Measure'));
        }
        if ((this.exportAppearance || hasAppearance) && dictionary.has('AP')) {
            const stream = this._getAppearanceString(dictionary.get('AP'));
            if (stream && stream.length > 0) {
                this._table.set('appearance', _encode(stream));
            }
        }
        if (dictionary.has('Sound')) {
            const sound = dictionary.get('Sound');
            if (sound && sound.dictionary) {
                const soundDictionary = sound.dictionary;
                if (soundDictionary.has('B')) {
                    this._table.set('bits', this._getValue(soundDictionary.get('B'), true));
                }
                if (soundDictionary.has('C')) {
                    this._table.set('channels', this._getValue(soundDictionary.get('C'), true));
                }
                if (soundDictionary.has('E')) {
                    this._table.set('encoding', this._getValue(soundDictionary.get('E'), true));
                }
                if (soundDictionary.has('R')) {
                    this._table.set('rate', this._getValue(soundDictionary.get('R'), true));
                }
                if (soundDictionary.has('Length') && soundDictionary.get('Length') > 0) {
                    const data = _byteArrayToHexString(sound.getBytes());
                    if (data && data !== '') {
                        this._table.set('MODE', 'raw');
                        this._table.set('encoding', 'hex');
                        if (soundDictionary.has('Length')) {
                            this._table.set('length', this._getValue(soundDictionary.get('Length'), true));
                        }
                        if (soundDictionary.has('Filter')) {
                            this._table.set('filter', this._getValue(soundDictionary.get('Filter'), true));
                        }
                        this._table.set('data', data);
                    }
                }
            }
        }
        else if (dictionary.has('FS')) {
            const fsDictionary = dictionary.get('FS');
            if (fsDictionary) {
                if (fsDictionary.has('F')) {
                    this._table.set('file', this._getValue(fsDictionary.get('F'), true));
                }
                if (fsDictionary.has('EF')) {
                    const efDictionary = fsDictionary.get('EF');
                    if (efDictionary && efDictionary.has('F')) {
                        const fStream = efDictionary.get('F');
                        if (fStream && fStream.dictionary) {
                            const fDictionary = fStream.dictionary;
                            if (fDictionary.has('Params')) {
                                const paramsDictionary = fDictionary.get('Params');
                                if (paramsDictionary) {
                                    if (paramsDictionary.has('CreationDate')) {
                                        const value = this._getValue(paramsDictionary.get('CreationDate'), true);
                                        this._table.set('creation', value);
                                    }
                                    if (paramsDictionary.has('ModificationDate')) {
                                        const value = this._getValue(paramsDictionary.get('ModificationDate'), true);
                                        this._table.set('modification', value);
                                    }
                                    if (paramsDictionary.has('Size')) {
                                        this._table.set('size', this._getValue(paramsDictionary.get('Size'), true));
                                    }
                                    if (paramsDictionary.has('CheckSum')) {
                                        const value = this._getValue(paramsDictionary.get('CheckSum'), true);
                                        const checksum = _stringToBytes(value);
                                        const hexString = _byteArrayToHexString(checksum);
                                        this._table.set('checksum', hexString);
                                    }
                                }
                            }
                            const data = _byteArrayToHexString(fStream.getBytes());
                            if (data && data !== '') {
                                this._table.set('MODE', 'raw');
                                this._table.set('encoding', 'hex');
                                if (fDictionary.has('Length')) {
                                    this._table.set('length', this._getValue(fDictionary.get('Length'), true));
                                }
                                if (fDictionary.has('Filter')) {
                                    this._table.set('filter', this._getValue(fDictionary.get('Filter'), true));
                                }
                                this._table.set('data', data);
                            }
                        }
                    }
                }
            }
        }
    }
    _writeColor(primitive, attribute, tag) {
        const color = this._getColor(primitive);
        if (typeof primitive === 'number' && tag) {
            const c = this._getValue(primitive, true);
            if (c && c !== '') {
                this._table.set(tag, c);
            }
        }
        if (color && color !== '') {
            this._table.set(attribute, color);
        }
    }
    _writeAttributeString(attribute, primitive, isLowerCase = false) {
        const value = this._getValue(primitive, true);
        this._table.set(attribute, isLowerCase ? value.toLowerCase() : value);
    }
    _writeAttribute(key, primitive, dictionary) {
        let value;
        switch (key) {
            case 'C':
                this._writeColor(primitive, 'color', 'c');
                break;
            case 'IC':
                this._writeColor(primitive, 'interior-color');
                break;
            case 'DA':
                value = dictionary.get('DA');
                if (value) {
                    this._table.set('defaultappearance', value);
                }
                break;
            case 'M':
                this._writeAttributeString('date', primitive);
                break;
            case 'NM':
                this._table.set('name', primitive);
                break;
            case 'Name':
                this._writeAttributeString('icon', primitive);
                break;
            case 'Subj':
                this._writeAttributeString('subject', primitive);
                break;
            case 'T':
                this._writeAttributeString('title', primitive);
                break;
            case 'Rect':
                value = this._getValue(primitive, true);
                if (value) {
                    const rectArray = value.split(',');
                    const subTable = new Map();
                    subTable.set('x', rectArray[0]);
                    subTable.set('y', rectArray[1]);
                    subTable.set('width', rectArray[2]);
                    subTable.set('height', rectArray[3]);
                    this._table.set(key.toLowerCase(), this._convertToJson(subTable));
                }
                break;
            case 'CreationDate':
                this._writeAttributeString('creationdate', primitive);
                break;
            case 'Rotate':
                this._writeAttributeString('rotation', primitive);
                break;
            case 'W':
                this._writeAttributeString('width', primitive);
                break;
            case 'LE':
                if (primitive && Array.isArray(primitive)) {
                    if (primitive.length === 2) {
                        this._table.set('head', this._getValue(primitive[0], true));
                        this._table.set('tail', this._getValue(primitive[1], true));
                    }
                }
                else if (primitive instanceof _PdfName) {
                    this._writeAttributeString('head', primitive);
                }
                break;
            case 'S':
                switch (this._getValue(primitive, true)) {
                    case 'D':
                        this._table.set('style', 'dash');
                        break;
                    case 'C':
                        this._table.set('style', 'cloudy');
                        break;
                    case 'S':
                        this._table.set('style', 'solid');
                        break;
                    case 'B':
                        this._table.set('style', 'bevelled');
                        break;
                    case 'I':
                        this._table.set('style', 'inset');
                        break;
                    case 'U':
                        this._table.set('style', 'underline');
                        break;
                }
                break;
            case 'D':
                this._writeAttributeString('dashes', primitive);
                break;
            case 'I':
                this._writeAttributeString('intensity', primitive);
                break;
            case 'RD':
                this._writeAttributeString('fringe', primitive);
                break;
            case 'IT':
                this._writeAttributeString('IT', primitive);
                break;
            case 'RT':
                this._writeAttributeString('replyType', primitive, true);
                break;
            case 'LL':
                this._writeAttributeString('leaderLength', primitive);
                break;
            case 'LLE':
                this._writeAttributeString('leaderExtend', primitive);
                break;
            case 'Cap':
                this._writeAttributeString('caption', primitive);
                break;
            case 'CP':
                this._writeAttributeString('caption-style', primitive);
                break;
            case 'CL':
                this._writeAttributeString('callout', primitive);
                break;
            case 'QuadPoints':
                this._writeAttributeString('coords', primitive);
                break;
            case 'CA':
                this._writeAttributeString('opacity', primitive);
                break;
            case 'F':
                if (typeof primitive === 'number') {
                    const flag = _annotationFlagsToString(primitive);
                    this._table.set('flags', flag);
                }
                break;
            case 'Contents':
                value = dictionary.get('Contents');
                if (value && value.length > 0) {
                    this._table.set('contents', this._getValidString(value));
                }
                break;
            case 'InkList':
                this._writeInkList(dictionary);
                break;
            case 'Vertices':
                this._writeVertices(dictionary);
                break;
            case 'DS':
                value = dictionary.get('DS');
                if (value) {
                    const styleTable = new Map();
                    const textStyle = value.split(';');
                    for (let i = 0; i < textStyle.length; i++) {
                        const text = textStyle[Number.parseInt(i.toString(), 10)].split(':');
                        if (text && text.length > 0 && text[0] && text[0].length > 1 && text[0].startsWith(' ')) {
                            text[0] = text[0].substring(1);
                        }
                        styleTable.set(text[0], text[1]);
                    }
                    this._table.set('defaultStyle', this._convertToJson(styleTable));
                }
                break;
            case 'AllowedInteractions':
                if (primitive.indexOf('"') !== -1) {
                    primitive = primitive.replace(/"/g, '\\"');
                }
                this._table.set(key, primitive);
                break;
            case 'Type':
            case 'Subtype':
            case 'P':
            case 'Parent':
            case 'L':
            case 'RC':
            case 'FS':
            case 'MeasurementTypes':
            case 'GroupNesting':
            case 'ITEx':
            case 'TextMarkupContent':
                break;
            case 'Border':
            case 'A':
            case 'R':
            case 'X':
            case 'ca':
                this._writeAttributeString(key.toLowerCase(), primitive);
                break;
            case 'CustomData':
                if (primitive && primitive.length > 2 && primitive.startsWith('{') && primitive.endsWith('}')) {
                    this._table.set(key, primitive);
                }
                else {
                    this._writeAttributeString(key, primitive);
                }
                break;
            default:
                this._writeAttributeString(key, primitive);
                break;
        }
    }
    _writeVertices(dictionary) {
        const vertices = dictionary.getArray('Vertices');
        if (vertices && vertices.length > 0) {
            const elementCount = vertices.length;
            if (elementCount % 2 === 0) {
                let vertice = '';
                for (let i = 0; i < elementCount - 1; i++) {
                    vertice += this._getValue(vertices[Number.parseInt(i.toString(), 10)], true) + (i % 2 !== 0 ? ';' : ',');
                }
                vertice += this._getValue(vertices[elementCount - 1], true);
                if (vertice && vertice !== '') {
                    this._table.set('vertices', vertice);
                }
            }
        }
    }
    _writeInkList(dictionary) {
        const inkList = dictionary.getArray('InkList');
        if (inkList && inkList.length > 0) {
            const points = new Map();
            let json = '[';
            for (let j = 0; j < inkList.length; j++) {
                json += '[' + this._getValue(inkList[Number.parseInt(j.toString(), 10)], true) + ']';
                if (j < inkList.length - 1) {
                    json += ',';
                }
            }
            json += ']';
            points.set('gesture', json);
            this._table.set('inklist', this._convertToJson(points));
        }
    }
    _exportMeasureDictionary(dictionary) {
        if (dictionary) {
            if (dictionary.has('Type')) {
                this._table.set('type1', 'Measure');
            }
            if (dictionary.has('R')) {
                this._table.set('ratevalue', this._getValue(dictionary.get('R'), true));
            }
            if (dictionary.has('SubType')) {
                this._table.set('SubType', this._getValue(dictionary.get('SubType'), true));
            }
            if (dictionary.has('TargetUnitConversion')) {
                this._table.set('TargetUnitConversion', this._getValue(dictionary.get('TargetUnitConversion'), true));
            }
            if (dictionary.has('A')) {
                const array = dictionary.getArray('A');
                this._exportMeasureFormatDetails('area', array[0]);
            }
            if (dictionary.has('D')) {
                const array = dictionary.getArray('D');
                this._exportMeasureFormatDetails('distance', array[0]);
            }
            if (dictionary.has('X')) {
                const array = dictionary.getArray('X');
                this._exportMeasureFormatDetails('xformat', array[0]);
            }
            if (dictionary.has('T')) {
                const array = dictionary.getArray('T');
                this._exportMeasureFormatDetails('tformat', array[0]);
            }
            if (dictionary.has('V')) {
                const array = dictionary.getArray('V');
                this._exportMeasureFormatDetails('vformat', array[0]);
            }
        }
    }
    _exportMeasureFormatDetails(key, measurementDetails) {
        const details = new Map();
        if (measurementDetails.has('C')) {
            details.set('c', this._getValue(measurementDetails.get('C'), true));
        }
        if (measurementDetails.has('F')) {
            details.set('f', this._getValue(measurementDetails.get('F'), true));
        }
        if (measurementDetails.has('D')) {
            details.set('d', this._getValue(measurementDetails.get('D'), true));
        }
        if (measurementDetails.has('RD')) {
            details.set('rd', this._getValue(measurementDetails.get('RD'), true));
        }
        if (measurementDetails.has('U')) {
            details.set('u', this._getValue(measurementDetails.get('U'), true));
        }
        if (measurementDetails.has('RT')) {
            details.set('rt', this._getValue(measurementDetails.get('RT'), true));
        }
        if (measurementDetails.has('SS')) {
            details.set('ss', this._getValue(measurementDetails.get('SS'), true));
        }
        if (measurementDetails.has('FD')) {
            details.set('fd', this._getValue(measurementDetails.get('FD'), true));
        }
        this._table.set(key, this._convertToJson(details));
    }
    _getAppearanceString(appearance) {
        const parentTable = new Map();
        const appearanceTable = new Map();
        this._writeAppearanceDictionary(appearanceTable, appearance);
        parentTable.set('ap', this._convertToJson(appearanceTable));
        return _stringToBytes(this._convertToJson(parentTable));
    }
    _writeAppearanceDictionary(table, dictionary) {
        if (dictionary && dictionary.size > 0) {
            dictionary.forEach((key, value) => {
                this._writeObject(table, ((value instanceof _PdfReference) ? dictionary.get(key) : value), dictionary, key);
            });
        }
    }
    _writeObject(table, value, dictionary, key, array) {
        if (value instanceof _PdfName) {
            this._writeTable('name', value.name, table, key, array);
        }
        else if (Array.isArray(value)) {
            const array = [];
            this._writeArray(array, value, dictionary);
            this._writeTable('array', this._convertToJsonArray(array), table, key, array);
        }
        else if (typeof value === 'string') {
            this._writeTable('string', value, table, key, array);
        }
        else if (typeof value === 'number') {
            this._writeTable(Number.isInteger(value) ? 'int' : 'fixed', value.toString(), table, key, array);
        }
        else if (typeof value === 'boolean') {
            this._writeTable('boolean', value ? 'true' : 'false', table, key, array);
        }
        else if (value instanceof _PdfDictionary) {
            const subTable = new Map();
            this._writeAppearanceDictionary(subTable, value);
            this._writeTable('dict', this._convertToJson(subTable), table, key, array);
        }
        else if (value instanceof _PdfBaseStream && value.dictionary) {
            const dataTable = new Map(); // eslint-disable-line
            const streamTable = new Map(); // eslint-disable-line
            const streamDictionary = value.dictionary;
            const data = value.getString(true);
            if (!streamDictionary.has('Length') && data && data !== '') {
                streamDictionary.update('Length', value.length);
            }
            this._writeAppearanceDictionary(streamTable, streamDictionary);
            let type;
            if (streamDictionary.has('Subtype')) {
                type = this._getValue(streamDictionary.get('Subtype'));
            }
            if ((!streamDictionary.has('Type') && !streamDictionary.has('Subtype')) ||
                (streamDictionary.has('Subtype') &&
                    (type === 'Image' || type === 'Form' || type === 'CIDFontType0C' || type === 'OpenType'))) {
                dataTable.set('mode', 'raw');
                dataTable.set('encoding', 'hex');
            }
            else {
                dataTable.set('mode', 'filtered');
                dataTable.set('encoding', 'ascii');
            }
            if (data && data !== '') {
                dataTable.set('bytes', data);
            }
            streamTable.set('data', this._convertToJson(dataTable));
            this._writeTable('stream', this._convertToJson(streamTable), table, key, array);
        }
        else if (value instanceof _PdfReference && this._crossReference) {
            this._writeObject(table, this._crossReference._fetch(value), dictionary, key);
        }
        else if (value === null || typeof value === 'undefined') {
            this._writeTable('null', 'null', table, key, array);
        }
    }
    _writeTable(tableKey, value, table, key, array) {
        const map = new Map();
        map.set(tableKey, value);
        if (key) {
            table.set(key, this._convertToJson(map));
        }
        else if (array) {
            array.push(map);
        }
    }
    _writeArray(array, value, dictionary) {
        for (let i = 0; i < value.length; i++) {
            this._writeObject(null, value[Number.parseInt(i.toString(), 10)], dictionary, null, array);
        }
    }
    _convertToJson(table) {
        let j = 0;
        let json = '{';
        table.forEach((value, key) => {
            if (value.startsWith('{') || value.startsWith('[')) {
                if (key === 'AllowedInteractions') {
                    json += '"' + key + '":"' + value + '"';
                }
                else {
                    json += '"' + key + '":' + value;
                }
            }
            else {
                if (value.startsWith(' ') && value.length > 1 && (value[1] === '[' || value[1] === '{')) {
                    value = value.substring(1);
                }
                json += '"' + key + '":"' + value + '"';
            }
            if (j < table.size - 1) {
                json += ',';
            }
            j++;
        });
        return json + '}';
    }
    _convertToJsonArray(array) {
        let json = '[';
        for (let i = 0; i < array.length; i++) {
            json += this._convertToJson(array[Number.parseInt(i.toString(), 10)]);
            if (i < array.length - 1) {
                json += ',';
            }
        }
        return json + ']';
    }
    // #import
    _parseJson(document, data) {
        this._document = document;
        this._crossReference = document._crossReference;
        let stringData = _bytesToString(data);
        if (stringData.startsWith('{') && !stringData.endsWith('}')) {
            while (stringData.length > 0 && !stringData.endsWith('}')) {
                stringData = stringData.substring(0, stringData.length - 1);
            }
        }
        return JSON.parse(stringData);
    }
    _importFormData(document, data) {
        const json = this._parseJson(document, data); // eslint-disable-line
        if (json) {
            const keys = Object.keys(json);
            if (keys && keys.length > 0) {
                for (let i = 0; i < keys.length; i++) {
                    const key = keys[Number.parseInt(i.toString(), 10)];
                    const value = json[key]; // eslint-disable-line
                    if (Array.isArray(value)) {
                        if (this._fields.has('key')) {
                            value.forEach((entry) => {
                                this._fields.get(key).push(entry);
                            });
                        }
                        else {
                            this._fields.set(key, value);
                        }
                    }
                    else {
                        if (this._fields.has('key')) {
                            this._fields.get(key).push(value);
                        }
                        else {
                            this._fields.set(key, [value]);
                        }
                    }
                }
                this._importField();
            }
        }
    }
    _importAnnotations(document, data) {
        const json = this._parseJson(document, data); // eslint-disable-line
        if (json) {
            const keys = Object.keys(json);
            if (keys.indexOf('pdfAnnotation') !== -1) {
                const pageAnnotations = json.pdfAnnotation; // eslint-disable-line
                const pageCount = document.pageCount;
                const pageKeys = Object.keys(pageAnnotations);
                if (pageKeys && pageKeys.length > 0) {
                    pageKeys.forEach((key) => {
                        const pageIndex = Number.parseInt(key, 10);
                        if (typeof pageIndex !== 'undefined' && pageIndex < pageCount) {
                            const page = document.getPage(pageIndex);
                            const pageAnnotation = pageAnnotations[key]; // eslint-disable-line
                            if (pageAnnotation) {
                                const pageAnnotationKeys = Object.keys(pageAnnotation);
                                if (pageAnnotationKeys && pageAnnotationKeys.length > 0 && pageAnnotationKeys.indexOf('shapeAnnotation') !== -1) {
                                    const annotations = pageAnnotation['shapeAnnotation']; // eslint-disable-line
                                    if (annotations && annotations.length > 0) {
                                        annotations.forEach((annotation) => {
                                            const annotationKeys = Object.keys(annotation);
                                            if (annotationKeys && annotationKeys.length > 0 && annotationKeys.indexOf('type') !== -1) {
                                                const dictionary = new _PdfDictionary(this._crossReference);
                                                dictionary.update('Type', _PdfName.get('Annot'));
                                                let isValidType = true;
                                                switch (annotation['type'].toLowerCase()) {
                                                    case 'line':
                                                        dictionary.update('Subtype', _PdfName.get('Line'));
                                                        break;
                                                    case 'circle':
                                                        dictionary.update('Subtype', _PdfName.get('Circle'));
                                                        break;
                                                    case 'square':
                                                        dictionary.update('Subtype', _PdfName.get('Square'));
                                                        break;
                                                    case 'polyline':
                                                        dictionary.update('Subtype', _PdfName.get('PolyLine'));
                                                        break;
                                                    case 'polygon':
                                                        dictionary.update('Subtype', _PdfName.get('Polygon'));
                                                        break;
                                                    case 'ink':
                                                        dictionary.update('Subtype', _PdfName.get('Ink'));
                                                        break;
                                                    case 'popup':
                                                        dictionary.update('Subtype', _PdfName.get('Popup'));
                                                        break;
                                                    case 'text':
                                                        dictionary.update('Subtype', _PdfName.get('Text'));
                                                        break;
                                                    case 'freetext':
                                                        dictionary.update('Subtype', _PdfName.get('FreeText'));
                                                        break;
                                                    case 'stamp':
                                                        dictionary.update('Subtype', _PdfName.get('Stamp'));
                                                        break;
                                                    case 'highlight':
                                                        dictionary.update('Subtype', _PdfName.get('Highlight'));
                                                        break;
                                                    case 'squiggly':
                                                        dictionary.update('Subtype', _PdfName.get('Squiggly'));
                                                        break;
                                                    case 'underline':
                                                        dictionary.update('Subtype', _PdfName.get('Underline'));
                                                        break;
                                                    case 'strikeout':
                                                        dictionary.update('Subtype', _PdfName.get('StrikeOut'));
                                                        break;
                                                    case 'fileattachment':
                                                        dictionary.update('Subtype', _PdfName.get('FileAttachment'));
                                                        break;
                                                    case 'sound':
                                                        dictionary.update('Subtype', _PdfName.get('Sound'));
                                                        break;
                                                    case 'redact':
                                                        dictionary.update('Subtype', _PdfName.get('Redact'));
                                                        break;
                                                    case 'caret':
                                                        dictionary.update('Subtype', _PdfName.get('Caret'));
                                                        break;
                                                    default:
                                                        isValidType = false;
                                                        break;
                                                }
                                                if (isValidType) {
                                                    this._addAnnotationData(dictionary, annotation, annotationKeys);
                                                    const pageDictionary = page._pageDictionary;
                                                    if (pageDictionary) {
                                                        const annotations = page.annotations;
                                                        const annotation = annotations._parseAnnotation(dictionary);
                                                        if (annotation) {
                                                            annotation._isImported = true;
                                                            const reference = this._crossReference._getNextReference();
                                                            this._crossReference._cacheMap.set(reference, dictionary);
                                                            if (dictionary.has('NM') || dictionary.has('IRT')) {
                                                                this._addReferenceToGroup(reference, dictionary);
                                                            }
                                                            annotation._ref = reference;
                                                            const index = annotations._annotations.length;
                                                            annotations._annotations.push(reference);
                                                            pageDictionary.set('Annots', annotations._annotations);
                                                            pageDictionary._updated = true;
                                                            annotations._parsedAnnotations.set(index, annotation);
                                                            this._handlePopup(annotations, reference, dictionary, pageDictionary);
                                                        }
                                                    }
                                                }
                                            }
                                        });
                                    }
                                }
                            }
                        }
                    });
                }
                if (this._groupHolders.length > 0) {
                    for (let i = 0; i < this._groupHolders.length; i++) {
                        const dictionary = this._groupHolders[Number.parseInt(i.toString(), 10)];
                        const inReplyTo = dictionary.get('IRT');
                        if (inReplyTo && inReplyTo !== '') {
                            if (this._groupReferences.has(inReplyTo)) {
                                dictionary.update('IRT', this._groupReferences.get(inReplyTo));
                            }
                            else {
                                delete dictionary._map.IRT;
                            }
                        }
                    }
                }
                this._groupHolders = [];
                this._groupReferences = new Map();
            }
        }
    }
    _addAnnotationData(dictionary, annotation, annotationKeys) {
        const borderEffectDictionary = new _PdfDictionary(this._crossReference);
        const borderStyleDictionary = new _PdfDictionary(this._crossReference);
        const dataStream = new Map();
        let linePoints = [];
        let beginLineStyle;
        let endLineStyle;
        let values = '';
        let rect;
        let outColor;
        annotationKeys.forEach((key) => {
            let value = annotation[key]; // eslint-disable-line
            switch (key.toLowerCase()) {
                case 'start':
                case 'end':
                    this._addLinePoints(value, linePoints);
                    if (linePoints.length === 4) {
                        dictionary.update('L', linePoints);
                        linePoints = [];
                    }
                    break;
                case 'itex':
                    break;
                case 'state':
                    this._addString(dictionary, 'State', value);
                    break;
                case 'statemodel':
                    this._addString(dictionary, 'StateModel', value);
                    break;
                case 'replytype':
                    if (value.toLowerCase() === 'group') {
                        dictionary.update('RT', _PdfName.get('Group'));
                    }
                    break;
                case 'inreplyto':
                    this._addString(dictionary, 'IRT', value);
                    break;
                case 'dashes':
                case 'width':
                case 'intensity':
                case 'style':
                    this._addBorderStyle(key, value, borderEffectDictionary, borderStyleDictionary);
                    break;
                case 'rect':
                    rect = value;
                    if (rect) {
                        const points = [];
                        points.push(Number.parseFloat(rect.x));
                        points.push(Number.parseFloat(rect.y));
                        points.push(Number.parseFloat(rect.width));
                        points.push(Number.parseFloat(rect.height));
                        if (points && points.length === 4) {
                            dictionary.update('Rect', points);
                        }
                    }
                    break;
                case 'color':
                    value = _convertToColor(value);
                    if (value && value.length === 3) {
                        dictionary.update('C', [value[0] / 255, value[1] / 255, value[2] / 255]);
                    }
                    break;
                case 'oc':
                    if (value && dictionary.get('Subtype').name === 'Redact') {
                        outColor = value.split(',');
                        const color = [];
                        outColor.forEach((entry) => {
                            color.push(Number.parseFloat(entry));
                        });
                        if (color && color.length > 0) {
                            dictionary.update('OC', color);
                        }
                    }
                    break;
                case 'interior-color':
                    value = _convertToColor(value);
                    if (value && value.length === 3) {
                        dictionary.update('IC', [value[0] / 255, value[1] / 255, value[2] / 255]);
                    }
                    break;
                case 'date':
                    this._addString(dictionary, 'M', value);
                    break;
                case 'creationdate':
                    this._addString(dictionary, 'CreationDate', value);
                    break;
                case 'name':
                    this._addString(dictionary, 'NM', value);
                    break;
                case 'icon':
                    if (value) {
                        dictionary.update('Name', _PdfName.get(value));
                    }
                    break;
                case 'subject':
                    this._addString(dictionary, 'Subj', value);
                    break;
                case 'title':
                    this._addString(dictionary, 'T', value);
                    break;
                case 'rotation':
                    dictionary.update('Rotate', Number.parseFloat(value));
                    break;
                case 'fringe':
                    this._addFloatPoints(dictionary, 'RD', this._parseFloatPoints(value));
                    break;
                case 'it':
                    if (value) {
                        dictionary.update('IT', _PdfName.get(value));
                    }
                    break;
                case 'leaderlength':
                    dictionary.update('LL', Number.parseFloat(value));
                    break;
                case 'leaderextend':
                    dictionary.update('LLE', Number.parseFloat(value));
                    break;
                case 'caption':
                    this._addBoolean(dictionary, 'Cap', value.toLowerCase());
                    break;
                case 'caption-style':
                    if (value) {
                        dictionary.update('CP', _PdfName.get(value));
                    }
                    break;
                case 'callout':
                    this._addFloatPoints(dictionary, 'CL', this._parseFloatPoints(value));
                    break;
                case 'coords':
                    this._addFloatPoints(dictionary, 'QuadPoints', this._parseFloatPoints(value));
                    break;
                case 'border':
                    this._addFloatPoints(dictionary, 'Border', this._parseFloatPoints(value));
                    break;
                case 'opacity':
                    dictionary.update('CA', Number.parseFloat(value));
                    break;
                case 'defaultstyle':
                    if (value) {
                        const styleKeys = Object.keys(value);
                        if (styleKeys && styleKeys.length > 0) {
                            let style = '';
                            let count = 0;
                            styleKeys.forEach((styleKey) => {
                                const styleValue = value[styleKey]; // eslint-disable-line
                                style += styleKey + ':' + styleValue;
                                if (count < styleKeys.length - 1) {
                                    style += ';';
                                }
                                count++;
                            });
                            this._addString(dictionary, 'DS', style);
                        }
                    }
                    break;
                case 'defaultappearance':
                    this._addString(dictionary, 'DA', value);
                    break;
                case 'flags':
                    if (value && typeof value === 'string') {
                        let annotFlag = PdfAnnotationFlag.default;
                        const flags = value.split(',');
                        for (let i = 0; i < flags.length; i++) {
                            const flagType = _stringToAnnotationFlags(flags[Number.parseInt(i.toString(), 10)]);
                            if (i === 0) {
                                annotFlag = flagType;
                            }
                            else {
                                annotFlag |= flagType;
                            }
                        }
                        dictionary.update('F', annotFlag);
                    }
                    break;
                case 'open':
                    this._addBoolean(dictionary, 'Open', value.toLowerCase());
                    break;
                case 'repeat':
                    this._addBoolean(dictionary, 'Repeat', value.toLowerCase());
                    break;
                case 'overlaytext':
                    this._addString(dictionary, 'OverlayText', value);
                    break;
                case 'contents':
                    if (typeof value === 'string') {
                        if (value.indexOf('\\r') !== -1) {
                            value = value.replace('\\r', '\r');
                        }
                        if (value) {
                            this._addString(dictionary, 'Contents', value);
                        }
                    }
                    break;
                case 'q':
                    dictionary.update('Q', Number.parseInt(value, 10));
                    break;
                case 'inklist':
                    if (value) {
                        const gestureKeys = Object.keys(value);
                        if (gestureKeys && gestureKeys.length > 0 && gestureKeys.indexOf('gesture') !== -1) {
                            const gesture = value.gesture;
                            if (gesture && gesture.length > 0) {
                                dictionary.update('InkList', gesture);
                            }
                        }
                    }
                    break;
                case 'head':
                    beginLineStyle = value;
                    break;
                case 'tail':
                    endLineStyle = value;
                    break;
                case 'creation':
                case 'modification':
                case 'file':
                case 'bits':
                case 'channels':
                case 'encoding':
                case 'rate':
                case 'length':
                case 'filter':
                case 'mode':
                case 'size':
                    dataStream.set(key, value);
                    break;
                case 'data':
                    values = value;
                    break;
                case 'vertices':
                    if (value && typeof value === 'string') {
                        const split = value.split(/[,;]/);
                        if (split && split.length > 0) {
                            const vertices = [];
                            for (let i = 0; i < split.length; i++) {
                                vertices.push(Number.parseFloat(split[Number.parseInt(i.toString(), 10)]));
                            }
                            if (vertices.length > 0 && vertices.length % 2 === 0) {
                                dictionary.update('Vertices', vertices);
                            }
                        }
                    }
                    break;
                case 'customdata':
                    this._addString(dictionary, 'CustomData', typeof value === 'string' ? value : JSON.stringify(value));
                    break;
                case 'appearance':
                    this._addAppearanceData(dictionary, value);
                    break;
                case 'allowedinteractions':
                    this._addString(dictionary, 'AllowedInteractions', value);
                    break;
                default:
                    if (this._document._allowImportCustomData && key !== 'type' && key !== 'page') {
                        this._addString(dictionary, key, value);
                    }
                    break;
            }
        });
        this._addMeasureDictionary(dictionary, annotation, annotationKeys);
        if (beginLineStyle) {
            if (endLineStyle) {
                dictionary.update('LE', [_PdfName.get(beginLineStyle), _PdfName.get(endLineStyle)]);
            }
            else {
                dictionary.update('LE', beginLineStyle);
            }
        }
        else if (endLineStyle) {
            dictionary.update('LE', endLineStyle);
        }
        if (borderStyleDictionary.size > 0) {
            borderStyleDictionary.update('Type', _PdfName.get('Border'));
            const reference = this._crossReference._getNextReference();
            borderStyleDictionary.objId = reference.objectNumber + ' ' + reference.generationNumber;
            this._crossReference._cacheMap.set(reference, borderStyleDictionary);
            dictionary.update('BS', reference);
        }
        if (borderEffectDictionary.size > 0) {
            const reference = this._crossReference._getNextReference();
            borderStyleDictionary.objId = reference.objectNumber + ' ' + reference.generationNumber;
            this._crossReference._cacheMap.set(reference, borderEffectDictionary);
            dictionary.update('BE', reference);
        }
        this._addStreamData(dictionary, dataStream, values);
    }
    _addLinePoints(value, linePoints) {
        if (value && value.indexOf(',') !== -1) {
            const points = value.split(',');
            points.forEach((point) => {
                linePoints.push(Number.parseFloat(point));
            });
        }
    }
    _addString(dictionary, key, value) {
        if (value) {
            dictionary.update(key, value);
        }
    }
    _addBoolean(dictionary, key, value) {
        if (value) {
            dictionary.update(key, value === 'yes' || value === 'true');
        }
    }
    _addBorderStyle(key, value, borderEffectDictionary, borderStyleDictionary) {
        let style = '';
        let isBasicStyle = true;
        switch (value) {
            case 'dash':
                style = 'D';
                break;
            case 'solid':
                style = 'S';
                break;
            case 'bevelled':
                style = 'B';
                break;
            case 'inset':
                style = 'I';
                break;
            case 'underline':
                style = 'U';
                break;
            case 'cloudy':
                style = 'C';
                isBasicStyle = false;
                break;
        }
        switch (key.toLowerCase()) {
            case 'width':
                borderStyleDictionary.update('W', Number.parseFloat(value));
                break;
            case 'intensity':
                borderEffectDictionary.update('I', Number.parseFloat(value));
                break;
            case 'dashes':
                if (value && value.indexOf(',') !== -1) {
                    borderStyleDictionary.update('D', this._parseFloatPoints(value));
                }
                break;
        }
        if (style) {
            if (isBasicStyle) {
                borderStyleDictionary.update('S', _PdfName.get(style));
            }
            else {
                borderEffectDictionary.update('S', _PdfName.get(style));
            }
        }
    }
    _parseFloatPoints(value) {
        const dashes = value.split(',');
        const dashArray = [];
        dashes.forEach((dash) => {
            dashArray.push(Number.parseFloat(dash));
        });
        return dashArray;
    }
    _addFloatPoints(dictionary, key, value) {
        if (value && value.length > 0) {
            dictionary.update(key, value);
        }
    }
    _addMeasureDictionary(dictionary, annotation, annotationKeys) {
        const measureDictionary = new _PdfDictionary(this._crossReference);
        const aArray = [];
        const dArray = [];
        const xArray = [];
        const tArray = [];
        const vArray = [];
        measureDictionary.set('A', aArray);
        measureDictionary.set('D', dArray);
        measureDictionary.set('X', xArray);
        measureDictionary.set('T', tArray);
        measureDictionary.set('V', vArray);
        if (annotationKeys.indexOf('ratevalue') !== -1) {
            this._addString(measureDictionary, 'R', annotation['ratevalue']);
        }
        if (annotationKeys.indexOf('subtype') !== -1) {
            this._addString(measureDictionary, 'Subtype', annotation['subtype']);
        }
        if (annotationKeys.indexOf('targetunitconversion') !== -1) {
            this._addString(measureDictionary, 'TargetUnitConversion', annotation['targetunitconversion']);
        }
        if (annotationKeys.indexOf('area') !== -1) {
            aArray.push(this._readDictionaryElements(annotation['area']));
        }
        if (annotationKeys.indexOf('distance') !== -1) {
            dArray.push(this._readDictionaryElements(annotation['distance']));
        }
        if (annotationKeys.indexOf('xformat') !== -1) {
            xArray.push(this._readDictionaryElements(annotation['xformat']));
        }
        if (annotationKeys.indexOf('tformat') !== -1) {
            tArray.push(this._readDictionaryElements(annotation['tformat']));
        }
        if (annotationKeys.indexOf('vformat') !== -1) {
            vArray.push(this._readDictionaryElements(annotation['vformat']));
        }
        if (annotationKeys.indexOf('type1') !== -1) {
            measureDictionary.set('Type', _PdfName.get('Measure'));
            const reference = this._crossReference._getNextReference();
            measureDictionary.objId = reference.objectNumber + ' ' + reference.generationNumber;
            this._crossReference._cacheMap.set(reference, measureDictionary);
            dictionary.update('Measure', reference);
        }
    }
    _readDictionaryElements(elements) {
        const keys = Object.keys(elements);
        const dictionary = new _PdfDictionary(this._crossReference);
        if (keys && keys.length > 0) {
            keys.forEach((key) => {
                const value = elements[key]; // eslint-disable-line
                if (key && value) {
                    switch (key) {
                        case 'd':
                            dictionary.set('D', Number.parseFloat(value));
                            break;
                        case 'c':
                            dictionary.set('C', Number.parseFloat(value));
                            break;
                        case 'rt':
                            dictionary.set('RT', value);
                            break;
                        case 'rd':
                            dictionary.set('RD', value);
                            break;
                        case 'ss':
                            dictionary.set('SS', value);
                            break;
                        case 'u':
                            dictionary.set('U', value);
                            break;
                        case 'f':
                            dictionary.set('F', _PdfName.get(value));
                            break;
                        case 'fd':
                            dictionary.set('FD', value);
                            break;
                        case 'type':
                            dictionary.set('Type', _PdfName.get(value));
                            break;
                    }
                }
            });
        }
        return dictionary;
    }
    _addStreamData(dictionary, data, values) {
        const subtype = dictionary.get('Subtype').name;
        const bytes = _hexStringToByteArray(values, true);
        if (subtype === 'Sound') {
            const soundStream = new _PdfContentStream(bytes);
            soundStream.dictionary._crossReference = this._crossReference;
            soundStream.dictionary.update('Type', _PdfName.get('Sound'));
            data.forEach((value, key) => {
                if (key && value) {
                    switch (key) {
                        case 'bits':
                        case 'rate':
                        case 'channels':
                            soundStream.dictionary.set(key, Number.parseInt(value, 10));
                            break;
                        case 'encoding':
                            soundStream.dictionary.set('E', _PdfName.get(value));
                            break;
                        case 'filter':
                            soundStream.dictionary.set('Filter', _PdfName.get('FlateDecode'));
                            break;
                    }
                }
            });
            soundStream.reference = this._crossReference._getNextReference();
            soundStream.dictionary.objId = soundStream.reference.objectNumber + ' ' + soundStream.reference.generationNumber;
            this._crossReference._cacheMap.set(soundStream.reference, soundStream);
            dictionary.update('Sound', soundStream.reference);
        }
        else if (subtype === 'FileAttachment') {
            const fileDictionary = new _PdfDictionary(this._crossReference);
            fileDictionary.update('Type', _PdfName.get('Filespec'));
            const fileStream = new _PdfContentStream(bytes);
            fileStream.dictionary._crossReference = this._crossReference;
            const param = new _PdfDictionary(this._crossReference);
            data.forEach((value, key) => {
                if (key && value) {
                    let size;
                    switch (key) {
                        case 'file':
                            this._addString(fileDictionary, 'F', value);
                            this._addString(fileDictionary, 'UF', value);
                            break;
                        case 'size':
                            size = Number.parseInt(value, 10);
                            if (typeof size !== 'undefined') {
                                param.update('Size', size);
                                fileStream.dictionary.update('DL', size);
                            }
                            break;
                        case 'creation':
                            this._addString(param, 'CreationDate', value);
                            break;
                        case 'modification':
                            this._addString(param, 'ModificationDate', value);
                            break;
                    }
                }
            });
            fileStream.dictionary.update('Params', param);
            fileStream.dictionary.update('Filter', _PdfName.get('FlateDecode'));
            fileStream.reference = this._crossReference._getNextReference();
            fileStream.dictionary.objId = fileStream.reference.objectNumber + ' ' + fileStream.reference.generationNumber;
            this._crossReference._cacheMap.set(fileStream.reference, fileStream);
            const embeddedFile = new _PdfDictionary(this._crossReference);
            embeddedFile.update('F', fileStream.reference);
            fileDictionary.update('EF', embeddedFile);
            const reference = this._crossReference._getNextReference();
            fileDictionary.objId = reference.objectNumber + ' ' + reference.generationNumber;
            this._crossReference._cacheMap.set(reference, fileDictionary);
            dictionary.update('FS', reference);
        }
    }
    _addAppearanceData(dictionary, data) {
        if (data) {
            const encoded = _decode(data, false);
            let decoded = _bytesToString(encoded);
            if (decoded.startsWith('{') && !decoded.endsWith('}')) {
                while (decoded.length > 0 && !decoded.endsWith('}')) {
                    decoded = decoded.substring(0, decoded.length - 1);
                }
            }
            const json = JSON.parse(decoded); // eslint-disable-line
            if (json) {
                const keys = Object.keys(json);
                if (keys && keys.length > 0 && keys.indexOf('ap') !== -1) {
                    dictionary.update('AP', this._parseDictionary(json['ap']));
                }
            }
        }
    }
    _parseAppearance(element) {
        let value; // eslint-disable-line
        const keys = Object.keys(element);
        if (keys.indexOf('name') !== -1) {
            value = _PdfName.get(element.name);
        }
        else if (keys.indexOf('int') !== -1) {
            value = Number.parseInt(element.int, 10);
        }
        else if (keys.indexOf('fixed') !== -1) {
            value = Number.parseFloat(element.fixed);
        }
        else if (keys.indexOf('string') !== -1) {
            value = element.string;
        }
        else if (keys.indexOf('boolean') !== -1) {
            value = element.boolean === 'true' ? true : false;
        }
        else if (keys.indexOf('array') !== -1) {
            const array = element.array; // eslint-disable-line
            value = [];
            array.forEach((element) => {
                value.push(this._parseAppearance(element));
            });
        }
        else if (keys.indexOf('dict') !== -1) {
            const dictionary = this._parseDictionary(element.dict);
            value = this._crossReference._getNextReference();
            dictionary.objId = value.objectNumber + ' ' + value.generationNumber;
            this._crossReference._cacheMap.set(value, dictionary);
        }
        else if (keys.indexOf('stream') !== -1) {
            const stream = this._parseStream(element.stream);
            value = this._crossReference._getNextReference();
            stream.reference = value;
            stream.dictionary.objId = value.objectNumber + ' ' + value.generationNumber;
            this._crossReference._cacheMap.set(value, stream);
        }
        else {
            value = null;
        }
        return value;
    }
    _parseDictionary(element) {
        const result = new _PdfDictionary(this._crossReference);
        if (element) {
            const keys = Object.keys(element);
            if (keys && keys.length > 0) {
                keys.forEach((key) => {
                    const value = element[key]; // eslint-disable-line
                    if (key !== 'data') {
                        const primitive = this._parseAppearance(value); // eslint-disable-line
                        result.update(key, primitive);
                    }
                });
            }
        }
        return result;
    }
    _parseStream(element) {
        let result;
        const keys = Object.keys(element);
        if (element && keys.indexOf('data')) {
            const data = element.data; // eslint-disable-line
            let bytes;
            if (data) {
                const dataKeys = Object.keys(data);
                if (dataKeys && dataKeys.indexOf('bytes') !== -1) {
                    const byteString = data.bytes;
                    if (byteString) {
                        bytes = _hexStringToByteArray(byteString, true);
                    }
                }
            }
            if (!bytes) {
                bytes = [];
            }
            const stream = new _PdfContentStream(bytes);
            const dictionary = this._parseDictionary(element);
            let isImage = false;
            if (dictionary && dictionary.has('Subtype')) {
                const type = dictionary.get('Subtype');
                isImage = type && type.name === 'Image';
            }
            if (isImage) {
                stream._isCompress = false;
            }
            else {
                if (dictionary.has('Length')) {
                    delete dictionary._map.Length;
                }
                if (dictionary.has('Filter')) {
                    delete dictionary._map.Filter;
                }
            }
            stream.dictionary = dictionary;
            result = stream;
        }
        return result;
    }
    _getValidString(value) {
        if (value.indexOf('\\') !== -1) {
            value = value.replace(/\\/g, '\\\\');
        }
        if (value.indexOf('"') !== -1) {
            value = value.replace(/"/g, '\\"');
        }
        if (value.indexOf('[') !== -1) {
            value = value.replace(/\[/g, '\\[');
        }
        if (value.indexOf(']') !== -1) {
            value = value.replace(/\[/g, '\\]');
        }
        if (value.indexOf('{') !== -1) {
            value = value.replace(/\[/g, '\\{');
        }
        if (value.indexOf('}') !== -1) {
            value = value.replace(/\}/g, '\\}');
        }
        if (value.indexOf('\n') !== -1) {
            value = value.replace(/\n/g, '\\n');
        }
        if (value.indexOf('\r') !== -1) {
            value = value.replace(/\r/g, '\\r');
        }
        return value;
    }
}

class _FdfDocument extends _ExportHelper {
    constructor(fileName) {
        super();
        this._annotationObjects = new Map(); // eslint-disable-line
        this._specialCharacters = 'âãÏÓ';
        if (fileName !== null && typeof fileName !== 'undefined') {
            this._fileName = fileName;
        }
    }
    _exportAnnotations(document) {
        this._document = document;
        this._crossReference = document._crossReference;
        this._isAnnotationExport = true;
        this._exportAnnotationData(document, document.pageCount);
        return this._save();
    }
    _exportFormFields(document) {
        this._document = document;
        this._crossReference = document._crossReference;
        this._isAnnotationExport = false;
        this._key = _getNewGuidString();
        return this._save();
    }
    _save() {
        let objectID = 0;
        const objectArray = [];
        if (!this._isAnnotationExport) {
            if (this._asPerSpecification) {
                this.fdfString += '%FDF-1.2\n%' + this._specialCharacters + '\r\n1 0 obj\r<</FDF<</F(';
                this.fdfString += this._fileName + ')';
                this.fdfString += '/Fields[';
            }
            else {
                this.fdfString += '%FDF-1.2\n';
            }
            const form = this._document.form;
            if (form !== null && typeof form !== 'undefined') {
                this._exportEmptyFields = form.exportEmptyFields;
                const count = this._document.form.count;
                for (let i = 0; i < count; i++) {
                    const field = this._document.form.fieldAt(i);
                    const value = this._exportFormFieldsData(field);
                    if (field instanceof PdfTextBoxField || field instanceof PdfListBoxField || field instanceof PdfComboBoxField
                        || field instanceof PdfRadioButtonListField || field instanceof PdfCheckBoxField) {
                        objectID++;
                    }
                    if (!this._asPerSpecification) {
                        if (field instanceof PdfTextBoxField || field instanceof PdfListBoxField || field instanceof PdfComboBoxField) {
                            objectArray.push(objectID);
                            this.fdfString += objectID + ' 0 obj<</T <' + this._stringToHexString(field.name) + '> /V ';
                            if (typeof value === 'string' || (Array.isArray(value) && value.length === 1)) {
                                this.fdfString += '<' + this._stringToHexString((Array.isArray(value) ? value[0] : value)) + '>';
                            }
                            else if (Array.isArray(value)) {
                                this.fdfString += '[';
                                for (let j = 0; j < value.length; j++) {
                                    this.fdfString += '<' + this._stringToHexString(value[Number.parseInt(j.toString(), 10)]) + '>';
                                    if (j !== value.length - 1) {
                                        this.fdfString += ' ';
                                    }
                                }
                                this.fdfString += ']';
                            }
                            this.fdfString += ' >>endobj\n';
                        }
                        else if (field instanceof PdfRadioButtonListField || field instanceof PdfCheckBoxField) {
                            objectArray.push(objectID);
                            this.fdfString += objectID + ' 0 obj<</T <' + this._stringToHexString(field.name) + '> /V /';
                            this.fdfString += value + ' >>endobj\n';
                        }
                    }
                    else {
                        if (field instanceof PdfTextBoxField || field instanceof PdfListBoxField || field instanceof PdfComboBoxField) {
                            objectArray.push(objectID);
                            this.fdfString += '<</T(' + field.name + ')/V';
                            if (typeof value === 'string' || (Array.isArray(value) && value.length === 1)) {
                                this.fdfString += '(' + (Array.isArray(value) ? value[0] : value) + ')';
                            }
                            else if (Array.isArray(value)) {
                                this.fdfString += '[';
                                for (let j = 0; j < value.length; j++) {
                                    this.fdfString += '(' + value[Number.parseInt(j.toString(), 10)] + ')';
                                    if (j !== value.length - 1) {
                                        this.fdfString += ' ';
                                    }
                                }
                                this.fdfString += ']';
                            }
                            this.fdfString += '>>';
                        }
                        else if (field instanceof PdfRadioButtonListField || field instanceof PdfCheckBoxField) {
                            objectArray.push(objectID);
                            this.fdfString += '<</T(' + field.name + ')/V/' + value + '>>';
                        }
                    }
                }
            }
            if (this._asPerSpecification) {
                this.fdfString += ']';
                this.fdfString += '/ID[]/UF(' + this._fileName + ')>>/Type/Catalog>>\rendobj\rtrailer\r\n<</Root 1 0 R>>\r\n';
                this.fdfString += '%%EOF\r\n';
            }
            else {
                this.fdfString += (this._table.size + 1) + ' 0 obj<</F <' + this._stringToHexString(this._fileName) + '>  /Fields [';
                for (let i = 0; i < this._table.size; i++) {
                    const field = this._document.form.fieldAt(i);
                    if (field !== null && typeof field !== 'undefined' && field.export) {
                        this.fdfString += objectArray[Number.parseInt(i.toString(), 10)] + ' 0 R ';
                    }
                }
                this.fdfString += ']>>endobj\n';
                this.fdfString += (objectArray.length + 2) + ' 0 obj<</Version /1.4 /FDF ' + (objectArray.length + 1) + ' 0 R>>endobj\n';
                this.fdfString += 'trailer\n<</Root ' + (objectArray.length + 2) + ' 0 R>>';
            }
        }
        const arrayBuffer = new ArrayBuffer(this.fdfString.length * 1);
        const result = new Uint8Array(arrayBuffer);
        result.forEach((val, i) => {
            result[i] = this.fdfString.charCodeAt(i); // eslint-disable-line
        });
        return result;
    }
    _importAnnotations(document, data) {
        this._document = document;
        this._crossReference = document._crossReference;
        this._isAnnotationExport = false;
        this._checkFdf(_bytesToString(data));
        const stream = new _PdfStream(data);
        this._isAnnotationImport = true;
        const parser = new _PdfParser(new _PdfLexicalOperator(stream), null, true, false);
        this._readFdfData(parser);
        if (this._annotationObjects !== null && typeof this._annotationObjects !== 'undefined' && this._annotationObjects.size > 0) {
            this._annotationObjects.clear();
        }
        if (this._table !== null && typeof this._table !== 'undefined' && this._table.size > 0) {
            this._table.clear();
        }
    }
    _importFormData(document, data) {
        this._document = document;
        this._crossReference = document._crossReference;
        this._isAnnotationExport = false;
        this._checkFdf(_bytesToString(data));
        const stream = new _PdfStream(data);
        const parser = new _PdfParser(new _PdfLexicalOperator(stream), null, false, false);
        this._readFdfData(parser);
    }
    _readFdfData(parser) {
        let token = parser.getObject(); // eslint-disable-line
        if (this._isAnnotationImport) {
            let key = '';
            while (token !== null && typeof token !== 'undefined' && token !== 'EOF') {
                if (token instanceof _PdfDictionary) {
                    this._table.set(key, token);
                    key = '';
                }
                else if (token instanceof _PdfStream || token instanceof _PdfFlateStream) {
                    this._table.set(key, token);
                    key = '';
                }
                else if (token !== null && Number.isInteger(token) && token !== 0) {
                    if (parser.first >= 0) {
                        key = token.toString() + ' ' + parser.first.toString();
                    }
                }
                else if (token instanceof _PdfCommand && token.command !== null && typeof token.command !== 'undefined' &&
                    token.command === 'trailer') {
                    key = token.command;
                }
                token = parser.getObject();
            }
            this._annotationObjects = this._parseAnnotationData();
            this._annotationObjects.forEach((value, key) => {
                const dictionary = value;
                dictionary._crossReference = this._crossReference;
                dictionary._updated = true;
                if (dictionary !== null && typeof dictionary !== 'undefined' && dictionary.has('Page')) {
                    const pageNumber = dictionary.get('Page');
                    if (pageNumber !== null && typeof pageNumber !== 'undefined') {
                        const pageIndex = pageNumber;
                        if (pageIndex < this._document.pageCount) {
                            const page = this._document.getPage(pageIndex);
                            const pageDictionary = page._pageDictionary;
                            if (pageDictionary !== null && typeof pageDictionary !== 'undefined') {
                                const annotations = page.annotations;
                                const annotation = annotations._parseAnnotation(dictionary);
                                if (annotation !== null && typeof annotation !== 'undefined') {
                                    annotation._isImported = true;
                                    const reference = this._crossReference._getNextReference();
                                    this._crossReference._cacheMap.set(reference, dictionary);
                                    if (dictionary.has('NM') || dictionary.has('IRT')) {
                                        this._addReferenceToGroup(reference, dictionary);
                                    }
                                    annotation._ref = reference;
                                    const index = annotations._annotations.length;
                                    annotations._annotations.push(reference);
                                    pageDictionary.set('Annots', annotations._annotations);
                                    pageDictionary._updated = true;
                                    annotations._parsedAnnotations.set(index, annotation);
                                    this._handlePopup(annotations, reference, dictionary, pageDictionary);
                                }
                            }
                        }
                    }
                }
            });
        }
        else {
            token = parser.getObject();
            if (!this._asPerSpecification) {
                token = parser.getObject();
                if (token instanceof _PdfCommand && token.command !== null) {
                    token = token.command;
                }
                while (token !== null && typeof token !== 'undefined' && token !== 'EOF') {
                    if (token instanceof _PdfDictionary) {
                        const t = token.getArray('T');
                        let v;
                        if (token._map.V instanceof _PdfName) {
                            v = token.getArray('V').name;
                        }
                        else {
                            v = token.getArray('V');
                        }
                        if (t !== null && t !== undefined && t.length > 0) {
                            this._table.set(t, v);
                        }
                    }
                    token = parser.getObject();
                }
            }
            else {
                while (token !== null && typeof token !== 'undefined' && token !== 'EOF') {
                    if (token instanceof _PdfDictionary && token !== null && token._map.FDF !== null && token._map.FDF !== undefined) {
                        token = token._map.FDF;
                        if (token instanceof _PdfDictionary && token._map.Fields !== null && token._map.Fields !== undefined) {
                            token = token._map.Fields;
                            if (token !== null && token !== undefined) {
                                for (let i = 0; i < token.length; i++) {
                                    const field = token[Number.parseInt(i.toString(), 10)];
                                    if (field instanceof _PdfDictionary && field !== null && field !== undefined) {
                                        const t = field.getArray('T');
                                        let v;
                                        if (field._map.V instanceof _PdfName) {
                                            v = field.getArray('V').name;
                                        }
                                        else {
                                            v = field.getArray('V');
                                        }
                                        if (t !== null && t !== undefined && t.length > 0) {
                                            this._table.set(t, v);
                                        }
                                    }
                                }
                            }
                        }
                    }
                    token = parser.getObject();
                }
            }
            this._importField();
        }
    }
    _parseAnnotationData() {
        let objects = new Map(); // eslint-disable-line
        let mappedObjects = new Map(); // eslint-disable-line  
        objects = this._table;
        if (objects !== null && typeof objects !== 'undefined' && objects.size > 0 && objects.has('trailer')) {
            const trailer = objects.get('trailer');
            if (trailer instanceof _PdfDictionary && trailer !== null && typeof trailer !== 'undefined' && trailer.has('Root')) {
                const holder = trailer.getRaw('Root');
                if (holder !== null && typeof holder !== 'undefined') {
                    const rootKey = holder.objectNumber.toString() + ' ' + holder.generationNumber.toString();
                    if (objects.has(rootKey)) {
                        const root = objects.get(rootKey);
                        if (root !== null && typeof root !== 'undefined' && root.has('FDF')) {
                            const fdf = root.get('FDF');
                            if (fdf !== null && typeof fdf !== 'undefined' && fdf.has('Annots')) {
                                const annots = fdf.get('Annots');
                                if (annots !== null && typeof annots !== 'undefined' && annots.length > 0) {
                                    for (let i = 0; i < annots.length; i++) {
                                        let annot = annots[Number.parseInt(i.toString(), 10)];
                                        const key = annot.objectNumber.toString() + ' ' + annot.generationNumber.toString();
                                        if (objects.has(key)) {
                                            annot = objects.get(key);
                                            mappedObjects.set(key, annot);
                                            objects.delete(key);
                                        }
                                    }
                                }
                            }
                        }
                    }
                    objects.delete(rootKey);
                }
            }
            objects.delete('trailer');
        }
        return mappedObjects;
    }
    _importField() {
        const form = this._document.form;
        const count = form.count;
        if (count) {
            this._table.forEach((value, key) => {
                let textValue;
                if (this._table.size > 0 && this._table.has(key)) {
                    textValue = this._table.get(key);
                }
                const index = form._getFieldIndex(key);
                if (index !== -1 && index < count) {
                    const field = form.fieldAt(index);
                    if (field) {
                        if (textValue && textValue !== '') {
                            field._dictionary.update('RV', textValue);
                        }
                        let param = [];
                        if (Array.isArray(value)) {
                            param = value;
                        }
                        else {
                            param.push(value);
                        }
                        this._importFieldData(field, param);
                    }
                }
            });
        }
    }
    //#region Export Annotations
    _exportAnnotationData(document, pageCount) {
        const genNumber = _StringTokenizer._whiteSpace + '0' + _StringTokenizer._whiteSpace;
        const startDictionary = '<<' + '/';
        this.fdfString += '%FDF-1.2' + '\r\n';
        let index = 2;
        let annot = new Array();
        const appearance = this.exportAppearance;
        for (let i = 0; i < pageCount; i++) {
            const page = document.getPage(i);
            if (page !== null && typeof page !== 'undefined' && page.annotations.count > 0) {
                for (let k = 0; k < page.annotations.count; k++) {
                    const annotation = page.annotations.at(k);
                    if (annotation !== null && typeof annotation !== 'undefined' && !(annotation instanceof PdfFileLinkAnnotation ||
                        annotation instanceof PdfTextWebLinkAnnotation || annotation instanceof PdfDocumentLinkAnnotation ||
                        annotation instanceof PdfUriAnnotation)) {
                        if (annotation instanceof PdfRubberStampAnnotation || annotation instanceof PdfRectangleAnnotation) {
                            const value = this._exportAnnotation(annotation, this.fdfString, index, annot, i, true);
                            index = value.index;
                            annot = value.annot;
                        }
                        else {
                            const value = this._exportAnnotation(annotation, this.fdfString, index, annot, i, appearance);
                            index = value.index;
                            annot = value.annot;
                        }
                    }
                }
            }
        }
        if (index !== 2) {
            const root = '1' + genNumber;
            this.fdfString += root + 'obj' + '\r\n' + startDictionary + 'FDF' + startDictionary + 'Annots' + '[';
            for (let i = 0; i < annot.length - 1; i++) {
                this.fdfString += annot[Number.parseInt(i.toString(), 10)] + genNumber + 'R' + ' ';
            }
            this.fdfString += annot[annot.length - 1] + genNumber + 'R' + ']' + '/' + 'F' + '(' + this._fileName + ')' + '/' + 'UF' + '(';
            this.fdfString += this._fileName + ')>>' + '/' + 'Type' + '/' + 'Catalog' + '>>' + '\r\n' + 'endobj' + '\r\n';
            this.fdfString += 'trailer' + '\r\n' + startDictionary + 'Root' + ' ' + root + 'R' + '>>' + '\r\n' + '%%EOF' + '\r\n';
        }
    }
    _exportAnnotation(annotation, fdfString, index, annot, pageIndex, appearance) {
        this.fdfString = fdfString;
        const helper = new _FdfHelper();
        let dictionary = annotation._dictionary;
        const startObject = _StringTokenizer._whiteSpace + '0' + _StringTokenizer._whiteSpace + 'obj' + '\r\n';
        const endObject = '\r\n' + 'endobj' + '\r\n';
        this._annotationID = index.toString();
        this.fdfString += index + startObject + '<<';
        let list = new Map(); // eslint-disable-line
        let streamReference = new Array();
        annot.push(this._annotationID);
        dictionary.set('Page', pageIndex);
        const annotValue = this._getEntries(list, streamReference, index, dictionary, this.fdfString, appearance);
        index = annotValue.index;
        list = annotValue.list;
        streamReference = annotValue.streamReference;
        delete dictionary._map.Page;
        this.fdfString += '>>' + endObject;
        while (list.size > 0) {
            const keys = Array();
            list.forEach((key, value) => {
                keys.push(value);
            });
            for (let i = 0; i < keys.length; i++) {
                const key = keys[Number.parseInt(i.toString(), 10)];
                if (list.get(key) instanceof _PdfDictionary || list.get(key) instanceof _PdfStream ||
                    list.get(key) instanceof _PdfFlateStream) {
                    if (list.get(key) instanceof _PdfDictionary) {
                        dictionary = list.get(key);
                    }
                    else {
                        dictionary = list.get(key).dictionary;
                    }
                    if (dictionary !== null && typeof dictionary !== 'undefined') {
                        if (dictionary instanceof _PdfDictionary && dictionary.has('Type')) {
                            const type = dictionary.get('Type');
                            if (type !== null && typeof type !== 'undefined' && type.name === 'Annot') {
                                annot.push(key.toString());
                                dictionary.set('Page', pageIndex);
                            }
                        }
                        this.fdfString += key + startObject + '<<';
                        const value = this._getEntries(list, streamReference, index, dictionary, this.fdfString, appearance);
                        list = value.list;
                        streamReference = value.streamReference;
                        index = value.index;
                        if (dictionary instanceof _PdfDictionary && dictionary.has('Page')) {
                            delete dictionary._map.Page;
                        }
                        this.fdfString += '>>';
                        if (streamReference !== null && typeof streamReference !== 'undefined' && streamReference.indexOf(key) !== -1) {
                            this._appendStream(list.get(key), this.fdfString);
                        }
                        this.fdfString += endObject;
                    }
                }
                list.delete(key);
            }
        }
        index++;
        helper.index = index;
        helper.annot = annot;
        return helper;
    }
    _appendStream(value, fdfString) {
        let stream = value; // eslint-disable-line
        this.fdfString = fdfString;
        if (value instanceof _PdfFlateStream || value instanceof _PdfStream) {
            if (value instanceof _PdfFlateStream) {
                stream = value.stream;
            }
            else {
                stream = value;
            }
        }
        if (value instanceof _PdfFlateStream || value instanceof _PdfStream) {
            const byteArray = stream.getBytes();
            const dataArray = new Uint8Array(byteArray);
            const sw = new CompressedStreamWriter();
            sw.write(dataArray, 0, dataArray.length);
            sw.close();
            const compressString = sw.getCompressedString;
            this.fdfString += 'stream' + '\r\n';
            this.fdfString += compressString;
            this.fdfString += '\r\n' + 'endstream';
        }
    }
    _getEntries(list, // eslint-disable-line
    streamReference, index, dictionary, fdfString, hasAppearance) {
        let flag = false;
        const helper = new _FdfHelper();
        this.fdfString = fdfString;
        let listDictionary = list; // eslint-disable-line
        dictionary.forEach((key, value) => {
            if (!((!hasAppearance && key === 'AP'))) {
                if (key !== 'P') {
                    this.fdfString += '/' + key;
                }
                if (key === 'Sound' || key === 'F' || hasAppearance) {
                    flag = true;
                }
                let primitive = value; // eslint-disable-line
                if (typeof primitive === 'string') {
                    this.fdfString += '(' + this._getFormattedString(primitive) + ')';
                }
                else if (primitive instanceof _PdfName) {
                    this.fdfString += '/' + primitive.name;
                }
                else if (primitive instanceof Array) {
                    primitive = primitive; // eslint-disable-line
                    const value = this._appendArray(primitive, this.fdfString, index, flag, listDictionary, streamReference);
                    listDictionary = value.list;
                    streamReference = value.streamReference;
                    index = value.index;
                }
                else if (typeof primitive === 'number') {
                    this.fdfString += ' ' + primitive.toString();
                }
                else if (typeof primitive === 'boolean') {
                    this.fdfString += ' ' + ((primitive) ? 'true' : 'false');
                }
                else if (primitive instanceof _PdfDictionary) {
                    this.fdfString += '<<';
                    primitive = primitive;
                    const value = this._getEntries(listDictionary, streamReference, index, primitive, this.fdfString, hasAppearance);
                    listDictionary = value.list;
                    streamReference = value.streamReference;
                    index = value.index;
                    this.fdfString += '>>';
                }
                else if (primitive instanceof _PdfReference) {
                    const pageNumber = dictionary.get('Page');
                    if (key === 'Parent') {
                        this.fdfString += ' ' + this._annotationID + ' 0 R';
                        this.fdfString += '/Page ' + pageNumber;
                    }
                    else if (key === 'IRT') {
                        if (dictionary.has('NM')) {
                            const name = dictionary.get('NM');
                            if (name !== null) {
                                this.fdfString += '(' + this._getFormattedString(name) + ')';
                            }
                        }
                    }
                    else if (key !== 'P') {
                        const holder = primitive;
                        if (holder !== null && typeof holder !== 'undefined') {
                            index++;
                            this.fdfString += ' ' + index + ' 0 R';
                            if (flag) {
                                streamReference.push(index);
                            }
                            listDictionary.set(index, dictionary.get(key));
                        }
                    }
                }
                flag = false;
            }
        });
        helper.list = listDictionary;
        helper.streamReference = streamReference;
        helper.index = index;
        return helper;
    }
    _appendArray(array, // eslint-disable-line
    fdfString, index, flag, list, // eslint-disable-line
    streamReference) {
        this.fdfString = fdfString;
        this.fdfString += '[';
        const helper = new _FdfHelper();
        let listDictionary = list; // eslint-disable-line
        if (array !== null && array.length > 0) {
            const count = array.length;
            for (let i = 0; i < count; i++) {
                const element = array[Number.parseInt(i.toString(), 10)]; // eslint-disable-line
                if (i !== 0 && (typeof element === 'number' || element instanceof _PdfReference || typeof element === 'boolean')) {
                    this.fdfString += ' ';
                }
                const value = this._appendElement(element, this.fdfString, index, flag, listDictionary, streamReference);
                listDictionary = value.list;
                streamReference = value.streamReference;
                index = value.index;
            }
        }
        this.fdfString += ']';
        helper.list = listDictionary;
        helper.streamReference = streamReference;
        helper.index = index;
        return helper;
    }
    _appendElement(element, // eslint-disable-line
    fdfString, index, flag, list, // eslint-disable-line
    streamReference) {
        this.fdfString = fdfString;
        const helper = new _FdfHelper();
        let listDictionary = list; // eslint-disable-line
        if (typeof element === 'number') {
            this.fdfString += (element).toString();
        }
        else if (element instanceof _PdfName) {
            this.fdfString += (element.name.toString());
        }
        else if (element instanceof Array) {
            element = element; // eslint-disable-line
            const value = this._appendArray(element, this.fdfString, index, flag, listDictionary, streamReference);
            listDictionary = value.list;
            streamReference = value.streamReference;
            index = value.index;
        }
        else if (element instanceof _PdfDictionary) {
            this.fdfString += '<<';
            element = element;
            const value = this._getEntries(listDictionary, streamReference, index, element, this.fdfString, flag);
            listDictionary = value.list;
            streamReference = value.streamReference;
            index = value.index;
            this.fdfString += '>>';
        }
        helper.list = listDictionary;
        helper.streamReference = streamReference;
        helper.index = index;
        return helper;
    }
    _getFormattedString(value) {
        let result = '';
        for (let i = 0; i < value.length; i++) {
            const c = value.charCodeAt(i);
            if (c === 40 || c === 41) {
                result += '\'';
            }
            result += String.fromCharCode(c);
        }
        return result;
    }
    //#endregion
    _checkFdf(element) {
        if (element.includes(this._specialCharacters) || element.includes('Ã¢Ã£Ã\u008fÃ\u0093')) {
            this._asPerSpecification = true;
        }
        if (element.startsWith('%')) {
            const token = element.substring(1, 5);
            if (token !== 'FDF-') { // eslint-disable-line
                throw new Error('Invalid FDF file.');
            }
        }
    }
    _stringToHexString(text) {
        let hexString = '';
        if (text !== null && typeof text !== 'undefined' && text.length > 0) {
            const bytesValue = _stringToBytes(text);
            hexString = _byteArrayToHexString(bytesValue);
        }
        return hexString;
    }
}
class _FdfHelper {
}

/**
 * Represents a base class for all bookmark objects.
 * ```typescript
 * // Load an existing PDF document
 * let document: PdfDocument = new PdfDocument(data, password);
 * // Get bookmarks
 * let bookmarks: PdfBookmarkBase = document.bookmarks;
 * // Destroy the document
 * document.destroy();
 * ```
 */
class PdfBookmarkBase {
    /**
     * Initializes a new instance of the `PdfBookmarkBase` class.
     *
     * @private
     * @param {_PdfDictionary} dictionary Outline dictionary.
     * @param {_PdfCrossReference} crossReference Cross reference.
     *
     */
    constructor(dictionary, crossReference) {
        this._bookMarkList = [];
        this._isExpanded = false;
        this._isLoadedBookmark = false;
        this._dictionary = dictionary;
        this._crossReference = crossReference;
    }
    /**
     * Gets the bookmark count (Read only).
     *
     * @returns {number} Number of bookmarks.
     *
     * ```typescript
     * // Load an existing PDF document
     * let document: PdfDocument = new PdfDocument(data, password);
     * // Get bookmarks
     * let bookmarks: PdfBookmarkBase = document.bookmarks;
     * // Get bookmark count
     * let bookmarkCount: number = bookmarks.count;
     * // Destroy the document
     * document.destroy();
     * ```
     */
    get count() {
        if (this._isLoadedBookmark && this._bookMarkList.length === 0) {
            this._reproduceTree();
        }
        return this._bookMarkList.length;
    }
    /**
     * Gets the `PdfBookmark` at the specified index.
     *
     * @param {number} index Bookmark index.
     * @returns {PdfBookmark} Bookmark at the specified index.
     *
     * ```typescript
     * // Load an existing PDF document
     * let document: PdfDocument = new PdfDocument(data, password);
     * // Get bookmarks
     * let bookmarks: PdfBookmarkBase = document.bookmarks;
     * // Get bookmark at the specified index
     * let bookmark: PdfBookmark = bookmarks.at(0) as PdfBookmark;
     * // Destroy the document
     * document.destroy();
     * ```
     */
    at(index) {
        let bookmark;
        if (index < 0 || index >= this.count) {
            throw Error('Index out of range.');
        }
        if (this._bookMarkList.length > 0 && index < this._bookMarkList.length) {
            bookmark = this._bookMarkList[Number.parseInt(index.toString(), 10)];
        }
        return bookmark;
    }
    /**
     * Gets the boolean flag indicating whether `PdfBookmark` is present or not.
     *
     * @param {PdfBookmark} outline Bookmark.
     * @returns {boolean} whether the bookmark is present or not.
     *
     * ```typescript
     * // Load an existing PDF document
     * let document: PdfDocument = new PdfDocument(data, password);
     * // Get the bookmarks
     * let bookmarks: PdfBookmarkBase = document.bookmarks;
     * // Get the bookmark at the specified index
     * let bookmark: PdfBookmark = bookmarks.at(0) as PdfBookmark;
     * // Gets the boolean flag indicating whether `PdfBookmark` is present or not.
     * let isPresent: boolean = bookmarks.contains(bookmark);
     * // Destroy the document
     * document.destroy();
     * ```
     */
    contains(outline) {
        return this._bookMarkList.indexOf(outline) !== -1;
    }
    _reproduceTree() {
        let bookmark = this._getFirstBookmark(this);
        let isBookmark = (bookmark) ? true : false;
        while (isBookmark && bookmark._dictionary) {
            this._bookMarkList.push(bookmark);
            bookmark = bookmark._next;
            isBookmark = (bookmark) ? true : false;
        }
    }
    _getFirstBookmark(bookmarkBase) {
        const bookmarkBaseDictionary = bookmarkBase._dictionary;
        let bookMark;
        if (bookmarkBaseDictionary && bookmarkBaseDictionary.has('First')) {
            const bookMarkDictionary = bookmarkBaseDictionary.get('First');
            if (bookMarkDictionary) {
                bookMark = new PdfBookmark(bookMarkDictionary, this._crossReference);
            }
        }
        return bookMark;
    }
}
/**
 * Represents a bookmark in a PDF document
 *
 * ```typescript
 * // Load an existing PDF document
 * let document: PdfDocument = new PdfDocument(data, password);
 * // Get the bookmarks
 * let bookmarks: PdfBookmarkBase = document.bookmarks;
 * // Gets the bookmark at the specified index
 * let bookmark: PdfBookmark = bookmarks.at(0) as PdfBookmark;
 * // Destroy the document
 * document.destroy();
 * ```
 */
class PdfBookmark extends PdfBookmarkBase {
    /**
     * Initializes a new instance of the `PdfBookmark` class.
     *
     * @private
     * @param {_PdfDictionary} dictionary Bookmark dictionary.
     * @param {_PdfCrossReference} crossReference Cross reference.
     *
     */
    constructor(dictionary, crossReference) {
        super(dictionary, crossReference);
        if (!this._dictionary.has('Dest') && this._dictionary.has('A')) {
            const actionDictionary = this._dictionary.get('A');
            if (actionDictionary && actionDictionary.has('D')) {
                const destinationArray = actionDictionary.getRaw('D'); // eslint-disable-line
                this._dictionary.update('Dest', destinationArray);
            }
        }
        this._isLoadedBookmark = true;
    }
    /**
     * Gets the destination (Read only).
     *
     * @returns {PdfDestination} Page destination.
     *
     * ```typescript
     * // Load an existing PDF document
     * let document: PdfDocument = new PdfDocument(data, password);
     * // Get the bookmarks
     * let bookmarks: PdfBookmarkBase = document.bookmarks;
     * // Gets the bookmark at the specified index
     * let bookmark: PdfBookmark = bookmarks.at(0) as PdfBookmark;
     * // Gets the destination
     * let destination: PdfDestination = bookmark.destination;
     * // Destroy the document
     * document.destroy();
     * ```
     */
    get destination() {
        let value;
        const namedDestination = this._obtainNamedDestination();
        if (namedDestination === null || typeof namedDestination === 'undefined') {
            value = this._obtainDestination();
        }
        return value;
    }
    /**
     * Gets the named destination (Read only).
     *
     * @returns {PdfNamedDestination} Named destination.
     *
     * ```typescript
     * // Load an existing PDF document
     * let document: PdfDocument = new PdfDocument(data, password);
     * // Get the bookmarks
     * let bookmarks: PdfBookmarkBase = document.bookmarks;
     * // Gets bookmark at the specified index
     * let bookmark: PdfBookmark = bookmarks.at(0) as PdfBookmark;
     * // Gets the named destination
     * let namedDestination: PdfNamedDestination = bookmark.namedDestination;
     * // Destroy the document
     * document.destroy();
     * ```
     */
    get namedDestination() {
        if (this._namedDestination === null || typeof this._namedDestination === 'undefined') {
            this._namedDestination = this._obtainNamedDestination();
        }
        return this._namedDestination;
    }
    /**
     * Gets the bookmark title (Read only).
     *
     * @returns {string} Bookmark title.
     *
     * ```typescript
     * // Load an existing PDF document
     * let document: PdfDocument = new PdfDocument(data, password);
     * // Get the bookmarks
     * let bookmarks: PdfBookmarkBase = document.bookmarks;
     * // Gets bookmark at the specified index
     * let bookmark: PdfBookmark = bookmarks.at(0) as PdfBookmark;
     * // Gets the bookmark title
     * let bookmarkTitle: string = bookmark.title;
     * // Destroy the document
     * document.destroy();
     * ```
     */
    get title() {
        if (this._title === null || typeof this._title === 'undefined') {
            this._title = this._obtainTitle();
        }
        return this._title;
    }
    /**
     * Gets the bookmark color (Read only).
     *
     * @returns {number[]} Bookmark color.
     *
     * ```typescript
     * // Load an existing PDF document
     * let document: PdfDocument = new PdfDocument(data, password);
     * // Get the bookmarks
     * let bookmarks: PdfBookmarkBase = document.bookmarks;
     * // Gets bookmark at the specified index
     * let bookmark: PdfBookmark = bookmarks.at(0) as PdfBookmark;
     * // Gets the bookmark color
     * let color: number[] = bookmark.color;
     * // Destroy the document
     * document.destroy();
     * ```
     */
    get color() {
        if (this._color === null || typeof this._color === 'undefined') {
            if (this._dictionary.has('C')) {
                this._color = _parseColor(this._dictionary.getArray('C'));
            }
        }
        return (this._color) ? this._color : [0, 0, 0];
    }
    /**
     * Gets the textStyle (Read only).
     *
     * @returns {PdfTextStyle} Text style.
     *
     * ```typescript
     * // Load an existing PDF document
     * let document: PdfDocument = new PdfDocument(data, password);
     * // Get the bookmarks
     * let bookmarks: PdfBookmarkBase = document.bookmarks;
     * // Gets bookmark at the specified index
     * let bookmark: PdfBookmark = bookmarks.at(0) as PdfBookmark;
     * // Gets the textStyle
     * let textStyle: PdfTextStyle = bookmark.textStyle;
     * // Destroy the document
     * document.destroy();
     * ```
     */
    get textStyle() {
        if (this._textStyle === null || typeof this._textStyle === 'undefined') {
            this._textStyle = this._obtainTextStyle();
        }
        return this._textStyle;
    }
    /**
     * Gets the boolean flag indicating whether the bookmark is expanded or not (Read only).
     *
     * @returns {boolean} whether the bookmark is expanded or not.
     *
     * ```typescript
     * // Load an existing PDF document
     * let document: PdfDocument = new PdfDocument(data, password);
     * // Get the bookmarks
     * let bookmarks: PdfBookmarkBase = document.bookmarks;
     * // Gets bookmark at the specified index
     * let bookmark: PdfBookmark = bookmarks.at(0) as PdfBookmark;
     * // Gets the boolean flag indicating whether the bookmark is expanded or not
     * let isExpanded: boolean = bookmark.isExpanded;
     * // Destroy the document
     * document.destroy();
     * ```
     */
    get isExpanded() {
        if (this._dictionary.has('Count')) {
            const value = this._dictionary.get('Count');
            if (value >= 0) {
                return true;
            }
        }
        return this._isExpanded;
    }
    get _next() {
        let nextBookmark;
        if (this._dictionary.has('Next')) {
            const dictionary = this._dictionary.get('Next');
            if (dictionary) {
                nextBookmark = new PdfBookmark(dictionary, this._crossReference);
            }
        }
        return nextBookmark;
    }
    _obtainTextStyle() {
        let style = PdfTextStyle.regular;
        if (this._dictionary.has('F')) {
            const flag = this._dictionary.get('F');
            let flagValue = 0;
            if (typeof flag !== 'undefined' && flag !== null) {
                flagValue = flag;
            }
            style |= flagValue;
        }
        return style;
    }
    _obtainTitle() {
        let value = '';
        if (this._dictionary.has('Title')) {
            value = this._dictionary.get('Title');
        }
        return value;
    }
    _obtainNamedDestination() {
        const document = this._crossReference._document;
        let destinationCollection;
        if (document) {
            destinationCollection = document._destinationCollection;
        }
        let destination; // eslint-disable-line
        let namedDestination;
        if (destinationCollection) {
            const dictionary = this._dictionary;
            if (dictionary.has('A')) {
                const action = dictionary.get('A');
                if (action.has('D')) {
                    destination = action.get('D');
                }
            }
            else if (dictionary.has('Dest')) {
                destination = dictionary.get('Dest');
            }
            if (destination) {
                let value;
                if (destination instanceof _PdfName) {
                    value = destination.name;
                }
                else if (typeof destination === 'string') {
                    value = destination;
                }
                if (value) {
                    const namedDestinations = destinationCollection._namedDestinations;
                    for (let i = 0; i < namedDestinations.length; i++) {
                        namedDestination = namedDestinations[Number.parseInt(i.toString(), 10)];
                        if (namedDestination._title === value) {
                            destination = namedDestination;
                            break;
                        }
                    }
                }
            }
        }
        return namedDestination;
    }
    _obtainDestination() {
        const bookMarkDictionary = this._dictionary;
        let page;
        if (bookMarkDictionary && bookMarkDictionary.has('Dest')) {
            const destinationArray = bookMarkDictionary.getArray('Dest'); // eslint-disable-line
            const loadedDocument = this._crossReference._document;
            let mode;
            if (destinationArray && Array.isArray(destinationArray) && destinationArray.length > 0) {
                const value = destinationArray[0]; // eslint-disable-line
                let left;
                let height;
                let bottom;
                let right;
                let zoom;
                if (typeof value === 'number') {
                    const pageNumber = destinationArray[0];
                    if (pageNumber >= 0) {
                        const document = this._crossReference._document;
                        if (document && document.pageCount > pageNumber) {
                            page = document.getPage(pageNumber);
                        }
                        if (destinationArray.length > 1) {
                            mode = destinationArray[1];
                        }
                        if (mode && mode.name === 'XYZ') {
                            if (destinationArray.length > 2) {
                                left = destinationArray[2];
                            }
                            if (destinationArray.length > 3) {
                                height = destinationArray[3];
                            }
                            if (destinationArray.length > 4) {
                                zoom = destinationArray[4];
                            }
                            if (page) {
                                const topValue = (height === null || typeof height === 'undefined') ? 0 : page.size[1] - height;
                                const leftValue = (left === null || typeof left === 'undefined') ? 0 : left;
                                if (page.rotation !== PdfRotationAngle.angle0) {
                                    _checkRotation(page, height, left);
                                }
                                this._destination = new PdfDestination(page, [leftValue, topValue]);
                                this._destination._index = pageNumber;
                                this._destination.zoom = (typeof zoom !== 'undefined' && zoom !== null) ? zoom : 0;
                                if (left === null || height === null || zoom === null || typeof left === 'undefined'
                                    || typeof height === 'undefined' || typeof zoom === 'undefined') {
                                    this._destination._setValidation(false);
                                }
                            }
                        }
                    }
                }
                if (value instanceof _PdfDictionary) {
                    const pageDictionary = value;
                    let index;
                    if (loadedDocument && pageDictionary) {
                        index = _getPageIndex(loadedDocument, pageDictionary);
                    }
                    if (typeof index !== 'undefined' && index !== null && index >= 0) {
                        page = loadedDocument.getPage(index);
                    }
                    if (destinationArray.length > 1) {
                        mode = destinationArray[1];
                    }
                    if (mode) {
                        if (mode.name === 'XYZ') {
                            if (destinationArray.length > 2) {
                                left = destinationArray[2];
                            }
                            if (destinationArray.length > 3) {
                                height = destinationArray[3];
                            }
                            if (destinationArray.length > 4) {
                                zoom = destinationArray[4];
                            }
                            if (page) {
                                let topValue = (height === null || typeof height === 'undefined') ? 0 : page.size[1] - height;
                                const leftValue = (left === null || typeof left === 'undefined') ? 0 : left;
                                if (page.rotation !== PdfRotationAngle.angle0) {
                                    topValue = _checkRotation(page, height, left);
                                }
                                this._destination = new PdfDestination(page, [leftValue, topValue]);
                                this._destination._index = index;
                                this._destination.zoom = (typeof zoom !== 'undefined' && zoom !== null) ? zoom : 0;
                                if (left === null || height === null || zoom === null || typeof left === 'undefined' ||
                                    typeof height === 'undefined' || typeof zoom === 'undefined') {
                                    this._destination._setValidation(false);
                                }
                            }
                        }
                        else {
                            if (mode.name === 'FitR') {
                                if (destinationArray.length > 2) {
                                    left = destinationArray[2];
                                }
                                if (destinationArray.length > 3) {
                                    bottom = destinationArray[3];
                                }
                                if (destinationArray.length > 4) {
                                    right = destinationArray[4];
                                }
                                if (destinationArray.length > 5) {
                                    height = destinationArray[5];
                                }
                                if (page) {
                                    left = (left === null || typeof left === 'undefined') ? 0 : left;
                                    bottom = (bottom === null || typeof bottom === 'undefined') ? 0 : bottom;
                                    height = (height === null || typeof height === 'undefined') ? 0 : height;
                                    right = (right === null || typeof right === 'undefined') ? 0 : right;
                                    this._destination = new PdfDestination(page, [left, bottom, right, height]);
                                    this._destination._index = index;
                                    this._destination.mode = PdfDestinationMode.fitR;
                                }
                            }
                            else if (mode.name === 'FitBH' || mode.name === 'FitH') {
                                if (destinationArray.length >= 3) {
                                    height = destinationArray[2];
                                }
                                if (typeof index !== 'undefined' && index !== null && index >= 0) {
                                    page = loadedDocument.getPage(index);
                                }
                                if (page && page.size) {
                                    const topValue = (height === null || typeof height === 'undefined') ? 0 : page.size[1] - height;
                                    this._destination = new PdfDestination(page, [0, topValue]);
                                    this._destination._index = index;
                                    this._destination.mode = PdfDestinationMode.fitH;
                                    if (height === null || typeof height === 'undefined') {
                                        this._destination._setValidation(false);
                                    }
                                }
                            }
                            else {
                                if (page && mode.name === 'Fit') {
                                    this._destination = new PdfDestination(page);
                                    this._destination._index = index;
                                    this._destination.mode = PdfDestinationMode.fitToPage;
                                }
                            }
                        }
                    }
                }
            }
        }
        return this._destination;
    }
}
/**
 * Represents a named destination in a PDF document.
 * ```typescript
 * // Load an existing PDF document
 * let document: PdfDocument = new PdfDocument(data, password);
 * // Get the bookmarks
 * let bookmarks: PdfBookmarkBase = document.bookmarks;
 * // Gets the bookmark at the specified index
 * let bookmark: PdfBookmark = bookmarks.at(0) as PdfBookmark;
 * // Gets the named destination
 * let namedDestination: PdfNamedDestination = bookmark.namedDestination;
 * // Destroy the document
 * document.destroy();
 * ```
 */
class PdfNamedDestination {
    /**
     * Initializes a new instance of the `PdfNamedDestination` class.
     *
     * @private
     * @param {_PdfDictionary} dictionary Destination dictionary.
     * @param {_PdfCrossReference} crossReference Cross reference.
     *
     */
    constructor(dictionary, crossReference) {
        this._dictionary = dictionary;
        this._crossReference = crossReference;
    }
    /**
     * Gets the destination.
     *
     * @returns {PdfDestination} Page destination.
     *
     * ```typescript
     * // Load an existing PDF document
     * let document: PdfDocument = new PdfDocument(data, password);
     * // Get the bookmarks
     * let bookmarks: PdfBookmarkBase = document.bookmarks;
     * // Gets the bookmark at the specified index
     * let bookmark: PdfBookmark = bookmarks.at(0) as PdfBookmark;
     * // Gets the named destination
     * let namedDestination: PdfNamedDestination = bookmark.namedDestination;
     * // Gets the destination
     * let destination: PdfDestination = namedDestination.destination;
     * // Destroy the document
     * document.destroy();
     * ```
     */
    get destination() {
        return this._destination;
    }
    /**
     * Sets the destination.
     *
     * @param {PdfDestination} value destination.
     *
     * ```typescript
     * // Load an existing PDF document
     * let document: PdfDocument = new PdfDocument(data, password);
     * // Get the bookmarks
     * let bookmarks: PdfBookmarkBase = document.bookmarks;
     * // Gets the bookmark at the specified index
     * let bookmark: PdfBookmark = bookmarks.at(0) as PdfBookmark;
     * // Gets the named destination
     * let namedDestination: PdfNamedDestination = bookmark.namedDestination;
     * // Set the destination
     * namedDestination.destination = new PdfDestination(page, [100, 200]);
     * // Save the document
     * document.save('output.pdf');
     * // Destroy the document
     * document.destroy();
     * ```
     */
    set destination(value) {
        if (value) {
            value._parent = this;
            this._destination = value;
            this._destination._initializePrimitive();
        }
    }
    /**
     * Gets the title.
     *
     * @returns {string} title.
     *
     * ```typescript
     * // Load an existing PDF document
     * let document: PdfDocument = new PdfDocument(data, password);
     * // Get the bookmarks
     * let bookmarks: PdfBookmarkBase = document.bookmarks;
     * // Gets the bookmark at the specified index
     * let bookmark: PdfBookmark = bookmarks.at(0) as PdfBookmark;
     * // Gets the named destination
     * let namedDestination: PdfNamedDestination = bookmark.namedDestination;
     * // Gets the title
     * let title: string = namedDestination.title;
     * // Destroy the document
     * document.destroy();
     * ```
     */
    get title() {
        return this._title;
    }
    /**
     * Sets the title.
     *
     * @param {string} value title.
     *
     * ```typescript
     * // Load an existing PDF document
     * let document: PdfDocument = new PdfDocument(data, password);
     * // Get the bookmarks
     * let bookmarks: PdfBookmarkBase = document.bookmarks;
     * // Gets the bookmark at the specified index
     * let bookmark: PdfBookmark = bookmarks.at(0) as PdfBookmark;
     * // Gets the named destination
     * let namedDestination: PdfNamedDestination = bookmark.namedDestination;
     * // Set the title
     * namedDestination.title = 'Syncfusion';
     * // Save the document
     * document.save('output.pdf');
     * // Destroy the document
     * document.destroy();
     * ```
     */
    set title(value) {
        if (value !== this._title) {
            this._title = value;
            this._dictionary.update('Title', value);
            this._dictionary._updated = true;
        }
    }
}
class _PdfNamedDestinationCollection {
    constructor(dictionary, crossReference) {
        this._namedDestinations = [];
        if (dictionary) {
            this._dictionary = dictionary;
        }
        if (crossReference) {
            this._crossReference = crossReference;
        }
        if (dictionary && dictionary.has('Dests')) {
            const destination = dictionary.get('Dests');
            if (destination) {
                if (destination.has('Names')) {
                    this._addCollection(destination);
                }
                else if (destination.has('Kids')) {
                    const destinationArray = destination.getArray('Kids'); // eslint-disable-line
                    for (let i = 0; i < destinationArray.length; i++) {
                        const destinationElement = destinationArray[Number.parseInt(i.toString(), 10)];
                        this._addCollection(destinationElement);
                    }
                }
            }
        }
    }
    _addCollection(destination) {
        let elements = destination.getRaw('Names'); // eslint-disable-line
        let ref; // eslint-disable-line
        let dictionary;
        if (elements instanceof _PdfReference) {
            ref = this._crossReference._fetch(elements);
        }
        if (ref && Array.isArray(ref) && ref.length > 0) {
            elements = ref;
        }
        if (elements && Array.isArray(elements) && elements.length > 0) {
            for (let i = 1; i < elements.length; i = i + 2) {
                let reference = elements[i]; // eslint-disable-line
                if (reference instanceof _PdfReference) {
                    const destinationArray = this._crossReference._fetch(reference); // eslint-disable-line
                    if (destinationArray && Array.isArray(destinationArray) && destinationArray.length > 0) {
                        dictionary = new _PdfDictionary();
                        dictionary.update('D', destinationArray);
                    }
                    else {
                        dictionary = this._crossReference._fetch(reference);
                    }
                }
                else if ((dictionary === null || typeof dictionary === 'undefined') && Array.isArray(reference)) {
                    dictionary = new _PdfDictionary();
                    dictionary.update('D', reference);
                }
                if (dictionary) {
                    const namedDestination = new PdfNamedDestination(dictionary, this._crossReference);
                    const value = elements[i - 1];
                    let destinationObject;
                    let destinationArray; // eslint-disable-line
                    if (value) {
                        namedDestination._title = value;
                        if (dictionary.has('D')) {
                            destinationArray = dictionary.get('D');
                            destinationObject = new PdfDestination();
                            const reference = destinationArray[0];
                            if (destinationArray && destinationArray[0] instanceof _PdfReference) {
                                const pageDictionary = this._crossReference._fetch(reference);
                                const loadedDocument = this._crossReference._document;
                                let index;
                                if (loadedDocument && pageDictionary) {
                                    index = _getPageIndex(loadedDocument, pageDictionary);
                                    if (typeof index !== 'undefined' && index !== null && index >= 0) {
                                        destinationObject._index = index;
                                        destinationObject.page = loadedDocument.getPage(index);
                                    }
                                }
                            }
                        }
                    }
                    if (destinationArray[1] instanceof _PdfName) {
                        let left;
                        let height;
                        let zoom;
                        const mode = destinationArray[1].name;
                        const page = destinationObject.page;
                        switch (mode) {
                            case 'Fit':
                                destinationObject._destinationMode = PdfDestinationMode.fitToPage;
                                break;
                            case 'XYZ':
                                destinationObject._destinationMode = PdfDestinationMode.location;
                                if (destinationArray.length > 2) {
                                    left = destinationArray[2];
                                }
                                if (destinationArray.length > 3) {
                                    height = destinationArray[3];
                                }
                                if (destinationArray.length > 4) {
                                    zoom = destinationArray[4];
                                }
                                if (page) {
                                    const size = page.size;
                                    let topValue = (height === null || typeof height === 'undefined') ? 0 : size[1] - height;
                                    const leftValue = (left === null || typeof left === 'undefined') ? 0 : left;
                                    destinationObject._location = [leftValue, topValue];
                                    if (page.rotation !== PdfRotationAngle.angle0) {
                                        topValue = _checkRotation(page, height, left);
                                    }
                                    destinationObject._zoom = (typeof zoom !== 'undefined' && zoom !== null) ? zoom : 0;
                                    if (left === null || height === null || zoom === null || typeof left === 'undefined'
                                        || typeof height === 'undefined' || typeof zoom === 'undefined') {
                                        destinationObject._isValid = false;
                                    }
                                }
                                break;
                            case 'FitH':
                            case 'FitBH':
                                destinationObject._destinationMode = PdfDestinationMode.fitH;
                                if (destinationArray.length >= 3) {
                                    height = destinationArray[2];
                                }
                                if (page) {
                                    const size = page.size;
                                    const topValue = (height === null || typeof height === 'undefined') ? 0 : size[1] - height;
                                    destinationObject._location = [0, topValue];
                                }
                                if (height === null || typeof height === 'undefined') {
                                    destinationObject._isValid = false;
                                }
                                break;
                            case 'FitR':
                                destinationObject._destinationMode = PdfDestinationMode.fitR;
                                break;
                        }
                    }
                    destinationObject._parent = namedDestination;
                    namedDestination._destination = destinationObject;
                    this._namedDestinations.push(namedDestination);
                }
            }
        }
    }
}

class _XmlDocument extends _ExportHelper {
    constructor(fileName) {
        super();
        if (fileName !== null && typeof fileName !== 'undefined') {
            this._fileName = fileName;
        }
    }
    _exportAnnotations() {
        throw new Error('Method not implemented.');
    }
    _exportFormFields(document) {
        this._document = document;
        this._crossReference = document._crossReference;
        this._isAnnotationExport = false;
        this._format = 'XML';
        this._key = _getNewGuidString();
        return this._save();
    }
    _save() {
        const writer = new _XmlWriter();
        writer._writeStartDocument();
        if (this._asPerSpecification) {
            writer._writeStartElement('fields');
            writer._writeAttributeString('xfdf', 'http://ns.adobe.com/xfdf-transition/', 'xmlns', null);
        }
        else {
            writer._writeStartElement('Fields');
        }
        const form = this._document.form;
        if (form !== null && typeof form !== 'undefined') {
            this._exportEmptyFields = form.exportEmptyFields;
            const count = this._document.form.count;
            for (let i = 0; i < count; i++) {
                const field = this._document.form.fieldAt(i);
                if (field !== null && typeof field !== 'undefined' && field.export) {
                    this._exportFormFieldData(field);
                }
            }
            this._writeFormFieldData(writer, this._asPerSpecification);
        }
        const result = writer._save();
        writer._destroy();
        return result;
    }
    _writeFormFieldData(writer, isAcrobat = false) {
        if (isAcrobat) {
            this._table.forEach((value, key) => {
                if (key.includes(' ')) {
                    const text = key.replace(/ /g, '');
                    writer._writeStartElement(text.toString());
                    writer._writeAttributeString('original', key.toString(), 'xfdf', null);
                }
                else {
                    writer._writeStartElement(key.toString());
                }
                writer._writeString(value.toString());
                writer._writeEndElement();
            });
        }
        else {
            this._table.forEach((value, key) => {
                if (key.includes(' ')) {
                    key = key.replace(/ /g, '_x0020_');
                }
                writer._writeStartElement(key.toString());
                writer._writeString(value.toString());
                writer._writeEndElement();
            });
        }
        writer._writeEndElement();
    }
    _importFormData(document, data) {
        this._document = document;
        this._crossReference = document._crossReference;
        this._isAnnotationExport = false;
        let value = _bytesToString(data);
        value = value.replace(/(\r\n|\n|\r)/gm, '');
        value = value.replace(/[^\x20-\x7E]/g, '');
        this._xmlDocument = (new DOMParser()).parseFromString(value, 'text/xml');
        this._checkXml(this._xmlDocument);
        this._xmlImport = true;
        this._parseFormData(this._xmlDocument.documentElement);
        this._xmlImport = false;
    }
    _parseFormData(root) {
        const child = root.childNodes;
        if (child !== null && typeof child !== 'undefined' && child.length > 0) {
            for (let i = 0; i < child.length; i++) {
                const childNode = child.item(i);
                if (childNode !== null && typeof childNode !== 'undefined' && childNode.nodeType === 1) {
                    const element = childNode;
                    let text = '';
                    if (element.attributes !== null && typeof element.attributes !== 'undefined' && element.attributes.length > 0) {
                        const attribute = element.attributes.item(0); // eslint-disable-line
                        if (attribute !== null && typeof attribute !== 'undefined' && attribute.name === 'xfdf:original') {
                            text = attribute.value;
                        }
                    }
                    else {
                        text = element.tagName;
                    }
                    const v = element.textContent;
                    if (text !== null && text !== undefined && text.length > 0) {
                        this._table.set(text, v);
                    }
                }
            }
        }
        this._importField();
    }
    _importField() {
        const form = this._document.form;
        const count = form.count;
        if (count) {
            this._table.forEach((value, key) => {
                let textValue;
                if (this._table.size > 0 && this._table.has(key)) {
                    textValue = this._table.get(key);
                }
                let text = key.toString();
                if (text.indexOf('_x0020_') !== -1) {
                    text = text.replace(/_x0020_/g, ' ');
                }
                const index = form._getFieldIndex(text);
                if (index !== -1 && index < count) {
                    const field = form.fieldAt(index);
                    if (field && field !== null && typeof field !== 'undefined') {
                        if (textValue && textValue !== '') {
                            field._dictionary.update('RV', textValue);
                        }
                        const param = [];
                        param.push(value);
                        this._importFieldData(field, param);
                    }
                }
            });
        }
    }
    _checkXml(xmlDocument) {
        if (xmlDocument.getElementsByTagName('parsererror').length > 0) {
            throw new Error('Invalid XML file.');
        }
    }
}

/**
 * `PdfFileStructure` class represents the internal structure of the PDF file.
 * ```typescript
 * // Load an existing PDF document
 * let document: PdfDocument = new PdfDocument(data, password);
 * // Access the internal file structure of the PDF document
 * let fileStructure: PdfFileStructure = document.fileStructure;
 * // Set the cross reference type
 * fileStructure.crossReferenceType = PdfCrossReferenceType.stream;
 * // Save the document
 * document.save('output.pdf');
 * // Destroy the document
 * document.destroy();
 * ```
 */
class PdfFileStructure {
    /**
     * Gets the cross reference type of the PDF document.
     *
     * @returns {PdfCrossReferenceType} - Returns the cross reference type of the PDF document.
     * ```typescript
     * // Load an existing PDF document
     * let document: PdfDocument = new PdfDocument(data, password);
     * // Access the internal file structure of the PDF document
     * let fileStructure: PdfFileStructure = document.fileStructure;
     * // Get the cross reference type
     * let type: PdfCrossReferenceType = fileStructure.crossReferenceType;
     * // Save the document
     * document.save('output.pdf');
     * // Destroy the document
     * document.destroy();
     * ```
     */
    get crossReferenceType() {
        return this._crossReferenceType;
    }
    /**
     * Sets the cross reference type of the PDF document.
     *
     * @param {PdfCrossReferenceType} value - Specifies the cross reference type of the PDF document.
     * ```typescript
     * // Load an existing PDF document
     * let document: PdfDocument = new PdfDocument(data, password);
     * // Access the internal file structure of the PDF document
     * let fileStructure: PdfFileStructure = document.fileStructure;
     * // Set the cross reference type
     * fileStructure.crossReferenceType = PdfCrossReferenceType.stream;
     * // Save the document
     * document.save('output.pdf');
     * // Destroy the document
     * document.destroy();
     * ```
     */
    set crossReferenceType(value) {
        this._crossReferenceType = value;
    }
}

/**
 * Represents a PDF document and can be used to parse an existing PDF document.
 * ```typescript
 * // Load an existing PDF document
 * let document: PdfDocument = new PdfDocument(data);
 * // Access first page
 * let page: PdfPage = document.getPage(0);
 * // Flatten annotations and form fields
 * document.flatten = true;
 * // Save the document
 * document.save('output.pdf');
 * // Destroy the document
 * document.destroy();
 * ```
 */
class PdfDocument {
    constructor(data, password) {
        this._headerSignature = new Uint8Array([0x25, 0x50, 0x44, 0x46, 0x2d]);
        this._startXrefSignature = new Uint8Array([0x73, 0x74, 0x61, 0x72, 0x74, 0x78, 0x72, 0x65, 0x66]);
        this._endObjSignature = new Uint8Array([0x65, 0x6e, 0x64, 0x6f, 0x62, 0x6a]);
        this._version = '';
        this._permissions = PdfPermissionFlag.default;
        this._isEncrypted = false;
        this._isUserPassword = false;
        this._hasUserPasswordOnly = false;
        this._encryptOnlyAttachment = false;
        this._encryptMetaData = false;
        this._isExport = false;
        this._allowCustomData = false;
        if (!data) {
            throw new Error('PDF data cannot be undefined or null');
        }
        this._stream = new _PdfStream(typeof data === 'string' ? _decode(data) : data);
        this._fileStructure = new PdfFileStructure();
        this._crossReference = new _PdfCrossReference(this, password);
        this._pages = new Map();
        this._checkHeader();
        this._crossReference._setStartXRef(this._startXRef);
        try {
            this._parse(false);
        }
        catch (e) {
            if (e.name === 'XRefParseException') {
                this._parse(true);
            }
            else {
                throw e;
            }
        }
        this._crossReference._version = this._version;
    }
    get _allowImportCustomData() {
        return this._allowCustomData;
    }
    set _allowImportCustomData(value) {
        this._allowCustomData = value;
    }
    get _linearization() {
        if (!this._linear) {
            let value;
            try {
                value = new _Linearization(this._stream);
            }
            catch (err) { } // eslint-disable-line
            this._linear = value;
        }
        return this._linear;
    }
    get _startXRef() {
        const stream = this._stream;
        let startXRef = 0;
        if (this._linearization && this._linearization.isValid) {
            stream.reset();
            if (this._find(stream, this._endObjSignature)) {
                startXRef = stream.position + 6 - stream.start;
            }
        }
        else {
            const step = 1024;
            const startXRefLength = this._startXrefSignature.length;
            let found = false;
            let position = stream.end;
            while (!found && position > 0) {
                position -= step - startXRefLength;
                if (position < 0) {
                    position = 0;
                }
                stream.position = position;
                found = this._find(stream, this._startXrefSignature, step, true);
            }
            if (found) {
                stream.skip(9);
                let ch;
                do {
                    ch = stream.getByte();
                } while (_isWhiteSpace(ch));
                let str = '';
                while (ch >= 0x20 && ch <= 0x39) {
                    str += String.fromCharCode(ch);
                    ch = stream.getByte();
                }
                startXRef = parseInt(str, 10);
                if (isNaN(startXRef)) {
                    startXRef = 0;
                }
            }
        }
        return startXRef;
    }
    /**
     * Gets a value indicating whether the document is encrypted. (Read Only).
     *
     * @returns {boolean} A boolean value indicates whether the document is encrypted.
     *
     * ```typescript
     * // Load an existing PDF document
     * let document: PdfDocument = new PdfDocument(data, password);
     * // Gets a value indicating whether the document is encrypted.
     * let isEncrypted: boolean = document.isEncrypted;
     * // Destroy the document
     * document.destroy();
     * ```
     */
    get isEncrypted() {
        return this._isEncrypted;
    }
    /**
     * Gets a value indicating whether the document is decrypted using the user password. (Read only).
     *
     * @returns {boolean} A boolean value indicates whether the document is decrypted using the user password.
     *
     * ```typescript
     * // Load an existing PDF document
     * let document: PdfDocument = new PdfDocument(data, password);
     * // Gets a value indicating whether the document is decrypted using the user password
     * let isUserPassword: boolean = document.isUserPassword;
     * // Destroy the document
     * document.destroy();
     * ```
     */
    get isUserPassword() {
        return this._isUserPassword;
    }
    /**
     * Gets the page count (Read only).
     *
     * @returns {number} Number of pages
     *
     * ```typescript
     * // Load an existing PDF document
     * let document: PdfDocument = new PdfDocument(data, password);
     * // Gets the page count
     * let count: number = document.pageCount;
     * // Destroy the document
     * document.destroy();
     * ```
     */
    get pageCount() {
        if (typeof this._pageCount === 'undefined') {
            this._pageCount = 0;
            if (this._linearization && this._linearization.isValid) {
                this._pageCount = this._linearization.pageCount;
            }
            else {
                this._pageCount = this._catalog.pageCount;
            }
        }
        return this._pageCount;
    }
    /**
     * Gets the PDF form fields included in the document (Read only).
     *
     * @returns {PdfForm} Form object
     *
     * ```typescript
     * // Load an existing PDF document
     * let document: PdfDocument = new PdfDocument(data, password);
     * // Access loaded form
     * let form: PdfForm = document.form;
     * // Destroy the document
     * document.destroy();
     * ```
     */
    get form() {
        if (typeof this._form === 'undefined') {
            this._form = new PdfForm(this._catalog.acroForm, this._crossReference);
        }
        return this._form;
    }
    /**
     * Gets the boolean flag to flatten the annotations and form fields.
     *
     * @returns {boolean} Flag to flatten
     *
     * ```typescript
     * // Load an existing PDF document
     * let document: PdfDocument = new PdfDocument(data, password);
     * // Gets the flatten value applied
     * let flatten: boolean = document.flatten;
     * // Destroy the document
     * document.destroy();
     * ```
     */
    get flatten() {
        return this._flatten;
    }
    /**
     * Sets the boolean flag to flatten the annotations and form fields.
     *
     * @param {boolean} value to flatten
     *
     * ```typescript
     * // Load an existing PDF document
     * let document: PdfDocument = new PdfDocument(data, password);
     * // Flatten PDF annotations and form fields
     * document.flatten = true;
     * // Destroy the document
     * document.destroy();
     * ```
     */
    set flatten(value) {
        this._flatten = value;
    }
    /**
     * Gets the permission flag of the PDF document (Read only).
     *
     * @returns {PdfPermissionFlag} permission flag. Default value is PdfPermissionFlag.default.
     *
     * ```typescript
     * // Load an existing PDF document
     * let document: PdfDocument = new PdfDocument(data, password);
     * // Gets the permission flag
     * let permission: PdfPermissionFlag = document.permissions;
     * // Destroy the document
     * document.destroy();
     * ```
     */
    get permissions() {
        if (this._crossReference) {
            const flag = this._crossReference._permissionFlags;
            if (typeof flag !== 'undefined') {
                this._permissions = (flag & ~-3904);
            }
        }
        return this._permissions;
    }
    /**
     * Gets the bookmarks (Read only).
     *
     * @returns {PdfBookmarkBase} Bookmarks.
     *
     * ```typescript
     * // Load an existing PDF document
     * let document: PdfDocument = new PdfDocument(data, password);
     * // Get bookmarks
     * let bookmarks: PdfBookmarkBase = document.bookmarks;
     * // Destroy the document
     * document.destroy();
     * ```
     */
    get bookmarks() {
        const catalog = this._catalog;
        if (catalog && catalog._catalogDictionary.has('Outlines')) {
            const outlines = catalog._catalogDictionary.get('Outlines');
            if (outlines) {
                this._bookmarkBase = new PdfBookmarkBase(outlines, this._crossReference);
                if (outlines.has('First')) {
                    this._bookmarkBase._reproduceTree();
                }
            }
        }
        return this._bookmarkBase;
    }
    /**
     * Gets the internal structure of the PDF document.
     *
     * @returns {PdfFileStructure} The internal structure of the PDF document.
     * ```typescript
     * // Load an existing PDF document
     * let document: PdfDocument = new PdfDocument(data, password);
     * // Access the internal file structure of the PDF document
     * let fileStructure: PdfFileStructure = document.fileStructure;
     * // Get the cross reference type
     * let type: PdfCrossReferenceType = fileStructure.crossReferenceType;
     * // Save the document
     * document.save('output.pdf');
     * // Destroy the document
     * document.destroy();
     * ```
     */
    get fileStructure() {
        return this._fileStructure;
    }
    /**
     * Gets the `PdfPage` at the specified index.
     *
     * @param {number} pageIndex Page index.
     * @returns {PdfPage} PDF page at the specified index.
     *
     * ```typescript
     * // Load an existing PDF document
     * let document: PdfDocument = new PdfDocument(data, password);
     * // Access first page
     * let page: PdfPage = document.getPage(0);
     * // Save the document
     * document.save('output.pdf');
     * // Destroy the document
     * document.destroy();
     * ```
     */
    getPage(pageIndex) {
        const cachedPage = this._pages.get(pageIndex);
        if (cachedPage) {
            return cachedPage;
        }
        const { _catalog, _linearization } = this;
        let promise;
        if (_linearization && _linearization.isValid && _linearization.pageFirst === pageIndex) {
            promise = this._getLinearizationPage(pageIndex);
        }
        else {
            promise = _catalog.getPageDictionary(pageIndex);
        }
        const page = new PdfPage(this._crossReference, pageIndex, promise.dictionary, promise.reference);
        this._pages.set(pageIndex, page);
        return page;
    }
    save(filename) {
        this._doPostProcess(this._flatten);
        if (typeof filename === 'string') {
            Save.save(filename, new Blob([this._crossReference._save()], { type: 'application/pdf' }));
        }
        else {
            return this._crossReference._save();
        }
    }
    /**
     * Saves the document to the specified output stream and return the stream as Blob.
     *
     * @returns {Promise<{ blobData: Blob }>} Saved PDF data as `Blob`.
     *
     * ```typescript
     * // Load an existing PDF document
     * let document: PdfDocument = new PdfDocument(data);
     * // Save the document
     * let data: Promise<{ blobData: Blob }> = document.saveAsBlob();
     * // Destroy the document
     * document.destroy();
     * ```
     */
    saveAsBlob() {
        return new Promise((resolve) => {
            const obj = { blobData: new Blob([this._crossReference._save()], { type: 'application/pdf' }) };
            resolve(obj);
        });
    }
    exportAnnotations(arg1, arg2) {
        this._isExport = true;
        this._doPostProcessOnAnnotations();
        let helper;
        let settings;
        if (arg1 && arg1 instanceof PdfAnnotationExportSettings) {
            settings = arg1;
        }
        else if (arg2 && arg2 instanceof PdfAnnotationExportSettings) {
            settings = arg2;
        }
        if (settings) {
            if (settings.dataFormat === DataFormat.xfdf) {
                helper = new _XfdfDocument();
            }
            else if (settings.dataFormat === DataFormat.json) {
                helper = new _JsonDocument();
            }
            else if (settings.dataFormat === DataFormat.fdf) {
                helper = new _FdfDocument();
            }
            else {
                return undefined;
            }
            helper.exportAppearance = settings.exportAppearance;
        }
        else {
            helper = new _XfdfDocument();
        }
        const result = helper._exportAnnotations(this);
        if (arg1 && typeof arg1 === 'string') {
            Save.save(arg1, new Blob([result], { type: 'text/plain' }));
        }
        else {
            return result;
        }
    }
    exportFormData(arg1, arg2) {
        this._doPostProcessOnFormFields();
        let helper;
        let settings;
        if (arg1 && arg1 instanceof PdfFormFieldExportSettings) {
            settings = arg1;
        }
        else if (arg2 && arg2 instanceof PdfFormFieldExportSettings) {
            settings = arg2;
        }
        if (settings) {
            if (settings.dataFormat === DataFormat.xfdf) {
                helper = new _XfdfDocument(settings.exportName);
            }
            else if (settings.dataFormat === DataFormat.json) {
                helper = new _JsonDocument(settings.exportName);
            }
            else if (settings.dataFormat === DataFormat.fdf) {
                helper = new _FdfDocument(settings.exportName);
            }
            else if (settings.dataFormat === DataFormat.xml) {
                helper = new _XmlDocument(settings.exportName);
            }
            else {
                return undefined;
            }
            helper._asPerSpecification = settings.asPerSpecification;
        }
        else {
            helper = new _XfdfDocument();
            helper._asPerSpecification = false;
        }
        if (arg1 && typeof arg1 === 'string') {
            Save.save(arg1, new Blob([helper._exportFormFields(this)], { type: 'text/plain' }));
        }
        else {
            return helper._exportFormFields(this);
        }
    }
    importAnnotations(data, dataFormat) {
        if (dataFormat === DataFormat.xfdf) {
            const xfdf = new _XfdfDocument();
            xfdf._importAnnotations(this, (typeof data === 'string') ? _decode(data) : data);
        }
        else if (dataFormat === DataFormat.json) {
            const json = new _JsonDocument();
            json._importAnnotations(this, (typeof data === 'string') ? _decode(data) : data);
        }
        else if (dataFormat === DataFormat.fdf) {
            const fdf = new _FdfDocument();
            fdf._importAnnotations(this, (typeof data === 'string') ? _decode(data) : data);
        }
    }
    importFormData(data, dataFormat) {
        if (this.form.count > 0) {
            if (dataFormat === DataFormat.xfdf) {
                const xfdf = new _XfdfDocument();
                xfdf._importFormData(this, (typeof data === 'string') ? _decode(data) : data);
            }
            else if (dataFormat === DataFormat.json) {
                const json = new _JsonDocument();
                json._importFormData(this, (typeof data === 'string') ? _decode(data) : data);
            }
            else if (dataFormat === DataFormat.fdf) {
                const fdf = new _FdfDocument();
                fdf._importFormData(this, (typeof data === 'string') ? _decode(data) : data);
            }
            else if (dataFormat === DataFormat.xml) {
                const xml = new _XmlDocument();
                xml._importFormData(this, (typeof data === 'string') ? _decode(data) : data);
            }
        }
    }
    /**
     * Disposes the current instance of `PdfDocument` class.
     *
     * @returns {void} Nothing.
     *
     * ```typescript
     * // Load an existing PDF document
     * let document: PdfDocument = new PdfDocument(data);
     * // Destroy the document
     * document.destroy();
     * ```
     */
    destroy() {
        if (this._crossReference) {
            this._crossReference._destroy();
            this._crossReference = undefined;
        }
        if (this._catalog) {
            this._catalog._destroy();
            this._catalog = undefined;
        }
        this._endObjSignature = undefined;
        this._headerSignature = undefined;
        if (this._pages && this._pages.size > 0) {
            this._pages.forEach((value) => {
                value._destroy();
            });
        }
        this._pages.clear();
        this._pages = undefined;
        this._startXrefSignature = undefined;
        this._stream = undefined;
        this._form = undefined;
        _clearPrimitiveCaches();
    }
    get _destinationCollection() {
        if (this._namedDestinationCollection === null || typeof this._namedDestinationCollection === 'undefined') {
            if (this._catalog._catalogDictionary.has('Names')) {
                const names = this._catalog._catalogDictionary.get('Names');
                this._namedDestinationCollection = new _PdfNamedDestinationCollection(names, this._crossReference);
            }
            else {
                this._namedDestinationCollection = new _PdfNamedDestinationCollection();
            }
        }
        return this._namedDestinationCollection;
    }
    _getLinearizationPage(pageIndex) {
        const { _catalog, _linearization, _crossReference } = this;
        const ref = _PdfReference.get(_linearization.objectNumberFirst, 0);
        try {
            const obj = _crossReference._fetch(ref); // eslint-disable-line
            if (obj instanceof _PdfDictionary) {
                const type = obj.get('Type');
                if (_isName(type, 'Page') || (!obj.has('Type') && !obj.has('Kids'))) {
                    if (!_catalog.pageKidsCountCache.has(ref)) {
                        _catalog.pageKidsCountCache.put(ref, 1);
                    }
                    if (!_catalog.pageIndexCache.has(ref)) {
                        _catalog.pageIndexCache.put(ref, 0);
                    }
                    return { dictionary: obj, reference: ref };
                }
            }
            throw new FormatError('The Linearization dictionary does not point to a valid Page dictionary.');
        }
        catch (reason) {
            return _catalog.getPageDictionary(pageIndex);
        }
    }
    _checkHeader() {
        const stream = this._stream;
        stream.reset();
        if (!this._find(stream, this._headerSignature)) {
            return;
        }
        stream.moveStart();
        let version = '';
        let ch = stream.getByte();
        while (ch > 0x20) {
            if (version.length >= 12) {
                break;
            }
            version += String.fromCharCode(ch);
            ch = stream.getByte();
        }
        if (!this._version) {
            this._version = version.substring(5);
        }
    }
    _parse(recoveryMode) {
        this._crossReference._parse(recoveryMode);
        this._catalog = new _PdfCatalog(this._crossReference);
        if (this._catalog.version) {
            this._version = this._catalog.version;
        }
    }
    _find(stream, signature, limit = 1024, backwards = false) {
        const signatureLength = signature.length;
        const scanBytes = stream.peekBytes(limit);
        const scanLength = scanBytes.length - signatureLength;
        if (scanLength <= 0) {
            return false;
        }
        if (backwards) {
            const signatureEnd = signatureLength - 1;
            let position = scanBytes.length - 1;
            while (position >= signatureEnd) {
                let j = 0;
                while (j < signatureLength && scanBytes[position - j] === signature[signatureEnd - j]) {
                    j++;
                }
                if (j >= signatureLength) {
                    stream.position += position - signatureEnd;
                    return true;
                }
                position--;
            }
        }
        else {
            let position = 0;
            while (position <= scanLength) {
                let j = 0;
                while (j < signatureLength && scanBytes[position + j] === signature[j]) { // eslint-disable-line
                    j++;
                }
                if (j >= signatureLength) {
                    stream.position += position;
                    return true;
                }
                position++;
            }
        }
        return false;
    }
    _doPostProcess(isFlatten = false) {
        this._doPostProcessOnFormFields(isFlatten);
        this._doPostProcessOnAnnotations(isFlatten);
    }
    _doPostProcessOnFormFields(isFlatten = false) {
        this.form._doPostProcess(isFlatten);
        if (isFlatten) {
            const formObject = this._catalog._catalogDictionary.getRaw('AcroForm');
            const dictionary = new _PdfDictionary(this._crossReference);
            dictionary._updated = true;
            if (formObject instanceof _PdfReference) {
                this._crossReference._cacheMap.set(formObject, dictionary);
            }
            else {
                this.form._dictionary = dictionary;
                this._crossReference._allowCatalog = true;
            }
            this.form._clear();
        }
    }
    _doPostProcessOnAnnotations(isFlatten = false) {
        for (let i = 0; i < this.pageCount; i++) {
            const page = this.getPage(i);
            page.annotations._isExport = this._isExport;
            page.annotations._doPostProcess(isFlatten);
            if (isFlatten) {
                if (page._pageDictionary.has('Annots')) {
                    delete page._pageDictionary._map.Annots;
                    page._pageDictionary._updated = true;
                }
                page.annotations._clear();
            }
        }
    }
    _addWatermarkText() {
        if (this.pageCount > 0) {
            for (let index = 0; index < this._pageCount; index++) {
                const page = this.getPage(index);
                if (page) {
                    try {
                        const graphics = page.graphics;
                        graphics.save();
                        graphics.setTransparency(0.20);
                        graphics.drawRectangle(0, 0, page.size[0], 33.75, new PdfBrush([255, 255, 255]));
                        graphics.restore();
                        graphics.save();
                        graphics.setTransparency(0.50);
                        const font = new PdfStandardFont(PdfFontFamily.helvetica, 12, PdfFontStyle.regular);
                        const format = new PdfStringFormat(PdfTextAlignment.center, PdfVerticalAlignment.middle);
                        graphics.drawString('Created with a trial version of Syncfusion Essential PDF', font, [0, 0, page.size[0], 33.75], null, new PdfBrush([0, 0, 0]), format);
                        graphics.restore();
                    }
                    catch (e) { } // eslint-disable-line
                }
            }
        }
    }
}
/**
 * Represents annotation export settings.
 * ```typescript
 * // Load an existing PDF document
 * let document: PdfDocument = new PdfDocument(data, password);
 * // Sets export data format as JSON type to annotation export settings
 * let settings: PdfAnnotationExportSettings = new PdfAnnotationExportSettings();
 * // Set the data format defined in annotation export settings
 * settings.dataFormat = DataFormat.json;
 * // Export annotations to JSON format
 * let json: Uint8Array = document.exportAnnotations(settings);
 * // Save the document
 * document.save('output.pdf');
 * // Destroy the document
 * document.destroy();
 * ```
 */
class PdfAnnotationExportSettings {
    constructor() {
        this._format = DataFormat.xfdf;
        this._exportAppearance = false;
    }
    /**
     * Gets the data format defined in annotation export settings.
     *
     * @returns {DataFormat} - Returns the data format.
     * ```typescript
     * // Load an existing PDF document
     * let document: PdfDocument = new PdfDocument(data, password);
     * // Sets export data format as JSON type to annotation export settings
     * let settings: PdfAnnotationExportSettings = new PdfAnnotationExportSettings();
     * // Export annotations to JSON format
     * let json: Uint8Array = document.exportAnnotations(settings);
     * // Get the data format defined in annotation export settings
     * let dataFormat: DataFormat = settings.dataFormat;
     * // Save the document
     * document.save('output.pdf');
     * // Destroy the document
     * document.destroy();
     * ```
     */
    get dataFormat() {
        return this._format;
    }
    /**
     * Sets the data format defined in annotation export settings.
     *
     * @param {DataFormat} format - Specifies the data format.
     * ```typescript
     * // Load an existing PDF document
     * let document: PdfDocument = new PdfDocument(data, password);
     * // Sets export data format as JSON type to annotation export settings
     * let settings: PdfAnnotationExportSettings = new PdfAnnotationExportSettings();
     * // Set the data format defined in annotation export settings
     * settings.dataFormat = DataFormat.json;
     * // Export annotations to JSON format
     * let json: Uint8Array = document.exportAnnotations(settings);
     * // Save the document
     * document.save('output.pdf');
     * // Destroy the document
     * document.destroy();
     * ```
     */
    set dataFormat(format) {
        this._format = format;
    }
    /**
     * Gets the boolean value indicating whether the appearance of a particular object can be exported or not.
     *
     * @returns {boolean} - Returns the boolean value.
     * ```typescript
     * // Load an existing PDF document
     * let document: PdfDocument = new PdfDocument(data, password);
     * // Sets the annotation export settings with enabled export appearance.
     * let settings: PdfAnnotationExportSettings = new PdfAnnotationExportSettings();
     * // Export annotations to XFDF format
     * let xfdf: Uint8Array = document.exportAnnotations(settings);
     * // Get the boolean value indicating whether the appearance of a particular object can be exported or not
     * let appearance: boolean = settings.exportAppearance;
     * // Save the document
     * document.save('output.pdf');
     * // Destroy the document
     * document.destroy();
     * ```
     */
    get exportAppearance() {
        return this._exportAppearance;
    }
    /**
     * Sets the boolean value indicating whether the appearance of a particular object can be exported or not.
     *
     * @param {boolean} value - The boolean value.
     * ```typescript
     * // Load an existing PDF document
     * let document: PdfDocument = new PdfDocument(data, password);
     * // Sets the annotation export settings with enabled export appearance.
     * let settings: PdfAnnotationExportSettings = new PdfAnnotationExportSettings();
     * // Set the boolean value indicating whether the appearance of a particular object can be exported or not
     * settings.exportAppearance = true;
     * // Export annotations to XFDF format
     * let xfdf: Uint8Array = document.exportAnnotations(settings);
     * // Save the document
     * document.save('output.pdf');
     * // Destroy the document
     * document.destroy();
     * ```
     */
    set exportAppearance(value) {
        this._exportAppearance = value;
    }
}
/**
 * Represents form fields export settings.
 * ```typescript
 * // Load an existing PDF document
 * let document: PdfDocument = new PdfDocument(data);
 * // Sets the form field data export settings with output data format.
 * let settings: PdfFormFieldExportSettings = new PdfFormFieldExportSettings();
 * // Set the data format defined in form field export settings.
 * settings.dataFormat = DataFormat.json;
 * // Export form field to JSON format
 * let json: Uint8Array = document.exportFormData(settings);
 * // Save the document
 * document.save('output.pdf');
 * // Destroy the document
 * document.destroy();
 * ```
 */
class PdfFormFieldExportSettings {
    constructor() {
        this._format = DataFormat.xfdf;
        this._exportName = '';
        this._asPerSpecification = true;
    }
    /**
     * Gets the data format defined in form field export settings.
     *
     * @returns {DataFormat} - Returns the data format.
     * ```typescript
     * // Load an existing PDF document
     * let document: PdfDocument = new PdfDocument(data);
     * // Sets the form field data export settings with output data format.
     * let settings: PdfFormFieldExportSettings = new PdfFormFieldExportSettings();
     * // Export form field to JSON format
     * let json: Uint8Array = document.exportFormData(settings);
     * // Get the data format defined in form field export settings
     * let dataFormat: DataFormat = settings.dataFormat;
     * // Save the document
     * document.save('output.pdf');
     * // Destroy the document
     * document.destroy();
     * ```
     */
    get dataFormat() {
        return this._format;
    }
    /**
     * Sets the data format defined in form field export settings.
     *
     * @param {DataFormat} format - Specifies the data format.
     * ```typescript
     * // Load an existing PDF document
     * let document: PdfDocument = new PdfDocument(data);
     * // Sets the form field data export settings with output data format.
     * let settings: PdfFormFieldExportSettings = new PdfFormFieldExportSettings();
     * // Set the data format defined in form field export settings.
     * settings.dataFormat = DataFormat.json;
     * // Export form field to JSON format
     * let json: Uint8Array = document.exportFormData(settings);
     * // Save the document
     * document.save('output.pdf');
     * // Destroy the document
     * document.destroy();
     * ```
     */
    set dataFormat(format) {
        this._format = format;
    }
    /**
     * Gets the export name defined in form field export settings.
     *
     * @returns {string} - Returns the string value.
     * ```typescript
     * // Load an existing PDF document
     * let document: PdfDocument = new PdfDocument(data);
     * // Sets the form field data export settings with export name.
     * let settings: PdfFormFieldExportSettings = new PdfFormFieldExportSettings();
     * // Export form field to JSON format
     * let json: Uint8Array = document.exportFormData(settings);
     * // Get the export name defined in form field export settings
     * let name: boolean = settings.exportName;
     * // Save the document
     * document.save('output.pdf');
     * // Destroy the document
     * document.destroy();
     * ```
     */
    get exportName() {
        return this._exportName;
    }
    /**
     * Sets the export name defined in form field export settings.
     *
     * @param {string} name - Specifies the export name of the form.
     * ```typescript
     * // Load an existing PDF document
     * let document: PdfDocument = new PdfDocument(data);
     * // Sets the form field data export settings with export name.
     * let settings: PdfFormFieldExportSettings = new PdfFormFieldExportSettings();
     * // Set the export name defined in form field export settings.
     * settings.exportName = ‘JobApplication’.
     * // Export form field to JSON format
     * let json: Uint8Array = document.exportFormData(settings);
     * // Save the document
     * document.save('output.pdf');
     * // Destroy the document
     * document.destroy();
     * ```
     */
    set exportName(name) {
        this._exportName = name;
    }
    /**
     * Gets the boolean value indicating whether the data in a form field can be exported based on a certain specification.
     *
     * @returns {boolean} - Returns the boolean value.
     * ```typescript
     * // Load an existing PDF document
     * let document: PdfDocument = new PdfDocument(data);
     * // Sets the boolean value indicating whether the data in a form field can be exported based on a certain specification.
     * let settings: PdfFormFieldExportSettings = new PdfFormFieldExportSettings();
     * // Export form field to JSON format
     * let json: Uint8Array = document.exportFormData(settings);
     * // Get the boolean value indicating whether the data in a form field can be exported based on a certain specification.
     * let asPerSpecification: boolean = settings.asPerSpecification;
     * // Save the document
     * document.save('output.pdf');
     * // Destroy the document
     * document.destroy();
     * ```
     */
    get asPerSpecification() {
        return this._asPerSpecification;
    }
    /**
     * Sets the boolean value indicating whether the data in a form field can be exported based on a certain specification.
     *
     * @param {boolean} value - The boolean value.
     * ```typescript
     * // Load an existing PDF document
     * let document: PdfDocument = new PdfDocument(data);
     * // Sets the boolean value indicating whether the data in a form field can be exported based on a certain specification.
     * let settings: PdfFormFieldExportSettings = new PdfFormFieldExportSettings();
     * // Set the boolean value indicating whether the data in a form field can be exported based on a certain specification.
     * settings.asPerSpecification = true;
     * // Export form field to JSON format
     * let json: Uint8Array = document.exportFormData(settings);
     * // Save the document
     * document.save('output.pdf');
     * // Destroy the document
     * document.destroy();
     * ```
     */
    set asPerSpecification(value) {
        this._asPerSpecification = value;
    }
}

class _PdfPaddings {
    constructor(left, top, right, bottom) {
        this._left = 0;
        this._right = 0;
        this._top = 0;
        this._bottom = 0;
        if (typeof left === 'undefined') {
            this._left = 0.5;
            this._right = 0.5;
            this._top = 0.5;
            this._bottom = 0.5;
        }
        else {
            this._left = left;
            this._right = right;
            this._top = top;
            this._bottom = bottom;
        }
    }
}

class _ImageDecoder {
    /**
     * Initializes a new instance of the `_ImageDecoder` class.
     *
     * @private
     * @param {Uint8Array} stream byte array.
     */
    constructor(stream) {
        this._format = _ImageFormat.unknown;
        this._height = 0;
        this._width = 0;
        this._bitsPerComponent = 8;
        this._position = 0;
        this._noOfComponents = -1;
        this._stream = stream;
        this._initialize();
    }
    get _imageDataAsNumberArray() {
        return this._imageData;
    }
    _initialize() {
        if (this._format === _ImageFormat.unknown && this._checkIfJpeg()) {
            this._format = _ImageFormat.jpeg;
            this._parseJpegImage();
        }
        else {
            throw new TypeError('Only the JPEG format is supported');
        }
        this._reset();
        this._imageData = new Uint8Array(this._stream.byteLength);
        this._read(this._imageData, 0, this._imageData.byteLength);
    }
    _reset() {
        this._position = 0;
    }
    _parseJpegImage() {
        this._reset();
        const imgData = new Uint8Array(this._stream.byteLength);
        this._read(imgData, 0, imgData.byteLength);
        let i = 4;
        let length = this._getBuffer(i) * 256 + this._getBuffer(i + 1);
        let isLengthExceed = false;
        while (i < imgData.byteLength) {
            i += length;
            if (i < imgData.byteLength) {
                if (this._getBuffer(i + 1) === 192) {
                    this._height = this._getBuffer(i + 5) * 256 + this._getBuffer(i + 6);
                    this._width = this._getBuffer(i + 7) * 256 + this._getBuffer(i + 8);
                    this._noOfComponents = this._getBuffer(i + 9);
                    if (this._width !== 0 && this._height !== 0) {
                        return;
                    }
                }
                else {
                    i += 2;
                    length = this._getBuffer(i) * 256 + this._getBuffer(i + 1);
                }
            }
            else {
                isLengthExceed = true;
                break;
            }
        }
        if (isLengthExceed) {
            this._reset();
            this._seek(2);
            this._readExceededJpegImage();
        }
    }
    _checkIfJpeg() {
        this._reset();
        for (let i = 0; i < _ImageDecoder._jpegHeader.length; i++) {
            if (_ImageDecoder._jpegHeader[Number.parseInt(i.toString(), 10)] !== this._getBuffer(i)) {
                return false;
            }
            this._position++;
        }
        return true;
    }
    _read(buffer, offset, count) {
        for (let index = offset; index < count; index++) {
            const position = this._position;
            buffer[Number.parseInt(index.toString(), 10)] = this._getBuffer(position);
            this._position++;
        }
    }
    _getBuffer(index) {
        return this._stream[Number.parseInt(index.toString(), 10)];
    }
    _getImageDictionary() {
        const data = []; // eslint-disable-line
        this._imageStream = new _PdfStream(data, new _PdfDictionary());
        this._imageStream.isImageStream = true;
        let tempString = '';
        let decodedString = '';
        for (let i = 0; i < this._imageDataAsNumberArray.byteLength; i++) {
            tempString += ' ' + String.fromCharCode(this._getBuffer(i));
        }
        for (let i = 0; i < tempString.length; i++) {
            if (i % 2 !== 0) {
                decodedString += tempString[Number.parseInt(i.toString(), 10)];
            }
        }
        this._imageStream.data = [decodedString];
        this._imageStream._isCompress = false;
        const dictionary = new _PdfDictionary();
        dictionary.set('Type', new _PdfName('XObject'));
        dictionary.set('Subtype', new _PdfName('Image'));
        dictionary.set('Width', this._width);
        dictionary.set('Height', this._height);
        dictionary.set('BitsPerComponent', this._bitsPerComponent);
        dictionary.set('Filter', new _PdfName('DCTDecode'));
        dictionary.set('ColorSpace', new _PdfName(this._getColorSpace()));
        dictionary.set('DecodeParms', this._getDecodeParams());
        this._imageStream.dictionary = dictionary;
        this._imageStream.bytes = new Uint8Array(this._imageStream.data[0].length);
        for (let i = 0; i < this._imageStream.data[0].length; i++) {
            this._imageStream.bytes[Number.parseInt(i.toString(), 10)] = this._imageStream.data[0].charCodeAt(i);
        }
        this._imageStream.end = this._imageStream.bytes.length;
        this._imageStream.dictionary._updated = true;
        return this._imageStream;
    }
    _getColorSpace() {
        if (this._noOfComponents === 1) {
            return 'DeviceGray';
        }
        else if (this._noOfComponents === 4) {
            return 'DeviceCMYK';
        }
        return 'DeviceRGB';
    }
    _getDecodeParams() {
        const decodeParams = new _PdfDictionary();
        decodeParams.set('Columns', this._width);
        decodeParams.set('BlackIs1', true);
        decodeParams.set('K', -1);
        decodeParams.set('Predictor', 15);
        decodeParams.set('BitsPerComponent', this._bitsPerComponent);
        return decodeParams;
    }
    _seek(length) {
        this._position += length;
    }
    _readByte() {
        if (this._position < this._stream.byteLength) {
            const value = this._getBuffer(this._position);
            this._position += 1;
            return value;
        }
        else {
            throw new Error('Error decoding JPEG image. Invalid offset.');
        }
    }
    _skipStream() {
        const length = this._getBuffer(this._position) << 8 | this._getBuffer(this._position + 1);
        this._seek(2);
        if (length < 2) {
            throw new Error('Error decoding JPEG image');
        }
        else if (length > 0) {
            this._seek(length - 2);
        }
    }
    _readExceededJpegImage() {
        let isContinueReading = true;
        while (isContinueReading) {
            const marker = this._getMarker();
            switch (marker) {
                case 0x00C0:
                case 0x00C1:
                case 0x00C2:
                case 0x00C3:
                case 0x00C5:
                case 0x00C6:
                case 0x00C7:
                case 0x00C9:
                case 0x00CA:
                case 0x00CB:
                case 0x00CD:
                case 0x00CE:
                case 0x00CF:
                    this._seek(3);
                    this._height = this._getBuffer(this._position) << 8 | this._getBuffer(this._position + 1);
                    this._seek(2);
                    this._width = this._getBuffer(this._position) << 8 | this._getBuffer(this._position + 1);
                    this._seek(2);
                    this._noOfComponents = this._getBuffer(this._position);
                    this._seek(1);
                    isContinueReading = false;
                    break;
                default:
                    this._skipStream();
                    break;
            }
        }
    }
    _toUnsigned16(value) {
        value = value & 0xFFFF;
        return value < 0 ? (value + 0x10000) : value;
    }
    _getMarker() {
        let skippedByte = 0;
        let marker = this._readByte();
        while (marker !== 255) {
            skippedByte++;
            marker = this._readByte();
        }
        do {
            marker = this._readByte();
        } while (marker === 255);
        if (skippedByte !== 0) {
            throw new Error('Error decoding JPEG image');
        }
        return this._toUnsigned16(marker);
    }
}
_ImageDecoder._jpegHeader = [255, 216];

/**
 * The 'PdfBitmap' contains methods and properties to handle the Bitmap images.
 * ```typescript
 * // Load an existing PDF document
 * let document: PdfDocument = new PdfDocument(data, password);
 * // Access first page
 * let page: PdfPage = document.getPage(0);
 * // Gets the graphics of the PDF page
 * let graphics: PdfGraphics = page.graphics;
 * // Create new image object by using JPEG image data as Base64 string format
 * let image: PdfImage = new PdfBitmap('/9j/4AAQSkZJRgABAQEAkACQAAD/4....QB//Z');
 * //Draw the image.
 * graphics.drawImage(image, 10, 20, 400, 400);
 * // Save the document
 * document.save('output.pdf');
 * // Destroy the document
 * document.destroy();
 * ```
 */
class PdfBitmap extends PdfImage {
    constructor(encodedString) {
        super();
        this._imageStatus = true;
        if (encodedString !== null && typeof encodedString !== 'undefined' && typeof encodedString === 'string') {
            this._initializeAsync(encodedString);
        }
        else {
            this._initializeAsync(encodedString);
        }
    }
    _initializeAsync(encodedString) {
        let byteArray = new Uint8Array(encodedString.length);
        if (encodedString !== null && typeof encodedString !== 'undefined' && typeof encodedString === 'string') {
            byteArray = _decode(encodedString, false);
        }
        else if (encodedString instanceof Uint8Array) {
            byteArray = encodedString;
        }
        this._decoder = new _ImageDecoder(byteArray);
        this.height = this._decoder._height;
        this.width = this._decoder._width;
        this._bitsPerComponent = this._decoder._bitsPerComponent;
    }
    _save() {
        this._imageStatus = true;
        this._imageStream = this._decoder._getImageDictionary();
    }
}

export { _PdfBaseStream, _PdfStream, _PdfContentStream, _PdfNullStream, _ContentParser, _ContentLexer, _PdfRecord, _PdfDecodeStream, _PdfDecryptStream, PdfAnnotationFlag, PdfLineEndingStyle, PdfLineIntent, PdfLineCaptionType, PdfBorderStyle, PdfBorderEffectStyle, PdfRotationAngle, PdfCrossReferenceType, PdfHighlightMode, PdfTextAlignment, PdfFormFieldVisibility, PdfMeasurementUnit, PdfCircleMeasurementType, PdfRubberStampAnnotationIcon, PdfCheckBoxStyle, PdfTextMarkupAnnotationType, PdfPopupIcon, PdfAnnotationState, PdfAnnotationStateModel, PdfAttachmentIcon, PdfAnnotationIntent, PdfDestinationMode, DataFormat, PdfFormFieldsTabOrder, _PdfAnnotationType, _PdfGraphicsUnit, _FieldFlag, _SignatureFlag, _PdfCheckFieldState, PdfPermissionFlag, PdfPageOrientation, PdfTextDirection, PdfSubSuperScript, PdfBlendMode, PdfFillMode, PdfDashStyle, PdfLineCap, PdfLineJoin, _PdfWordWrapType, _FontDescriptorFlag, _TrueTypeCmapFormat, _TrueTypeCmapEncoding, _TrueTypePlatformID, _TrueTypeMicrosoftEncodingID, _TrueTypeMacintoshEncodingID, _TrueTypeCompositeGlyphFlag, _ImageFormat, _TokenType, PdfTextStyle, _PdfFlateStream, _PdfCatalog, _PdfCrossReference, PdfDocument, PdfAnnotationExportSettings, PdfFormFieldExportSettings, PdfFileStructure, PdfPage, PdfDestination, PdfBookmarkBase, PdfBookmark, PdfNamedDestination, _PdfNamedDestinationCollection, _PdfLexicalOperator, _PdfParser, _Linearization, _PdfName, _PdfCommand, _PdfReference, _PdfReferenceSet, _PdfReferenceSetCache, Dictionary, _PdfDictionary, _PdfNull, _clearPrimitiveCaches, _isName, _isCommand, PdfPredictorStream, _checkRotation, _getPageIndex, _annotationFlagsToString, _stringToAnnotationFlags, _stringToPdfString, _stringToBytes, _convertStringToBytes, _areArrayEqual, _numberToString, _areNotEqual, _bytesToString, _stringToUnicodeArray, _byteArrayToHexString, _hexStringToByteArray, _hexStringToString, _isWhiteSpace, _decode, _encode, _getInheritableProperty, _parseRectangle, _calculateBounds, _toRectangle, _fromRectangle, _getUpdatedBounds, _convertToColor, _parseColor, _mapBorderStyle, _mapBorderEffectStyle, _reverseMapEndingStyle, _mapLineEndingStyle, _mapHighlightMode, _reverseMapHighlightMode, _reverseMapBlendMode, _mapBlendMode, _floatToString, _addProcSet, _getNewGuidString, _escapePdfName, _getBezierArc, _findPage, _checkField, _getItemValue, _getStateTemplate, _getColorValue, _setMatrix, _styleToString, _stringToStyle, _mapMeasurementUnit, _mapMarkupAnnotationType, _reverseMarkupAnnotationType, _mapGraphicsUnit, _mapRubberStampIcon, _mapPopupIcon, _reverseMapAnnotationState, _mapAnnotationState, _reverseMapAnnotationStateModel, _mapAnnotationStateModel, _mapAttachmentIcon, _mapAnnotationIntent, _reverseMapPdfFontStyle, _getSpecialCharacter, _getLatinCharacter, _encodeValue, _getCommentsOrReview, _checkReview, _checkComment, _updateVisibility, _removeDuplicateReference, _removeDuplicateFromResources, _removeReferences, BaseException, FormatError, ParserEndOfFileException, _defaultToString, _obtainFontDetails, _getFontStyle, _mapFont, _tryParseFontStream, _checkInkPoints, PdfAnnotationCollection, PdfPopupAnnotationCollection, PdfAnnotation, PdfComment, PdfLineAnnotation, PdfCircleAnnotation, PdfEllipseAnnotation, PdfSquareAnnotation, PdfRectangleAnnotation, PdfPolygonAnnotation, PdfPolyLineAnnotation, PdfAngleMeasurementAnnotation, PdfInkAnnotation, PdfPopupAnnotation, PdfFileLinkAnnotation, PdfUriAnnotation, PdfDocumentLinkAnnotation, PdfTextWebLinkAnnotation, PdfAttachmentAnnotation, Pdf3DAnnotation, PdfTextMarkupAnnotation, PdfWatermarkAnnotation, PdfRubberStampAnnotation, PdfSoundAnnotation, PdfFreeTextAnnotation, PdfRedactionAnnotation, PdfRichMediaAnnotation, PdfWidgetAnnotation, PdfStateItem, PdfRadioButtonListItem, PdfListFieldItem, PdfAnnotationCaption, PdfAnnotationLineEndingStyle, PdfInteractiveBorder, PdfAnnotationBorder, PdfBorderEffect, _PaintParameter, PdfAppearance, _PdfPaddings, _PdfFontMetrics, _WidthTable, _StandardWidthTable, _CjkWidthTable, _CjkWidth, _CjkSameWidth, _CjkDifferentWidth, PdfFont, PdfStandardFont, PdfCjkStandardFont, PdfTrueTypeFont, _PdfStandardFontMetricsFactory, _PdfCjkStandardFontMetricsFactory, _PdfCjkFontDescriptorFactory, PdfFontStyle, PdfFontFamily, PdfCjkFontFamily, _UnicodeLine, PdfStringFormat, PdfVerticalAlignment, _PdfStringLayouter, _PdfStringLayoutResult, _LineInfo, _LineType, _StringTokenizer, _TrueTypeReader, _TrueTypeNameRecord, _TrueTypeMetrics, _TrueTypeLongHorMetric, _TrueTypeGlyph, _TrueTypeLocaTable, _TrueTypeGlyphHeader, _BigEndianWriter, _TrueTypeTableInfo, _TrueTypeOS2Table, _TrueTypePostTable, _TrueTypeNameTable, _TrueTypeMicrosoftCmapSubTable, _TrueTypeHorizontalHeaderTable, _TrueTypeHeadTable, _TrueTypeCmapTable, _TrueTypeCmapSubTable, _TrueTypeAppleCmapSubTable, _TrueTypeTrimmedCmapSubTable, _UnicodeTrueTypeFont, PdfField, PdfTextBoxField, PdfButtonField, PdfCheckBoxField, PdfRadioButtonListField, PdfListField, PdfComboBoxField, PdfListBoxField, PdfSignatureField, _PdfDefaultAppearance, PdfForm, PdfGraphics, _PdfTransformationMatrix, _Matrix, PdfGraphicsState, _TextRenderingMode, PdfBrush, PdfPen, _PdfUnitConvertor, _PdfPath, _PathPointType, _PdfStreamWriter, PdfTemplate, _Bidirectional, _RtlCharacters, _ArabicShapeRenderer, _ArabicShape, _RtlRenderer, _ImageDecoder, PdfBitmap, PdfImage, _PdfEncryptor, _MD5, _Sha256, _Sha512, _Word64, _EncryptionKey, _BasicEncryption, _AdvancedEncryption, _Cipher, _NormalCipherFour, _AdvancedEncryptionBaseCipher, _AdvancedEncryption128Cipher, _AdvancedEncryption256Cipher, _NullCipher, _CipherTransform, _ExportHelper, _XfdfDocument, _FontStructure, _XmlWriter, _Namespace, _XmlElement, _XmlAttribute, _FdfDocument, _FdfHelper, _JsonDocument, _XmlDocument };
//# sourceMappingURL=ej2-pdf.es2015.js.map
